{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"source/_drafts/字典的存储结构.md","hash":"8fba3ba386cff56788a75b67f9f5ced1323e351a","modified":1650438513121},{"_id":"source/_drafts/常用工具.md","hash":"ab73794c0743c9e276e30c1c99eca4575fbfdb30","modified":1650438513121},{"_id":"source/_posts/RAC和内存管理.md","hash":"60dba95639f958176e821c321b806f9c2f6e9691","modified":1650438513123},{"_id":"source/_posts/Shell-Tip.md","hash":"3b4a197ef122b57dfd5ea26734c6a30e11e0eb0e","modified":1650438513124},{"_id":"source/_posts/Swift-High-Performance-Tip 1：Array和ContiguousArray.md","hash":"3a38b69ca8d7248ece6d53aab2be5bd9421d7387","modified":1650438513124},{"_id":"source/_posts/Swift-High-Performance-Tip 2：final和private(fileprivate).md","hash":"76438d026841197040f2529775a332658a462785","modified":1650438513124},{"_id":"source/_posts/Swift-High-Performance-Tip 3：@objc-和-dynamic.md","hash":"a13cdf33dfa540f713ec3bc07583d3adc5b23105","modified":1650438513124},{"_id":"source/_posts/UIScrollView-的偏移问题.md","hash":"c5a18167e1e03dd9833e3538eab561fa7fd0d3d4","modified":1650438513124},{"_id":"source/_posts/Vim-Tip.md","hash":"06835dc2cc01099c72381b80582b6d34b8e1fa06","modified":1650438513124},{"_id":"source/_drafts/浅谈-iOS-架构.md","hash":"9a497784a752cb34b06e907c3e08ef38a7ab7930","modified":1650438513122},{"_id":"source/_posts/Notification-的一些知识点.md","hash":"ae0ed8c010dd04722fec953e7dcdd25c79b0a2b0","modified":1650438513123},{"_id":"source/_drafts/Raspberry-PI-基本使用.md","hash":"9a724c082c2d689866e4edfc8cb8bcb57ed74ae2","modified":1650438513121},{"_id":"source/_posts/include和import的区别.md","hash":"86e62dda34dd64f28d3083138387932ce8ae627f","modified":1650438513124},{"_id":"source/_posts/redux-之页面跳转.md","hash":"7d4f19664ac6b8ec3ee786f7ce47cd7b9c3bbbab","modified":1650438513125},{"_id":"source/_posts/self-在-block-中的引用计数变化.md","hash":"290856dd224f551942c92c62e33a0a2505215ba4","modified":1650438513125},{"_id":"source/_posts/初步了解GCD.md","hash":"2330b526c01b138b975b7c411196c624d0d01e9b","modified":1650438513125},{"_id":"source/_posts/说说-Objective-C-中的-Copy-操作.md","hash":"f310afdf01f960edf21a4a11dde4571fb9409930","modified":1650438513125},{"_id":"source/categories/index.md","hash":"55bee2cb88da438a2e8b1f29b1d7e954c07a9e60","modified":1650438513126},{"_id":"source/about/index.md","hash":"a34f6cd43c13c4370e2075b78c33d400e666a9b4","modified":1650511546487},{"_id":"source/tags/index.md","hash":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1650438513126},{"_id":"source/_posts/如何在-iOS-上自定义-React-Native-Component.md","hash":"fa2ebdd3911b3bab49d225fbbdd7bae1b89916f2","modified":1650438513125},{"_id":"source/_posts/如何用-Objective-C-实现一个死锁.md","hash":"7f6a3ff3572aff1d00bb2d313eb4c669504befb3","modified":1650438513125},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1650507463942},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1650507463947},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1650507463941},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1650507463947},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1650507463941},{"_id":"themes/next/_config.yml","hash":"940050f14e70bfcc66ed9573ad35c7ffdb12c624","modified":1650511756572},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1650507463947},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1650507463949},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1650507463948},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1650507463988},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1650507463947},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1650507463959},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1650507463949},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1650507463950},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1650507463951},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1650507463951},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1650507463950},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1650507463951},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1650507463952},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1650507463952},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1650507463953},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1650507463959},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1650507463960},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1650507463961},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1650507463960},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1650507463961},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1650507463960},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1650507463961},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1650507463962},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1650507463963},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1650507463962},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1650507463962},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1650507463963},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1650507463964},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1650507463962},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1650507463963},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1650507463964},{"_id":"themes/next/languages/tr.yml","hash":"2b041eeb8bd096f549464f191cfc1ea0181daca4","modified":1650507463964},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1650507463964},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1650507463965},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1650507463965},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1650507463966},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1650507463965},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1650507463966},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1650507463986},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1650507463987},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1650507463987},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1650507463988},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1650507463996},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1650507463987},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1650507463988},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1650507463954},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1650507463955},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1650507463954},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1650507463954},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1650507463956},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1650507463957},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1650507463955},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1650507463957},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1650507463958},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1650507463956},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1650507463958},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1650507463958},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1650507463966},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1650507463967},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1650507463967},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4369b313cbbeae742cb35f86d23d99d4285f7359","modified":1650507463967},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1650507463967},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1650507463970},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1650507463971},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1650507463975},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1650507463974},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1650507463978},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1650507463976},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1650507463975},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1650507463977},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1650507463981},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1650507463982},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1650507463989},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1650507463993},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1650507463979},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1650507463994},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1650507463994},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1650507463995},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1650507463995},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1650507463995},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1650507463982},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1650507463995},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1650507463996},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1650507463997},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1650507463997},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1650507463997},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1650507463997},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1650507463998},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1650507463998},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1650507463998},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1650507463998},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1650507463999},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1650507463999},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1650507463994},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1650507464000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1650507464035},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1650507464034},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1650507464024},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1650507464036},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1650507464037},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1650507464036},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1650507464037},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1650507464038},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1650507464039},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1650507464039},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1650507464038},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1650507464041},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1650507464042},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1650507464042},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1650507464043},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1650507464041},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1650507464043},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1650507464044},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1650507464044},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1650507464043},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1650507463968},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1650507463953},{"_id":"themes/next/source/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1650507464045},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1650507464046},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1650507463969},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1650507463969},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1650507463969},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1650507463970},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1650507463968},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1650507463970},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1650507463971},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1650507463971},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1650507463972},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1650507463972},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1650507463973},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1650507463972},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1650507463973},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1650507463973},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1650507463973},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1650507463974},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1650507463976},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1650507463974},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1650507463976},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1650507463977},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1650507463977},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1650507463978},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1650507463976},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1650507463978},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1650507463979},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1650507463979},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1650507463978},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1650507463979},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1650507463980},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1650507463980},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1650507463981},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1650507463980},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1650507463981},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1650507463982},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1650507463982},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1650507463982},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1650507463981},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1650507463983},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1650507463984},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1650507463983},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1650507463983},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1650507463984},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1650507463985},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1650507463984},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1650507463990},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1650507463990},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1650507463986},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1650507463990},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1650507463991},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1650507463985},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1650507463985},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1650507463992},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1650507463992},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1650507463992},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1650507463992},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1650507463993},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1650507463993},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1650507463993},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1650507464031},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1650507464031},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1650507464034},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1650507464044},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1650507464032},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1650507464033},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1650507464045},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1650507464000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1650507464000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1650507464001},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1650507464008},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1650507464012},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1650507464052},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1650507464013},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1650507464016},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1650507464052},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1650507464016},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1650507464017},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1650507464019},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1650507464019},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1650507464020},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1650507464025},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1650507464026},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1650507464020},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1650507464024},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1650507464026},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1650507464027},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1650507464027},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1650507464026},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1650507464027},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1650507464028},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1650507464028},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1650507464029},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1650507464029},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1650507464028},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1650507464029},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1650507464030},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1650507464030},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1650507464029},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1650507464030},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1650507464030},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1650507464048},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1650507464050},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1650507464002},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1650507464002},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1650507464002},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1650507464004},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1650507464004},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1650507464003},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1650507464003},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1650507464004},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1650507464005},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1650507464005},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1650507464005},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1650507464004},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1650507464006},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1650507464006},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1650507464006},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1650507464007},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1650507464007},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1650507464008},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1650507464007},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1650507464008},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1650507464009},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1650507464009},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1650507464009},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1650507464010},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1650507464011},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1650507464011},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1650507464011},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1650507464011},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1650507464012},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1650507464012},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1650507464012},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1650507464013},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1650507464013},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1650507464014},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1650507464013},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1650507464014},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1650507464014},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1650507464015},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1650507464015},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1650507464015},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1650507464016},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1650507464017},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1650507464018},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1650507464018},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1650507464019},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1650507464021},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1650507464021},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1650507464021},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1650507464022},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1650507464022},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1650507464022},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1650507464022},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1650507464049},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1650507464051},{"_id":"public/about/index.html","hash":"3488916c05d31dfc3d07ae7626c73720dc74886b","modified":1650512542853},{"_id":"public/categories/index.html","hash":"87df012ed2fe30660f8f86ddb7eda87aa5fbb45e","modified":1650512542853},{"_id":"public/tags/index.html","hash":"5d1a107add93e542f3c0f8bec33aea9e2f876349","modified":1650512542853},{"_id":"public/2017/09/05/Swift-High-Performance-Tip 2：final和private(fileprivate)/index.html","hash":"b813802008b50b5ed3446c8f46371bfa8f72b3ae","modified":1650512542853},{"_id":"public/archives/index.html","hash":"da225858ed9648b835a8f141990c24d727cce27d","modified":1650512542853},{"_id":"public/archives/page/2/index.html","hash":"ef1877954c81e859c214666b7fbf20422d97dd35","modified":1650512542853},{"_id":"public/archives/2017/index.html","hash":"eefdf4db9d7c2ba26a5ab8a5fea5e90dab35d20c","modified":1650512542853},{"_id":"public/archives/2017/09/index.html","hash":"8b455ee6077e426bbf60e0abd57d85818a010460","modified":1650512542853},{"_id":"public/archives/2018/index.html","hash":"5e865ee2f02380c433d904f539c19dab5aec39af","modified":1650512542853},{"_id":"public/archives/2018/02/index.html","hash":"d5e9d9a54a55bde8c966d6659c17a949d2b5bcf4","modified":1650512542853},{"_id":"public/archives/2018/03/index.html","hash":"7ab0798bf77a711ec6b410b73d7123661770e3a9","modified":1650512542853},{"_id":"public/archives/2018/04/index.html","hash":"52d0420f892aedd69cb482c3cbd104bb8d838db1","modified":1650512542853},{"_id":"public/archives/2018/05/index.html","hash":"9003a54254b7c8f923e92f4239cc06b2dc85d4e9","modified":1650512542853},{"_id":"public/archives/2018/11/index.html","hash":"7343594c68be76974c103e2be7ffb33bb382dddc","modified":1650512542853},{"_id":"public/archives/2019/index.html","hash":"c3600a1114d409f8ed96907cbf4367c6f749a2ce","modified":1650512542853},{"_id":"public/2019/09/28/UIScrollView-的偏移问题/index.html","hash":"f5083a2c9e4d4c5706ff4d63f95f2bb781559c00","modified":1650512542853},{"_id":"public/2018/11/06/Notification-的一些知识点/index.html","hash":"6ccf676737cc8fd6348396c83ba9b09d1bc3cc56","modified":1650512542853},{"_id":"public/2018/05/25/Swift-High-Performance-Tip 3：@objc-和-dynamic/index.html","hash":"14bad12638c3230a1a37b062e47a94a3f2d88406","modified":1650512542853},{"_id":"public/2018/04/19/self-在-block-中的引用计数变化/index.html","hash":"7d1728e34939d768d9b12ef3a6588e11d24ae756","modified":1650512542853},{"_id":"public/2018/04/02/如何用-Objective-C-实现一个死锁/index.html","hash":"f429194142e8ecab0629c84dbe9ab1c231da7b38","modified":1650512542853},{"_id":"public/2018/03/24/说说-Objective-C-中的-Copy-操作/index.html","hash":"9da99551a5129fdcb14a1f1b602d59ac31e66f48","modified":1650512542853},{"_id":"public/2018/03/20/如何在-iOS-上自定义-React-Native-Component/index.html","hash":"c32c6b00b813f2085af458cebd087a4ae25463e2","modified":1650512542853},{"_id":"public/2018/02/27/redux-之页面跳转/index.html","hash":"9a997306125b7b204467d2e4003fd4cccbb94adc","modified":1650512542853},{"_id":"public/2017/09/05/RAC和内存管理/index.html","hash":"094855f0b2aad6f7580842afea43e5bd43a9cc6d","modified":1650512542853},{"_id":"public/2017/09/05/Shell-Tip/index.html","hash":"93d0285bb386a5e8bd4cb5d8a5a28ef5fc7ad208","modified":1650512542853},{"_id":"public/2017/09/05/Swift-High-Performance-Tip 1：Array和ContiguousArray/index.html","hash":"e0554f8a929483aa211cae6fa36f47b69c479b7f","modified":1650512542853},{"_id":"public/2017/09/05/Vim-Tip/index.html","hash":"b1c0fbd57074d9c573d9da7fa49343a3f7c2e2b4","modified":1650512542853},{"_id":"public/2017/09/05/include和import的区别/index.html","hash":"d085e6acb8b52ebc9d545047bfea6b4a3b46124e","modified":1650512542853},{"_id":"public/2017/09/05/初步了解GCD/index.html","hash":"141e33950dcfb3ae60be5b517a4e115fbccfb752","modified":1650512542853},{"_id":"public/archives/2019/09/index.html","hash":"576aebf7010fa88dc2e83ead5ba79cfa56bcccaa","modified":1650512542853},{"_id":"public/categories/技术/index.html","hash":"466731c57b9db6fb97a0e0e8a7ed576e25df9b19","modified":1650512542853},{"_id":"public/categories/技术/page/2/index.html","hash":"104e0e36f69845679d50235f9202fd91e9621bfa","modified":1650512542853},{"_id":"public/tags/iOS/index.html","hash":"3fb9725e4345061d779fba7784287c01b0dca574","modified":1650512542853},{"_id":"public/tags/iOS/page/2/index.html","hash":"e8accd9abbad822b7215dd3e6021bb76b98f42c5","modified":1650512542853},{"_id":"public/tags/Swift/index.html","hash":"2a37fcee21a0a9e18525e02945175c3636ef1114","modified":1650512542853},{"_id":"public/tags/RAC/index.html","hash":"d20b6927d4edfb845a885f1cf787272fd538b7b9","modified":1650512542853},{"_id":"public/tags/tip/index.html","hash":"3a2269f96f933c314cba7596cebc1c74823968e3","modified":1650512542853},{"_id":"public/tags/RN/index.html","hash":"1da9d751665711af054d8d3e91b484a7136ab767","modified":1650512542853},{"_id":"public/tags/redux/index.html","hash":"61be528254906758e5e10146cbf0a666fee571f2","modified":1650512542853},{"_id":"public/tags/Objective-C/index.html","hash":"938e936d2085cf909e38b2bfefb2525f0879cc2c","modified":1650512542853},{"_id":"public/tags/Block/index.html","hash":"1e5bed9c5a8f255588985b126ef0a60138564e7d","modified":1650512542853},{"_id":"public/tags/GCD/index.html","hash":"b7ddfc5b4b6ed5f0d19fe29d649e473a7e488f61","modified":1650512542853},{"_id":"public/index.html","hash":"e0103aea9563314fc6493bd0d16b8fe370586183","modified":1650512542853},{"_id":"public/page/2/index.html","hash":"aaa6666c464541b9198cf828724cf8b814271690","modified":1650512542853},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1650512542853},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1650512542853},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1650512542853},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1650512542853},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1650512542853},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1650512542853},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1650512542853},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1650512542853},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1650512542853},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1650512542853},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1650512542853},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1650512542853},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1650512542853},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1650512542853},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1650512542853},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1650512542853},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1650512542853},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1650512542853},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1650512542853},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1650512542853},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1650512542853},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1650512542853},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1650512542853},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1650512542853},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1650512542853},{"_id":"public/css/main.css","hash":"095100e65c65d97f536bb16c3275d75dd0341f2d","modified":1650512542853},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1650512542853},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1650512542853},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1650512542853}],"Category":[{"name":"Raspberry PI","_id":"cl28gjxdz00046enq6pnq3a39"},{"name":"技术","_id":"cl28gjxe4000a6enqdcpdhii2"}],"Data":[],"Page":[{"title":"About","layout":"page","_content":"\n## 工作经历\n### 北京微梦创科网络技术有限公司\n\niOS 高级工程师（2019.12 - 至今）\n\n1. 负责对进行架构设计、开发、性能分析和优化，分析和发现系统的优化点 \n2. 新技术的学习并推动团队成员的技术进步\n3. 为产品部门提供技术支持，提出产品的不足之处，帮助改进产品\n4. 重构代码，封装常用的工具和团队的基础业务\n5. 日常的研发编码工作\n6. 自动化打包流程\n\n[![Social案例](https://is3-ssl.mzstatic.com/image/thumb/Purple116/v4/6b/0c/2d/6b0c2d4b-8ee3-6274-0773-285d56324dcf/AppIcon-0-0-1x_U007emarketing-0-0-0-5-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/230x0w.webp)](https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420)\n[Social案例](https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420)\n\n\n### 北京品冠天成科技有限公司\n\niOS 高级工程师（2016.08 - 2019.12）\n\n1. 负责日常的产品研发和维护工作 \n2. 负责对新技术的研究与应用\n3. 负责代码的重构和封装\n4. 定制项目的开发\n5. 微信小程序的开发 \n6. React Native 的开发 \n7. 自动化打包流程\n\n[![样本通](https://is1-ssl.mzstatic.com/image/thumb/Purple125/v4/d3/9e/07/d39e07f9-991b-03da-c670-e2cc3c30f462/AppIcon-0-0-1x_U007emarketing-0-0-0-7-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/230x0w.webp)](https://apps.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417)\n[样本通](https://apps.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417)\n\n### 北京黑米世纪网络科技有限公司\n\niOS 高级工程师（2013.03 - 2016.08）\n\n1. Review 团队成员代码，提出指导意见\n2. 负责对进行架构设计、开发、性能分析和优化，分析和发现系统的优化点 \n3. 新技术的学习并推动团队成员的技术进步\n4. 为产品部门提供技术支持，提出产品的不足之处，帮助改进产品\n5. 重构代码，封装常用的工具和公司的基础业务\n6. 日常的研发编码工作\n7. 负责客户端团队的招聘工作","source":"about/index.md","raw":"title: \"About\"\nlayout: \"page\"\n---\n\n## 工作经历\n### 北京微梦创科网络技术有限公司\n\niOS 高级工程师（2019.12 - 至今）\n\n1. 负责对进行架构设计、开发、性能分析和优化，分析和发现系统的优化点 \n2. 新技术的学习并推动团队成员的技术进步\n3. 为产品部门提供技术支持，提出产品的不足之处，帮助改进产品\n4. 重构代码，封装常用的工具和团队的基础业务\n5. 日常的研发编码工作\n6. 自动化打包流程\n\n[![Social案例](https://is3-ssl.mzstatic.com/image/thumb/Purple116/v4/6b/0c/2d/6b0c2d4b-8ee3-6274-0773-285d56324dcf/AppIcon-0-0-1x_U007emarketing-0-0-0-5-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/230x0w.webp)](https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420)\n[Social案例](https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420)\n\n\n### 北京品冠天成科技有限公司\n\niOS 高级工程师（2016.08 - 2019.12）\n\n1. 负责日常的产品研发和维护工作 \n2. 负责对新技术的研究与应用\n3. 负责代码的重构和封装\n4. 定制项目的开发\n5. 微信小程序的开发 \n6. React Native 的开发 \n7. 自动化打包流程\n\n[![样本通](https://is1-ssl.mzstatic.com/image/thumb/Purple125/v4/d3/9e/07/d39e07f9-991b-03da-c670-e2cc3c30f462/AppIcon-0-0-1x_U007emarketing-0-0-0-7-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/230x0w.webp)](https://apps.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417)\n[样本通](https://apps.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417)\n\n### 北京黑米世纪网络科技有限公司\n\niOS 高级工程师（2013.03 - 2016.08）\n\n1. Review 团队成员代码，提出指导意见\n2. 负责对进行架构设计、开发、性能分析和优化，分析和发现系统的优化点 \n3. 新技术的学习并推动团队成员的技术进步\n4. 为产品部门提供技术支持，提出产品的不足之处，帮助改进产品\n5. 重构代码，封装常用的工具和公司的基础业务\n6. 日常的研发编码工作\n7. 负责客户端团队的招聘工作","date":"2022-04-21T03:25:46.487Z","updated":"2022-04-21T03:25:46.487Z","path":"about/index.html","comments":1,"_id":"cl28gjxdr00006enq3hr1d9ew","content":"<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><h3 id=\"北京微梦创科网络技术有限公司\"><a href=\"#北京微梦创科网络技术有限公司\" class=\"headerlink\" title=\"北京微梦创科网络技术有限公司\"></a>北京微梦创科网络技术有限公司</h3><p>iOS 高级工程师（2019.12 - 至今）</p>\n<ol>\n<li>负责对进行架构设计、开发、性能分析和优化，分析和发现系统的优化点 </li>\n<li>新技术的学习并推动团队成员的技术进步</li>\n<li>为产品部门提供技术支持，提出产品的不足之处，帮助改进产品</li>\n<li>重构代码，封装常用的工具和团队的基础业务</li>\n<li>日常的研发编码工作</li>\n<li>自动化打包流程</li>\n</ol>\n<p><a href=\"https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420\"><img src=\"https://is3-ssl.mzstatic.com/image/thumb/Purple116/v4/6b/0c/2d/6b0c2d4b-8ee3-6274-0773-285d56324dcf/AppIcon-0-0-1x_U007emarketing-0-0-0-5-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/230x0w.webp\" alt=\"Social案例\"></a><br><a href=\"https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420\">Social案例</a></p>\n<h3 id=\"北京品冠天成科技有限公司\"><a href=\"#北京品冠天成科技有限公司\" class=\"headerlink\" title=\"北京品冠天成科技有限公司\"></a>北京品冠天成科技有限公司</h3><p>iOS 高级工程师（2016.08 - 2019.12）</p>\n<ol>\n<li>负责日常的产品研发和维护工作 </li>\n<li>负责对新技术的研究与应用</li>\n<li>负责代码的重构和封装</li>\n<li>定制项目的开发</li>\n<li>微信小程序的开发 </li>\n<li>React Native 的开发 </li>\n<li>自动化打包流程</li>\n</ol>\n<p><a href=\"https://apps.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417\"><img src=\"https://is1-ssl.mzstatic.com/image/thumb/Purple125/v4/d3/9e/07/d39e07f9-991b-03da-c670-e2cc3c30f462/AppIcon-0-0-1x_U007emarketing-0-0-0-7-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/230x0w.webp\" alt=\"样本通\"></a><br><a href=\"https://apps.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417\">样本通</a></p>\n<h3 id=\"北京黑米世纪网络科技有限公司\"><a href=\"#北京黑米世纪网络科技有限公司\" class=\"headerlink\" title=\"北京黑米世纪网络科技有限公司\"></a>北京黑米世纪网络科技有限公司</h3><p>iOS 高级工程师（2013.03 - 2016.08）</p>\n<ol>\n<li>Review 团队成员代码，提出指导意见</li>\n<li>负责对进行架构设计、开发、性能分析和优化，分析和发现系统的优化点 </li>\n<li>新技术的学习并推动团队成员的技术进步</li>\n<li>为产品部门提供技术支持，提出产品的不足之处，帮助改进产品</li>\n<li>重构代码，封装常用的工具和公司的基础业务</li>\n<li>日常的研发编码工作</li>\n<li>负责客户端团队的招聘工作</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><h3 id=\"北京微梦创科网络技术有限公司\"><a href=\"#北京微梦创科网络技术有限公司\" class=\"headerlink\" title=\"北京微梦创科网络技术有限公司\"></a>北京微梦创科网络技术有限公司</h3><p>iOS 高级工程师（2019.12 - 至今）</p>\n<ol>\n<li>负责对进行架构设计、开发、性能分析和优化，分析和发现系统的优化点 </li>\n<li>新技术的学习并推动团队成员的技术进步</li>\n<li>为产品部门提供技术支持，提出产品的不足之处，帮助改进产品</li>\n<li>重构代码，封装常用的工具和团队的基础业务</li>\n<li>日常的研发编码工作</li>\n<li>自动化打包流程</li>\n</ol>\n<p><a href=\"https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420\"><img src=\"https://is3-ssl.mzstatic.com/image/thumb/Purple116/v4/6b/0c/2d/6b0c2d4b-8ee3-6274-0773-285d56324dcf/AppIcon-0-0-1x_U007emarketing-0-0-0-5-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/230x0w.webp\" alt=\"Social案例\"></a><br><a href=\"https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420\">Social案例</a></p>\n<h3 id=\"北京品冠天成科技有限公司\"><a href=\"#北京品冠天成科技有限公司\" class=\"headerlink\" title=\"北京品冠天成科技有限公司\"></a>北京品冠天成科技有限公司</h3><p>iOS 高级工程师（2016.08 - 2019.12）</p>\n<ol>\n<li>负责日常的产品研发和维护工作 </li>\n<li>负责对新技术的研究与应用</li>\n<li>负责代码的重构和封装</li>\n<li>定制项目的开发</li>\n<li>微信小程序的开发 </li>\n<li>React Native 的开发 </li>\n<li>自动化打包流程</li>\n</ol>\n<p><a href=\"https://apps.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417\"><img src=\"https://is1-ssl.mzstatic.com/image/thumb/Purple125/v4/d3/9e/07/d39e07f9-991b-03da-c670-e2cc3c30f462/AppIcon-0-0-1x_U007emarketing-0-0-0-7-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/230x0w.webp\" alt=\"样本通\"></a><br><a href=\"https://apps.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417\">样本通</a></p>\n<h3 id=\"北京黑米世纪网络科技有限公司\"><a href=\"#北京黑米世纪网络科技有限公司\" class=\"headerlink\" title=\"北京黑米世纪网络科技有限公司\"></a>北京黑米世纪网络科技有限公司</h3><p>iOS 高级工程师（2013.03 - 2016.08）</p>\n<ol>\n<li>Review 团队成员代码，提出指导意见</li>\n<li>负责对进行架构设计、开发、性能分析和优化，分析和发现系统的优化点 </li>\n<li>新技术的学习并推动团队成员的技术进步</li>\n<li>为产品部门提供技术支持，提出产品的不足之处，帮助改进产品</li>\n<li>重构代码，封装常用的工具和公司的基础业务</li>\n<li>日常的研发编码工作</li>\n<li>负责客户端团队的招聘工作</li>\n</ol>\n"},{"title":"Categories","layout":"categories","_content":"","source":"categories/index.md","raw":"title: \"Categories\"\nlayout: \"categories\"\n---\n","date":"2022-04-20T07:08:33.126Z","updated":"2022-04-20T07:08:33.126Z","path":"categories/index.html","comments":1,"_id":"cl28gjxdx00026enqa5jedai4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"Tags\"\nlayout: \"tags\"\n---\n","date":"2022-04-20T07:08:33.126Z","updated":"2022-04-20T07:08:33.126Z","path":"tags/index.html","comments":1,"_id":"cl28gjxe000066enqdxdy9efn","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Raspberry PI 基本使用","date":"2018-03-05T22:04:56.000Z","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1507289872412-523fc6b2db5f?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=20ca9d0eba2016344894aec7bb453a2d&auto=format&fit=crop&w=160&q=100","_content":"\n\n## 1. 保证 Raspberry PI 能够在外网使用\n\n```sh\n// 在你的 Raspberry PI 上使用 autossh 来实现不掉线的反向代理：\nautossh -M 5678 -fNR 2018:localhost:22 root@54.219.12.213\n```\n\n```\n// 在你的外网服务器（比如上面例子中的：54.219.12.213）上可以使用 ssh 登录你的 Raspberry PI\nssh -p 2018 pi@127.0.0.1\n```\n\n","source":"_drafts/Raspberry-PI-基本使用.md","raw":"---\ntitle: Raspberry PI 基本使用\ndate: 2018-03-05 22:04:56 +0800\nauthor: 帕帕\ncategories: Raspberry PI\ntags: [Raspberry PI]\nthumbnail: https://images.unsplash.com/photo-1507289872412-523fc6b2db5f?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=20ca9d0eba2016344894aec7bb453a2d&auto=format&fit=crop&w=160&q=100\n---\n\n\n## 1. 保证 Raspberry PI 能够在外网使用\n\n```sh\n// 在你的 Raspberry PI 上使用 autossh 来实现不掉线的反向代理：\nautossh -M 5678 -fNR 2018:localhost:22 root@54.219.12.213\n```\n\n```\n// 在你的外网服务器（比如上面例子中的：54.219.12.213）上可以使用 ssh 登录你的 Raspberry PI\nssh -p 2018 pi@127.0.0.1\n```\n\n","slug":"Raspberry-PI-基本使用","published":0,"updated":"2022-04-20T07:08:33.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxdu00016enq7fcwdya8","content":"<h2 id=\"1-保证-Raspberry-PI-能够在外网使用\"><a href=\"#1-保证-Raspberry-PI-能够在外网使用\" class=\"headerlink\" title=\"1. 保证 Raspberry PI 能够在外网使用\"></a>1. 保证 Raspberry PI 能够在外网使用</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在你的 Raspberry PI 上使用 autossh 来实现不掉线的反向代理：</span><br><span class=\"line\">autossh -M 5678 -fNR 2018:localhost:22 root@54.219.12.213</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在你的外网服务器（比如上面例子中的：54.219.12.213）上可以使用 ssh 登录你的 Raspberry PI</span><br><span class=\"line\">ssh -p 2018 pi@127.0.0.1</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-保证-Raspberry-PI-能够在外网使用\"><a href=\"#1-保证-Raspberry-PI-能够在外网使用\" class=\"headerlink\" title=\"1. 保证 Raspberry PI 能够在外网使用\"></a>1. 保证 Raspberry PI 能够在外网使用</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在你的 Raspberry PI 上使用 autossh 来实现不掉线的反向代理：</span><br><span class=\"line\">autossh -M 5678 -fNR 2018:localhost:22 root@54.219.12.213</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在你的外网服务器（比如上面例子中的：54.219.12.213）上可以使用 ssh 登录你的 Raspberry PI</span><br><span class=\"line\">ssh -p 2018 pi@127.0.0.1</span><br></pre></td></tr></table></figure>\n\n"},{"title":"字典的存储结构","date":"2018-08-02T15:41:10.000Z","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1517077304055-6e89abbf09b0?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3f799bed83db2959c476e69a3307d39e&auto=format&fit=crop&w=160&q=100","_content":"\n在 Swift 中我们会这样来构造一个字典：\n```Swift\nlet dic = [\"cat\": \"vCat\", \"art\": \"vArt\", \"dog\": \"vDog\", \"rat\": \"vRat\"]\n```\n那如果让你来设计字典的存储结构，你会怎么设计呢？\n\n![](https://i.imgur.com/tmhQb4z.jpg)\n\n从图中可以看出，字典的存储结构其实也是一个数组（注意：数组里的每个元素也都是一个数组）。接下来，我们尝试用 Swift 来构造字典的存储和操作。\n\n## \n\n\n\n\n---\n\n**参考文献**\n\n1. https://adrianmejia.com/blog/2018/04/28/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial/#HashMaps\n\n","source":"_drafts/字典的存储结构.md","raw":"---\ntitle: 字典的存储结构\ndate: 2018-08-02 15:41:10 +0800\nauthor: 帕帕\ncategories: 技术\ntags: [iOS, Swift]\nthumbnail: https://images.unsplash.com/photo-1517077304055-6e89abbf09b0?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3f799bed83db2959c476e69a3307d39e&auto=format&fit=crop&w=160&q=100\n---\n\n在 Swift 中我们会这样来构造一个字典：\n```Swift\nlet dic = [\"cat\": \"vCat\", \"art\": \"vArt\", \"dog\": \"vDog\", \"rat\": \"vRat\"]\n```\n那如果让你来设计字典的存储结构，你会怎么设计呢？\n\n![](https://i.imgur.com/tmhQb4z.jpg)\n\n从图中可以看出，字典的存储结构其实也是一个数组（注意：数组里的每个元素也都是一个数组）。接下来，我们尝试用 Swift 来构造字典的存储和操作。\n\n## \n\n\n\n\n---\n\n**参考文献**\n\n1. https://adrianmejia.com/blog/2018/04/28/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial/#HashMaps\n\n","slug":"字典的存储结构","published":0,"updated":"2022-04-20T07:08:33.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxdy00036enq2n1cb83r","content":"<p>在 Swift 中我们会这样来构造一个字典：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dic <span class=\"operator\">=</span> [<span class=\"string\">&quot;cat&quot;</span>: <span class=\"string\">&quot;vCat&quot;</span>, <span class=\"string\">&quot;art&quot;</span>: <span class=\"string\">&quot;vArt&quot;</span>, <span class=\"string\">&quot;dog&quot;</span>: <span class=\"string\">&quot;vDog&quot;</span>, <span class=\"string\">&quot;rat&quot;</span>: <span class=\"string\">&quot;vRat&quot;</span>]</span><br></pre></td></tr></table></figure>\n<p>那如果让你来设计字典的存储结构，你会怎么设计呢？</p>\n<p><img src=\"https://i.imgur.com/tmhQb4z.jpg\"></p>\n<p>从图中可以看出，字典的存储结构其实也是一个数组（注意：数组里的每个元素也都是一个数组）。接下来，我们尝试用 Swift 来构造字典的存储和操作。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><hr>\n<p><strong>参考文献</strong></p>\n<ol>\n<li><a href=\"https://adrianmejia.com/blog/2018/04/28/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial/#HashMaps\">https://adrianmejia.com/blog/2018/04/28/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial/#HashMaps</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>在 Swift 中我们会这样来构造一个字典：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dic <span class=\"operator\">=</span> [<span class=\"string\">&quot;cat&quot;</span>: <span class=\"string\">&quot;vCat&quot;</span>, <span class=\"string\">&quot;art&quot;</span>: <span class=\"string\">&quot;vArt&quot;</span>, <span class=\"string\">&quot;dog&quot;</span>: <span class=\"string\">&quot;vDog&quot;</span>, <span class=\"string\">&quot;rat&quot;</span>: <span class=\"string\">&quot;vRat&quot;</span>]</span><br></pre></td></tr></table></figure>\n<p>那如果让你来设计字典的存储结构，你会怎么设计呢？</p>\n<p><img src=\"https://i.imgur.com/tmhQb4z.jpg\"></p>\n<p>从图中可以看出，字典的存储结构其实也是一个数组（注意：数组里的每个元素也都是一个数组）。接下来，我们尝试用 Swift 来构造字典的存储和操作。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><hr>\n<p><strong>参考文献</strong></p>\n<ol>\n<li><a href=\"https://adrianmejia.com/blog/2018/04/28/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial/#HashMaps\">https://adrianmejia.com/blog/2018/04/28/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial/#HashMaps</a></li>\n</ol>\n"},{"title":"常用工具","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1514443031610-8c063c7a9822?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=73d9a7ce5ba0ed22cb91bdc0506ac9d0&auto=format&fit=crop&w=160&q=10","_content":"\n> 此文章暂未完成....\n\n# Ruby\n\n## 版本管理工具 - rvm\n\n* `$ rvm list` 列出已安装的 ruby 版本\n* `$ rvm list kn=own` 显示 local + remote 的 ruby 版本\n* `$ rvm use [ruby-version]` 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本\n* `$ rvm remove [ruby-version]` 删除 ruby 版本\n\n## 包管理工具 - gem\n\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem update` 更新 gem 包\n* `$ gem update --system` 更新 gem 本身\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem list` 列出所有安装的 gem 包\n* `$ gem remove [gem-package]` 删除安装过的 gem 包\n\n\n## 常用工具\n\n### cocoapods\n\n* `$ gem instal cocoapods` 安装 cocoapods\n* `$ pod setup` 初始化 Pod 库\n* `$ pod repo update` 更新 Pod 库\n* `$ pod install` 根据当前目录的 Podfile 文件安装 Pod 库\n* `$ pod update` 更新 Podfile 文件中的 Pod 库\n\n# Python\n\n## 版本管理工具 - pyenv\n\n\n# JavaScript\n\n\n## 包管理工具 - npm\n\n\n# 包管理工具 - brew\n\n* `brew update` 更新 pythpackage\n* `brew cleanup` 移除旧版本\n* `brew cleanup -n` 查看可以清理的旧版本\n* `brew list` 列出已安装的 package\n\n\n","source":"_drafts/常用工具.md","raw":"---\ntitle: 常用工具\nauthor: 帕帕\ncategories: 技术\ntags: [其他]\nthumbnail: https://images.unsplash.com/photo-1514443031610-8c063c7a9822?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=73d9a7ce5ba0ed22cb91bdc0506ac9d0&auto=format&fit=crop&w=160&q=10\n---\n\n> 此文章暂未完成....\n\n# Ruby\n\n## 版本管理工具 - rvm\n\n* `$ rvm list` 列出已安装的 ruby 版本\n* `$ rvm list kn=own` 显示 local + remote 的 ruby 版本\n* `$ rvm use [ruby-version]` 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本\n* `$ rvm remove [ruby-version]` 删除 ruby 版本\n\n## 包管理工具 - gem\n\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem update` 更新 gem 包\n* `$ gem update --system` 更新 gem 本身\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem list` 列出所有安装的 gem 包\n* `$ gem remove [gem-package]` 删除安装过的 gem 包\n\n\n## 常用工具\n\n### cocoapods\n\n* `$ gem instal cocoapods` 安装 cocoapods\n* `$ pod setup` 初始化 Pod 库\n* `$ pod repo update` 更新 Pod 库\n* `$ pod install` 根据当前目录的 Podfile 文件安装 Pod 库\n* `$ pod update` 更新 Podfile 文件中的 Pod 库\n\n# Python\n\n## 版本管理工具 - pyenv\n\n\n# JavaScript\n\n\n## 包管理工具 - npm\n\n\n# 包管理工具 - brew\n\n* `brew update` 更新 pythpackage\n* `brew cleanup` 移除旧版本\n* `brew cleanup -n` 查看可以清理的旧版本\n* `brew list` 列出已安装的 package\n\n\n","slug":"常用工具","published":0,"date":"2022-04-20T07:08:33.121Z","updated":"2022-04-20T07:08:33.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxe100076enq224yhw95","content":"<blockquote>\n<p>此文章暂未完成….</p>\n</blockquote>\n<h1 id=\"Ruby\"><a href=\"#Ruby\" class=\"headerlink\" title=\"Ruby\"></a>Ruby</h1><h2 id=\"版本管理工具-rvm\"><a href=\"#版本管理工具-rvm\" class=\"headerlink\" title=\"版本管理工具 - rvm\"></a>版本管理工具 - rvm</h2><ul>\n<li><code>$ rvm list</code> 列出已安装的 ruby 版本</li>\n<li><code>$ rvm list kn=own</code> 显示 local + remote 的 ruby 版本</li>\n<li><code>$ rvm use [ruby-version]</code> 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本</li>\n<li><code>$ rvm remove [ruby-version]</code> 删除 ruby 版本</li>\n</ul>\n<h2 id=\"包管理工具-gem\"><a href=\"#包管理工具-gem\" class=\"headerlink\" title=\"包管理工具 - gem\"></a>包管理工具 - gem</h2><ul>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem update</code> 更新 gem 包</li>\n<li><code>$ gem update --system</code> 更新 gem 本身</li>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem list</code> 列出所有安装的 gem 包</li>\n<li><code>$ gem remove [gem-package]</code> 删除安装过的 gem 包</li>\n</ul>\n<h2 id=\"常用工具\"><a href=\"#常用工具\" class=\"headerlink\" title=\"常用工具\"></a>常用工具</h2><h3 id=\"cocoapods\"><a href=\"#cocoapods\" class=\"headerlink\" title=\"cocoapods\"></a>cocoapods</h3><ul>\n<li><code>$ gem instal cocoapods</code> 安装 cocoapods</li>\n<li><code>$ pod setup</code> 初始化 Pod 库</li>\n<li><code>$ pod repo update</code> 更新 Pod 库</li>\n<li><code>$ pod install</code> 根据当前目录的 Podfile 文件安装 Pod 库</li>\n<li><code>$ pod update</code> 更新 Podfile 文件中的 Pod 库</li>\n</ul>\n<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h2 id=\"版本管理工具-pyenv\"><a href=\"#版本管理工具-pyenv\" class=\"headerlink\" title=\"版本管理工具 - pyenv\"></a>版本管理工具 - pyenv</h2><h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><h2 id=\"包管理工具-npm\"><a href=\"#包管理工具-npm\" class=\"headerlink\" title=\"包管理工具 - npm\"></a>包管理工具 - npm</h2><h1 id=\"包管理工具-brew\"><a href=\"#包管理工具-brew\" class=\"headerlink\" title=\"包管理工具 - brew\"></a>包管理工具 - brew</h1><ul>\n<li><code>brew update</code> 更新 pythpackage</li>\n<li><code>brew cleanup</code> 移除旧版本</li>\n<li><code>brew cleanup -n</code> 查看可以清理的旧版本</li>\n<li><code>brew list</code> 列出已安装的 package</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>此文章暂未完成….</p>\n</blockquote>\n<h1 id=\"Ruby\"><a href=\"#Ruby\" class=\"headerlink\" title=\"Ruby\"></a>Ruby</h1><h2 id=\"版本管理工具-rvm\"><a href=\"#版本管理工具-rvm\" class=\"headerlink\" title=\"版本管理工具 - rvm\"></a>版本管理工具 - rvm</h2><ul>\n<li><code>$ rvm list</code> 列出已安装的 ruby 版本</li>\n<li><code>$ rvm list kn=own</code> 显示 local + remote 的 ruby 版本</li>\n<li><code>$ rvm use [ruby-version]</code> 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本</li>\n<li><code>$ rvm remove [ruby-version]</code> 删除 ruby 版本</li>\n</ul>\n<h2 id=\"包管理工具-gem\"><a href=\"#包管理工具-gem\" class=\"headerlink\" title=\"包管理工具 - gem\"></a>包管理工具 - gem</h2><ul>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem update</code> 更新 gem 包</li>\n<li><code>$ gem update --system</code> 更新 gem 本身</li>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem list</code> 列出所有安装的 gem 包</li>\n<li><code>$ gem remove [gem-package]</code> 删除安装过的 gem 包</li>\n</ul>\n<h2 id=\"常用工具\"><a href=\"#常用工具\" class=\"headerlink\" title=\"常用工具\"></a>常用工具</h2><h3 id=\"cocoapods\"><a href=\"#cocoapods\" class=\"headerlink\" title=\"cocoapods\"></a>cocoapods</h3><ul>\n<li><code>$ gem instal cocoapods</code> 安装 cocoapods</li>\n<li><code>$ pod setup</code> 初始化 Pod 库</li>\n<li><code>$ pod repo update</code> 更新 Pod 库</li>\n<li><code>$ pod install</code> 根据当前目录的 Podfile 文件安装 Pod 库</li>\n<li><code>$ pod update</code> 更新 Podfile 文件中的 Pod 库</li>\n</ul>\n<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h2 id=\"版本管理工具-pyenv\"><a href=\"#版本管理工具-pyenv\" class=\"headerlink\" title=\"版本管理工具 - pyenv\"></a>版本管理工具 - pyenv</h2><h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><h2 id=\"包管理工具-npm\"><a href=\"#包管理工具-npm\" class=\"headerlink\" title=\"包管理工具 - npm\"></a>包管理工具 - npm</h2><h1 id=\"包管理工具-brew\"><a href=\"#包管理工具-brew\" class=\"headerlink\" title=\"包管理工具 - brew\"></a>包管理工具 - brew</h1><ul>\n<li><code>brew update</code> 更新 pythpackage</li>\n<li><code>brew cleanup</code> 移除旧版本</li>\n<li><code>brew cleanup -n</code> 查看可以清理的旧版本</li>\n<li><code>brew list</code> 列出已安装的 package</li>\n</ul>\n"},{"title":"浅谈 iOS 架构","date":"2019-03-04T16:58:32.000Z","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1514464750060-00e6e34c8b8c?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3749c47dd7beec20102c6b32fc19833a&auto=format&fit=crop&w=160&q=100","_content":"\n## 架构还是框架\n老实说，一开始我对这两个概念还是很模糊的。这段时间通过不断的思考和学习，从我个人的理解来说架构和框架有一个根本性的区别（当然，对架构和框架的理解会随着不停的深入而有所不同）：de\n\n> 架构：原则指导\n> 框架：规则约束\n\n架构设计可以通过一些原则（比如单一职责原则、开放封闭原则、接口分离原则等等）来指导我们进行设计，设计的过程中需要考虑业务和团队的因素。\n\n框架其实是一套规则，它约束着你应该怎么去做实现。比如我们常见的 MVC、MVVM、MVP、VIPER 等等，这些都是属于框架的范畴。框架是可以被具现化的，这是它和架构的一个不同点。比如我们常说的 redux 框架，它就有具体的实现 [redux.js](https://redux.js.org/)，我将这成为框架的具现化。\n\n## 架构设计\n我们都知道用户对客户端的最重要和最直接的感受就是 UI，而 UI 的内容是需要用数据来填充的。所以，对于客户端的架构设计，我们大体上可以从这两个维度来设计。\n\n### UI 设计\nUI 的架构设计基本上没有什么好说的。这里我们需要注意的就是把控件分成两种类型，基础控件和业务组件。业务组件是指跟业务强相关的控件，一旦换了业务就代表这个控件可能不再可用；基础控件基本上就跟业务无关了，它主要是确定了整个 UI 的风格和基调，并且它可以比较方便的被移植。\n\n在 iOS 上还有一个需要注意的是，不应该在 UITableViewCell、UICollectionViewCell、UICollectionReusableView 做具体的 UI 实现，而是应该在 UIView 或 UIResponse 的子类中做具体的 UI 实现，然后在 UITableViewCell、UICollectionViewCell、UICollectionReusableView **「贴上」**具体的 UI 实现。假设你用 UITableViewCell 直接做 UI 细节的实现，一旦当前页面要换成 UICollectionView 实现的时候，我们就很难直接复用 UITableViewCell 的 UI 实现了。\n\n### 数据设计\n\n这里需要注意的是，网络层和持久层所处理的数据都是原始数据，数据层需要将原始数据 Model 化，交给上层使用。\n\n\n\n## 框架设计\n在 iOS 开发中，主要的框架有 MVC、MVP、MVVM、VIPER 等等，至于这几个架构的优缺点可以看看「[iOS Architecture Patterns Demystifying MVC, MVP, MVVM and VIPER](https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.tliwdfd60)」这篇文章。\n\n其中 MVC(Model-View-Controller) 是最为开发者所熟悉的，同时也是用的最多的。但随着时间的推移和业务的发展，MVC 框架已经不能满足我们的需求。因为所有的业务逻辑都围着 C 转，C 变得越来越臃肿，越来越难以维护。于是广大的开发者又探讨出来几种其他的框架，有些是基于 MVC 框架改造的，有些是借鉴了其他平台的主流框架（比如 redux）。\n\n在框架选择上，我主要选择 MVVM 框架。主要是考虑到团队成员都有开发 iOS 的背景，所以大家都比较熟悉原来的 MVC 框架，而 MVVM 是在 MVC 的框架上做改进，所以团队的成员要上手 MVVM 也会比较容易，推广起来也会容易点。如果有一天，当我们使用跨平台的技术栈来实现我们的业务，那我可能就不会选择 MVVM 了，有可能就选在 redux。所以选择框架的时候还是要根据自身的业务和团队情况选择合适的框架。\n\n接下来我会主要讲讲 MVVM，包括对 MVVM 的一些改变吧。\n\n### MVVM\n\n![图一](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png)\n\n在图一这个经典的 MVVM 框架图中，总共有四个角色。\n\n* Model:\nModel 只是简单的做数据展示和通知数据发生变化的工作，当然你也可以用 KVO 或者 RX 框架来主动监听 Model 数据的变化。\n\n* View:\nView 也只是简单的处理 UI 的布局和变化。\n\n* ViewModel:\nViewModel 基本上承接了以前 Controller 的大部分工作，它需要处理各种业务逻辑（数据缓存、网络请求、事件处理等等）。\n\n* Controller:\nController 现在同时拥有 View 和 ViewModel，并且它的主要工作基本上就是绑定。\nViewModel 会有一系列 States 和 Actions，当在 Controller 中完成了绑定的工作，那么 ViewModel 的 State 发生了变化就会引起 View 的变化，View 的事件都会交给 ViewModel 的 Action 进行处理。\n\n现在假设我们有两个按钮「收藏」和「保存」可以对图片进行操作，其中收藏按钮通过点击之后会向服务器发送请求，请求成功之后收藏按钮的文案变成「已收藏」；点击保存按钮之后就直接把图片保存到本地相册。以前我们会把这一系列逻辑代码都写到 Controller，那现在如果用 MVVM 可以会变成什么样呢？看下面代码：\n\n```Swift\nclass FavViewModel {\n    init(id: String) {\n        // init\n    }\n    \n    // MARK: - States\n    private var title: String = \"收藏\" {\n        didSet(oldValue) {\n            guard oldValue != title else {\n                return\n            }\n            DispatchQueue.main.async {\n                self.titleChange?(self.title)\n            }\n        }\n    }\n    var titleChange: ((String) -> Void)? {\n        didSet {\n            DispatchQueue.main.async {\n                self.titleChange?(self.title)\n            }\n        }\n    }\n    \n    // MARK: - Actions\n    @objc func favAction() {\n        // Async Request\n        title = \"已收藏\"\n    }\n}\nclass SaveViewModel {\n    init(image: UIImage) {\n        // init\n    }\n    \n    // MARK: - States\n    let title = \"保存\" \n        \n    // MARK: - Actions\n    @objc func saveAction() {\n        // Async save image\n    }\n}\n\nclass Controller: UIViewController {  \n    override func viewDidLoad() {\n        view.addSubview(favButton)\n        view.addSubview(saveButton)\n        \n        // 绑定 FavButton 和 FavViewModel\n        favButton.addTarget(favViewModel, action: #selector(FavViewModel.favAction), for: .touchUpInside)\n        favViewModel.titleChange = { [unowned self] title in\n            self.favButton.setTitle(title, for: .normal)\n        }\n        \n        // 绑定 SaveButton 和 SaveViewModel\n        saveButton.setTitle(saveViewModel.title, for: .normal)\n        saveButton.addTarget(saveViewModel, action: #selector(SaveViewModel.saveAction), for: .touchUpInside)\n    }\n    \n     // MARK: - Lazy\n    lazy var favButton = { () -> UIButton in\n        return UIButton()\n    }()\n    lazy var favViewModel = { () -> FavViewModel in\n        return FavViewModel.init(id: self.id)\n    }()\n    \n    lazy var saveButton = { () -> UIButton in\n        return UIButton()\n    }()\n    lazy var saveViewModel = { () -> SaveViewModel in\n        return SaveViewModel.init(image: self.image)\n    }()\n}\n```\n\n👆的代码基本上展示了如何在 Swift 中实现经典的 MVVM 框架，其中有几个需要注意的地方：\n1. 当给 titleChange 赋值的时候需要立即调用 titleChange(title)\n2. 需要在主线程调用 titleChange(title)\n\n> 上面的代码没有用到任何第三方框架就可以实现 MVVM，当然如果使用了 Rx 之类的框架可以让我们在代码上和绑定逻辑上可以写得更简洁。\n\n上面的例子在实际的实践过程中还是有一些问题的：\n1. 如果有多个 Controller 都用到相同的 View，那在每个 Controller 中都要做一遍绑定的工作么？\n2. 如果有不同的 ViewModel 用到相同的 Model，那从网络请求到转换成 Model 到本地缓存这一些逻辑都要再写一遍么？\n\n我的处理方法是在这里加一层 Extension(⚠️，这里的 Extension 只是为了表明对原有功能的扩展，它和 Objective-C 中 Extension 的概念不一样哦。在 Objective-C 中可以用 Category 来实现这一层扩展，当然在 Swfit 中可以是 Extension)，看下面的图二：\n\n![图二](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png)\n\n首先我们注意到 Controller 和 ViewMode 的关系从原来的「实线 Owns」变成「虚线 Create」，这表明了 Controller 不再持有 ViewModel，而是创建 ViewModel 然后分配给不同的 View。从图中可以看到 View 持有了 ViewModel，同时在 View 的 Extension 层完成了绑定的工作。首先，这样就解决了我们之前的问题，实现在不同的 Controller 中重复完成绑定的工作。\n\n为什么要在 View 的 Extension 中做这个绑定并且持有 ViewModel 的操作？首先，我们要明白其实这个绑定工作是和 View 有强联系的。而且 View 和不同 ViewModel 的绑定都可以统一到这个扩展层，方便管理。\n\n所以我们之前的例子可以稍微做一下修改：\n```Swift\nextension UIButton {\n    func bind(viewModel: FavViewModel) {\n        addTarget(viewModel, action: #selector(FavViewModel.favAction), for: .touchUpInside)\n        viewModel.titleChange = { [unowned self] title in\n            self.setTitle(title, for: .normal)\n        }\n    }\n    \n    func bind(viewMode: SaveViewModel) {\n        setTitle(viewMode.title, for: .normal)\n        addTarget(viewMode, action: #selector(SaveViewModel.saveAction), for: .touchUpInside)\n    }\n}\n\nclass ControllerA: UIViewController {\n    override func viewDidLoad() {\n        view.addSubview(favButton)\n        view.addSubview(saveButton)\n        \n        favButton.bind(viewMode: FavViewModel.init(id: self.id))\n        saveButton.bind(viewMode: SaveViewModel.init(image: self.image))\n    }\n}\n\nclass ControllerB: UIViewController {\n    override func viewDidLoad() {\n        view.addSubview(favButton)\n        \n        favButton.bind(viewMode: FavViewModel.init(id: self.id))\n    }\n}\n```\n\n我们可以看到，ControllerA 和 ControllerB 的工作变得异常简单，创建 ViewModel 然后传给 View 的 Extension 层去做绑定。\n\n类似的，Model 这一边也可以增加 Extension 层来统一管理 Model 的缓存、数据请求、JSON 转 Model 还有一些其他的弱业务逻辑处理。但是如果这样做，本来一个纯数据展示的「瘦 Model」就变成一个带逻辑的「胖 Model」（关于「胖 Model」和「瘦 Model」的讨论，推荐看一下这篇文章「[iOS应用架构谈 view层的组织和调用方案](https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html)」）。不过因为我们是用 Extension 机制来实现的，不会对 Model 的数据造成额外的影响。当我们需要迁移 Model 的时候只需要把 Extension 这一层舍弃掉就可以了。至于是「胖 Model」还是「瘦 Model」，我觉得问题都不大，只要这些工作都是围绕 Model 本身来实现的，然后在整个架构中取得一个平衡就可以了。\n\n所以修改后的 MVVM 框架图如下：\n\n![图三](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png)\n\n> 注意：图三中还有一个 Router，它主要是来实现模块和模块之间的跳转，后面我们会继续深入了解。这里就先放着，暂不做详细的说明。\n\n这里我们以一个稍微复杂点的例子来说明一下，假设我们有一个新闻列表页面，新闻列表只需要显示标题；点击某条新闻之后进入新闻详情页面，在新闻详情页面可以点赞这条新闻。\n\n\n\n目的：\n1. 指导代码的实现\n2. 代码可单元测试\n3. 高内聚，低耦合\n4. 提高代码的可复用性\n\n\nMVC框架：\n\n优点：\n1. 其概念简单，易于理解，iOS 开发附赠\n2. 其中 View 和 Model 的可维护性和可测试性较好\n\n缺点：\n1. Controller 职责过于复杂，导致其可维护性和可测试性特别差\n2. Model 和 View 不一定能一一对应起来，需要在 Controller 中\n3. 任务分配极其不合理，View 和 Model 的任务过于轻松\n4. 代码可读性差\n\n\nMVVM 框架：\n\n优点：\n1. 基于 MVC 改进而来，上手难度不大\n2. Controller 变得轻量级，维护方便\n3. Model 不和 View 直接对应，而是通过 ViewModel 做了转换之后可以一一对应\n4. 开发人员可以专注于业务逻辑和数据的开发 ViewModel，设计人员可以专注于页面设计\n\n缺点：\n1. ViewModel 容易变得跟 Controller 一样臃肿\n2. 如何把一个页面拆分成不同的 ViewModel 来实现，会增加复杂性\n3. 数据存储可能会不一致\n4. 过于简单的图形界面不适用\n\n\nMVVM + Extension 框架\n\n优点：\n1. 任务拆分相对合理，每个角色都有自己的任务\n2. Extension 跟 View 和 Model 形成强绑定关系，一旦 View 或 Model 被移除掉，相对应的 Extension 也可以不要\n3. 每个角色的功能比较清晰，在开发相应角色时只需要完成该角色本身的功能即可，开发流程相对固定\n4. 代码重用度高\n\n缺点：\n1. 代码文件多增多，增加切换文件的成本\n2. 上手难度较大，需要额外理解 Extension 的作用\n3. 过于简单的图形界面不适用\n\n\n架构方案 A：三层结构是由于之前的 MVC 框架导致的，因为在 MVC 框架中会不小心就把所有代码都放到 Controller 实现。\n\n优点：\n1. 业务开发快速\n2. 层级简单，开发基本上只需要关心业务层的开发\n3. 开发周期快\n\n缺点：\n1. 代码重用度不高，导致相同的功能在不同模块可能会出现实现逻辑不一致的问题\n2. 测试困难，业务层涵盖的功能和任务太多\n3. 项目可理解性差\n\n架构方案 B：\n优点：\n1. 代码重用度高\n2. 把业务（变化快）和服务（变化慢）分层实现，有利于项目的维护以及在后续开发中节省时间\n3. 模块与模块间的耦合性低\n4. 代码可以单元测试\n5. 容易理解（万岁）\n\n缺点：\n1. 增加了把哪些内容下沉到服务以及如何拆分服务的复杂度\n2. 模块跳转时需要知道目标模块的地址（字符串），需要单独维护一个表来实现跳转的功能\n3. \n","source":"_drafts/浅谈-iOS-架构.md","raw":"---\ntitle: 浅谈 iOS 架构\ndate: 2019-03-04 16:58:32 +0800\nauthor: 帕帕\ncategories: 技术\ntags: [iOS]\nthumbnail: https://images.unsplash.com/photo-1514464750060-00e6e34c8b8c?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3749c47dd7beec20102c6b32fc19833a&auto=format&fit=crop&w=160&q=100\n---\n\n## 架构还是框架\n老实说，一开始我对这两个概念还是很模糊的。这段时间通过不断的思考和学习，从我个人的理解来说架构和框架有一个根本性的区别（当然，对架构和框架的理解会随着不停的深入而有所不同）：de\n\n> 架构：原则指导\n> 框架：规则约束\n\n架构设计可以通过一些原则（比如单一职责原则、开放封闭原则、接口分离原则等等）来指导我们进行设计，设计的过程中需要考虑业务和团队的因素。\n\n框架其实是一套规则，它约束着你应该怎么去做实现。比如我们常见的 MVC、MVVM、MVP、VIPER 等等，这些都是属于框架的范畴。框架是可以被具现化的，这是它和架构的一个不同点。比如我们常说的 redux 框架，它就有具体的实现 [redux.js](https://redux.js.org/)，我将这成为框架的具现化。\n\n## 架构设计\n我们都知道用户对客户端的最重要和最直接的感受就是 UI，而 UI 的内容是需要用数据来填充的。所以，对于客户端的架构设计，我们大体上可以从这两个维度来设计。\n\n### UI 设计\nUI 的架构设计基本上没有什么好说的。这里我们需要注意的就是把控件分成两种类型，基础控件和业务组件。业务组件是指跟业务强相关的控件，一旦换了业务就代表这个控件可能不再可用；基础控件基本上就跟业务无关了，它主要是确定了整个 UI 的风格和基调，并且它可以比较方便的被移植。\n\n在 iOS 上还有一个需要注意的是，不应该在 UITableViewCell、UICollectionViewCell、UICollectionReusableView 做具体的 UI 实现，而是应该在 UIView 或 UIResponse 的子类中做具体的 UI 实现，然后在 UITableViewCell、UICollectionViewCell、UICollectionReusableView **「贴上」**具体的 UI 实现。假设你用 UITableViewCell 直接做 UI 细节的实现，一旦当前页面要换成 UICollectionView 实现的时候，我们就很难直接复用 UITableViewCell 的 UI 实现了。\n\n### 数据设计\n\n这里需要注意的是，网络层和持久层所处理的数据都是原始数据，数据层需要将原始数据 Model 化，交给上层使用。\n\n\n\n## 框架设计\n在 iOS 开发中，主要的框架有 MVC、MVP、MVVM、VIPER 等等，至于这几个架构的优缺点可以看看「[iOS Architecture Patterns Demystifying MVC, MVP, MVVM and VIPER](https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.tliwdfd60)」这篇文章。\n\n其中 MVC(Model-View-Controller) 是最为开发者所熟悉的，同时也是用的最多的。但随着时间的推移和业务的发展，MVC 框架已经不能满足我们的需求。因为所有的业务逻辑都围着 C 转，C 变得越来越臃肿，越来越难以维护。于是广大的开发者又探讨出来几种其他的框架，有些是基于 MVC 框架改造的，有些是借鉴了其他平台的主流框架（比如 redux）。\n\n在框架选择上，我主要选择 MVVM 框架。主要是考虑到团队成员都有开发 iOS 的背景，所以大家都比较熟悉原来的 MVC 框架，而 MVVM 是在 MVC 的框架上做改进，所以团队的成员要上手 MVVM 也会比较容易，推广起来也会容易点。如果有一天，当我们使用跨平台的技术栈来实现我们的业务，那我可能就不会选择 MVVM 了，有可能就选在 redux。所以选择框架的时候还是要根据自身的业务和团队情况选择合适的框架。\n\n接下来我会主要讲讲 MVVM，包括对 MVVM 的一些改变吧。\n\n### MVVM\n\n![图一](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png)\n\n在图一这个经典的 MVVM 框架图中，总共有四个角色。\n\n* Model:\nModel 只是简单的做数据展示和通知数据发生变化的工作，当然你也可以用 KVO 或者 RX 框架来主动监听 Model 数据的变化。\n\n* View:\nView 也只是简单的处理 UI 的布局和变化。\n\n* ViewModel:\nViewModel 基本上承接了以前 Controller 的大部分工作，它需要处理各种业务逻辑（数据缓存、网络请求、事件处理等等）。\n\n* Controller:\nController 现在同时拥有 View 和 ViewModel，并且它的主要工作基本上就是绑定。\nViewModel 会有一系列 States 和 Actions，当在 Controller 中完成了绑定的工作，那么 ViewModel 的 State 发生了变化就会引起 View 的变化，View 的事件都会交给 ViewModel 的 Action 进行处理。\n\n现在假设我们有两个按钮「收藏」和「保存」可以对图片进行操作，其中收藏按钮通过点击之后会向服务器发送请求，请求成功之后收藏按钮的文案变成「已收藏」；点击保存按钮之后就直接把图片保存到本地相册。以前我们会把这一系列逻辑代码都写到 Controller，那现在如果用 MVVM 可以会变成什么样呢？看下面代码：\n\n```Swift\nclass FavViewModel {\n    init(id: String) {\n        // init\n    }\n    \n    // MARK: - States\n    private var title: String = \"收藏\" {\n        didSet(oldValue) {\n            guard oldValue != title else {\n                return\n            }\n            DispatchQueue.main.async {\n                self.titleChange?(self.title)\n            }\n        }\n    }\n    var titleChange: ((String) -> Void)? {\n        didSet {\n            DispatchQueue.main.async {\n                self.titleChange?(self.title)\n            }\n        }\n    }\n    \n    // MARK: - Actions\n    @objc func favAction() {\n        // Async Request\n        title = \"已收藏\"\n    }\n}\nclass SaveViewModel {\n    init(image: UIImage) {\n        // init\n    }\n    \n    // MARK: - States\n    let title = \"保存\" \n        \n    // MARK: - Actions\n    @objc func saveAction() {\n        // Async save image\n    }\n}\n\nclass Controller: UIViewController {  \n    override func viewDidLoad() {\n        view.addSubview(favButton)\n        view.addSubview(saveButton)\n        \n        // 绑定 FavButton 和 FavViewModel\n        favButton.addTarget(favViewModel, action: #selector(FavViewModel.favAction), for: .touchUpInside)\n        favViewModel.titleChange = { [unowned self] title in\n            self.favButton.setTitle(title, for: .normal)\n        }\n        \n        // 绑定 SaveButton 和 SaveViewModel\n        saveButton.setTitle(saveViewModel.title, for: .normal)\n        saveButton.addTarget(saveViewModel, action: #selector(SaveViewModel.saveAction), for: .touchUpInside)\n    }\n    \n     // MARK: - Lazy\n    lazy var favButton = { () -> UIButton in\n        return UIButton()\n    }()\n    lazy var favViewModel = { () -> FavViewModel in\n        return FavViewModel.init(id: self.id)\n    }()\n    \n    lazy var saveButton = { () -> UIButton in\n        return UIButton()\n    }()\n    lazy var saveViewModel = { () -> SaveViewModel in\n        return SaveViewModel.init(image: self.image)\n    }()\n}\n```\n\n👆的代码基本上展示了如何在 Swift 中实现经典的 MVVM 框架，其中有几个需要注意的地方：\n1. 当给 titleChange 赋值的时候需要立即调用 titleChange(title)\n2. 需要在主线程调用 titleChange(title)\n\n> 上面的代码没有用到任何第三方框架就可以实现 MVVM，当然如果使用了 Rx 之类的框架可以让我们在代码上和绑定逻辑上可以写得更简洁。\n\n上面的例子在实际的实践过程中还是有一些问题的：\n1. 如果有多个 Controller 都用到相同的 View，那在每个 Controller 中都要做一遍绑定的工作么？\n2. 如果有不同的 ViewModel 用到相同的 Model，那从网络请求到转换成 Model 到本地缓存这一些逻辑都要再写一遍么？\n\n我的处理方法是在这里加一层 Extension(⚠️，这里的 Extension 只是为了表明对原有功能的扩展，它和 Objective-C 中 Extension 的概念不一样哦。在 Objective-C 中可以用 Category 来实现这一层扩展，当然在 Swfit 中可以是 Extension)，看下面的图二：\n\n![图二](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png)\n\n首先我们注意到 Controller 和 ViewMode 的关系从原来的「实线 Owns」变成「虚线 Create」，这表明了 Controller 不再持有 ViewModel，而是创建 ViewModel 然后分配给不同的 View。从图中可以看到 View 持有了 ViewModel，同时在 View 的 Extension 层完成了绑定的工作。首先，这样就解决了我们之前的问题，实现在不同的 Controller 中重复完成绑定的工作。\n\n为什么要在 View 的 Extension 中做这个绑定并且持有 ViewModel 的操作？首先，我们要明白其实这个绑定工作是和 View 有强联系的。而且 View 和不同 ViewModel 的绑定都可以统一到这个扩展层，方便管理。\n\n所以我们之前的例子可以稍微做一下修改：\n```Swift\nextension UIButton {\n    func bind(viewModel: FavViewModel) {\n        addTarget(viewModel, action: #selector(FavViewModel.favAction), for: .touchUpInside)\n        viewModel.titleChange = { [unowned self] title in\n            self.setTitle(title, for: .normal)\n        }\n    }\n    \n    func bind(viewMode: SaveViewModel) {\n        setTitle(viewMode.title, for: .normal)\n        addTarget(viewMode, action: #selector(SaveViewModel.saveAction), for: .touchUpInside)\n    }\n}\n\nclass ControllerA: UIViewController {\n    override func viewDidLoad() {\n        view.addSubview(favButton)\n        view.addSubview(saveButton)\n        \n        favButton.bind(viewMode: FavViewModel.init(id: self.id))\n        saveButton.bind(viewMode: SaveViewModel.init(image: self.image))\n    }\n}\n\nclass ControllerB: UIViewController {\n    override func viewDidLoad() {\n        view.addSubview(favButton)\n        \n        favButton.bind(viewMode: FavViewModel.init(id: self.id))\n    }\n}\n```\n\n我们可以看到，ControllerA 和 ControllerB 的工作变得异常简单，创建 ViewModel 然后传给 View 的 Extension 层去做绑定。\n\n类似的，Model 这一边也可以增加 Extension 层来统一管理 Model 的缓存、数据请求、JSON 转 Model 还有一些其他的弱业务逻辑处理。但是如果这样做，本来一个纯数据展示的「瘦 Model」就变成一个带逻辑的「胖 Model」（关于「胖 Model」和「瘦 Model」的讨论，推荐看一下这篇文章「[iOS应用架构谈 view层的组织和调用方案](https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html)」）。不过因为我们是用 Extension 机制来实现的，不会对 Model 的数据造成额外的影响。当我们需要迁移 Model 的时候只需要把 Extension 这一层舍弃掉就可以了。至于是「胖 Model」还是「瘦 Model」，我觉得问题都不大，只要这些工作都是围绕 Model 本身来实现的，然后在整个架构中取得一个平衡就可以了。\n\n所以修改后的 MVVM 框架图如下：\n\n![图三](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png)\n\n> 注意：图三中还有一个 Router，它主要是来实现模块和模块之间的跳转，后面我们会继续深入了解。这里就先放着，暂不做详细的说明。\n\n这里我们以一个稍微复杂点的例子来说明一下，假设我们有一个新闻列表页面，新闻列表只需要显示标题；点击某条新闻之后进入新闻详情页面，在新闻详情页面可以点赞这条新闻。\n\n\n\n目的：\n1. 指导代码的实现\n2. 代码可单元测试\n3. 高内聚，低耦合\n4. 提高代码的可复用性\n\n\nMVC框架：\n\n优点：\n1. 其概念简单，易于理解，iOS 开发附赠\n2. 其中 View 和 Model 的可维护性和可测试性较好\n\n缺点：\n1. Controller 职责过于复杂，导致其可维护性和可测试性特别差\n2. Model 和 View 不一定能一一对应起来，需要在 Controller 中\n3. 任务分配极其不合理，View 和 Model 的任务过于轻松\n4. 代码可读性差\n\n\nMVVM 框架：\n\n优点：\n1. 基于 MVC 改进而来，上手难度不大\n2. Controller 变得轻量级，维护方便\n3. Model 不和 View 直接对应，而是通过 ViewModel 做了转换之后可以一一对应\n4. 开发人员可以专注于业务逻辑和数据的开发 ViewModel，设计人员可以专注于页面设计\n\n缺点：\n1. ViewModel 容易变得跟 Controller 一样臃肿\n2. 如何把一个页面拆分成不同的 ViewModel 来实现，会增加复杂性\n3. 数据存储可能会不一致\n4. 过于简单的图形界面不适用\n\n\nMVVM + Extension 框架\n\n优点：\n1. 任务拆分相对合理，每个角色都有自己的任务\n2. Extension 跟 View 和 Model 形成强绑定关系，一旦 View 或 Model 被移除掉，相对应的 Extension 也可以不要\n3. 每个角色的功能比较清晰，在开发相应角色时只需要完成该角色本身的功能即可，开发流程相对固定\n4. 代码重用度高\n\n缺点：\n1. 代码文件多增多，增加切换文件的成本\n2. 上手难度较大，需要额外理解 Extension 的作用\n3. 过于简单的图形界面不适用\n\n\n架构方案 A：三层结构是由于之前的 MVC 框架导致的，因为在 MVC 框架中会不小心就把所有代码都放到 Controller 实现。\n\n优点：\n1. 业务开发快速\n2. 层级简单，开发基本上只需要关心业务层的开发\n3. 开发周期快\n\n缺点：\n1. 代码重用度不高，导致相同的功能在不同模块可能会出现实现逻辑不一致的问题\n2. 测试困难，业务层涵盖的功能和任务太多\n3. 项目可理解性差\n\n架构方案 B：\n优点：\n1. 代码重用度高\n2. 把业务（变化快）和服务（变化慢）分层实现，有利于项目的维护以及在后续开发中节省时间\n3. 模块与模块间的耦合性低\n4. 代码可以单元测试\n5. 容易理解（万岁）\n\n缺点：\n1. 增加了把哪些内容下沉到服务以及如何拆分服务的复杂度\n2. 模块跳转时需要知道目标模块的地址（字符串），需要单独维护一个表来实现跳转的功能\n3. \n","slug":"浅谈-iOS-架构","published":0,"updated":"2022-04-20T07:08:33.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxe200086enqcvs2c3ar","content":"<h2 id=\"架构还是框架\"><a href=\"#架构还是框架\" class=\"headerlink\" title=\"架构还是框架\"></a>架构还是框架</h2><p>老实说，一开始我对这两个概念还是很模糊的。这段时间通过不断的思考和学习，从我个人的理解来说架构和框架有一个根本性的区别（当然，对架构和框架的理解会随着不停的深入而有所不同）：de</p>\n<blockquote>\n<p>架构：原则指导<br>框架：规则约束</p>\n</blockquote>\n<p>架构设计可以通过一些原则（比如单一职责原则、开放封闭原则、接口分离原则等等）来指导我们进行设计，设计的过程中需要考虑业务和团队的因素。</p>\n<p>框架其实是一套规则，它约束着你应该怎么去做实现。比如我们常见的 MVC、MVVM、MVP、VIPER 等等，这些都是属于框架的范畴。框架是可以被具现化的，这是它和架构的一个不同点。比如我们常说的 redux 框架，它就有具体的实现 <a href=\"https://redux.js.org/\">redux.js</a>，我将这成为框架的具现化。</p>\n<h2 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h2><p>我们都知道用户对客户端的最重要和最直接的感受就是 UI，而 UI 的内容是需要用数据来填充的。所以，对于客户端的架构设计，我们大体上可以从这两个维度来设计。</p>\n<h3 id=\"UI-设计\"><a href=\"#UI-设计\" class=\"headerlink\" title=\"UI 设计\"></a>UI 设计</h3><p>UI 的架构设计基本上没有什么好说的。这里我们需要注意的就是把控件分成两种类型，基础控件和业务组件。业务组件是指跟业务强相关的控件，一旦换了业务就代表这个控件可能不再可用；基础控件基本上就跟业务无关了，它主要是确定了整个 UI 的风格和基调，并且它可以比较方便的被移植。</p>\n<p>在 iOS 上还有一个需要注意的是，不应该在 UITableViewCell、UICollectionViewCell、UICollectionReusableView 做具体的 UI 实现，而是应该在 UIView 或 UIResponse 的子类中做具体的 UI 实现，然后在 UITableViewCell、UICollectionViewCell、UICollectionReusableView <strong>「贴上」</strong>具体的 UI 实现。假设你用 UITableViewCell 直接做 UI 细节的实现，一旦当前页面要换成 UICollectionView 实现的时候，我们就很难直接复用 UITableViewCell 的 UI 实现了。</p>\n<h3 id=\"数据设计\"><a href=\"#数据设计\" class=\"headerlink\" title=\"数据设计\"></a>数据设计</h3><p>这里需要注意的是，网络层和持久层所处理的数据都是原始数据，数据层需要将原始数据 Model 化，交给上层使用。</p>\n<h2 id=\"框架设计\"><a href=\"#框架设计\" class=\"headerlink\" title=\"框架设计\"></a>框架设计</h2><p>在 iOS 开发中，主要的框架有 MVC、MVP、MVVM、VIPER 等等，至于这几个架构的优缺点可以看看「<a href=\"https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.tliwdfd60\">iOS Architecture Patterns Demystifying MVC, MVP, MVVM and VIPER</a>」这篇文章。</p>\n<p>其中 MVC(Model-View-Controller) 是最为开发者所熟悉的，同时也是用的最多的。但随着时间的推移和业务的发展，MVC 框架已经不能满足我们的需求。因为所有的业务逻辑都围着 C 转，C 变得越来越臃肿，越来越难以维护。于是广大的开发者又探讨出来几种其他的框架，有些是基于 MVC 框架改造的，有些是借鉴了其他平台的主流框架（比如 redux）。</p>\n<p>在框架选择上，我主要选择 MVVM 框架。主要是考虑到团队成员都有开发 iOS 的背景，所以大家都比较熟悉原来的 MVC 框架，而 MVVM 是在 MVC 的框架上做改进，所以团队的成员要上手 MVVM 也会比较容易，推广起来也会容易点。如果有一天，当我们使用跨平台的技术栈来实现我们的业务，那我可能就不会选择 MVVM 了，有可能就选在 redux。所以选择框架的时候还是要根据自身的业务和团队情况选择合适的框架。</p>\n<p>接下来我会主要讲讲 MVVM，包括对 MVVM 的一些改变吧。</p>\n<h3 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h3><p><img src=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png\" alt=\"图一\"></p>\n<p>在图一这个经典的 MVVM 框架图中，总共有四个角色。</p>\n<ul>\n<li><p>Model:<br>Model 只是简单的做数据展示和通知数据发生变化的工作，当然你也可以用 KVO 或者 RX 框架来主动监听 Model 数据的变化。</p>\n</li>\n<li><p>View:<br>View 也只是简单的处理 UI 的布局和变化。</p>\n</li>\n<li><p>ViewModel:<br>ViewModel 基本上承接了以前 Controller 的大部分工作，它需要处理各种业务逻辑（数据缓存、网络请求、事件处理等等）。</p>\n</li>\n<li><p>Controller:<br>Controller 现在同时拥有 View 和 ViewModel，并且它的主要工作基本上就是绑定。<br>ViewModel 会有一系列 States 和 Actions，当在 Controller 中完成了绑定的工作，那么 ViewModel 的 State 发生了变化就会引起 View 的变化，View 的事件都会交给 ViewModel 的 Action 进行处理。</p>\n</li>\n</ul>\n<p>现在假设我们有两个按钮「收藏」和「保存」可以对图片进行操作，其中收藏按钮通过点击之后会向服务器发送请求，请求成功之后收藏按钮的文案变成「已收藏」；点击保存按钮之后就直接把图片保存到本地相册。以前我们会把这一系列逻辑代码都写到 Controller，那现在如果用 MVVM 可以会变成什么样呢？看下面代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FavViewModel</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">id</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// init</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// MARK: - States</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> title: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;收藏&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">didSet</span>(oldValue) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">guard</span> oldValue <span class=\"operator\">!=</span> title <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.titleChange<span class=\"operator\">?</span>(<span class=\"keyword\">self</span>.title)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> titleChange: ((<span class=\"type\">String</span>) -&gt; <span class=\"type\">Void</span>)<span class=\"operator\">?</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">didSet</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.titleChange<span class=\"operator\">?</span>(<span class=\"keyword\">self</span>.title)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// MARK: - Actions</span></span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">func</span> <span class=\"title function_\">favAction</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Async Request</span></span><br><span class=\"line\">        title <span class=\"operator\">=</span> <span class=\"string\">&quot;已收藏&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SaveViewModel</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">image</span>: <span class=\"type\">UIImage</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// init</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// MARK: - States</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> title <span class=\"operator\">=</span> <span class=\"string\">&quot;保存&quot;</span> </span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// MARK: - Actions</span></span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">func</span> <span class=\"title function_\">saveAction</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Async save image</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Controller</span>: <span class=\"title class_\">UIViewController</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">viewDidLoad</span>() &#123;</span><br><span class=\"line\">        view.addSubview(favButton)</span><br><span class=\"line\">        view.addSubview(saveButton)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 绑定 FavButton 和 FavViewModel</span></span><br><span class=\"line\">        favButton.addTarget(favViewModel, action: <span class=\"keyword\">#selector</span>(<span class=\"type\">FavViewModel</span>.favAction), for: .touchUpInside)</span><br><span class=\"line\">        favViewModel.titleChange <span class=\"operator\">=</span> &#123; [<span class=\"keyword\">unowned</span> <span class=\"keyword\">self</span>] title <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.favButton.setTitle(title, for: .normal)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 绑定 SaveButton 和 SaveViewModel</span></span><br><span class=\"line\">        saveButton.setTitle(saveViewModel.title, for: .normal)</span><br><span class=\"line\">        saveButton.addTarget(saveViewModel, action: <span class=\"keyword\">#selector</span>(<span class=\"type\">SaveViewModel</span>.saveAction), for: .touchUpInside)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"comment\">// MARK: - Lazy</span></span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> favButton <span class=\"operator\">=</span> &#123; () -&gt; <span class=\"type\">UIButton</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">UIButton</span>()</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> favViewModel <span class=\"operator\">=</span> &#123; () -&gt; <span class=\"type\">FavViewModel</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">FavViewModel</span>.<span class=\"keyword\">init</span>(id: <span class=\"keyword\">self</span>.id)</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> saveButton <span class=\"operator\">=</span> &#123; () -&gt; <span class=\"type\">UIButton</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">UIButton</span>()</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> saveViewModel <span class=\"operator\">=</span> &#123; () -&gt; <span class=\"type\">SaveViewModel</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">SaveViewModel</span>.<span class=\"keyword\">init</span>(image: <span class=\"keyword\">self</span>.image)</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>👆的代码基本上展示了如何在 Swift 中实现经典的 MVVM 框架，其中有几个需要注意的地方：</p>\n<ol>\n<li>当给 titleChange 赋值的时候需要立即调用 titleChange(title)</li>\n<li>需要在主线程调用 titleChange(title)</li>\n</ol>\n<blockquote>\n<p>上面的代码没有用到任何第三方框架就可以实现 MVVM，当然如果使用了 Rx 之类的框架可以让我们在代码上和绑定逻辑上可以写得更简洁。</p>\n</blockquote>\n<p>上面的例子在实际的实践过程中还是有一些问题的：</p>\n<ol>\n<li>如果有多个 Controller 都用到相同的 View，那在每个 Controller 中都要做一遍绑定的工作么？</li>\n<li>如果有不同的 ViewModel 用到相同的 Model，那从网络请求到转换成 Model 到本地缓存这一些逻辑都要再写一遍么？</li>\n</ol>\n<p>我的处理方法是在这里加一层 Extension(⚠️，这里的 Extension 只是为了表明对原有功能的扩展，它和 Objective-C 中 Extension 的概念不一样哦。在 Objective-C 中可以用 Category 来实现这一层扩展，当然在 Swfit 中可以是 Extension)，看下面的图二：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png\" alt=\"图二\"></p>\n<p>首先我们注意到 Controller 和 ViewMode 的关系从原来的「实线 Owns」变成「虚线 Create」，这表明了 Controller 不再持有 ViewModel，而是创建 ViewModel 然后分配给不同的 View。从图中可以看到 View 持有了 ViewModel，同时在 View 的 Extension 层完成了绑定的工作。首先，这样就解决了我们之前的问题，实现在不同的 Controller 中重复完成绑定的工作。</p>\n<p>为什么要在 View 的 Extension 中做这个绑定并且持有 ViewModel 的操作？首先，我们要明白其实这个绑定工作是和 View 有强联系的。而且 View 和不同 ViewModel 的绑定都可以统一到这个扩展层，方便管理。</p>\n<p>所以我们之前的例子可以稍微做一下修改：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extension</span> <span class=\"title class_\">UIButton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">bind</span>(<span class=\"params\">viewModel</span>: <span class=\"type\">FavViewModel</span>) &#123;</span><br><span class=\"line\">        addTarget(viewModel, action: <span class=\"keyword\">#selector</span>(<span class=\"type\">FavViewModel</span>.favAction), for: .touchUpInside)</span><br><span class=\"line\">        viewModel.titleChange <span class=\"operator\">=</span> &#123; [<span class=\"keyword\">unowned</span> <span class=\"keyword\">self</span>] title <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.setTitle(title, for: .normal)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">bind</span>(<span class=\"params\">viewMode</span>: <span class=\"type\">SaveViewModel</span>) &#123;</span><br><span class=\"line\">        setTitle(viewMode.title, for: .normal)</span><br><span class=\"line\">        addTarget(viewMode, action: <span class=\"keyword\">#selector</span>(<span class=\"type\">SaveViewModel</span>.saveAction), for: .touchUpInside)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ControllerA</span>: <span class=\"title class_\">UIViewController</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">viewDidLoad</span>() &#123;</span><br><span class=\"line\">        view.addSubview(favButton)</span><br><span class=\"line\">        view.addSubview(saveButton)</span><br><span class=\"line\">        </span><br><span class=\"line\">        favButton.bind(viewMode: <span class=\"type\">FavViewModel</span>.<span class=\"keyword\">init</span>(id: <span class=\"keyword\">self</span>.id))</span><br><span class=\"line\">        saveButton.bind(viewMode: <span class=\"type\">SaveViewModel</span>.<span class=\"keyword\">init</span>(image: <span class=\"keyword\">self</span>.image))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ControllerB</span>: <span class=\"title class_\">UIViewController</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">viewDidLoad</span>() &#123;</span><br><span class=\"line\">        view.addSubview(favButton)</span><br><span class=\"line\">        </span><br><span class=\"line\">        favButton.bind(viewMode: <span class=\"type\">FavViewModel</span>.<span class=\"keyword\">init</span>(id: <span class=\"keyword\">self</span>.id))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，ControllerA 和 ControllerB 的工作变得异常简单，创建 ViewModel 然后传给 View 的 Extension 层去做绑定。</p>\n<p>类似的，Model 这一边也可以增加 Extension 层来统一管理 Model 的缓存、数据请求、JSON 转 Model 还有一些其他的弱业务逻辑处理。但是如果这样做，本来一个纯数据展示的「瘦 Model」就变成一个带逻辑的「胖 Model」（关于「胖 Model」和「瘦 Model」的讨论，推荐看一下这篇文章「<a href=\"https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html\">iOS应用架构谈 view层的组织和调用方案</a>」）。不过因为我们是用 Extension 机制来实现的，不会对 Model 的数据造成额外的影响。当我们需要迁移 Model 的时候只需要把 Extension 这一层舍弃掉就可以了。至于是「胖 Model」还是「瘦 Model」，我觉得问题都不大，只要这些工作都是围绕 Model 本身来实现的，然后在整个架构中取得一个平衡就可以了。</p>\n<p>所以修改后的 MVVM 框架图如下：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png\" alt=\"图三\"></p>\n<blockquote>\n<p>注意：图三中还有一个 Router，它主要是来实现模块和模块之间的跳转，后面我们会继续深入了解。这里就先放着，暂不做详细的说明。</p>\n</blockquote>\n<p>这里我们以一个稍微复杂点的例子来说明一下，假设我们有一个新闻列表页面，新闻列表只需要显示标题；点击某条新闻之后进入新闻详情页面，在新闻详情页面可以点赞这条新闻。</p>\n<p>目的：</p>\n<ol>\n<li>指导代码的实现</li>\n<li>代码可单元测试</li>\n<li>高内聚，低耦合</li>\n<li>提高代码的可复用性</li>\n</ol>\n<p>MVC框架：</p>\n<p>优点：</p>\n<ol>\n<li>其概念简单，易于理解，iOS 开发附赠</li>\n<li>其中 View 和 Model 的可维护性和可测试性较好</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>Controller 职责过于复杂，导致其可维护性和可测试性特别差</li>\n<li>Model 和 View 不一定能一一对应起来，需要在 Controller 中</li>\n<li>任务分配极其不合理，View 和 Model 的任务过于轻松</li>\n<li>代码可读性差</li>\n</ol>\n<p>MVVM 框架：</p>\n<p>优点：</p>\n<ol>\n<li>基于 MVC 改进而来，上手难度不大</li>\n<li>Controller 变得轻量级，维护方便</li>\n<li>Model 不和 View 直接对应，而是通过 ViewModel 做了转换之后可以一一对应</li>\n<li>开发人员可以专注于业务逻辑和数据的开发 ViewModel，设计人员可以专注于页面设计</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>ViewModel 容易变得跟 Controller 一样臃肿</li>\n<li>如何把一个页面拆分成不同的 ViewModel 来实现，会增加复杂性</li>\n<li>数据存储可能会不一致</li>\n<li>过于简单的图形界面不适用</li>\n</ol>\n<p>MVVM + Extension 框架</p>\n<p>优点：</p>\n<ol>\n<li>任务拆分相对合理，每个角色都有自己的任务</li>\n<li>Extension 跟 View 和 Model 形成强绑定关系，一旦 View 或 Model 被移除掉，相对应的 Extension 也可以不要</li>\n<li>每个角色的功能比较清晰，在开发相应角色时只需要完成该角色本身的功能即可，开发流程相对固定</li>\n<li>代码重用度高</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>代码文件多增多，增加切换文件的成本</li>\n<li>上手难度较大，需要额外理解 Extension 的作用</li>\n<li>过于简单的图形界面不适用</li>\n</ol>\n<p>架构方案 A：三层结构是由于之前的 MVC 框架导致的，因为在 MVC 框架中会不小心就把所有代码都放到 Controller 实现。</p>\n<p>优点：</p>\n<ol>\n<li>业务开发快速</li>\n<li>层级简单，开发基本上只需要关心业务层的开发</li>\n<li>开发周期快</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>代码重用度不高，导致相同的功能在不同模块可能会出现实现逻辑不一致的问题</li>\n<li>测试困难，业务层涵盖的功能和任务太多</li>\n<li>项目可理解性差</li>\n</ol>\n<p>架构方案 B：<br>优点：</p>\n<ol>\n<li>代码重用度高</li>\n<li>把业务（变化快）和服务（变化慢）分层实现，有利于项目的维护以及在后续开发中节省时间</li>\n<li>模块与模块间的耦合性低</li>\n<li>代码可以单元测试</li>\n<li>容易理解（万岁）</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>增加了把哪些内容下沉到服务以及如何拆分服务的复杂度</li>\n<li>模块跳转时需要知道目标模块的地址（字符串），需要单独维护一个表来实现跳转的功能</li>\n<li></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"架构还是框架\"><a href=\"#架构还是框架\" class=\"headerlink\" title=\"架构还是框架\"></a>架构还是框架</h2><p>老实说，一开始我对这两个概念还是很模糊的。这段时间通过不断的思考和学习，从我个人的理解来说架构和框架有一个根本性的区别（当然，对架构和框架的理解会随着不停的深入而有所不同）：de</p>\n<blockquote>\n<p>架构：原则指导<br>框架：规则约束</p>\n</blockquote>\n<p>架构设计可以通过一些原则（比如单一职责原则、开放封闭原则、接口分离原则等等）来指导我们进行设计，设计的过程中需要考虑业务和团队的因素。</p>\n<p>框架其实是一套规则，它约束着你应该怎么去做实现。比如我们常见的 MVC、MVVM、MVP、VIPER 等等，这些都是属于框架的范畴。框架是可以被具现化的，这是它和架构的一个不同点。比如我们常说的 redux 框架，它就有具体的实现 <a href=\"https://redux.js.org/\">redux.js</a>，我将这成为框架的具现化。</p>\n<h2 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h2><p>我们都知道用户对客户端的最重要和最直接的感受就是 UI，而 UI 的内容是需要用数据来填充的。所以，对于客户端的架构设计，我们大体上可以从这两个维度来设计。</p>\n<h3 id=\"UI-设计\"><a href=\"#UI-设计\" class=\"headerlink\" title=\"UI 设计\"></a>UI 设计</h3><p>UI 的架构设计基本上没有什么好说的。这里我们需要注意的就是把控件分成两种类型，基础控件和业务组件。业务组件是指跟业务强相关的控件，一旦换了业务就代表这个控件可能不再可用；基础控件基本上就跟业务无关了，它主要是确定了整个 UI 的风格和基调，并且它可以比较方便的被移植。</p>\n<p>在 iOS 上还有一个需要注意的是，不应该在 UITableViewCell、UICollectionViewCell、UICollectionReusableView 做具体的 UI 实现，而是应该在 UIView 或 UIResponse 的子类中做具体的 UI 实现，然后在 UITableViewCell、UICollectionViewCell、UICollectionReusableView <strong>「贴上」</strong>具体的 UI 实现。假设你用 UITableViewCell 直接做 UI 细节的实现，一旦当前页面要换成 UICollectionView 实现的时候，我们就很难直接复用 UITableViewCell 的 UI 实现了。</p>\n<h3 id=\"数据设计\"><a href=\"#数据设计\" class=\"headerlink\" title=\"数据设计\"></a>数据设计</h3><p>这里需要注意的是，网络层和持久层所处理的数据都是原始数据，数据层需要将原始数据 Model 化，交给上层使用。</p>\n<h2 id=\"框架设计\"><a href=\"#框架设计\" class=\"headerlink\" title=\"框架设计\"></a>框架设计</h2><p>在 iOS 开发中，主要的框架有 MVC、MVP、MVVM、VIPER 等等，至于这几个架构的优缺点可以看看「<a href=\"https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.tliwdfd60\">iOS Architecture Patterns Demystifying MVC, MVP, MVVM and VIPER</a>」这篇文章。</p>\n<p>其中 MVC(Model-View-Controller) 是最为开发者所熟悉的，同时也是用的最多的。但随着时间的推移和业务的发展，MVC 框架已经不能满足我们的需求。因为所有的业务逻辑都围着 C 转，C 变得越来越臃肿，越来越难以维护。于是广大的开发者又探讨出来几种其他的框架，有些是基于 MVC 框架改造的，有些是借鉴了其他平台的主流框架（比如 redux）。</p>\n<p>在框架选择上，我主要选择 MVVM 框架。主要是考虑到团队成员都有开发 iOS 的背景，所以大家都比较熟悉原来的 MVC 框架，而 MVVM 是在 MVC 的框架上做改进，所以团队的成员要上手 MVVM 也会比较容易，推广起来也会容易点。如果有一天，当我们使用跨平台的技术栈来实现我们的业务，那我可能就不会选择 MVVM 了，有可能就选在 redux。所以选择框架的时候还是要根据自身的业务和团队情况选择合适的框架。</p>\n<p>接下来我会主要讲讲 MVVM，包括对 MVVM 的一些改变吧。</p>\n<h3 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h3><p><img src=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png\" alt=\"图一\"></p>\n<p>在图一这个经典的 MVVM 框架图中，总共有四个角色。</p>\n<ul>\n<li><p>Model:<br>Model 只是简单的做数据展示和通知数据发生变化的工作，当然你也可以用 KVO 或者 RX 框架来主动监听 Model 数据的变化。</p>\n</li>\n<li><p>View:<br>View 也只是简单的处理 UI 的布局和变化。</p>\n</li>\n<li><p>ViewModel:<br>ViewModel 基本上承接了以前 Controller 的大部分工作，它需要处理各种业务逻辑（数据缓存、网络请求、事件处理等等）。</p>\n</li>\n<li><p>Controller:<br>Controller 现在同时拥有 View 和 ViewModel，并且它的主要工作基本上就是绑定。<br>ViewModel 会有一系列 States 和 Actions，当在 Controller 中完成了绑定的工作，那么 ViewModel 的 State 发生了变化就会引起 View 的变化，View 的事件都会交给 ViewModel 的 Action 进行处理。</p>\n</li>\n</ul>\n<p>现在假设我们有两个按钮「收藏」和「保存」可以对图片进行操作，其中收藏按钮通过点击之后会向服务器发送请求，请求成功之后收藏按钮的文案变成「已收藏」；点击保存按钮之后就直接把图片保存到本地相册。以前我们会把这一系列逻辑代码都写到 Controller，那现在如果用 MVVM 可以会变成什么样呢？看下面代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FavViewModel</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">id</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// init</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// MARK: - States</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> title: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;收藏&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">didSet</span>(oldValue) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">guard</span> oldValue <span class=\"operator\">!=</span> title <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.titleChange<span class=\"operator\">?</span>(<span class=\"keyword\">self</span>.title)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> titleChange: ((<span class=\"type\">String</span>) -&gt; <span class=\"type\">Void</span>)<span class=\"operator\">?</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">didSet</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.titleChange<span class=\"operator\">?</span>(<span class=\"keyword\">self</span>.title)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// MARK: - Actions</span></span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">func</span> <span class=\"title function_\">favAction</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Async Request</span></span><br><span class=\"line\">        title <span class=\"operator\">=</span> <span class=\"string\">&quot;已收藏&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SaveViewModel</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">image</span>: <span class=\"type\">UIImage</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// init</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// MARK: - States</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> title <span class=\"operator\">=</span> <span class=\"string\">&quot;保存&quot;</span> </span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// MARK: - Actions</span></span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">func</span> <span class=\"title function_\">saveAction</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Async save image</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Controller</span>: <span class=\"title class_\">UIViewController</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">viewDidLoad</span>() &#123;</span><br><span class=\"line\">        view.addSubview(favButton)</span><br><span class=\"line\">        view.addSubview(saveButton)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 绑定 FavButton 和 FavViewModel</span></span><br><span class=\"line\">        favButton.addTarget(favViewModel, action: <span class=\"keyword\">#selector</span>(<span class=\"type\">FavViewModel</span>.favAction), for: .touchUpInside)</span><br><span class=\"line\">        favViewModel.titleChange <span class=\"operator\">=</span> &#123; [<span class=\"keyword\">unowned</span> <span class=\"keyword\">self</span>] title <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.favButton.setTitle(title, for: .normal)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 绑定 SaveButton 和 SaveViewModel</span></span><br><span class=\"line\">        saveButton.setTitle(saveViewModel.title, for: .normal)</span><br><span class=\"line\">        saveButton.addTarget(saveViewModel, action: <span class=\"keyword\">#selector</span>(<span class=\"type\">SaveViewModel</span>.saveAction), for: .touchUpInside)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"comment\">// MARK: - Lazy</span></span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> favButton <span class=\"operator\">=</span> &#123; () -&gt; <span class=\"type\">UIButton</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">UIButton</span>()</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> favViewModel <span class=\"operator\">=</span> &#123; () -&gt; <span class=\"type\">FavViewModel</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">FavViewModel</span>.<span class=\"keyword\">init</span>(id: <span class=\"keyword\">self</span>.id)</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> saveButton <span class=\"operator\">=</span> &#123; () -&gt; <span class=\"type\">UIButton</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">UIButton</span>()</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> saveViewModel <span class=\"operator\">=</span> &#123; () -&gt; <span class=\"type\">SaveViewModel</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">SaveViewModel</span>.<span class=\"keyword\">init</span>(image: <span class=\"keyword\">self</span>.image)</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>👆的代码基本上展示了如何在 Swift 中实现经典的 MVVM 框架，其中有几个需要注意的地方：</p>\n<ol>\n<li>当给 titleChange 赋值的时候需要立即调用 titleChange(title)</li>\n<li>需要在主线程调用 titleChange(title)</li>\n</ol>\n<blockquote>\n<p>上面的代码没有用到任何第三方框架就可以实现 MVVM，当然如果使用了 Rx 之类的框架可以让我们在代码上和绑定逻辑上可以写得更简洁。</p>\n</blockquote>\n<p>上面的例子在实际的实践过程中还是有一些问题的：</p>\n<ol>\n<li>如果有多个 Controller 都用到相同的 View，那在每个 Controller 中都要做一遍绑定的工作么？</li>\n<li>如果有不同的 ViewModel 用到相同的 Model，那从网络请求到转换成 Model 到本地缓存这一些逻辑都要再写一遍么？</li>\n</ol>\n<p>我的处理方法是在这里加一层 Extension(⚠️，这里的 Extension 只是为了表明对原有功能的扩展，它和 Objective-C 中 Extension 的概念不一样哦。在 Objective-C 中可以用 Category 来实现这一层扩展，当然在 Swfit 中可以是 Extension)，看下面的图二：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png\" alt=\"图二\"></p>\n<p>首先我们注意到 Controller 和 ViewMode 的关系从原来的「实线 Owns」变成「虚线 Create」，这表明了 Controller 不再持有 ViewModel，而是创建 ViewModel 然后分配给不同的 View。从图中可以看到 View 持有了 ViewModel，同时在 View 的 Extension 层完成了绑定的工作。首先，这样就解决了我们之前的问题，实现在不同的 Controller 中重复完成绑定的工作。</p>\n<p>为什么要在 View 的 Extension 中做这个绑定并且持有 ViewModel 的操作？首先，我们要明白其实这个绑定工作是和 View 有强联系的。而且 View 和不同 ViewModel 的绑定都可以统一到这个扩展层，方便管理。</p>\n<p>所以我们之前的例子可以稍微做一下修改：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extension</span> <span class=\"title class_\">UIButton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">bind</span>(<span class=\"params\">viewModel</span>: <span class=\"type\">FavViewModel</span>) &#123;</span><br><span class=\"line\">        addTarget(viewModel, action: <span class=\"keyword\">#selector</span>(<span class=\"type\">FavViewModel</span>.favAction), for: .touchUpInside)</span><br><span class=\"line\">        viewModel.titleChange <span class=\"operator\">=</span> &#123; [<span class=\"keyword\">unowned</span> <span class=\"keyword\">self</span>] title <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.setTitle(title, for: .normal)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">bind</span>(<span class=\"params\">viewMode</span>: <span class=\"type\">SaveViewModel</span>) &#123;</span><br><span class=\"line\">        setTitle(viewMode.title, for: .normal)</span><br><span class=\"line\">        addTarget(viewMode, action: <span class=\"keyword\">#selector</span>(<span class=\"type\">SaveViewModel</span>.saveAction), for: .touchUpInside)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ControllerA</span>: <span class=\"title class_\">UIViewController</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">viewDidLoad</span>() &#123;</span><br><span class=\"line\">        view.addSubview(favButton)</span><br><span class=\"line\">        view.addSubview(saveButton)</span><br><span class=\"line\">        </span><br><span class=\"line\">        favButton.bind(viewMode: <span class=\"type\">FavViewModel</span>.<span class=\"keyword\">init</span>(id: <span class=\"keyword\">self</span>.id))</span><br><span class=\"line\">        saveButton.bind(viewMode: <span class=\"type\">SaveViewModel</span>.<span class=\"keyword\">init</span>(image: <span class=\"keyword\">self</span>.image))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ControllerB</span>: <span class=\"title class_\">UIViewController</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">viewDidLoad</span>() &#123;</span><br><span class=\"line\">        view.addSubview(favButton)</span><br><span class=\"line\">        </span><br><span class=\"line\">        favButton.bind(viewMode: <span class=\"type\">FavViewModel</span>.<span class=\"keyword\">init</span>(id: <span class=\"keyword\">self</span>.id))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，ControllerA 和 ControllerB 的工作变得异常简单，创建 ViewModel 然后传给 View 的 Extension 层去做绑定。</p>\n<p>类似的，Model 这一边也可以增加 Extension 层来统一管理 Model 的缓存、数据请求、JSON 转 Model 还有一些其他的弱业务逻辑处理。但是如果这样做，本来一个纯数据展示的「瘦 Model」就变成一个带逻辑的「胖 Model」（关于「胖 Model」和「瘦 Model」的讨论，推荐看一下这篇文章「<a href=\"https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html\">iOS应用架构谈 view层的组织和调用方案</a>」）。不过因为我们是用 Extension 机制来实现的，不会对 Model 的数据造成额外的影响。当我们需要迁移 Model 的时候只需要把 Extension 这一层舍弃掉就可以了。至于是「胖 Model」还是「瘦 Model」，我觉得问题都不大，只要这些工作都是围绕 Model 本身来实现的，然后在整个架构中取得一个平衡就可以了。</p>\n<p>所以修改后的 MVVM 框架图如下：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png\" alt=\"图三\"></p>\n<blockquote>\n<p>注意：图三中还有一个 Router，它主要是来实现模块和模块之间的跳转，后面我们会继续深入了解。这里就先放着，暂不做详细的说明。</p>\n</blockquote>\n<p>这里我们以一个稍微复杂点的例子来说明一下，假设我们有一个新闻列表页面，新闻列表只需要显示标题；点击某条新闻之后进入新闻详情页面，在新闻详情页面可以点赞这条新闻。</p>\n<p>目的：</p>\n<ol>\n<li>指导代码的实现</li>\n<li>代码可单元测试</li>\n<li>高内聚，低耦合</li>\n<li>提高代码的可复用性</li>\n</ol>\n<p>MVC框架：</p>\n<p>优点：</p>\n<ol>\n<li>其概念简单，易于理解，iOS 开发附赠</li>\n<li>其中 View 和 Model 的可维护性和可测试性较好</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>Controller 职责过于复杂，导致其可维护性和可测试性特别差</li>\n<li>Model 和 View 不一定能一一对应起来，需要在 Controller 中</li>\n<li>任务分配极其不合理，View 和 Model 的任务过于轻松</li>\n<li>代码可读性差</li>\n</ol>\n<p>MVVM 框架：</p>\n<p>优点：</p>\n<ol>\n<li>基于 MVC 改进而来，上手难度不大</li>\n<li>Controller 变得轻量级，维护方便</li>\n<li>Model 不和 View 直接对应，而是通过 ViewModel 做了转换之后可以一一对应</li>\n<li>开发人员可以专注于业务逻辑和数据的开发 ViewModel，设计人员可以专注于页面设计</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>ViewModel 容易变得跟 Controller 一样臃肿</li>\n<li>如何把一个页面拆分成不同的 ViewModel 来实现，会增加复杂性</li>\n<li>数据存储可能会不一致</li>\n<li>过于简单的图形界面不适用</li>\n</ol>\n<p>MVVM + Extension 框架</p>\n<p>优点：</p>\n<ol>\n<li>任务拆分相对合理，每个角色都有自己的任务</li>\n<li>Extension 跟 View 和 Model 形成强绑定关系，一旦 View 或 Model 被移除掉，相对应的 Extension 也可以不要</li>\n<li>每个角色的功能比较清晰，在开发相应角色时只需要完成该角色本身的功能即可，开发流程相对固定</li>\n<li>代码重用度高</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>代码文件多增多，增加切换文件的成本</li>\n<li>上手难度较大，需要额外理解 Extension 的作用</li>\n<li>过于简单的图形界面不适用</li>\n</ol>\n<p>架构方案 A：三层结构是由于之前的 MVC 框架导致的，因为在 MVC 框架中会不小心就把所有代码都放到 Controller 实现。</p>\n<p>优点：</p>\n<ol>\n<li>业务开发快速</li>\n<li>层级简单，开发基本上只需要关心业务层的开发</li>\n<li>开发周期快</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>代码重用度不高，导致相同的功能在不同模块可能会出现实现逻辑不一致的问题</li>\n<li>测试困难，业务层涵盖的功能和任务太多</li>\n<li>项目可理解性差</li>\n</ol>\n<p>架构方案 B：<br>优点：</p>\n<ol>\n<li>代码重用度高</li>\n<li>把业务（变化快）和服务（变化慢）分层实现，有利于项目的维护以及在后续开发中节省时间</li>\n<li>模块与模块间的耦合性低</li>\n<li>代码可以单元测试</li>\n<li>容易理解（万岁）</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>增加了把哪些内容下沉到服务以及如何拆分服务的复杂度</li>\n<li>模块跳转时需要知道目标模块的地址（字符串），需要单独维护一个表来实现跳转的功能</li>\n<li></li>\n</ol>\n"},{"title":"Notification 的一些知识点","date":"2018-11-05T17:55:26.000Z","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1514464750060-00e6e34c8b8c?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3749c47dd7beec20102c6b32fc19833a&auto=format&fit=crop&w=160&q=100","_content":"\n## 重复添加相同观察者\n\n我们先来看看日常开发中我们对 NSNotification 的正常用法，如下：\n```swift\n// 定义通知\nlet TestNotification = NSNotification.Name.init(\"com.papa.test\")\n\n// 测试类\nclass Test {\n\n    init() {\n        NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: TestNotification, object: nil)\n    }\n\n    // 注意\n    deinit {\n        NotificationCenter.default.removeObserver(self)\n    }\n\n    @objc func test(notification: Notification) {\n        print(\"Test\")\n    }\n}\n```\n\n但是如果我们在刚才代码中的 `init` 方法里面对同一个通知多次添加同一个观察者的话，会发生什么？\n```swift\ninit() {\n    NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: TestNotification, object: nil)\n    NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: TestNotification, object: nil)\n}\n\n// 发送 TestNotification 通知\nNotificationCenter.default.post(name: TestNotification, object: nil)\n```\n\n答案是会输出：\n```swift\nTest\nTest\n```\n\n所以我们要尽量避免重复添加观察者，因为这有可能会造成一些未知现象的发生。\n\n## 通知中的线程问题\n \n```swift\n// 定义通知\nlet ThreadNotification = NSNotification.Name.init(\"com.papa.thread\")\n\n// 测试类\nclass Test {\n\n    init() {\n        print(\"Add Observer: \\(Thread.current)\")\n        NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: ThreadNotification, object: nil)\n    }\n\n    // 注意\n    deinit {\n        NotificationCenter.default.removeObserver(self)\n    }\n\n    @objc func test(notification: Notification) {\n        print(\"Receive: \\(Thread.current)\")\n    }\n}\n\nDispatchQueue.init(label: \"com.ps.test.queue\").async {\n    print(\"Post: \\(Thread.current)\")\n    NotificationCenter.default.post(name: ThreadNotification, object: nil)\n}\n\n```\n\n我们来看看观察者是在什么线程上接受到通知的:\n```swift\nAdd Observer: <NSThread: 0x60000147d1c0>{number = 1, name = main}\nPost: <NSThread: 0x600001462640>{number = 3, name = (null)}\nReceive: <NSThread: 0x600001462640>{number = 3, name = (null)}\n```\n\n虽然我们是在主线程中去添加观察者，但是因为我们是在其他线程中去发送通知的，所以最后我们也是在其他线程中接收到通知的。\n\n## 通知中的阻塞问题\n\n```swift\n// 定义通知\nlet SleepNotification = NSNotification.Name.init(\"com.papa.sleep\")\n\n// 测试类\nclass Test {\n\n    init() {\n        NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: SleepNotification, object: nil)\n    }\n\n    // 注意\n    deinit {\n        NotificationCenter.default.removeObserver(self)\n    }\n\n    @objc func test(notification: Notification) {\n        sleep(3)\n    }\n}\n\nlet start = Date()\nNotificationCenter.default.post(name: SleepNotification, object: nil)\nlet end = Date()\nprint(\"相差：\\(end.timeIntervalSince(start))\")\n```\n\n我们可以看到最后相差时间大概是 `3s` ，通过上面的代码我们就知道单 NotificationCenter 去 post 一个通知的时候，它会等待观察者处理完改通知之后才会继续往后执行。所以平常使用过程中我们要注意 post 有可能会阻塞当前线程，特别是在主线程中。","source":"_posts/Notification-的一些知识点.md","raw":"---\ntitle: Notification 的一些知识点\ndate: 2018-11-05 17:55:26 +0800\nauthor: 帕帕\ncategories: 技术\ntags: [iOS]\nthumbnail: https://images.unsplash.com/photo-1514464750060-00e6e34c8b8c?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3749c47dd7beec20102c6b32fc19833a&auto=format&fit=crop&w=160&q=100\n---\n\n## 重复添加相同观察者\n\n我们先来看看日常开发中我们对 NSNotification 的正常用法，如下：\n```swift\n// 定义通知\nlet TestNotification = NSNotification.Name.init(\"com.papa.test\")\n\n// 测试类\nclass Test {\n\n    init() {\n        NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: TestNotification, object: nil)\n    }\n\n    // 注意\n    deinit {\n        NotificationCenter.default.removeObserver(self)\n    }\n\n    @objc func test(notification: Notification) {\n        print(\"Test\")\n    }\n}\n```\n\n但是如果我们在刚才代码中的 `init` 方法里面对同一个通知多次添加同一个观察者的话，会发生什么？\n```swift\ninit() {\n    NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: TestNotification, object: nil)\n    NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: TestNotification, object: nil)\n}\n\n// 发送 TestNotification 通知\nNotificationCenter.default.post(name: TestNotification, object: nil)\n```\n\n答案是会输出：\n```swift\nTest\nTest\n```\n\n所以我们要尽量避免重复添加观察者，因为这有可能会造成一些未知现象的发生。\n\n## 通知中的线程问题\n \n```swift\n// 定义通知\nlet ThreadNotification = NSNotification.Name.init(\"com.papa.thread\")\n\n// 测试类\nclass Test {\n\n    init() {\n        print(\"Add Observer: \\(Thread.current)\")\n        NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: ThreadNotification, object: nil)\n    }\n\n    // 注意\n    deinit {\n        NotificationCenter.default.removeObserver(self)\n    }\n\n    @objc func test(notification: Notification) {\n        print(\"Receive: \\(Thread.current)\")\n    }\n}\n\nDispatchQueue.init(label: \"com.ps.test.queue\").async {\n    print(\"Post: \\(Thread.current)\")\n    NotificationCenter.default.post(name: ThreadNotification, object: nil)\n}\n\n```\n\n我们来看看观察者是在什么线程上接受到通知的:\n```swift\nAdd Observer: <NSThread: 0x60000147d1c0>{number = 1, name = main}\nPost: <NSThread: 0x600001462640>{number = 3, name = (null)}\nReceive: <NSThread: 0x600001462640>{number = 3, name = (null)}\n```\n\n虽然我们是在主线程中去添加观察者，但是因为我们是在其他线程中去发送通知的，所以最后我们也是在其他线程中接收到通知的。\n\n## 通知中的阻塞问题\n\n```swift\n// 定义通知\nlet SleepNotification = NSNotification.Name.init(\"com.papa.sleep\")\n\n// 测试类\nclass Test {\n\n    init() {\n        NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: SleepNotification, object: nil)\n    }\n\n    // 注意\n    deinit {\n        NotificationCenter.default.removeObserver(self)\n    }\n\n    @objc func test(notification: Notification) {\n        sleep(3)\n    }\n}\n\nlet start = Date()\nNotificationCenter.default.post(name: SleepNotification, object: nil)\nlet end = Date()\nprint(\"相差：\\(end.timeIntervalSince(start))\")\n```\n\n我们可以看到最后相差时间大概是 `3s` ，通过上面的代码我们就知道单 NotificationCenter 去 post 一个通知的时候，它会等待观察者处理完改通知之后才会继续往后执行。所以平常使用过程中我们要注意 post 有可能会阻塞当前线程，特别是在主线程中。","slug":"Notification-的一些知识点","published":1,"updated":"2022-04-20T07:08:33.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxe300096enq201807tr","content":"<h2 id=\"重复添加相同观察者\"><a href=\"#重复添加相同观察者\" class=\"headerlink\" title=\"重复添加相同观察者\"></a>重复添加相同观察者</h2><p>我们先来看看日常开发中我们对 NSNotification 的正常用法，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义通知</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">TestNotification</span> <span class=\"operator\">=</span> <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>.<span class=\"keyword\">init</span>(<span class=\"string\">&quot;com.papa.test&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">TestNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注意</span></span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">func</span> <span class=\"title function_\">test</span>(<span class=\"params\">notification</span>: <span class=\"type\">Notification</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Test&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是如果我们在刚才代码中的 <code>init</code> 方法里面对同一个通知多次添加同一个观察者的话，会发生什么？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">TestNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">TestNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送 TestNotification 通知</span></span><br><span class=\"line\"><span class=\"type\">NotificationCenter</span>.default.post(name: <span class=\"type\">TestNotification</span>, object: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n\n<p>答案是会输出：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Test</span></span><br><span class=\"line\"><span class=\"type\">Test</span></span><br></pre></td></tr></table></figure>\n\n<p>所以我们要尽量避免重复添加观察者，因为这有可能会造成一些未知现象的发生。</p>\n<h2 id=\"通知中的线程问题\"><a href=\"#通知中的线程问题\" class=\"headerlink\" title=\"通知中的线程问题\"></a>通知中的线程问题</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义通知</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">ThreadNotification</span> <span class=\"operator\">=</span> <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>.<span class=\"keyword\">init</span>(<span class=\"string\">&quot;com.papa.thread&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Add Observer: <span class=\"subst\">\\(Thread.current)</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">ThreadNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注意</span></span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">func</span> <span class=\"title function_\">test</span>(<span class=\"params\">notification</span>: <span class=\"type\">Notification</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Receive: <span class=\"subst\">\\(Thread.current)</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">DispatchQueue</span>.<span class=\"keyword\">init</span>(label: <span class=\"string\">&quot;com.ps.test.queue&quot;</span>).async &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Post: <span class=\"subst\">\\(Thread.current)</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.default.post(name: <span class=\"type\">ThreadNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们来看看观察者是在什么线程上接受到通知的:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Add</span> <span class=\"type\">Observer</span>: <span class=\"operator\">&lt;</span><span class=\"type\">NSThread</span>: <span class=\"number\">0x60000147d1c0</span><span class=\"operator\">&gt;</span>&#123;number <span class=\"operator\">=</span> <span class=\"number\">1</span>, name <span class=\"operator\">=</span> main&#125;</span><br><span class=\"line\"><span class=\"type\">Post</span>: <span class=\"operator\">&lt;</span><span class=\"type\">NSThread</span>: <span class=\"number\">0x600001462640</span><span class=\"operator\">&gt;</span>&#123;number <span class=\"operator\">=</span> <span class=\"number\">3</span>, name <span class=\"operator\">=</span> (null)&#125;</span><br><span class=\"line\"><span class=\"type\">Receive</span>: <span class=\"operator\">&lt;</span><span class=\"type\">NSThread</span>: <span class=\"number\">0x600001462640</span><span class=\"operator\">&gt;</span>&#123;number <span class=\"operator\">=</span> <span class=\"number\">3</span>, name <span class=\"operator\">=</span> (null)&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然我们是在主线程中去添加观察者，但是因为我们是在其他线程中去发送通知的，所以最后我们也是在其他线程中接收到通知的。</p>\n<h2 id=\"通知中的阻塞问题\"><a href=\"#通知中的阻塞问题\" class=\"headerlink\" title=\"通知中的阻塞问题\"></a>通知中的阻塞问题</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义通知</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">SleepNotification</span> <span class=\"operator\">=</span> <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>.<span class=\"keyword\">init</span>(<span class=\"string\">&quot;com.papa.sleep&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">SleepNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注意</span></span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">func</span> <span class=\"title function_\">test</span>(<span class=\"params\">notification</span>: <span class=\"type\">Notification</span>) &#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">3</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> start <span class=\"operator\">=</span> <span class=\"type\">Date</span>()</span><br><span class=\"line\"><span class=\"type\">NotificationCenter</span>.default.post(name: <span class=\"type\">SleepNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> end <span class=\"operator\">=</span> <span class=\"type\">Date</span>()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;相差：<span class=\"subst\">\\(end.timeIntervalSince(start))</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到最后相差时间大概是 <code>3s</code> ，通过上面的代码我们就知道单 NotificationCenter 去 post 一个通知的时候，它会等待观察者处理完改通知之后才会继续往后执行。所以平常使用过程中我们要注意 post 有可能会阻塞当前线程，特别是在主线程中。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"重复添加相同观察者\"><a href=\"#重复添加相同观察者\" class=\"headerlink\" title=\"重复添加相同观察者\"></a>重复添加相同观察者</h2><p>我们先来看看日常开发中我们对 NSNotification 的正常用法，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义通知</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">TestNotification</span> <span class=\"operator\">=</span> <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>.<span class=\"keyword\">init</span>(<span class=\"string\">&quot;com.papa.test&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">TestNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注意</span></span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">func</span> <span class=\"title function_\">test</span>(<span class=\"params\">notification</span>: <span class=\"type\">Notification</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Test&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是如果我们在刚才代码中的 <code>init</code> 方法里面对同一个通知多次添加同一个观察者的话，会发生什么？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">TestNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">TestNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送 TestNotification 通知</span></span><br><span class=\"line\"><span class=\"type\">NotificationCenter</span>.default.post(name: <span class=\"type\">TestNotification</span>, object: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n\n<p>答案是会输出：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Test</span></span><br><span class=\"line\"><span class=\"type\">Test</span></span><br></pre></td></tr></table></figure>\n\n<p>所以我们要尽量避免重复添加观察者，因为这有可能会造成一些未知现象的发生。</p>\n<h2 id=\"通知中的线程问题\"><a href=\"#通知中的线程问题\" class=\"headerlink\" title=\"通知中的线程问题\"></a>通知中的线程问题</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义通知</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">ThreadNotification</span> <span class=\"operator\">=</span> <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>.<span class=\"keyword\">init</span>(<span class=\"string\">&quot;com.papa.thread&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Add Observer: <span class=\"subst\">\\(Thread.current)</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">ThreadNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注意</span></span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">func</span> <span class=\"title function_\">test</span>(<span class=\"params\">notification</span>: <span class=\"type\">Notification</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Receive: <span class=\"subst\">\\(Thread.current)</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">DispatchQueue</span>.<span class=\"keyword\">init</span>(label: <span class=\"string\">&quot;com.ps.test.queue&quot;</span>).async &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Post: <span class=\"subst\">\\(Thread.current)</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.default.post(name: <span class=\"type\">ThreadNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们来看看观察者是在什么线程上接受到通知的:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Add</span> <span class=\"type\">Observer</span>: <span class=\"operator\">&lt;</span><span class=\"type\">NSThread</span>: <span class=\"number\">0x60000147d1c0</span><span class=\"operator\">&gt;</span>&#123;number <span class=\"operator\">=</span> <span class=\"number\">1</span>, name <span class=\"operator\">=</span> main&#125;</span><br><span class=\"line\"><span class=\"type\">Post</span>: <span class=\"operator\">&lt;</span><span class=\"type\">NSThread</span>: <span class=\"number\">0x600001462640</span><span class=\"operator\">&gt;</span>&#123;number <span class=\"operator\">=</span> <span class=\"number\">3</span>, name <span class=\"operator\">=</span> (null)&#125;</span><br><span class=\"line\"><span class=\"type\">Receive</span>: <span class=\"operator\">&lt;</span><span class=\"type\">NSThread</span>: <span class=\"number\">0x600001462640</span><span class=\"operator\">&gt;</span>&#123;number <span class=\"operator\">=</span> <span class=\"number\">3</span>, name <span class=\"operator\">=</span> (null)&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然我们是在主线程中去添加观察者，但是因为我们是在其他线程中去发送通知的，所以最后我们也是在其他线程中接收到通知的。</p>\n<h2 id=\"通知中的阻塞问题\"><a href=\"#通知中的阻塞问题\" class=\"headerlink\" title=\"通知中的阻塞问题\"></a>通知中的阻塞问题</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义通知</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">SleepNotification</span> <span class=\"operator\">=</span> <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>.<span class=\"keyword\">init</span>(<span class=\"string\">&quot;com.papa.sleep&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">SleepNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注意</span></span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">func</span> <span class=\"title function_\">test</span>(<span class=\"params\">notification</span>: <span class=\"type\">Notification</span>) &#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">3</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> start <span class=\"operator\">=</span> <span class=\"type\">Date</span>()</span><br><span class=\"line\"><span class=\"type\">NotificationCenter</span>.default.post(name: <span class=\"type\">SleepNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> end <span class=\"operator\">=</span> <span class=\"type\">Date</span>()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;相差：<span class=\"subst\">\\(end.timeIntervalSince(start))</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到最后相差时间大概是 <code>3s</code> ，通过上面的代码我们就知道单 NotificationCenter 去 post 一个通知的时候，它会等待观察者处理完改通知之后才会继续往后执行。所以平常使用过程中我们要注意 post 有可能会阻塞当前线程，特别是在主线程中。</p>\n"},{"layout":"post","title":"RAC 和内存管理","author":"帕帕","date":"2017-09-05T15:30:56.000Z","thumbnail":"https://images.unsplash.com/photo-1517077304055-6e89abbf09b0?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3f799bed83db2959c476e69a3307d39e&auto=format&fit=crop&w=160&q=100","_content":"\n最近在用 RAC 的时候发现自己对内存管理还是有些困惑，于是自己写了一些代码来验证自己的一些理解。\n在一开始接触 RAC 的时候，我们知道 RAC 对于 block 都是 copy 赋值的。\n\n```Swift\n@implementation RACSignal\n\n#pragma mark Lifecycle\n\n+ (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe {\n    return [RACDynamicSignal createSignal:didSubscribe];\n}\n```\n\n```Swift\n@implementation RACDynamicSignal\n\n#pragma mark Lifecycle\n\n+ (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe {\n    RACDynamicSignal *signal = [[self alloc] init];\n    signal->_didSubscribe = [didSubscribe copy];\n    return [signal setNameWithFormat:@\"+createSignal:\"];\n}\n```\n\n在创建 RACSingal 的时候会调用其子类 RACDynamicSignal 去创建，我们也看到 RACDynamicSignal 对 didSuscribe 这个 block 是进行了 copy。所以大家可能会被要求注意循环引用的问题，于是大家都用 @weakify(target) 和 @strongify(target) 来避免循环引用的问题。那是不是所有用到 RAC 的地方都需要使用这些宏来避免循环引用的问题，不尽然。比如下面这个：\n\n```Swift\n// 场景1\n[RACObserve(self, title) subscribeNext:^(id x) {\n    NSLog(@\"%@\", x);\n}];\n```\n\n接下来，我们来对比以下的几种用法：\n\n```Swift\n@interface ViewController()\n@property (strong, nonatomic) ViewModel * viewModel;\n@end\n\n@implementation ViewController\n\n- (void)viewDidiLoad {\n    [super viewDidLoad];\n\n    self.viewModel = [ViewModel new];\n\n    // 场景2\n    dispatch_async(dispatch_get_main_queue(), ^{\n        self.title = @\"你好\";\n    });\n\n    // 场景3\n    [self.viewModel.titleSignal subscribeNext:^(NSString * title) {\n        self.title = title;\n    }];\n\n    // 场景4\n    [RACObserve(self.viewModel, title) subscribeNext:^(NSString * title)     {\n        self.title = title;\n    }]; \n}\n\n@end\n```\n\n场景2是我们平常都会用到的，而且我们也没有在这种场景下去考虑循环引用的问题，这是因为 dispatch 的 block 不是属于 self 的（至于这个 block 是属于谁的，回头我再查点资料或者请各位指教），所以即使你在 block 使用了 self 也不会有循环应用的问题。\n\n场景3很明显是有循环引用的问题：**self->viewModel->titleSignal->block->self**，这个时候如果我们不做处理的话，那么 self 就永远不会被释放。正确的做法应该是使用 @weakify(self) 和 @strongify(self)：\n\n```Swift\n// 场景3\n@weakify(self);\n[self.viewModel.titleSignal subscribeNext:^(NSString * title) {\n    @strongify(self);\n    self.title = title;\n}];\n```\n\n场景4在我们看来是没有问题的，因为这里看起来只有 **singal->block->self** 的引用，它们之间并没有造成循环引用的问题。我们先来看看 RACObserve 的实现：\n\n```Swift\n#define RACObserve(TARGET, KEYPATH) \\\n({ \\\n_Pragma(\"clang diagnostic push\") \\\n_Pragma(\"clang diagnostic ignored \\\"-Wreceiver-is-weak\\\"\") \\\n__weak id target_ = (TARGET); \\\n[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \\\n_Pragma(\"clang diagnostic pop\") \\\n})\n\n- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak NSObject *)observer;\n```\n\n其实，看到这里你会认为这里只是调用了一个方法创建了一个 Signal，而且这个 Signal 也并不属于任何对象。我们再来看看具体的实现是怎么样的？\n\n```Swift\n- (RACSignal *)rac_valuesAndChangesForKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options observer:(__weak NSObject *)weakObserver {\n    NSObject *strongObserver = weakObserver;\n    keyPath = [keyPath copy];\n\n    NSRecursiveLock *objectLock = [[NSRecursiveLock alloc] init];\n    objectLock.name = @\"org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing\";\n\n    __weak NSObject *weakSelf = self;\n\n    RACSignal *deallocSignal = [[RACSignal zip:@[\n                            self.rac_willDeallocSignal,\n                            strongObserver.rac_willDeallocSignal ?: [RACSignal never]\n    ]] doCompleted:^{\n        // Forces deallocation to wait if the object variables are currently\n        // being read on another thread.\n        [objectLock lock];\n        @onExit {\n            [objectLock unlock];\n        };\n    }];\n\n    return [[[RACSignal createSignal:^ RACDisposable * (id<RACSubscriber> subscriber) {\n        // Hold onto the lock the whole time we're setting up the KVO\n        // observation, because any resurrection that might be caused by our\n        // retaining below must be balanced out by the time -dealloc returns\n        // (if another thread is waiting on the lock above).\n        [objectLock lock];\n        @onExit {\n            [objectLock unlock];\n        };\n    \n        __strong NSObject *observer __attribute__((objc_precise_lifetime)) = weakObserver;\n        __strong NSObject *self __attribute__((objc_precise_lifetime)) = weakSelf;\n    \n        if (self == nil) {\n            [subscriber sendCompleted];\n            return nil;\n        }\n    \n        return [self rac_observeKeyPath:keyPath options:options observer:observer block:^(id value, NSDictionary *change, BOOL causedByDealloc, BOOL affectedOnlyLastComponent) {\n                [subscriber sendNext:RACTuplePack(value, change)];\n        }];\n    }] takeUntil:deallocSignal] setNameWithFormat:@\"%@ -rac_valueAndChangesForKeyPath: %@ options: %lu observer: %@\", self.rac_description, keyPath, (unsigned long)options, strongObserver.rac_description];\n}\n```\n\n重点观察 **deallocSignal** 和 **[signal takeUntile:deallocSignal]**，我们把 deallocSignal 单独拿出来看看：\n\n```Swift\nRACSignal *deallocSignal = [[RACSignal zip:@[\n                        self.rac_willDeallocSignal,\n                        strongObserver.rac_willDeallocSignal ?: [RACSignal never]\n                        ]] doCompleted:^{\n    // Forces deallocation to wait if the object variables are currently\n    // being read on another thread.\n    [objectLock lock];\n    @onExit {\n    [objectLock unlock];\n    };\n}];\n```\n\n这里的 deallocSignal 是只有在 self 和 strongObserve 都将要发生 dealloc 的时候才会触发的。即用 RACObserve 创建的信号只有在其 target 和 observe 都发生 dealloc 的时候才会被 disposable (这个好像是 RAC 用来销毁自己资源的东西)。不明白的童鞋，我们回头来分析一下场景4的代码：\n\n```Swift\n// 场景4\n[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) {\n    self.title = title;\n}];\n```\n\n用 RACObserve 创建的信号看起来只要出了函数体其资源应该就会被回收，但是这个信号其实是只有在 self.viewModel.rac_willDeallocSignal 和 self.rac_willDeallocSignal 都发生的情况下才会被释放。所以场景4的引用关系看起来只有 signal->block->self，但是这个 signal 只有在 self.rac_willDeallocSignal 的时候才会被释放。所以这里如果不打断这种关系的话就会造成循环引用的问题，正确做法应该是：\n\n```Swift\n// 场景4\n@weakify(self);\n[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) {\n    @strongify(self);\n    self.title = title;\n}];\n```\n\n最后，在说一个特别需要注意的，就是 UITableViewCell 和 UICollectionViewCell 复用和 RAC 的问题。\n\n```Swift\n- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return 1000;\n}\n\n- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath {\n    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"TableViewCell\"];\n\n    @weakify(self);\n    [RACObserve(cell.textLabel, text) subscribeNext:^(id x) {\n        @strongify(self);\n        NSLog(@\"%@\", self);\n    }];\n\n    return cell;\n}\n```\n\n我们看到这里的 RACObserve 创建的 Signal 和 self 之间已经去掉了循环引用的问题，所以应该是没有什么问题的。但是结合之前我们对 RACObserve 的理解再仔细分析一下，这里的 Signal 只要 self 没有被 dealloc 的话就不会被释放。虽然每次 UITableViewCell 都会被重用，但是每次重用过程中创建的信号确实无法被 disposable。那我们该怎么做呢？\n\n```Swift\n- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return 1000;\n}\n\n- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath {\n    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"TableViewCell\"];\n\n    @weakify(self);\n    [[RACObserve(cell.textLabel, text) takeUntil:cell.rac_prepareForReuseSignal] subscribeNext:^(id x) {\n        @strongify(self);\n        NSLog(@\"%@\", self);\n    }];\n\n    return cell;\n}\n```\n\n注意，我们在cell里面创建的信号加上 takeUntil:cell.rac_prepareForReuseSignal，这个是让 cell 在每次重用的时候都去 disposable 创建的信号。\n\n以上所说的关于内存的东西我都用 Instrument 的 Allocations 验证过了，但是依旧建议大家自己也去试试。\n\n\n","source":"_posts/RAC和内存管理.md","raw":"---\nlayout: post \ntitle: RAC 和内存管理\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: 技术\ntags: [iOS, RAC]\nthumbnail: https://images.unsplash.com/photo-1517077304055-6e89abbf09b0?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3f799bed83db2959c476e69a3307d39e&auto=format&fit=crop&w=160&q=100\n---\n\n最近在用 RAC 的时候发现自己对内存管理还是有些困惑，于是自己写了一些代码来验证自己的一些理解。\n在一开始接触 RAC 的时候，我们知道 RAC 对于 block 都是 copy 赋值的。\n\n```Swift\n@implementation RACSignal\n\n#pragma mark Lifecycle\n\n+ (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe {\n    return [RACDynamicSignal createSignal:didSubscribe];\n}\n```\n\n```Swift\n@implementation RACDynamicSignal\n\n#pragma mark Lifecycle\n\n+ (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe {\n    RACDynamicSignal *signal = [[self alloc] init];\n    signal->_didSubscribe = [didSubscribe copy];\n    return [signal setNameWithFormat:@\"+createSignal:\"];\n}\n```\n\n在创建 RACSingal 的时候会调用其子类 RACDynamicSignal 去创建，我们也看到 RACDynamicSignal 对 didSuscribe 这个 block 是进行了 copy。所以大家可能会被要求注意循环引用的问题，于是大家都用 @weakify(target) 和 @strongify(target) 来避免循环引用的问题。那是不是所有用到 RAC 的地方都需要使用这些宏来避免循环引用的问题，不尽然。比如下面这个：\n\n```Swift\n// 场景1\n[RACObserve(self, title) subscribeNext:^(id x) {\n    NSLog(@\"%@\", x);\n}];\n```\n\n接下来，我们来对比以下的几种用法：\n\n```Swift\n@interface ViewController()\n@property (strong, nonatomic) ViewModel * viewModel;\n@end\n\n@implementation ViewController\n\n- (void)viewDidiLoad {\n    [super viewDidLoad];\n\n    self.viewModel = [ViewModel new];\n\n    // 场景2\n    dispatch_async(dispatch_get_main_queue(), ^{\n        self.title = @\"你好\";\n    });\n\n    // 场景3\n    [self.viewModel.titleSignal subscribeNext:^(NSString * title) {\n        self.title = title;\n    }];\n\n    // 场景4\n    [RACObserve(self.viewModel, title) subscribeNext:^(NSString * title)     {\n        self.title = title;\n    }]; \n}\n\n@end\n```\n\n场景2是我们平常都会用到的，而且我们也没有在这种场景下去考虑循环引用的问题，这是因为 dispatch 的 block 不是属于 self 的（至于这个 block 是属于谁的，回头我再查点资料或者请各位指教），所以即使你在 block 使用了 self 也不会有循环应用的问题。\n\n场景3很明显是有循环引用的问题：**self->viewModel->titleSignal->block->self**，这个时候如果我们不做处理的话，那么 self 就永远不会被释放。正确的做法应该是使用 @weakify(self) 和 @strongify(self)：\n\n```Swift\n// 场景3\n@weakify(self);\n[self.viewModel.titleSignal subscribeNext:^(NSString * title) {\n    @strongify(self);\n    self.title = title;\n}];\n```\n\n场景4在我们看来是没有问题的，因为这里看起来只有 **singal->block->self** 的引用，它们之间并没有造成循环引用的问题。我们先来看看 RACObserve 的实现：\n\n```Swift\n#define RACObserve(TARGET, KEYPATH) \\\n({ \\\n_Pragma(\"clang diagnostic push\") \\\n_Pragma(\"clang diagnostic ignored \\\"-Wreceiver-is-weak\\\"\") \\\n__weak id target_ = (TARGET); \\\n[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \\\n_Pragma(\"clang diagnostic pop\") \\\n})\n\n- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak NSObject *)observer;\n```\n\n其实，看到这里你会认为这里只是调用了一个方法创建了一个 Signal，而且这个 Signal 也并不属于任何对象。我们再来看看具体的实现是怎么样的？\n\n```Swift\n- (RACSignal *)rac_valuesAndChangesForKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options observer:(__weak NSObject *)weakObserver {\n    NSObject *strongObserver = weakObserver;\n    keyPath = [keyPath copy];\n\n    NSRecursiveLock *objectLock = [[NSRecursiveLock alloc] init];\n    objectLock.name = @\"org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing\";\n\n    __weak NSObject *weakSelf = self;\n\n    RACSignal *deallocSignal = [[RACSignal zip:@[\n                            self.rac_willDeallocSignal,\n                            strongObserver.rac_willDeallocSignal ?: [RACSignal never]\n    ]] doCompleted:^{\n        // Forces deallocation to wait if the object variables are currently\n        // being read on another thread.\n        [objectLock lock];\n        @onExit {\n            [objectLock unlock];\n        };\n    }];\n\n    return [[[RACSignal createSignal:^ RACDisposable * (id<RACSubscriber> subscriber) {\n        // Hold onto the lock the whole time we're setting up the KVO\n        // observation, because any resurrection that might be caused by our\n        // retaining below must be balanced out by the time -dealloc returns\n        // (if another thread is waiting on the lock above).\n        [objectLock lock];\n        @onExit {\n            [objectLock unlock];\n        };\n    \n        __strong NSObject *observer __attribute__((objc_precise_lifetime)) = weakObserver;\n        __strong NSObject *self __attribute__((objc_precise_lifetime)) = weakSelf;\n    \n        if (self == nil) {\n            [subscriber sendCompleted];\n            return nil;\n        }\n    \n        return [self rac_observeKeyPath:keyPath options:options observer:observer block:^(id value, NSDictionary *change, BOOL causedByDealloc, BOOL affectedOnlyLastComponent) {\n                [subscriber sendNext:RACTuplePack(value, change)];\n        }];\n    }] takeUntil:deallocSignal] setNameWithFormat:@\"%@ -rac_valueAndChangesForKeyPath: %@ options: %lu observer: %@\", self.rac_description, keyPath, (unsigned long)options, strongObserver.rac_description];\n}\n```\n\n重点观察 **deallocSignal** 和 **[signal takeUntile:deallocSignal]**，我们把 deallocSignal 单独拿出来看看：\n\n```Swift\nRACSignal *deallocSignal = [[RACSignal zip:@[\n                        self.rac_willDeallocSignal,\n                        strongObserver.rac_willDeallocSignal ?: [RACSignal never]\n                        ]] doCompleted:^{\n    // Forces deallocation to wait if the object variables are currently\n    // being read on another thread.\n    [objectLock lock];\n    @onExit {\n    [objectLock unlock];\n    };\n}];\n```\n\n这里的 deallocSignal 是只有在 self 和 strongObserve 都将要发生 dealloc 的时候才会触发的。即用 RACObserve 创建的信号只有在其 target 和 observe 都发生 dealloc 的时候才会被 disposable (这个好像是 RAC 用来销毁自己资源的东西)。不明白的童鞋，我们回头来分析一下场景4的代码：\n\n```Swift\n// 场景4\n[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) {\n    self.title = title;\n}];\n```\n\n用 RACObserve 创建的信号看起来只要出了函数体其资源应该就会被回收，但是这个信号其实是只有在 self.viewModel.rac_willDeallocSignal 和 self.rac_willDeallocSignal 都发生的情况下才会被释放。所以场景4的引用关系看起来只有 signal->block->self，但是这个 signal 只有在 self.rac_willDeallocSignal 的时候才会被释放。所以这里如果不打断这种关系的话就会造成循环引用的问题，正确做法应该是：\n\n```Swift\n// 场景4\n@weakify(self);\n[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) {\n    @strongify(self);\n    self.title = title;\n}];\n```\n\n最后，在说一个特别需要注意的，就是 UITableViewCell 和 UICollectionViewCell 复用和 RAC 的问题。\n\n```Swift\n- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return 1000;\n}\n\n- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath {\n    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"TableViewCell\"];\n\n    @weakify(self);\n    [RACObserve(cell.textLabel, text) subscribeNext:^(id x) {\n        @strongify(self);\n        NSLog(@\"%@\", self);\n    }];\n\n    return cell;\n}\n```\n\n我们看到这里的 RACObserve 创建的 Signal 和 self 之间已经去掉了循环引用的问题，所以应该是没有什么问题的。但是结合之前我们对 RACObserve 的理解再仔细分析一下，这里的 Signal 只要 self 没有被 dealloc 的话就不会被释放。虽然每次 UITableViewCell 都会被重用，但是每次重用过程中创建的信号确实无法被 disposable。那我们该怎么做呢？\n\n```Swift\n- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return 1000;\n}\n\n- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath {\n    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"TableViewCell\"];\n\n    @weakify(self);\n    [[RACObserve(cell.textLabel, text) takeUntil:cell.rac_prepareForReuseSignal] subscribeNext:^(id x) {\n        @strongify(self);\n        NSLog(@\"%@\", self);\n    }];\n\n    return cell;\n}\n```\n\n注意，我们在cell里面创建的信号加上 takeUntil:cell.rac_prepareForReuseSignal，这个是让 cell 在每次重用的时候都去 disposable 创建的信号。\n\n以上所说的关于内存的东西我都用 Instrument 的 Allocations 验证过了，但是依旧建议大家自己也去试试。\n\n\n","slug":"RAC和内存管理","published":1,"updated":"2022-04-20T07:08:33.123Z","comments":1,"photos":[],"link":"","_id":"cl28gjxe5000d6enqeoa752x1","content":"<p>最近在用 RAC 的时候发现自己对内存管理还是有些困惑，于是自己写了一些代码来验证自己的一些理解。<br>在一开始接触 RAC 的时候，我们知道 RAC 对于 block 都是 copy 赋值的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@implementation</span> <span class=\"type\">RACSignal</span></span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark <span class=\"type\">Lifecycle</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">+</span> (<span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>)createSignal:(<span class=\"type\">RACDisposable</span> <span class=\"operator\">*</span> (<span class=\"operator\">^</span>)(id<span class=\"operator\">&lt;</span><span class=\"type\">RACSubscriber</span><span class=\"operator\">&gt;</span> subscriber))didSubscribe &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"type\">RACDynamicSignal</span> createSignal:didSubscribe];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@implementation</span> <span class=\"type\">RACDynamicSignal</span></span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark <span class=\"type\">Lifecycle</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">+</span> (<span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>)createSignal:(<span class=\"type\">RACDisposable</span> <span class=\"operator\">*</span> (<span class=\"operator\">^</span>)(id<span class=\"operator\">&lt;</span><span class=\"type\">RACSubscriber</span><span class=\"operator\">&gt;</span> subscriber))didSubscribe &#123;</span><br><span class=\"line\">    <span class=\"type\">RACDynamicSignal</span> <span class=\"operator\">*</span>signal <span class=\"operator\">=</span> [[<span class=\"keyword\">self</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    signal-&gt;_didSubscribe <span class=\"operator\">=</span> [didSubscribe copy];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [signal setNameWithFormat:@<span class=\"string\">&quot;+createSignal:&quot;</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在创建 RACSingal 的时候会调用其子类 RACDynamicSignal 去创建，我们也看到 RACDynamicSignal 对 didSuscribe 这个 block 是进行了 copy。所以大家可能会被要求注意循环引用的问题，于是大家都用 @weakify(target) 和 @strongify(target) 来避免循环引用的问题。那是不是所有用到 RAC 的地方都需要使用这些宏来避免循环引用的问题，不尽然。比如下面这个：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 场景1</span></span><br><span class=\"line\">[<span class=\"type\">RACObserve</span>(<span class=\"keyword\">self</span>, title) subscribeNext:<span class=\"operator\">^</span>(id x) &#123;</span><br><span class=\"line\">    <span class=\"type\">NSLog</span>(@<span class=\"string\">&quot;%@&quot;</span>, x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们来对比以下的几种用法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@interface</span> <span class=\"type\">ViewController</span>()</span><br><span class=\"line\"><span class=\"meta\">@property</span> (strong, nonatomic) <span class=\"type\">ViewModel</span> <span class=\"operator\">*</span> viewModel;</span><br><span class=\"line\"><span class=\"meta\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@implementation</span> <span class=\"type\">ViewController</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> (void)viewDidiLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.viewModel <span class=\"operator\">=</span> [<span class=\"type\">ViewModel</span> new];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 场景2</span></span><br><span class=\"line\">    dispatch_async(dispatch_get_main_queue(), <span class=\"operator\">^</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> @<span class=\"string\">&quot;你好&quot;</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 场景3</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.viewModel.titleSignal subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 场景4</span></span><br><span class=\"line\">    [<span class=\"type\">RACObserve</span>(<span class=\"keyword\">self</span>.viewModel, title) subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title)     &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">    &#125;]; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>场景2是我们平常都会用到的，而且我们也没有在这种场景下去考虑循环引用的问题，这是因为 dispatch 的 block 不是属于 self 的（至于这个 block 是属于谁的，回头我再查点资料或者请各位指教），所以即使你在 block 使用了 self 也不会有循环应用的问题。</p>\n<p>场景3很明显是有循环引用的问题：<strong>self-&gt;viewModel-&gt;titleSignal-&gt;block-&gt;self</strong>，这个时候如果我们不做处理的话，那么 self 就永远不会被释放。正确的做法应该是使用 @weakify(self) 和 @strongify(self)：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 场景3</span></span><br><span class=\"line\"><span class=\"meta\">@weakify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.viewModel.titleSignal subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@strongify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>场景4在我们看来是没有问题的，因为这里看起来只有 <strong>singal-&gt;block-&gt;self</strong> 的引用，它们之间并没有造成循环引用的问题。我们先来看看 RACObserve 的实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define <span class=\"type\">RACObserve</span>(<span class=\"type\">TARGET</span>, <span class=\"type\">KEYPATH</span>) \\</span><br><span class=\"line\">(&#123; \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">&quot;clang diagnostic push&quot;</span>) \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">&quot;clang diagnostic ignored <span class=\"subst\">\\&quot;</span>-Wreceiver-is-weak<span class=\"subst\">\\&quot;</span>&quot;</span>) \\</span><br><span class=\"line\">__weak id target_ <span class=\"operator\">=</span> (<span class=\"type\">TARGET</span>); \\</span><br><span class=\"line\">[target_ rac_valuesForKeyPath:<span class=\"meta\">@keypath</span>(<span class=\"type\">TARGET</span>, <span class=\"type\">KEYPATH</span>) observer:<span class=\"keyword\">self</span>]; \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">&quot;clang diagnostic pop&quot;</span>) \\</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>)rac_valuesForKeyPath:(<span class=\"type\">NSString</span> <span class=\"operator\">*</span>)keyPath observer:(__weak <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>)observer;</span><br></pre></td></tr></table></figure>\n\n<p>其实，看到这里你会认为这里只是调用了一个方法创建了一个 Signal，而且这个 Signal 也并不属于任何对象。我们再来看看具体的实现是怎么样的？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>)rac_valuesAndChangesForKeyPath:(<span class=\"type\">NSString</span> <span class=\"operator\">*</span>)keyPath options:(<span class=\"type\">NSKeyValueObservingOptions</span>)options observer:(__weak <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>)weakObserver &#123;</span><br><span class=\"line\">    <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>strongObserver <span class=\"operator\">=</span> weakObserver;</span><br><span class=\"line\">    keyPath <span class=\"operator\">=</span> [keyPath copy];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">NSRecursiveLock</span> <span class=\"operator\">*</span>objectLock <span class=\"operator\">=</span> [[<span class=\"type\">NSRecursiveLock</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    objectLock.name <span class=\"operator\">=</span> @<span class=\"string\">&quot;org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    __weak <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>weakSelf <span class=\"operator\">=</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>deallocSignal <span class=\"operator\">=</span> [[<span class=\"type\">RACSignal</span> zip:@[</span><br><span class=\"line\">                            <span class=\"keyword\">self</span>.rac_willDeallocSignal,</span><br><span class=\"line\">                            strongObserver.rac_willDeallocSignal <span class=\"operator\">?</span>: [<span class=\"type\">RACSignal</span> never]</span><br><span class=\"line\">    ]] doCompleted:<span class=\"operator\">^</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Forces deallocation to wait if the object variables are currently</span></span><br><span class=\"line\">        <span class=\"comment\">// being read on another thread.</span></span><br><span class=\"line\">        [objectLock lock];</span><br><span class=\"line\">        <span class=\"meta\">@onExit</span> &#123;</span><br><span class=\"line\">            [objectLock unlock];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[[<span class=\"type\">RACSignal</span> createSignal:<span class=\"operator\">^</span> <span class=\"type\">RACDisposable</span> <span class=\"operator\">*</span> (id<span class=\"operator\">&lt;</span><span class=\"type\">RACSubscriber</span><span class=\"operator\">&gt;</span> subscriber) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Hold onto the lock the whole time we&#x27;re setting up the KVO</span></span><br><span class=\"line\">        <span class=\"comment\">// observation, because any resurrection that might be caused by our</span></span><br><span class=\"line\">        <span class=\"comment\">// retaining below must be balanced out by the time -dealloc returns</span></span><br><span class=\"line\">        <span class=\"comment\">// (if another thread is waiting on the lock above).</span></span><br><span class=\"line\">        [objectLock lock];</span><br><span class=\"line\">        <span class=\"meta\">@onExit</span> &#123;</span><br><span class=\"line\">            [objectLock unlock];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">        __strong <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>observer __attribute__((objc_precise_lifetime)) <span class=\"operator\">=</span> weakObserver;</span><br><span class=\"line\">        __strong <span class=\"type\">NSObject</span> <span class=\"operator\">*</span><span class=\"keyword\">self</span> __attribute__((objc_precise_lifetime)) <span class=\"operator\">=</span> weakSelf;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> <span class=\"operator\">==</span> <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">            [subscriber sendCompleted];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> rac_observeKeyPath:keyPath options:options observer:observer block:<span class=\"operator\">^</span>(id value, <span class=\"type\">NSDictionary</span> <span class=\"operator\">*</span>change, <span class=\"type\">BOOL</span> causedByDealloc, <span class=\"type\">BOOL</span> affectedOnlyLastComponent) &#123;</span><br><span class=\"line\">                [subscriber sendNext:<span class=\"type\">RACTuplePack</span>(value, change)];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;] takeUntil:deallocSignal] setNameWithFormat:@<span class=\"string\">&quot;%@ -rac_valueAndChangesForKeyPath: %@ options: %lu observer: %@&quot;</span>, <span class=\"keyword\">self</span>.rac_description, keyPath, (unsigned long)options, strongObserver.rac_description];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重点观察 <strong>deallocSignal</strong> 和 **[signal takeUntile:deallocSignal]**，我们把 deallocSignal 单独拿出来看看：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>deallocSignal <span class=\"operator\">=</span> [[<span class=\"type\">RACSignal</span> zip:@[</span><br><span class=\"line\">                        <span class=\"keyword\">self</span>.rac_willDeallocSignal,</span><br><span class=\"line\">                        strongObserver.rac_willDeallocSignal <span class=\"operator\">?</span>: [<span class=\"type\">RACSignal</span> never]</span><br><span class=\"line\">                        ]] doCompleted:<span class=\"operator\">^</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Forces deallocation to wait if the object variables are currently</span></span><br><span class=\"line\">    <span class=\"comment\">// being read on another thread.</span></span><br><span class=\"line\">    [objectLock lock];</span><br><span class=\"line\">    <span class=\"meta\">@onExit</span> &#123;</span><br><span class=\"line\">    [objectLock unlock];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>这里的 deallocSignal 是只有在 self 和 strongObserve 都将要发生 dealloc 的时候才会触发的。即用 RACObserve 创建的信号只有在其 target 和 observe 都发生 dealloc 的时候才会被 disposable (这个好像是 RAC 用来销毁自己资源的东西)。不明白的童鞋，我们回头来分析一下场景4的代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 场景4</span></span><br><span class=\"line\">[<span class=\"type\">RACObserve</span>(<span class=\"keyword\">self</span>.viewModel, title) subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>用 RACObserve 创建的信号看起来只要出了函数体其资源应该就会被回收，但是这个信号其实是只有在 self.viewModel.rac_willDeallocSignal 和 self.rac_willDeallocSignal 都发生的情况下才会被释放。所以场景4的引用关系看起来只有 signal-&gt;block-&gt;self，但是这个 signal 只有在 self.rac_willDeallocSignal 的时候才会被释放。所以这里如果不打断这种关系的话就会造成循环引用的问题，正确做法应该是：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 场景4</span></span><br><span class=\"line\"><span class=\"meta\">@weakify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">[<span class=\"type\">RACObserve</span>(<span class=\"keyword\">self</span>.viewModel, title) subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@strongify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>最后，在说一个特别需要注意的，就是 UITableViewCell 和 UICollectionViewCell 复用和 RAC 的问题。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">NSInteger</span>)tableView:(nonnull <span class=\"type\">UITableView</span> <span class=\"operator\">*</span>)tableView numberOfRowsInSection:(<span class=\"type\">NSInteger</span>)section &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">UITableViewCell</span> <span class=\"operator\">*</span>)tableView:(nonnull <span class=\"type\">UITableView</span> <span class=\"operator\">*</span>)tableView cellForRowAtIndexPath:(nonnull <span class=\"type\">NSIndexPath</span> <span class=\"operator\">*</span>)indexPath &#123;</span><br><span class=\"line\">    <span class=\"type\">UITableViewCell</span> <span class=\"operator\">*</span> cell <span class=\"operator\">=</span> [tableView dequeueReusableCellWithIdentifier:@<span class=\"string\">&quot;TableViewCell&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@weakify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    [<span class=\"type\">RACObserve</span>(cell.textLabel, text) subscribeNext:<span class=\"operator\">^</span>(id x) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@strongify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(@<span class=\"string\">&quot;%@&quot;</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们看到这里的 RACObserve 创建的 Signal 和 self 之间已经去掉了循环引用的问题，所以应该是没有什么问题的。但是结合之前我们对 RACObserve 的理解再仔细分析一下，这里的 Signal 只要 self 没有被 dealloc 的话就不会被释放。虽然每次 UITableViewCell 都会被重用，但是每次重用过程中创建的信号确实无法被 disposable。那我们该怎么做呢？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">NSInteger</span>)tableView:(nonnull <span class=\"type\">UITableView</span> <span class=\"operator\">*</span>)tableView numberOfRowsInSection:(<span class=\"type\">NSInteger</span>)section &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">UITableViewCell</span> <span class=\"operator\">*</span>)tableView:(nonnull <span class=\"type\">UITableView</span> <span class=\"operator\">*</span>)tableView cellForRowAtIndexPath:(nonnull <span class=\"type\">NSIndexPath</span> <span class=\"operator\">*</span>)indexPath &#123;</span><br><span class=\"line\">    <span class=\"type\">UITableViewCell</span> <span class=\"operator\">*</span> cell <span class=\"operator\">=</span> [tableView dequeueReusableCellWithIdentifier:@<span class=\"string\">&quot;TableViewCell&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@weakify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    [[<span class=\"type\">RACObserve</span>(cell.textLabel, text) takeUntil:cell.rac_prepareForReuseSignal] subscribeNext:<span class=\"operator\">^</span>(id x) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@strongify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(@<span class=\"string\">&quot;%@&quot;</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，我们在cell里面创建的信号加上 takeUntil:cell.rac_prepareForReuseSignal，这个是让 cell 在每次重用的时候都去 disposable 创建的信号。</p>\n<p>以上所说的关于内存的东西我都用 Instrument 的 Allocations 验证过了，但是依旧建议大家自己也去试试。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在用 RAC 的时候发现自己对内存管理还是有些困惑，于是自己写了一些代码来验证自己的一些理解。<br>在一开始接触 RAC 的时候，我们知道 RAC 对于 block 都是 copy 赋值的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@implementation</span> <span class=\"type\">RACSignal</span></span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark <span class=\"type\">Lifecycle</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">+</span> (<span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>)createSignal:(<span class=\"type\">RACDisposable</span> <span class=\"operator\">*</span> (<span class=\"operator\">^</span>)(id<span class=\"operator\">&lt;</span><span class=\"type\">RACSubscriber</span><span class=\"operator\">&gt;</span> subscriber))didSubscribe &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"type\">RACDynamicSignal</span> createSignal:didSubscribe];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@implementation</span> <span class=\"type\">RACDynamicSignal</span></span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark <span class=\"type\">Lifecycle</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">+</span> (<span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>)createSignal:(<span class=\"type\">RACDisposable</span> <span class=\"operator\">*</span> (<span class=\"operator\">^</span>)(id<span class=\"operator\">&lt;</span><span class=\"type\">RACSubscriber</span><span class=\"operator\">&gt;</span> subscriber))didSubscribe &#123;</span><br><span class=\"line\">    <span class=\"type\">RACDynamicSignal</span> <span class=\"operator\">*</span>signal <span class=\"operator\">=</span> [[<span class=\"keyword\">self</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    signal-&gt;_didSubscribe <span class=\"operator\">=</span> [didSubscribe copy];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [signal setNameWithFormat:@<span class=\"string\">&quot;+createSignal:&quot;</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在创建 RACSingal 的时候会调用其子类 RACDynamicSignal 去创建，我们也看到 RACDynamicSignal 对 didSuscribe 这个 block 是进行了 copy。所以大家可能会被要求注意循环引用的问题，于是大家都用 @weakify(target) 和 @strongify(target) 来避免循环引用的问题。那是不是所有用到 RAC 的地方都需要使用这些宏来避免循环引用的问题，不尽然。比如下面这个：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 场景1</span></span><br><span class=\"line\">[<span class=\"type\">RACObserve</span>(<span class=\"keyword\">self</span>, title) subscribeNext:<span class=\"operator\">^</span>(id x) &#123;</span><br><span class=\"line\">    <span class=\"type\">NSLog</span>(@<span class=\"string\">&quot;%@&quot;</span>, x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们来对比以下的几种用法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@interface</span> <span class=\"type\">ViewController</span>()</span><br><span class=\"line\"><span class=\"meta\">@property</span> (strong, nonatomic) <span class=\"type\">ViewModel</span> <span class=\"operator\">*</span> viewModel;</span><br><span class=\"line\"><span class=\"meta\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@implementation</span> <span class=\"type\">ViewController</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> (void)viewDidiLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.viewModel <span class=\"operator\">=</span> [<span class=\"type\">ViewModel</span> new];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 场景2</span></span><br><span class=\"line\">    dispatch_async(dispatch_get_main_queue(), <span class=\"operator\">^</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> @<span class=\"string\">&quot;你好&quot;</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 场景3</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.viewModel.titleSignal subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 场景4</span></span><br><span class=\"line\">    [<span class=\"type\">RACObserve</span>(<span class=\"keyword\">self</span>.viewModel, title) subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title)     &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">    &#125;]; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>场景2是我们平常都会用到的，而且我们也没有在这种场景下去考虑循环引用的问题，这是因为 dispatch 的 block 不是属于 self 的（至于这个 block 是属于谁的，回头我再查点资料或者请各位指教），所以即使你在 block 使用了 self 也不会有循环应用的问题。</p>\n<p>场景3很明显是有循环引用的问题：<strong>self-&gt;viewModel-&gt;titleSignal-&gt;block-&gt;self</strong>，这个时候如果我们不做处理的话，那么 self 就永远不会被释放。正确的做法应该是使用 @weakify(self) 和 @strongify(self)：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 场景3</span></span><br><span class=\"line\"><span class=\"meta\">@weakify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.viewModel.titleSignal subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@strongify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>场景4在我们看来是没有问题的，因为这里看起来只有 <strong>singal-&gt;block-&gt;self</strong> 的引用，它们之间并没有造成循环引用的问题。我们先来看看 RACObserve 的实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define <span class=\"type\">RACObserve</span>(<span class=\"type\">TARGET</span>, <span class=\"type\">KEYPATH</span>) \\</span><br><span class=\"line\">(&#123; \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">&quot;clang diagnostic push&quot;</span>) \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">&quot;clang diagnostic ignored <span class=\"subst\">\\&quot;</span>-Wreceiver-is-weak<span class=\"subst\">\\&quot;</span>&quot;</span>) \\</span><br><span class=\"line\">__weak id target_ <span class=\"operator\">=</span> (<span class=\"type\">TARGET</span>); \\</span><br><span class=\"line\">[target_ rac_valuesForKeyPath:<span class=\"meta\">@keypath</span>(<span class=\"type\">TARGET</span>, <span class=\"type\">KEYPATH</span>) observer:<span class=\"keyword\">self</span>]; \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">&quot;clang diagnostic pop&quot;</span>) \\</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>)rac_valuesForKeyPath:(<span class=\"type\">NSString</span> <span class=\"operator\">*</span>)keyPath observer:(__weak <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>)observer;</span><br></pre></td></tr></table></figure>\n\n<p>其实，看到这里你会认为这里只是调用了一个方法创建了一个 Signal，而且这个 Signal 也并不属于任何对象。我们再来看看具体的实现是怎么样的？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>)rac_valuesAndChangesForKeyPath:(<span class=\"type\">NSString</span> <span class=\"operator\">*</span>)keyPath options:(<span class=\"type\">NSKeyValueObservingOptions</span>)options observer:(__weak <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>)weakObserver &#123;</span><br><span class=\"line\">    <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>strongObserver <span class=\"operator\">=</span> weakObserver;</span><br><span class=\"line\">    keyPath <span class=\"operator\">=</span> [keyPath copy];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">NSRecursiveLock</span> <span class=\"operator\">*</span>objectLock <span class=\"operator\">=</span> [[<span class=\"type\">NSRecursiveLock</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    objectLock.name <span class=\"operator\">=</span> @<span class=\"string\">&quot;org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    __weak <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>weakSelf <span class=\"operator\">=</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>deallocSignal <span class=\"operator\">=</span> [[<span class=\"type\">RACSignal</span> zip:@[</span><br><span class=\"line\">                            <span class=\"keyword\">self</span>.rac_willDeallocSignal,</span><br><span class=\"line\">                            strongObserver.rac_willDeallocSignal <span class=\"operator\">?</span>: [<span class=\"type\">RACSignal</span> never]</span><br><span class=\"line\">    ]] doCompleted:<span class=\"operator\">^</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Forces deallocation to wait if the object variables are currently</span></span><br><span class=\"line\">        <span class=\"comment\">// being read on another thread.</span></span><br><span class=\"line\">        [objectLock lock];</span><br><span class=\"line\">        <span class=\"meta\">@onExit</span> &#123;</span><br><span class=\"line\">            [objectLock unlock];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[[<span class=\"type\">RACSignal</span> createSignal:<span class=\"operator\">^</span> <span class=\"type\">RACDisposable</span> <span class=\"operator\">*</span> (id<span class=\"operator\">&lt;</span><span class=\"type\">RACSubscriber</span><span class=\"operator\">&gt;</span> subscriber) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Hold onto the lock the whole time we&#x27;re setting up the KVO</span></span><br><span class=\"line\">        <span class=\"comment\">// observation, because any resurrection that might be caused by our</span></span><br><span class=\"line\">        <span class=\"comment\">// retaining below must be balanced out by the time -dealloc returns</span></span><br><span class=\"line\">        <span class=\"comment\">// (if another thread is waiting on the lock above).</span></span><br><span class=\"line\">        [objectLock lock];</span><br><span class=\"line\">        <span class=\"meta\">@onExit</span> &#123;</span><br><span class=\"line\">            [objectLock unlock];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">        __strong <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>observer __attribute__((objc_precise_lifetime)) <span class=\"operator\">=</span> weakObserver;</span><br><span class=\"line\">        __strong <span class=\"type\">NSObject</span> <span class=\"operator\">*</span><span class=\"keyword\">self</span> __attribute__((objc_precise_lifetime)) <span class=\"operator\">=</span> weakSelf;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> <span class=\"operator\">==</span> <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">            [subscriber sendCompleted];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> rac_observeKeyPath:keyPath options:options observer:observer block:<span class=\"operator\">^</span>(id value, <span class=\"type\">NSDictionary</span> <span class=\"operator\">*</span>change, <span class=\"type\">BOOL</span> causedByDealloc, <span class=\"type\">BOOL</span> affectedOnlyLastComponent) &#123;</span><br><span class=\"line\">                [subscriber sendNext:<span class=\"type\">RACTuplePack</span>(value, change)];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;] takeUntil:deallocSignal] setNameWithFormat:@<span class=\"string\">&quot;%@ -rac_valueAndChangesForKeyPath: %@ options: %lu observer: %@&quot;</span>, <span class=\"keyword\">self</span>.rac_description, keyPath, (unsigned long)options, strongObserver.rac_description];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重点观察 <strong>deallocSignal</strong> 和 **[signal takeUntile:deallocSignal]**，我们把 deallocSignal 单独拿出来看看：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>deallocSignal <span class=\"operator\">=</span> [[<span class=\"type\">RACSignal</span> zip:@[</span><br><span class=\"line\">                        <span class=\"keyword\">self</span>.rac_willDeallocSignal,</span><br><span class=\"line\">                        strongObserver.rac_willDeallocSignal <span class=\"operator\">?</span>: [<span class=\"type\">RACSignal</span> never]</span><br><span class=\"line\">                        ]] doCompleted:<span class=\"operator\">^</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Forces deallocation to wait if the object variables are currently</span></span><br><span class=\"line\">    <span class=\"comment\">// being read on another thread.</span></span><br><span class=\"line\">    [objectLock lock];</span><br><span class=\"line\">    <span class=\"meta\">@onExit</span> &#123;</span><br><span class=\"line\">    [objectLock unlock];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>这里的 deallocSignal 是只有在 self 和 strongObserve 都将要发生 dealloc 的时候才会触发的。即用 RACObserve 创建的信号只有在其 target 和 observe 都发生 dealloc 的时候才会被 disposable (这个好像是 RAC 用来销毁自己资源的东西)。不明白的童鞋，我们回头来分析一下场景4的代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 场景4</span></span><br><span class=\"line\">[<span class=\"type\">RACObserve</span>(<span class=\"keyword\">self</span>.viewModel, title) subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>用 RACObserve 创建的信号看起来只要出了函数体其资源应该就会被回收，但是这个信号其实是只有在 self.viewModel.rac_willDeallocSignal 和 self.rac_willDeallocSignal 都发生的情况下才会被释放。所以场景4的引用关系看起来只有 signal-&gt;block-&gt;self，但是这个 signal 只有在 self.rac_willDeallocSignal 的时候才会被释放。所以这里如果不打断这种关系的话就会造成循环引用的问题，正确做法应该是：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 场景4</span></span><br><span class=\"line\"><span class=\"meta\">@weakify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">[<span class=\"type\">RACObserve</span>(<span class=\"keyword\">self</span>.viewModel, title) subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@strongify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>最后，在说一个特别需要注意的，就是 UITableViewCell 和 UICollectionViewCell 复用和 RAC 的问题。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">NSInteger</span>)tableView:(nonnull <span class=\"type\">UITableView</span> <span class=\"operator\">*</span>)tableView numberOfRowsInSection:(<span class=\"type\">NSInteger</span>)section &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">UITableViewCell</span> <span class=\"operator\">*</span>)tableView:(nonnull <span class=\"type\">UITableView</span> <span class=\"operator\">*</span>)tableView cellForRowAtIndexPath:(nonnull <span class=\"type\">NSIndexPath</span> <span class=\"operator\">*</span>)indexPath &#123;</span><br><span class=\"line\">    <span class=\"type\">UITableViewCell</span> <span class=\"operator\">*</span> cell <span class=\"operator\">=</span> [tableView dequeueReusableCellWithIdentifier:@<span class=\"string\">&quot;TableViewCell&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@weakify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    [<span class=\"type\">RACObserve</span>(cell.textLabel, text) subscribeNext:<span class=\"operator\">^</span>(id x) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@strongify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(@<span class=\"string\">&quot;%@&quot;</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们看到这里的 RACObserve 创建的 Signal 和 self 之间已经去掉了循环引用的问题，所以应该是没有什么问题的。但是结合之前我们对 RACObserve 的理解再仔细分析一下，这里的 Signal 只要 self 没有被 dealloc 的话就不会被释放。虽然每次 UITableViewCell 都会被重用，但是每次重用过程中创建的信号确实无法被 disposable。那我们该怎么做呢？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">NSInteger</span>)tableView:(nonnull <span class=\"type\">UITableView</span> <span class=\"operator\">*</span>)tableView numberOfRowsInSection:(<span class=\"type\">NSInteger</span>)section &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">UITableViewCell</span> <span class=\"operator\">*</span>)tableView:(nonnull <span class=\"type\">UITableView</span> <span class=\"operator\">*</span>)tableView cellForRowAtIndexPath:(nonnull <span class=\"type\">NSIndexPath</span> <span class=\"operator\">*</span>)indexPath &#123;</span><br><span class=\"line\">    <span class=\"type\">UITableViewCell</span> <span class=\"operator\">*</span> cell <span class=\"operator\">=</span> [tableView dequeueReusableCellWithIdentifier:@<span class=\"string\">&quot;TableViewCell&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@weakify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    [[<span class=\"type\">RACObserve</span>(cell.textLabel, text) takeUntil:cell.rac_prepareForReuseSignal] subscribeNext:<span class=\"operator\">^</span>(id x) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@strongify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(@<span class=\"string\">&quot;%@&quot;</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，我们在cell里面创建的信号加上 takeUntil:cell.rac_prepareForReuseSignal，这个是让 cell 在每次重用的时候都去 disposable 创建的信号。</p>\n<p>以上所说的关于内存的东西我都用 Instrument 的 Allocations 验证过了，但是依旧建议大家自己也去试试。</p>\n"},{"title":"Shell Tip","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n> 记录日常中用到的一些 Bash 脚本，经常更新\n\n## Tip 1 : 修改文件里面的内容\n早上产品有一个小需求就是把工程中的所有网页的标题修改为黑米流量通，可以使用以下命令来实现\n\n```sh\n$ find . -name '*.html' -print0 | xargs -0 sed -i '' -e 's/<title>.*<\\/title>/<title>黑米流量通<\\/title>/g'\n```\n\n* `find`          查找命令，可以用 man find 查看更多的信息\n* `.`             代表当前目录\n* `-name`         find 命令的参数，表示要查找的文件名\n* `-print0`       是一种不换行的输出格式，以 ASCII NUL 字符（也就是\\0）作为分隔符。上面的例子可能是 `a.html\\0b.html\\0c.html`\n* `|`             这是一个管道符，表示把前面命令的输出作为后面命令的输入\n* `xargs`         是用来构造输入参数，并且循环执行每一个参数\n* `-0`            表示让 xargs 使用 ASCII NUL 来分隔参数。上面的例子将被分隔成 `a.html` `b.html` `c.html` 三个参数依次执行\n* `sed`           这是一个流编辑器，如果传的是文件名会把文件内容读入内存，如果只是普通字符串就会把字符串读入内存\n* `-i`            表示要把原来的文件内容做一次备份，后面的 `''` 是表示要备份的文件名字，如果没有文件名字就表示不需要备份\n* `-e`            表示后面的字符串是一个命令，需要被执行\n* `s/old/new/g`   这个是用来替换字符串的命令\n\n## Tip 2 : 查找文件的内容\n把匹配的文件内容的相关文件列出来\n\n```sh\n$ find . -name '*.html' -print0 | xargs -0 grep 'PATTERN'\n```\n\n## Tip 3 : 解决 Homebrew 的权限问题\n查看 Homebrew 的所有权\n\n```sh\n$ ls -al `which brew`\n```\n\n把 Homebrew 的用户和分组修改为 root 和 wheel\n\n```sh\n$ sudo chown root:wheel `which brew`\n```\n\n最后还原 Homebrew 的权限（安全）\n\n```sh\n$ sudo chown : `chown brew`\n```\n\n## Tip 4 : 利用 Shell 生成生成 ICON\n\n```sh\n#!/bin/sh\n#此脚本是用来生成 iPhone 和 iPad 所需 icon 的不同尺寸的，最好是准备一张 1024x1024 的 Icon 图片\n\n\nfilename=\"icon.png\"\n\ndirname=\"icon\"\n\nname_array=(\"Icon-20.png\" \"Icon-20@2x.png\" \"Icon-20@3x.png\"\n\"Icon-29.png\" \"Icon-29@2x.png\" \"Icon-29@3x.png\"\n\"Icon-40.png\" \"Icon-40@2x.png\" \"Icon-40@3x.png\"\n\"Icon-60@2x.png\" \"Icon-60@3x.png\"\n\"Icon-76.png\" \"Icon-76@2x.png\"\n\"Icon-83.5@2x.png\")\nsize_array=(\"20\" \"40\" \"60\"\n\"29\" \"58\" \"87\"\n\"40\" \"80\" \"120\"\n\"120\" \"180\"\n\"76\" \"152\"\n\"167\")\n\nmkdir $dirname\n\nfor ((i=0;i<${#name_array[@]};++i)); do\n    m_dir=$dirname/${name_array[i]}\n    cp $filename $m_dir\n    sips -Z ${size_array[i]} $m_dir\n# 如果图片是 sRGB 的话，使用下面的命令\n#    sips --matchTo '/System/Library/ColorSync/Profiles/sRGB Profile.icc' -Z ${size_array[i]} $m_dir \ndone\n```\n\n## Tip5 : 使用 Python 共享当前目录\n\n利用下面的命令可以暂时开启一个端口号为 8000 的 HTTP 服务，其他人只需要在浏览器输入 `http://ip-address:8000` 即可浏览共享目录下的文件\n\n```sh\n$ python -m SimpleHTTPServer\n```\n\n\n## Tip6 : 加密和解密文件\n\n* 加密\n\n```sh\n$ tar czf - {SRC_DIR} | openssl des3 -salt -k \"{KEY}\" -out {DIST_PACKAGE}.tar.gz\n```\n\n示例：\n\n目录名 `paris_code`，秘钥 `meta#com`，输出包 `paris_code_20161008.tar.gz`\n\n```sh\n$ tar czf - paris_code | openssl des3 -salt -k \"meta#com\" -out paris_code_20161008.tar.gz\n```\n\n* 解密\n\n第一步：获取代码压缩文件包\n\n下载地址 `http://XXXX.com/paris_code_20161008.tar.gz`\n\n第二步：解密文件（OS X / Linux only）\n\n在 Terminal 进入压缩文件包同级目录，输入以下命令：\n\n```sh\n$ openssl des3 -d -k \"meta#com\" -salt -in paris_code_20161008.tar.gz | tar xzf -\n```\n\n## Tip7: iOS 打包命令\n\n```sh\necho \"----------------\"\necho \"Begin Build!\"\nPROJECT_NAME=\"orbit\"\nBUILD_DATE=\"$(date +'%Y%m%d')\"\nBUNDLE_ID=\"com.meta.paris\"\ncd ${WORKSPACE}\n\n#/usr/local/bin/npm install\n\nif [ -d \"${WORKSPACE}/build\" ]; then \n    if ls ${WORKSPACE}/build/**/*.ipa 1> /dev/null 2>&1; then\n        rm -rf ${WORKSPACE}/build/**/*.ipa; \n    fi;\n    if ls ${WORKSPACE}/build/**/*.xcarchive 1> /dev/null 2>&1; then\n        rm -rf ${WORKSPACE}/build/**/*.xcarchive; \n    fi;\nelse \n    mkdir ${WORKSPACE}/build; \nfi;\n\necho \"计算今天的 Build Version\"\nif [ -d \"${WORKSPACE}/build/${BUILD_DATE}\" ]; then \n   #如果不加上面的 if, Jenkins 无法直接执行下面的命令❓\n\tBUILD_DATE_COUNT=$(ls ${WORKSPACE}/build | grep \"^${BUILD_DATE}\" -c)\n    if [ ${BUILD_DATE_COUNT} -lt 10 ]; then\n        BUILD_DATE_COUNT=\"0${BUILD_DATE_COUNT}\"\n    fi;\n\tBUILD_VERSION=\"${BUILD_DATE}${BUILD_DATE_COUNT}\"\nelse \n  \tBUILD_VERSION=${BUILD_DATE}\nfi;\necho \"今天的 Build Version 是 ${BUILD_VERSION}\"\n\nif [ -d \"${WORKSPACE}/build/${BUILD_VERSION}\" ]; then \n    rm -rf ${WORKSPACE}/build/${BUILD_VERSION}; \nfi;\nmkdir ${WORKSPACE}/build/${BUILD_VERSION};\n\nif [ -d \"${WORKSPACE}/Enterprise.plist\" ]; then\n    rm ${WORKSPACE}/Enterprise.plist; \nfi;\n\n#http://www.matrixprojects.net/p/xcodebuild-export-options-plist/\nEnterprise='<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n        <key>teamID</key>\n        <string></string>\n        <key>method</key>\n        <string>app-store</string>\n        <key>uploadSymbols</key>\n        <true/>\n        <key>uploadBitcode</key>\n        <false/>\n</dict>\n</plist>'\necho ${Enterprise} > ${WORKSPACE}/Enterprise.plist\n\nsed -i '' 's/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g' \\\n${WORKSPACE}/${PROJECT_NAME}.xcodeproj/project.pbxproj\n\nsed -i '' 's/DEVELOPMENT_TEAM = .*;/DEVELOPMENT_TEAM = \"\";/g' \\\n${WORKSPACE}/${PROJECT_NAME}.xcodeproj/project.pbxproj\n\n#动态生成 Build Version\nsed -i '' \"/<key>CFBundleVersion<\\/key>/{N;s/<string>.*<\\/string>/<string>${BUILD_VERSION}<\\/string>/g;}\" \\\n${WORKSPACE}/${PROJECT_NAME}/${PROJECT_NAME}-Info.plist\n\nxcodebuild -workspace ${WORKSPACE}/${PROJECT_NAME}.xcworkspace \\\n-scheme ${PROJECT_NAME} -sdk iphoneos \\\nbuild CODE_SIGN_IDENTITY=\"iPhone Distribution: Beijing PS Technology Co., Ltd.\" \\\nPROVISIONING_PROFILE=\"\" \\\n-configuration Release clean archive \\\n-archivePath ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.xcarchive\n\nxcodebuild -exportArchive -exportOptionsPlist ${WORKSPACE}/Enterprise.plist \\\n-archivePath ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.xcarchive \\\n-exportPath ${WORKSPACE}/build/${BUILD_VERSION}/\n\necho \"----------------\"\necho \"Build successfully!\"\n\n\necho \"Begin Upload to itunes...\"\n#Use [shenzhen](https://github.com/nomad/shenzhen) to upload the ipa file to itunes connect.\n/usr/local/bin/ipa distribute:itunesconnect -f ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.ipa -a YourAppleID -p YourPassword -i ${BUNDLE_ID} --upload\necho \"Upload successfully!\"\n```\n\n\n## Tip8: 重置 iOS 模拟器\n\n相信各位在做 iOS 开发的同学都会碰到模拟器上各种神奇的现象，通过重置 iOS 模拟器基本上可以解决大部分问题：\n\n```Sh\n// 退出当前的所有模拟器\n$ osascript -e 'tell application \"iOS Simulator\" to quit'\n$ osascript -e 'tell application \"Simulator\" to quit'\n\n// 清掉之前使用模拟器产生的所有内容\n$ xcrun simctl erase all\n```\n\n## Tip9: 模拟器截图\n\n下面的命令会默认截取第一个启动的模拟器：\n\n```Sh\nxcrun simctl io booted screenshot screenshot.png\n```\n\n当你同时启动了多个模拟器的情况下，需要先查看当前启动的模拟器 ID，然后指定 ID 截图：\n\n```Sh\nxcrun simctl list\nxcrun simctl io B5EEDDC0-CDA3-46A9-A2B6-FA940D693DFC screenshot screenshot.png\n```","source":"_posts/Shell-Tip.md","raw":"---\ntitle: Shell Tip\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: 技术\ntags: [tip] \n---\n\n> 记录日常中用到的一些 Bash 脚本，经常更新\n\n## Tip 1 : 修改文件里面的内容\n早上产品有一个小需求就是把工程中的所有网页的标题修改为黑米流量通，可以使用以下命令来实现\n\n```sh\n$ find . -name '*.html' -print0 | xargs -0 sed -i '' -e 's/<title>.*<\\/title>/<title>黑米流量通<\\/title>/g'\n```\n\n* `find`          查找命令，可以用 man find 查看更多的信息\n* `.`             代表当前目录\n* `-name`         find 命令的参数，表示要查找的文件名\n* `-print0`       是一种不换行的输出格式，以 ASCII NUL 字符（也就是\\0）作为分隔符。上面的例子可能是 `a.html\\0b.html\\0c.html`\n* `|`             这是一个管道符，表示把前面命令的输出作为后面命令的输入\n* `xargs`         是用来构造输入参数，并且循环执行每一个参数\n* `-0`            表示让 xargs 使用 ASCII NUL 来分隔参数。上面的例子将被分隔成 `a.html` `b.html` `c.html` 三个参数依次执行\n* `sed`           这是一个流编辑器，如果传的是文件名会把文件内容读入内存，如果只是普通字符串就会把字符串读入内存\n* `-i`            表示要把原来的文件内容做一次备份，后面的 `''` 是表示要备份的文件名字，如果没有文件名字就表示不需要备份\n* `-e`            表示后面的字符串是一个命令，需要被执行\n* `s/old/new/g`   这个是用来替换字符串的命令\n\n## Tip 2 : 查找文件的内容\n把匹配的文件内容的相关文件列出来\n\n```sh\n$ find . -name '*.html' -print0 | xargs -0 grep 'PATTERN'\n```\n\n## Tip 3 : 解决 Homebrew 的权限问题\n查看 Homebrew 的所有权\n\n```sh\n$ ls -al `which brew`\n```\n\n把 Homebrew 的用户和分组修改为 root 和 wheel\n\n```sh\n$ sudo chown root:wheel `which brew`\n```\n\n最后还原 Homebrew 的权限（安全）\n\n```sh\n$ sudo chown : `chown brew`\n```\n\n## Tip 4 : 利用 Shell 生成生成 ICON\n\n```sh\n#!/bin/sh\n#此脚本是用来生成 iPhone 和 iPad 所需 icon 的不同尺寸的，最好是准备一张 1024x1024 的 Icon 图片\n\n\nfilename=\"icon.png\"\n\ndirname=\"icon\"\n\nname_array=(\"Icon-20.png\" \"Icon-20@2x.png\" \"Icon-20@3x.png\"\n\"Icon-29.png\" \"Icon-29@2x.png\" \"Icon-29@3x.png\"\n\"Icon-40.png\" \"Icon-40@2x.png\" \"Icon-40@3x.png\"\n\"Icon-60@2x.png\" \"Icon-60@3x.png\"\n\"Icon-76.png\" \"Icon-76@2x.png\"\n\"Icon-83.5@2x.png\")\nsize_array=(\"20\" \"40\" \"60\"\n\"29\" \"58\" \"87\"\n\"40\" \"80\" \"120\"\n\"120\" \"180\"\n\"76\" \"152\"\n\"167\")\n\nmkdir $dirname\n\nfor ((i=0;i<${#name_array[@]};++i)); do\n    m_dir=$dirname/${name_array[i]}\n    cp $filename $m_dir\n    sips -Z ${size_array[i]} $m_dir\n# 如果图片是 sRGB 的话，使用下面的命令\n#    sips --matchTo '/System/Library/ColorSync/Profiles/sRGB Profile.icc' -Z ${size_array[i]} $m_dir \ndone\n```\n\n## Tip5 : 使用 Python 共享当前目录\n\n利用下面的命令可以暂时开启一个端口号为 8000 的 HTTP 服务，其他人只需要在浏览器输入 `http://ip-address:8000` 即可浏览共享目录下的文件\n\n```sh\n$ python -m SimpleHTTPServer\n```\n\n\n## Tip6 : 加密和解密文件\n\n* 加密\n\n```sh\n$ tar czf - {SRC_DIR} | openssl des3 -salt -k \"{KEY}\" -out {DIST_PACKAGE}.tar.gz\n```\n\n示例：\n\n目录名 `paris_code`，秘钥 `meta#com`，输出包 `paris_code_20161008.tar.gz`\n\n```sh\n$ tar czf - paris_code | openssl des3 -salt -k \"meta#com\" -out paris_code_20161008.tar.gz\n```\n\n* 解密\n\n第一步：获取代码压缩文件包\n\n下载地址 `http://XXXX.com/paris_code_20161008.tar.gz`\n\n第二步：解密文件（OS X / Linux only）\n\n在 Terminal 进入压缩文件包同级目录，输入以下命令：\n\n```sh\n$ openssl des3 -d -k \"meta#com\" -salt -in paris_code_20161008.tar.gz | tar xzf -\n```\n\n## Tip7: iOS 打包命令\n\n```sh\necho \"----------------\"\necho \"Begin Build!\"\nPROJECT_NAME=\"orbit\"\nBUILD_DATE=\"$(date +'%Y%m%d')\"\nBUNDLE_ID=\"com.meta.paris\"\ncd ${WORKSPACE}\n\n#/usr/local/bin/npm install\n\nif [ -d \"${WORKSPACE}/build\" ]; then \n    if ls ${WORKSPACE}/build/**/*.ipa 1> /dev/null 2>&1; then\n        rm -rf ${WORKSPACE}/build/**/*.ipa; \n    fi;\n    if ls ${WORKSPACE}/build/**/*.xcarchive 1> /dev/null 2>&1; then\n        rm -rf ${WORKSPACE}/build/**/*.xcarchive; \n    fi;\nelse \n    mkdir ${WORKSPACE}/build; \nfi;\n\necho \"计算今天的 Build Version\"\nif [ -d \"${WORKSPACE}/build/${BUILD_DATE}\" ]; then \n   #如果不加上面的 if, Jenkins 无法直接执行下面的命令❓\n\tBUILD_DATE_COUNT=$(ls ${WORKSPACE}/build | grep \"^${BUILD_DATE}\" -c)\n    if [ ${BUILD_DATE_COUNT} -lt 10 ]; then\n        BUILD_DATE_COUNT=\"0${BUILD_DATE_COUNT}\"\n    fi;\n\tBUILD_VERSION=\"${BUILD_DATE}${BUILD_DATE_COUNT}\"\nelse \n  \tBUILD_VERSION=${BUILD_DATE}\nfi;\necho \"今天的 Build Version 是 ${BUILD_VERSION}\"\n\nif [ -d \"${WORKSPACE}/build/${BUILD_VERSION}\" ]; then \n    rm -rf ${WORKSPACE}/build/${BUILD_VERSION}; \nfi;\nmkdir ${WORKSPACE}/build/${BUILD_VERSION};\n\nif [ -d \"${WORKSPACE}/Enterprise.plist\" ]; then\n    rm ${WORKSPACE}/Enterprise.plist; \nfi;\n\n#http://www.matrixprojects.net/p/xcodebuild-export-options-plist/\nEnterprise='<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n        <key>teamID</key>\n        <string></string>\n        <key>method</key>\n        <string>app-store</string>\n        <key>uploadSymbols</key>\n        <true/>\n        <key>uploadBitcode</key>\n        <false/>\n</dict>\n</plist>'\necho ${Enterprise} > ${WORKSPACE}/Enterprise.plist\n\nsed -i '' 's/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g' \\\n${WORKSPACE}/${PROJECT_NAME}.xcodeproj/project.pbxproj\n\nsed -i '' 's/DEVELOPMENT_TEAM = .*;/DEVELOPMENT_TEAM = \"\";/g' \\\n${WORKSPACE}/${PROJECT_NAME}.xcodeproj/project.pbxproj\n\n#动态生成 Build Version\nsed -i '' \"/<key>CFBundleVersion<\\/key>/{N;s/<string>.*<\\/string>/<string>${BUILD_VERSION}<\\/string>/g;}\" \\\n${WORKSPACE}/${PROJECT_NAME}/${PROJECT_NAME}-Info.plist\n\nxcodebuild -workspace ${WORKSPACE}/${PROJECT_NAME}.xcworkspace \\\n-scheme ${PROJECT_NAME} -sdk iphoneos \\\nbuild CODE_SIGN_IDENTITY=\"iPhone Distribution: Beijing PS Technology Co., Ltd.\" \\\nPROVISIONING_PROFILE=\"\" \\\n-configuration Release clean archive \\\n-archivePath ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.xcarchive\n\nxcodebuild -exportArchive -exportOptionsPlist ${WORKSPACE}/Enterprise.plist \\\n-archivePath ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.xcarchive \\\n-exportPath ${WORKSPACE}/build/${BUILD_VERSION}/\n\necho \"----------------\"\necho \"Build successfully!\"\n\n\necho \"Begin Upload to itunes...\"\n#Use [shenzhen](https://github.com/nomad/shenzhen) to upload the ipa file to itunes connect.\n/usr/local/bin/ipa distribute:itunesconnect -f ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.ipa -a YourAppleID -p YourPassword -i ${BUNDLE_ID} --upload\necho \"Upload successfully!\"\n```\n\n\n## Tip8: 重置 iOS 模拟器\n\n相信各位在做 iOS 开发的同学都会碰到模拟器上各种神奇的现象，通过重置 iOS 模拟器基本上可以解决大部分问题：\n\n```Sh\n// 退出当前的所有模拟器\n$ osascript -e 'tell application \"iOS Simulator\" to quit'\n$ osascript -e 'tell application \"Simulator\" to quit'\n\n// 清掉之前使用模拟器产生的所有内容\n$ xcrun simctl erase all\n```\n\n## Tip9: 模拟器截图\n\n下面的命令会默认截取第一个启动的模拟器：\n\n```Sh\nxcrun simctl io booted screenshot screenshot.png\n```\n\n当你同时启动了多个模拟器的情况下，需要先查看当前启动的模拟器 ID，然后指定 ID 截图：\n\n```Sh\nxcrun simctl list\nxcrun simctl io B5EEDDC0-CDA3-46A9-A2B6-FA940D693DFC screenshot screenshot.png\n```","slug":"Shell-Tip","published":1,"updated":"2022-04-20T07:08:33.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxe6000e6enq0kwu1ztj","content":"<blockquote>\n<p>记录日常中用到的一些 Bash 脚本，经常更新</p>\n</blockquote>\n<h2 id=\"Tip-1-修改文件里面的内容\"><a href=\"#Tip-1-修改文件里面的内容\" class=\"headerlink\" title=\"Tip 1 : 修改文件里面的内容\"></a>Tip 1 : 修改文件里面的内容</h2><p>早上产品有一个小需求就是把工程中的所有网页的标题修改为黑米流量通，可以使用以下命令来实现</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ find . -name <span class=\"string\">&#x27;*.html&#x27;</span> -print0 | xargs -0 sed -i <span class=\"string\">&#x27;&#x27;</span> -e <span class=\"string\">&#x27;s/&lt;title&gt;.*&lt;\\/title&gt;/&lt;title&gt;黑米流量通&lt;\\/title&gt;/g&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>find</code>          查找命令，可以用 man find 查看更多的信息</li>\n<li><code>.</code>             代表当前目录</li>\n<li><code>-name</code>         find 命令的参数，表示要查找的文件名</li>\n<li><code>-print0</code>       是一种不换行的输出格式，以 ASCII NUL 字符（也就是\\0）作为分隔符。上面的例子可能是 <code>a.html\\0b.html\\0c.html</code></li>\n<li><code>|</code>             这是一个管道符，表示把前面命令的输出作为后面命令的输入</li>\n<li><code>xargs</code>         是用来构造输入参数，并且循环执行每一个参数</li>\n<li><code>-0</code>            表示让 xargs 使用 ASCII NUL 来分隔参数。上面的例子将被分隔成 <code>a.html</code> <code>b.html</code> <code>c.html</code> 三个参数依次执行</li>\n<li><code>sed</code>           这是一个流编辑器，如果传的是文件名会把文件内容读入内存，如果只是普通字符串就会把字符串读入内存</li>\n<li><code>-i</code>            表示要把原来的文件内容做一次备份，后面的 <code>&#39;&#39;</code> 是表示要备份的文件名字，如果没有文件名字就表示不需要备份</li>\n<li><code>-e</code>            表示后面的字符串是一个命令，需要被执行</li>\n<li><code>s/old/new/g</code>   这个是用来替换字符串的命令</li>\n</ul>\n<h2 id=\"Tip-2-查找文件的内容\"><a href=\"#Tip-2-查找文件的内容\" class=\"headerlink\" title=\"Tip 2 : 查找文件的内容\"></a>Tip 2 : 查找文件的内容</h2><p>把匹配的文件内容的相关文件列出来</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ find . -name <span class=\"string\">&#x27;*.html&#x27;</span> -print0 | xargs -0 grep <span class=\"string\">&#x27;PATTERN&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip-3-解决-Homebrew-的权限问题\"><a href=\"#Tip-3-解决-Homebrew-的权限问题\" class=\"headerlink\" title=\"Tip 3 : 解决 Homebrew 的权限问题\"></a>Tip 3 : 解决 Homebrew 的权限问题</h2><p>查看 Homebrew 的所有权</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">ls</span> -al `<span class=\"built_in\">which</span> brew`</span><br></pre></td></tr></table></figure>\n\n<p>把 Homebrew 的用户和分组修改为 root 和 wheel</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo <span class=\"built_in\">chown</span> root:wheel `<span class=\"built_in\">which</span> brew`</span><br></pre></td></tr></table></figure>\n\n<p>最后还原 Homebrew 的权限（安全）</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo <span class=\"built_in\">chown</span> : `<span class=\"built_in\">chown</span> brew`</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip-4-利用-Shell-生成生成-ICON\"><a href=\"#Tip-4-利用-Shell-生成生成-ICON\" class=\"headerlink\" title=\"Tip 4 : 利用 Shell 生成生成 ICON\"></a>Tip 4 : 利用 Shell 生成生成 ICON</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"comment\">#此脚本是用来生成 iPhone 和 iPad 所需 icon 的不同尺寸的，最好是准备一张 1024x1024 的 Icon 图片</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">filename=<span class=\"string\">&quot;icon.png&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">dirname</span>=<span class=\"string\">&quot;icon&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">name_array=(<span class=\"string\">&quot;Icon-20.png&quot;</span> <span class=\"string\">&quot;Icon-20@2x.png&quot;</span> <span class=\"string\">&quot;Icon-20@3x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-29.png&quot;</span> <span class=\"string\">&quot;Icon-29@2x.png&quot;</span> <span class=\"string\">&quot;Icon-29@3x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-40.png&quot;</span> <span class=\"string\">&quot;Icon-40@2x.png&quot;</span> <span class=\"string\">&quot;Icon-40@3x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-60@2x.png&quot;</span> <span class=\"string\">&quot;Icon-60@3x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-76.png&quot;</span> <span class=\"string\">&quot;Icon-76@2x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-83.5@2x.png&quot;</span>)</span><br><span class=\"line\">size_array=(<span class=\"string\">&quot;20&quot;</span> <span class=\"string\">&quot;40&quot;</span> <span class=\"string\">&quot;60&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;29&quot;</span> <span class=\"string\">&quot;58&quot;</span> <span class=\"string\">&quot;87&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;40&quot;</span> <span class=\"string\">&quot;80&quot;</span> <span class=\"string\">&quot;120&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;120&quot;</span> <span class=\"string\">&quot;180&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;76&quot;</span> <span class=\"string\">&quot;152&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;167&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> <span class=\"variable\">$dirname</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> ((i=0;i&lt;<span class=\"variable\">$&#123;#name_array[@]&#125;</span>;++i)); <span class=\"keyword\">do</span></span><br><span class=\"line\">    m_dir=<span class=\"variable\">$dirname</span>/<span class=\"variable\">$&#123;name_array[i]&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">cp</span> <span class=\"variable\">$filename</span> <span class=\"variable\">$m_dir</span></span><br><span class=\"line\">    sips -Z <span class=\"variable\">$&#123;size_array[i]&#125;</span> <span class=\"variable\">$m_dir</span></span><br><span class=\"line\"><span class=\"comment\"># 如果图片是 sRGB 的话，使用下面的命令</span></span><br><span class=\"line\"><span class=\"comment\">#    sips --matchTo &#x27;/System/Library/ColorSync/Profiles/sRGB Profile.icc&#x27; -Z $&#123;size_array[i]&#125; $m_dir </span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip5-使用-Python-共享当前目录\"><a href=\"#Tip5-使用-Python-共享当前目录\" class=\"headerlink\" title=\"Tip5 : 使用 Python 共享当前目录\"></a>Tip5 : 使用 Python 共享当前目录</h2><p>利用下面的命令可以暂时开启一个端口号为 8000 的 HTTP 服务，其他人只需要在浏览器输入 <code>http://ip-address:8000</code> 即可浏览共享目录下的文件</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Tip6-加密和解密文件\"><a href=\"#Tip6-加密和解密文件\" class=\"headerlink\" title=\"Tip6 : 加密和解密文件\"></a>Tip6 : 加密和解密文件</h2><ul>\n<li>加密</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar czf - &#123;SRC_DIR&#125; | openssl des3 -salt -k <span class=\"string\">&quot;&#123;KEY&#125;&quot;</span> -out &#123;DIST_PACKAGE&#125;.tar.gz</span><br></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<p>目录名 <code>paris_code</code>，秘钥 <code>meta#com</code>，输出包 <code>paris_code_20161008.tar.gz</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar czf - paris_code | openssl des3 -salt -k <span class=\"string\">&quot;meta#com&quot;</span> -out paris_code_20161008.tar.gz</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>解密</li>\n</ul>\n<p>第一步：获取代码压缩文件包</p>\n<p>下载地址 <code>http://XXXX.com/paris_code_20161008.tar.gz</code></p>\n<p>第二步：解密文件（OS X &#x2F; Linux only）</p>\n<p>在 Terminal 进入压缩文件包同级目录，输入以下命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ openssl des3 -d -k <span class=\"string\">&quot;meta#com&quot;</span> -salt -<span class=\"keyword\">in</span> paris_code_20161008.tar.gz | tar xzf -</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip7-iOS-打包命令\"><a href=\"#Tip7-iOS-打包命令\" class=\"headerlink\" title=\"Tip7: iOS 打包命令\"></a>Tip7: iOS 打包命令</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;----------------&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Begin Build!&quot;</span></span><br><span class=\"line\">PROJECT_NAME=<span class=\"string\">&quot;orbit&quot;</span></span><br><span class=\"line\">BUILD_DATE=<span class=\"string\">&quot;<span class=\"subst\">$(date +&#x27;%Y%m%d&#x27;)</span>&quot;</span></span><br><span class=\"line\">BUNDLE_ID=<span class=\"string\">&quot;com.meta.paris&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#/usr/local/bin/npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build&quot;</span> ]; <span class=\"keyword\">then</span> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">ls</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/**/*.ipa 1&gt; /dev/null 2&gt;&amp;1; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">rm</span> -rf <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/**/*.ipa; </span><br><span class=\"line\">    <span class=\"keyword\">fi</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">ls</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/**/*.xcarchive 1&gt; /dev/null 2&gt;&amp;1; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">rm</span> -rf <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/**/*.xcarchive; </span><br><span class=\"line\">    <span class=\"keyword\">fi</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">    <span class=\"built_in\">mkdir</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build; </span><br><span class=\"line\"><span class=\"keyword\">fi</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;计算今天的 Build Version&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_DATE&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span> </span><br><span class=\"line\">   <span class=\"comment\">#如果不加上面的 if, Jenkins 无法直接执行下面的命令❓</span></span><br><span class=\"line\">\tBUILD_DATE_COUNT=$(<span class=\"built_in\">ls</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build | grep <span class=\"string\">&quot;^<span class=\"variable\">$&#123;BUILD_DATE&#125;</span>&quot;</span> -c)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"variable\">$&#123;BUILD_DATE_COUNT&#125;</span> -lt 10 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">        BUILD_DATE_COUNT=<span class=\"string\">&quot;0<span class=\"variable\">$&#123;BUILD_DATE_COUNT&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span>;</span><br><span class=\"line\">\tBUILD_VERSION=<span class=\"string\">&quot;<span class=\"variable\">$&#123;BUILD_DATE&#125;</span><span class=\"variable\">$&#123;BUILD_DATE_COUNT&#125;</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">  \tBUILD_VERSION=<span class=\"variable\">$&#123;BUILD_DATE&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span>;</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;今天的 Build Version 是 <span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span> </span><br><span class=\"line\">    <span class=\"built_in\">rm</span> -rf <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>; </span><br><span class=\"line\"><span class=\"keyword\">fi</span>;</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$&#123;WORKSPACE&#125;</span>/Enterprise.plist&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">rm</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/Enterprise.plist; </span><br><span class=\"line\"><span class=\"keyword\">fi</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#http://www.matrixprojects.net/p/xcodebuild-export-options-plist/</span></span><br><span class=\"line\">Enterprise=<span class=\"string\">&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;plist version=&quot;1.0&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;dict&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;key&gt;teamID&lt;/key&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;string&gt;&lt;/string&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;key&gt;method&lt;/key&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;string&gt;app-store&lt;/string&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;key&gt;uploadSymbols&lt;/key&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;true/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;key&gt;uploadBitcode&lt;/key&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;false/&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/dict&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/plist&gt;&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;Enterprise&#125;</span> &gt; <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/Enterprise.plist</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g&#x27;</span> \\</span><br><span class=\"line\"><span class=\"variable\">$&#123;WORKSPACE&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcodeproj/project.pbxproj</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/DEVELOPMENT_TEAM = .*;/DEVELOPMENT_TEAM = &quot;&quot;;/g&#x27;</span> \\</span><br><span class=\"line\"><span class=\"variable\">$&#123;WORKSPACE&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcodeproj/project.pbxproj</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#动态生成 Build Version</span></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&quot;/&lt;key&gt;CFBundleVersion&lt;\\/key&gt;/&#123;N;s/&lt;string&gt;.*&lt;\\/string&gt;/&lt;string&gt;<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>&lt;\\/string&gt;/g;&#125;&quot;</span> \\</span><br><span class=\"line\"><span class=\"variable\">$&#123;WORKSPACE&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>-Info.plist</span><br><span class=\"line\"></span><br><span class=\"line\">xcodebuild -workspace <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcworkspace \\</span><br><span class=\"line\">-scheme <span class=\"variable\">$&#123;PROJECT_NAME&#125;</span> -sdk iphoneos \\</span><br><span class=\"line\">build CODE_SIGN_IDENTITY=<span class=\"string\">&quot;iPhone Distribution: Beijing PS Technology Co., Ltd.&quot;</span> \\</span><br><span class=\"line\">PROVISIONING_PROFILE=<span class=\"string\">&quot;&quot;</span> \\</span><br><span class=\"line\">-configuration Release clean archive \\</span><br><span class=\"line\">-archivePath <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcarchive</span><br><span class=\"line\"></span><br><span class=\"line\">xcodebuild -exportArchive -exportOptionsPlist <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/Enterprise.plist \\</span><br><span class=\"line\">-archivePath <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcarchive \\</span><br><span class=\"line\">-exportPath <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;----------------&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Build successfully!&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Begin Upload to itunes...&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#Use [shenzhen](https://github.com/nomad/shenzhen) to upload the ipa file to itunes connect.</span></span><br><span class=\"line\">/usr/local/bin/ipa distribute:itunesconnect -f <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.ipa -a YourAppleID -p YourPassword -i <span class=\"variable\">$&#123;BUNDLE_ID&#125;</span> --upload</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Upload successfully!&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Tip8-重置-iOS-模拟器\"><a href=\"#Tip8-重置-iOS-模拟器\" class=\"headerlink\" title=\"Tip8: 重置 iOS 模拟器\"></a>Tip8: 重置 iOS 模拟器</h2><p>相信各位在做 iOS 开发的同学都会碰到模拟器上各种神奇的现象，通过重置 iOS 模拟器基本上可以解决大部分问题：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 退出当前的所有模拟器</span><br><span class=\"line\">$ osascript -e <span class=\"string\">&#x27;tell application &quot;iOS Simulator&quot; to quit&#x27;</span></span><br><span class=\"line\">$ osascript -e <span class=\"string\">&#x27;tell application &quot;Simulator&quot; to quit&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">// 清掉之前使用模拟器产生的所有内容</span><br><span class=\"line\">$ xcrun simctl erase all</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip9-模拟器截图\"><a href=\"#Tip9-模拟器截图\" class=\"headerlink\" title=\"Tip9: 模拟器截图\"></a>Tip9: 模拟器截图</h2><p>下面的命令会默认截取第一个启动的模拟器：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcrun simctl io booted screenshot screenshot.png</span><br></pre></td></tr></table></figure>\n\n<p>当你同时启动了多个模拟器的情况下，需要先查看当前启动的模拟器 ID，然后指定 ID 截图：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcrun simctl list</span><br><span class=\"line\">xcrun simctl io B5EEDDC0-CDA3-46A9-A2B6-FA940D693DFC screenshot screenshot.png</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>记录日常中用到的一些 Bash 脚本，经常更新</p>\n</blockquote>\n<h2 id=\"Tip-1-修改文件里面的内容\"><a href=\"#Tip-1-修改文件里面的内容\" class=\"headerlink\" title=\"Tip 1 : 修改文件里面的内容\"></a>Tip 1 : 修改文件里面的内容</h2><p>早上产品有一个小需求就是把工程中的所有网页的标题修改为黑米流量通，可以使用以下命令来实现</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ find . -name <span class=\"string\">&#x27;*.html&#x27;</span> -print0 | xargs -0 sed -i <span class=\"string\">&#x27;&#x27;</span> -e <span class=\"string\">&#x27;s/&lt;title&gt;.*&lt;\\/title&gt;/&lt;title&gt;黑米流量通&lt;\\/title&gt;/g&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>find</code>          查找命令，可以用 man find 查看更多的信息</li>\n<li><code>.</code>             代表当前目录</li>\n<li><code>-name</code>         find 命令的参数，表示要查找的文件名</li>\n<li><code>-print0</code>       是一种不换行的输出格式，以 ASCII NUL 字符（也就是\\0）作为分隔符。上面的例子可能是 <code>a.html\\0b.html\\0c.html</code></li>\n<li><code>|</code>             这是一个管道符，表示把前面命令的输出作为后面命令的输入</li>\n<li><code>xargs</code>         是用来构造输入参数，并且循环执行每一个参数</li>\n<li><code>-0</code>            表示让 xargs 使用 ASCII NUL 来分隔参数。上面的例子将被分隔成 <code>a.html</code> <code>b.html</code> <code>c.html</code> 三个参数依次执行</li>\n<li><code>sed</code>           这是一个流编辑器，如果传的是文件名会把文件内容读入内存，如果只是普通字符串就会把字符串读入内存</li>\n<li><code>-i</code>            表示要把原来的文件内容做一次备份，后面的 <code>&#39;&#39;</code> 是表示要备份的文件名字，如果没有文件名字就表示不需要备份</li>\n<li><code>-e</code>            表示后面的字符串是一个命令，需要被执行</li>\n<li><code>s/old/new/g</code>   这个是用来替换字符串的命令</li>\n</ul>\n<h2 id=\"Tip-2-查找文件的内容\"><a href=\"#Tip-2-查找文件的内容\" class=\"headerlink\" title=\"Tip 2 : 查找文件的内容\"></a>Tip 2 : 查找文件的内容</h2><p>把匹配的文件内容的相关文件列出来</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ find . -name <span class=\"string\">&#x27;*.html&#x27;</span> -print0 | xargs -0 grep <span class=\"string\">&#x27;PATTERN&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip-3-解决-Homebrew-的权限问题\"><a href=\"#Tip-3-解决-Homebrew-的权限问题\" class=\"headerlink\" title=\"Tip 3 : 解决 Homebrew 的权限问题\"></a>Tip 3 : 解决 Homebrew 的权限问题</h2><p>查看 Homebrew 的所有权</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">ls</span> -al `<span class=\"built_in\">which</span> brew`</span><br></pre></td></tr></table></figure>\n\n<p>把 Homebrew 的用户和分组修改为 root 和 wheel</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo <span class=\"built_in\">chown</span> root:wheel `<span class=\"built_in\">which</span> brew`</span><br></pre></td></tr></table></figure>\n\n<p>最后还原 Homebrew 的权限（安全）</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo <span class=\"built_in\">chown</span> : `<span class=\"built_in\">chown</span> brew`</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip-4-利用-Shell-生成生成-ICON\"><a href=\"#Tip-4-利用-Shell-生成生成-ICON\" class=\"headerlink\" title=\"Tip 4 : 利用 Shell 生成生成 ICON\"></a>Tip 4 : 利用 Shell 生成生成 ICON</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"comment\">#此脚本是用来生成 iPhone 和 iPad 所需 icon 的不同尺寸的，最好是准备一张 1024x1024 的 Icon 图片</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">filename=<span class=\"string\">&quot;icon.png&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">dirname</span>=<span class=\"string\">&quot;icon&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">name_array=(<span class=\"string\">&quot;Icon-20.png&quot;</span> <span class=\"string\">&quot;Icon-20@2x.png&quot;</span> <span class=\"string\">&quot;Icon-20@3x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-29.png&quot;</span> <span class=\"string\">&quot;Icon-29@2x.png&quot;</span> <span class=\"string\">&quot;Icon-29@3x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-40.png&quot;</span> <span class=\"string\">&quot;Icon-40@2x.png&quot;</span> <span class=\"string\">&quot;Icon-40@3x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-60@2x.png&quot;</span> <span class=\"string\">&quot;Icon-60@3x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-76.png&quot;</span> <span class=\"string\">&quot;Icon-76@2x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-83.5@2x.png&quot;</span>)</span><br><span class=\"line\">size_array=(<span class=\"string\">&quot;20&quot;</span> <span class=\"string\">&quot;40&quot;</span> <span class=\"string\">&quot;60&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;29&quot;</span> <span class=\"string\">&quot;58&quot;</span> <span class=\"string\">&quot;87&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;40&quot;</span> <span class=\"string\">&quot;80&quot;</span> <span class=\"string\">&quot;120&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;120&quot;</span> <span class=\"string\">&quot;180&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;76&quot;</span> <span class=\"string\">&quot;152&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;167&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> <span class=\"variable\">$dirname</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> ((i=0;i&lt;<span class=\"variable\">$&#123;#name_array[@]&#125;</span>;++i)); <span class=\"keyword\">do</span></span><br><span class=\"line\">    m_dir=<span class=\"variable\">$dirname</span>/<span class=\"variable\">$&#123;name_array[i]&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">cp</span> <span class=\"variable\">$filename</span> <span class=\"variable\">$m_dir</span></span><br><span class=\"line\">    sips -Z <span class=\"variable\">$&#123;size_array[i]&#125;</span> <span class=\"variable\">$m_dir</span></span><br><span class=\"line\"><span class=\"comment\"># 如果图片是 sRGB 的话，使用下面的命令</span></span><br><span class=\"line\"><span class=\"comment\">#    sips --matchTo &#x27;/System/Library/ColorSync/Profiles/sRGB Profile.icc&#x27; -Z $&#123;size_array[i]&#125; $m_dir </span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip5-使用-Python-共享当前目录\"><a href=\"#Tip5-使用-Python-共享当前目录\" class=\"headerlink\" title=\"Tip5 : 使用 Python 共享当前目录\"></a>Tip5 : 使用 Python 共享当前目录</h2><p>利用下面的命令可以暂时开启一个端口号为 8000 的 HTTP 服务，其他人只需要在浏览器输入 <code>http://ip-address:8000</code> 即可浏览共享目录下的文件</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Tip6-加密和解密文件\"><a href=\"#Tip6-加密和解密文件\" class=\"headerlink\" title=\"Tip6 : 加密和解密文件\"></a>Tip6 : 加密和解密文件</h2><ul>\n<li>加密</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar czf - &#123;SRC_DIR&#125; | openssl des3 -salt -k <span class=\"string\">&quot;&#123;KEY&#125;&quot;</span> -out &#123;DIST_PACKAGE&#125;.tar.gz</span><br></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<p>目录名 <code>paris_code</code>，秘钥 <code>meta#com</code>，输出包 <code>paris_code_20161008.tar.gz</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar czf - paris_code | openssl des3 -salt -k <span class=\"string\">&quot;meta#com&quot;</span> -out paris_code_20161008.tar.gz</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>解密</li>\n</ul>\n<p>第一步：获取代码压缩文件包</p>\n<p>下载地址 <code>http://XXXX.com/paris_code_20161008.tar.gz</code></p>\n<p>第二步：解密文件（OS X &#x2F; Linux only）</p>\n<p>在 Terminal 进入压缩文件包同级目录，输入以下命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ openssl des3 -d -k <span class=\"string\">&quot;meta#com&quot;</span> -salt -<span class=\"keyword\">in</span> paris_code_20161008.tar.gz | tar xzf -</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip7-iOS-打包命令\"><a href=\"#Tip7-iOS-打包命令\" class=\"headerlink\" title=\"Tip7: iOS 打包命令\"></a>Tip7: iOS 打包命令</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;----------------&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Begin Build!&quot;</span></span><br><span class=\"line\">PROJECT_NAME=<span class=\"string\">&quot;orbit&quot;</span></span><br><span class=\"line\">BUILD_DATE=<span class=\"string\">&quot;<span class=\"subst\">$(date +&#x27;%Y%m%d&#x27;)</span>&quot;</span></span><br><span class=\"line\">BUNDLE_ID=<span class=\"string\">&quot;com.meta.paris&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#/usr/local/bin/npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build&quot;</span> ]; <span class=\"keyword\">then</span> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">ls</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/**/*.ipa 1&gt; /dev/null 2&gt;&amp;1; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">rm</span> -rf <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/**/*.ipa; </span><br><span class=\"line\">    <span class=\"keyword\">fi</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">ls</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/**/*.xcarchive 1&gt; /dev/null 2&gt;&amp;1; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">rm</span> -rf <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/**/*.xcarchive; </span><br><span class=\"line\">    <span class=\"keyword\">fi</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">    <span class=\"built_in\">mkdir</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build; </span><br><span class=\"line\"><span class=\"keyword\">fi</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;计算今天的 Build Version&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_DATE&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span> </span><br><span class=\"line\">   <span class=\"comment\">#如果不加上面的 if, Jenkins 无法直接执行下面的命令❓</span></span><br><span class=\"line\">\tBUILD_DATE_COUNT=$(<span class=\"built_in\">ls</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build | grep <span class=\"string\">&quot;^<span class=\"variable\">$&#123;BUILD_DATE&#125;</span>&quot;</span> -c)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"variable\">$&#123;BUILD_DATE_COUNT&#125;</span> -lt 10 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">        BUILD_DATE_COUNT=<span class=\"string\">&quot;0<span class=\"variable\">$&#123;BUILD_DATE_COUNT&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span>;</span><br><span class=\"line\">\tBUILD_VERSION=<span class=\"string\">&quot;<span class=\"variable\">$&#123;BUILD_DATE&#125;</span><span class=\"variable\">$&#123;BUILD_DATE_COUNT&#125;</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">  \tBUILD_VERSION=<span class=\"variable\">$&#123;BUILD_DATE&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span>;</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;今天的 Build Version 是 <span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span> </span><br><span class=\"line\">    <span class=\"built_in\">rm</span> -rf <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>; </span><br><span class=\"line\"><span class=\"keyword\">fi</span>;</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$&#123;WORKSPACE&#125;</span>/Enterprise.plist&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">rm</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/Enterprise.plist; </span><br><span class=\"line\"><span class=\"keyword\">fi</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#http://www.matrixprojects.net/p/xcodebuild-export-options-plist/</span></span><br><span class=\"line\">Enterprise=<span class=\"string\">&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;plist version=&quot;1.0&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;dict&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;key&gt;teamID&lt;/key&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;string&gt;&lt;/string&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;key&gt;method&lt;/key&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;string&gt;app-store&lt;/string&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;key&gt;uploadSymbols&lt;/key&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;true/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;key&gt;uploadBitcode&lt;/key&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;false/&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/dict&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/plist&gt;&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;Enterprise&#125;</span> &gt; <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/Enterprise.plist</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g&#x27;</span> \\</span><br><span class=\"line\"><span class=\"variable\">$&#123;WORKSPACE&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcodeproj/project.pbxproj</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/DEVELOPMENT_TEAM = .*;/DEVELOPMENT_TEAM = &quot;&quot;;/g&#x27;</span> \\</span><br><span class=\"line\"><span class=\"variable\">$&#123;WORKSPACE&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcodeproj/project.pbxproj</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#动态生成 Build Version</span></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&quot;/&lt;key&gt;CFBundleVersion&lt;\\/key&gt;/&#123;N;s/&lt;string&gt;.*&lt;\\/string&gt;/&lt;string&gt;<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>&lt;\\/string&gt;/g;&#125;&quot;</span> \\</span><br><span class=\"line\"><span class=\"variable\">$&#123;WORKSPACE&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>-Info.plist</span><br><span class=\"line\"></span><br><span class=\"line\">xcodebuild -workspace <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcworkspace \\</span><br><span class=\"line\">-scheme <span class=\"variable\">$&#123;PROJECT_NAME&#125;</span> -sdk iphoneos \\</span><br><span class=\"line\">build CODE_SIGN_IDENTITY=<span class=\"string\">&quot;iPhone Distribution: Beijing PS Technology Co., Ltd.&quot;</span> \\</span><br><span class=\"line\">PROVISIONING_PROFILE=<span class=\"string\">&quot;&quot;</span> \\</span><br><span class=\"line\">-configuration Release clean archive \\</span><br><span class=\"line\">-archivePath <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcarchive</span><br><span class=\"line\"></span><br><span class=\"line\">xcodebuild -exportArchive -exportOptionsPlist <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/Enterprise.plist \\</span><br><span class=\"line\">-archivePath <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcarchive \\</span><br><span class=\"line\">-exportPath <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;----------------&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Build successfully!&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Begin Upload to itunes...&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#Use [shenzhen](https://github.com/nomad/shenzhen) to upload the ipa file to itunes connect.</span></span><br><span class=\"line\">/usr/local/bin/ipa distribute:itunesconnect -f <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.ipa -a YourAppleID -p YourPassword -i <span class=\"variable\">$&#123;BUNDLE_ID&#125;</span> --upload</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Upload successfully!&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Tip8-重置-iOS-模拟器\"><a href=\"#Tip8-重置-iOS-模拟器\" class=\"headerlink\" title=\"Tip8: 重置 iOS 模拟器\"></a>Tip8: 重置 iOS 模拟器</h2><p>相信各位在做 iOS 开发的同学都会碰到模拟器上各种神奇的现象，通过重置 iOS 模拟器基本上可以解决大部分问题：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 退出当前的所有模拟器</span><br><span class=\"line\">$ osascript -e <span class=\"string\">&#x27;tell application &quot;iOS Simulator&quot; to quit&#x27;</span></span><br><span class=\"line\">$ osascript -e <span class=\"string\">&#x27;tell application &quot;Simulator&quot; to quit&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">// 清掉之前使用模拟器产生的所有内容</span><br><span class=\"line\">$ xcrun simctl erase all</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip9-模拟器截图\"><a href=\"#Tip9-模拟器截图\" class=\"headerlink\" title=\"Tip9: 模拟器截图\"></a>Tip9: 模拟器截图</h2><p>下面的命令会默认截取第一个启动的模拟器：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcrun simctl io booted screenshot screenshot.png</span><br></pre></td></tr></table></figure>\n\n<p>当你同时启动了多个模拟器的情况下，需要先查看当前启动的模拟器 ID，然后指定 ID 截图：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcrun simctl list</span><br><span class=\"line\">xcrun simctl io B5EEDDC0-CDA3-46A9-A2B6-FA940D693DFC screenshot screenshot.png</span><br></pre></td></tr></table></figure>"},{"title":"Swift High-Performance Tip 1：Array 和 ContiguousArray","author":"帕帕","date":"2017-09-05T15:30:56.000Z","thumbnail":"https://images.unsplash.com/photo-1485988412941-77a35537dae4?ixlib=rb-0.3.5&s=177fa5618e070b6d13cf5debd2034426&auto=format&fit=crop&w=160&q=100","_content":"\n> Array 是随机存储的（random-access）集合类型。\n\n> ContiguousArray 是连续存储（contiguously stored）的数组，并且不允许和 NSArray 进行桥接的。\n\n当我们的数组元素是 Class 或 @objc protocol 类型的话，并且我们不需要在 Objective-C 中使用该数组的话，那么我们最好使用 ContiguousArray。这是因为 Array 需要额外的资源来处理跟 NSArray 的桥接功能，但是 ContiguousArray 则不需要，所以 ContiguousArray 比 Array 的效率要高。\n\n```Swift\nclass A {\n\n}\n\n// 不要用Array: let array = Array<A>()\n\nlet contiguousArray = ContiguousArray<A>()\n```\n\n另外需要注意的是官方文档说如果数组元素不是 Class 和 @objc protocol 类型的话，Array 和 ContiguousArray 的效率是一样的。（我猜测是因为如果 Array 的元素都是 Struct 类型的话，它就不需要消耗资源来处理桥接的问题了。）\n\n> Efficiency is equivalent to that of Array, unless Element is a class or @objc protocol type, in which case using ContiguousArray may be more efficient.\n\n但是 [@Paul Hudson](https://twitter.com/twostraws) 在他的[《Pro Swift》](https://gumroad.com/l/proswift)中说他发现即使数组元素是 Struct 类型的话，ContiguousArray 也要比 Array 更快。我们来看看他给出的例子：\n\n```Swift\nlet array2 = Array<Int>(1...1000000)\nlet array3 = ContiguousArray<Int>(1...1000000)\n\nvar start = CFAbsoluteTimeGetCurrent()\narray2.reduce(0, combine: +)\nvar end = CFAbsoluteTimeGetCurrent() - start\nprint(\"Took \\(end) seconds\")\n\nstart = CFAbsoluteTimeGetCurrent()\narray3.reduce(0, combine: +)\nend = CFAbsoluteTimeGetCurrent() - start\nprint(\"Took \\(end) seconds\")\n```\n\n经过我的测试，上面的代码中 ContiguousArray 只用了0.19秒而 Array 用了0.38秒，所以 ContiguousArray 确实要比 Array 快。\n\n如果大家想在性能上有所提升的话，建议大家可以用 ContiguousArray 试一试。\n\n","source":"_posts/Swift-High-Performance-Tip 1：Array和ContiguousArray.md","raw":"---\ntitle: Swift High-Performance Tip 1：Array 和 ContiguousArray\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: 技术\ntags: [iOS, Swift]\nthumbnail: https://images.unsplash.com/photo-1485988412941-77a35537dae4?ixlib=rb-0.3.5&s=177fa5618e070b6d13cf5debd2034426&auto=format&fit=crop&w=160&q=100\n---\n\n> Array 是随机存储的（random-access）集合类型。\n\n> ContiguousArray 是连续存储（contiguously stored）的数组，并且不允许和 NSArray 进行桥接的。\n\n当我们的数组元素是 Class 或 @objc protocol 类型的话，并且我们不需要在 Objective-C 中使用该数组的话，那么我们最好使用 ContiguousArray。这是因为 Array 需要额外的资源来处理跟 NSArray 的桥接功能，但是 ContiguousArray 则不需要，所以 ContiguousArray 比 Array 的效率要高。\n\n```Swift\nclass A {\n\n}\n\n// 不要用Array: let array = Array<A>()\n\nlet contiguousArray = ContiguousArray<A>()\n```\n\n另外需要注意的是官方文档说如果数组元素不是 Class 和 @objc protocol 类型的话，Array 和 ContiguousArray 的效率是一样的。（我猜测是因为如果 Array 的元素都是 Struct 类型的话，它就不需要消耗资源来处理桥接的问题了。）\n\n> Efficiency is equivalent to that of Array, unless Element is a class or @objc protocol type, in which case using ContiguousArray may be more efficient.\n\n但是 [@Paul Hudson](https://twitter.com/twostraws) 在他的[《Pro Swift》](https://gumroad.com/l/proswift)中说他发现即使数组元素是 Struct 类型的话，ContiguousArray 也要比 Array 更快。我们来看看他给出的例子：\n\n```Swift\nlet array2 = Array<Int>(1...1000000)\nlet array3 = ContiguousArray<Int>(1...1000000)\n\nvar start = CFAbsoluteTimeGetCurrent()\narray2.reduce(0, combine: +)\nvar end = CFAbsoluteTimeGetCurrent() - start\nprint(\"Took \\(end) seconds\")\n\nstart = CFAbsoluteTimeGetCurrent()\narray3.reduce(0, combine: +)\nend = CFAbsoluteTimeGetCurrent() - start\nprint(\"Took \\(end) seconds\")\n```\n\n经过我的测试，上面的代码中 ContiguousArray 只用了0.19秒而 Array 用了0.38秒，所以 ContiguousArray 确实要比 Array 快。\n\n如果大家想在性能上有所提升的话，建议大家可以用 ContiguousArray 试一试。\n\n","slug":"Swift-High-Performance-Tip 1：Array和ContiguousArray","published":1,"updated":"2022-04-20T07:08:33.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxe9000i6enqe5nefawp","content":"<blockquote>\n<p>Array 是随机存储的（random-access）集合类型。</p>\n</blockquote>\n<blockquote>\n<p>ContiguousArray 是连续存储（contiguously stored）的数组，并且不允许和 NSArray 进行桥接的。</p>\n</blockquote>\n<p>当我们的数组元素是 Class 或 @objc protocol 类型的话，并且我们不需要在 Objective-C 中使用该数组的话，那么我们最好使用 ContiguousArray。这是因为 Array 需要额外的资源来处理跟 NSArray 的桥接功能，但是 ContiguousArray 则不需要，所以 ContiguousArray 比 Array 的效率要高。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不要用Array: let array = Array&lt;A&gt;()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> contiguousArray <span class=\"operator\">=</span> <span class=\"type\">ContiguousArray</span>&lt;<span class=\"type\">A</span>&gt;()</span><br></pre></td></tr></table></figure>\n\n<p>另外需要注意的是官方文档说如果数组元素不是 Class 和 @objc protocol 类型的话，Array 和 ContiguousArray 的效率是一样的。（我猜测是因为如果 Array 的元素都是 Struct 类型的话，它就不需要消耗资源来处理桥接的问题了。）</p>\n<blockquote>\n<p>Efficiency is equivalent to that of Array, unless Element is a class or @objc protocol type, in which case using ContiguousArray may be more efficient.</p>\n</blockquote>\n<p>但是 <a href=\"https://twitter.com/twostraws\">@Paul Hudson</a> 在他的<a href=\"https://gumroad.com/l/proswift\">《Pro Swift》</a>中说他发现即使数组元素是 Struct 类型的话，ContiguousArray 也要比 Array 更快。我们来看看他给出的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> array2 <span class=\"operator\">=</span> <span class=\"type\">Array</span>&lt;<span class=\"type\">Int</span>&gt;(<span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">1000000</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> array3 <span class=\"operator\">=</span> <span class=\"type\">ContiguousArray</span>&lt;<span class=\"type\">Int</span>&gt;(<span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">1000000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> start <span class=\"operator\">=</span> <span class=\"type\">CFAbsoluteTimeGetCurrent</span>()</span><br><span class=\"line\">array2.reduce(<span class=\"number\">0</span>, combine: <span class=\"operator\">+</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> end <span class=\"operator\">=</span> <span class=\"type\">CFAbsoluteTimeGetCurrent</span>() <span class=\"operator\">-</span> start</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Took <span class=\"subst\">\\(end)</span> seconds&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">start <span class=\"operator\">=</span> <span class=\"type\">CFAbsoluteTimeGetCurrent</span>()</span><br><span class=\"line\">array3.reduce(<span class=\"number\">0</span>, combine: <span class=\"operator\">+</span>)</span><br><span class=\"line\">end <span class=\"operator\">=</span> <span class=\"type\">CFAbsoluteTimeGetCurrent</span>() <span class=\"operator\">-</span> start</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Took <span class=\"subst\">\\(end)</span> seconds&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>经过我的测试，上面的代码中 ContiguousArray 只用了0.19秒而 Array 用了0.38秒，所以 ContiguousArray 确实要比 Array 快。</p>\n<p>如果大家想在性能上有所提升的话，建议大家可以用 ContiguousArray 试一试。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Array 是随机存储的（random-access）集合类型。</p>\n</blockquote>\n<blockquote>\n<p>ContiguousArray 是连续存储（contiguously stored）的数组，并且不允许和 NSArray 进行桥接的。</p>\n</blockquote>\n<p>当我们的数组元素是 Class 或 @objc protocol 类型的话，并且我们不需要在 Objective-C 中使用该数组的话，那么我们最好使用 ContiguousArray。这是因为 Array 需要额外的资源来处理跟 NSArray 的桥接功能，但是 ContiguousArray 则不需要，所以 ContiguousArray 比 Array 的效率要高。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不要用Array: let array = Array&lt;A&gt;()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> contiguousArray <span class=\"operator\">=</span> <span class=\"type\">ContiguousArray</span>&lt;<span class=\"type\">A</span>&gt;()</span><br></pre></td></tr></table></figure>\n\n<p>另外需要注意的是官方文档说如果数组元素不是 Class 和 @objc protocol 类型的话，Array 和 ContiguousArray 的效率是一样的。（我猜测是因为如果 Array 的元素都是 Struct 类型的话，它就不需要消耗资源来处理桥接的问题了。）</p>\n<blockquote>\n<p>Efficiency is equivalent to that of Array, unless Element is a class or @objc protocol type, in which case using ContiguousArray may be more efficient.</p>\n</blockquote>\n<p>但是 <a href=\"https://twitter.com/twostraws\">@Paul Hudson</a> 在他的<a href=\"https://gumroad.com/l/proswift\">《Pro Swift》</a>中说他发现即使数组元素是 Struct 类型的话，ContiguousArray 也要比 Array 更快。我们来看看他给出的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> array2 <span class=\"operator\">=</span> <span class=\"type\">Array</span>&lt;<span class=\"type\">Int</span>&gt;(<span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">1000000</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> array3 <span class=\"operator\">=</span> <span class=\"type\">ContiguousArray</span>&lt;<span class=\"type\">Int</span>&gt;(<span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">1000000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> start <span class=\"operator\">=</span> <span class=\"type\">CFAbsoluteTimeGetCurrent</span>()</span><br><span class=\"line\">array2.reduce(<span class=\"number\">0</span>, combine: <span class=\"operator\">+</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> end <span class=\"operator\">=</span> <span class=\"type\">CFAbsoluteTimeGetCurrent</span>() <span class=\"operator\">-</span> start</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Took <span class=\"subst\">\\(end)</span> seconds&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">start <span class=\"operator\">=</span> <span class=\"type\">CFAbsoluteTimeGetCurrent</span>()</span><br><span class=\"line\">array3.reduce(<span class=\"number\">0</span>, combine: <span class=\"operator\">+</span>)</span><br><span class=\"line\">end <span class=\"operator\">=</span> <span class=\"type\">CFAbsoluteTimeGetCurrent</span>() <span class=\"operator\">-</span> start</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Took <span class=\"subst\">\\(end)</span> seconds&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>经过我的测试，上面的代码中 ContiguousArray 只用了0.19秒而 Array 用了0.38秒，所以 ContiguousArray 确实要比 Array 快。</p>\n<p>如果大家想在性能上有所提升的话，建议大家可以用 ContiguousArray 试一试。</p>\n"},{"title":"Swift High-Performance Tip 2：final 和 private(fileprivate)","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n> Dynamic dispatch means that program has to determine at run time which method or property is being referred to and then perform an indirect call or indirect access.\n\n我们都知道 Swift 的 class 是可以被继承，function 和 property 是可以被重写的，而这就意味着 Swift 需要 dynamic dispatch 这种机制来完成这些功能。Swift 的 dynamic dispatch 首先会再 method table 查找方法，然后间接调用。很明显这种方式要比直接调用的效率慢，并且用间接调用的方式还会阻止编译器的一些优化无法实现。\n\n**那么应该怎么优化呢？**\n\n当我们明确的知道 class、function、property 是不需要 overridden，我们可以通过使用 final 和 private(fileprivate) 这些关键字减少动态派发的发生，从而有效的提高效率。\n\n在 Swift 中，如果被 final 或 private(fileprivate) 修饰的 class、function、property 是不能 overridden，并且调用这些 class、function、property 的时候不再通过 dynamic dispatch 去间接调用，而是直接调用。\n\n所以，通过在必要的代码中使用 final 或 private(fileprivate) 这些关键字进行优化的话，将可以有效提高的效率。\n\n**Whole Module Optimization**\n\nSwift 的 class、function、property 的默认权限都是 internal ，除非我们明确的加上 public 或 private(fileprivate) 关键字才能改变它们的默认权限。\n\n编译器在编译 Module 的时候都是对里面的源文件进行单独编译，这样的话编译器就无法确切的知道被 internal 修饰的 class、function、property 究竟有没有被 overridden。一旦我们开启 Whole Module Optimization 的优化选项，编译器就会同时对整个 Module 的所有源文件进行编译，这个时候编译器就可以知道哪些被 internal 修饰的 class、function、property 没有被 overridden，从而把它们的权限从 internal 修改为 final。这样的话，就可以减少 dynamic dispatch 的发生从而提高效率。\n\n开启编译优化选项的步骤如下：Xcode -> Build Settings -> Swift Compiler -> Optimization Level。\n\n![](http://i.imgur.com/0AxWEVA.jpg)\n\n---\n\n**参考文献**\n\n1. https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/\n\n2. https://developer.apple.com/swift/blog/?id=27\n\n3. https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations\n\n","source":"_posts/Swift-High-Performance-Tip 2：final和private(fileprivate).md","raw":"---\ntitle: Swift High-Performance Tip 2：final 和 private(fileprivate)\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: 技术\ntags: [iOS, Swift]\n---\n\n> Dynamic dispatch means that program has to determine at run time which method or property is being referred to and then perform an indirect call or indirect access.\n\n我们都知道 Swift 的 class 是可以被继承，function 和 property 是可以被重写的，而这就意味着 Swift 需要 dynamic dispatch 这种机制来完成这些功能。Swift 的 dynamic dispatch 首先会再 method table 查找方法，然后间接调用。很明显这种方式要比直接调用的效率慢，并且用间接调用的方式还会阻止编译器的一些优化无法实现。\n\n**那么应该怎么优化呢？**\n\n当我们明确的知道 class、function、property 是不需要 overridden，我们可以通过使用 final 和 private(fileprivate) 这些关键字减少动态派发的发生，从而有效的提高效率。\n\n在 Swift 中，如果被 final 或 private(fileprivate) 修饰的 class、function、property 是不能 overridden，并且调用这些 class、function、property 的时候不再通过 dynamic dispatch 去间接调用，而是直接调用。\n\n所以，通过在必要的代码中使用 final 或 private(fileprivate) 这些关键字进行优化的话，将可以有效提高的效率。\n\n**Whole Module Optimization**\n\nSwift 的 class、function、property 的默认权限都是 internal ，除非我们明确的加上 public 或 private(fileprivate) 关键字才能改变它们的默认权限。\n\n编译器在编译 Module 的时候都是对里面的源文件进行单独编译，这样的话编译器就无法确切的知道被 internal 修饰的 class、function、property 究竟有没有被 overridden。一旦我们开启 Whole Module Optimization 的优化选项，编译器就会同时对整个 Module 的所有源文件进行编译，这个时候编译器就可以知道哪些被 internal 修饰的 class、function、property 没有被 overridden，从而把它们的权限从 internal 修改为 final。这样的话，就可以减少 dynamic dispatch 的发生从而提高效率。\n\n开启编译优化选项的步骤如下：Xcode -> Build Settings -> Swift Compiler -> Optimization Level。\n\n![](http://i.imgur.com/0AxWEVA.jpg)\n\n---\n\n**参考文献**\n\n1. https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/\n\n2. https://developer.apple.com/swift/blog/?id=27\n\n3. https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations\n\n","slug":"Swift-High-Performance-Tip 2：final和private(fileprivate)","published":1,"updated":"2022-04-20T07:08:33.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxea000j6enq0jabcl5o","content":"<blockquote>\n<p>Dynamic dispatch means that program has to determine at run time which method or property is being referred to and then perform an indirect call or indirect access.</p>\n</blockquote>\n<p>我们都知道 Swift 的 class 是可以被继承，function 和 property 是可以被重写的，而这就意味着 Swift 需要 dynamic dispatch 这种机制来完成这些功能。Swift 的 dynamic dispatch 首先会再 method table 查找方法，然后间接调用。很明显这种方式要比直接调用的效率慢，并且用间接调用的方式还会阻止编译器的一些优化无法实现。</p>\n<p><strong>那么应该怎么优化呢？</strong></p>\n<p>当我们明确的知道 class、function、property 是不需要 overridden，我们可以通过使用 final 和 private(fileprivate) 这些关键字减少动态派发的发生，从而有效的提高效率。</p>\n<p>在 Swift 中，如果被 final 或 private(fileprivate) 修饰的 class、function、property 是不能 overridden，并且调用这些 class、function、property 的时候不再通过 dynamic dispatch 去间接调用，而是直接调用。</p>\n<p>所以，通过在必要的代码中使用 final 或 private(fileprivate) 这些关键字进行优化的话，将可以有效提高的效率。</p>\n<p><strong>Whole Module Optimization</strong></p>\n<p>Swift 的 class、function、property 的默认权限都是 internal ，除非我们明确的加上 public 或 private(fileprivate) 关键字才能改变它们的默认权限。</p>\n<p>编译器在编译 Module 的时候都是对里面的源文件进行单独编译，这样的话编译器就无法确切的知道被 internal 修饰的 class、function、property 究竟有没有被 overridden。一旦我们开启 Whole Module Optimization 的优化选项，编译器就会同时对整个 Module 的所有源文件进行编译，这个时候编译器就可以知道哪些被 internal 修饰的 class、function、property 没有被 overridden，从而把它们的权限从 internal 修改为 final。这样的话，就可以减少 dynamic dispatch 的发生从而提高效率。</p>\n<p>开启编译优化选项的步骤如下：Xcode -&gt; Build Settings -&gt; Swift Compiler -&gt; Optimization Level。</p>\n<p><img src=\"http://i.imgur.com/0AxWEVA.jpg\"></p>\n<hr>\n<p><strong>参考文献</strong></p>\n<ol>\n<li><p><a href=\"https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/\">https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/</a></p>\n</li>\n<li><p><a href=\"https://developer.apple.com/swift/blog/?id=27\">https://developer.apple.com/swift/blog/?id=27</a></p>\n</li>\n<li><p><a href=\"https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations\">https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Dynamic dispatch means that program has to determine at run time which method or property is being referred to and then perform an indirect call or indirect access.</p>\n</blockquote>\n<p>我们都知道 Swift 的 class 是可以被继承，function 和 property 是可以被重写的，而这就意味着 Swift 需要 dynamic dispatch 这种机制来完成这些功能。Swift 的 dynamic dispatch 首先会再 method table 查找方法，然后间接调用。很明显这种方式要比直接调用的效率慢，并且用间接调用的方式还会阻止编译器的一些优化无法实现。</p>\n<p><strong>那么应该怎么优化呢？</strong></p>\n<p>当我们明确的知道 class、function、property 是不需要 overridden，我们可以通过使用 final 和 private(fileprivate) 这些关键字减少动态派发的发生，从而有效的提高效率。</p>\n<p>在 Swift 中，如果被 final 或 private(fileprivate) 修饰的 class、function、property 是不能 overridden，并且调用这些 class、function、property 的时候不再通过 dynamic dispatch 去间接调用，而是直接调用。</p>\n<p>所以，通过在必要的代码中使用 final 或 private(fileprivate) 这些关键字进行优化的话，将可以有效提高的效率。</p>\n<p><strong>Whole Module Optimization</strong></p>\n<p>Swift 的 class、function、property 的默认权限都是 internal ，除非我们明确的加上 public 或 private(fileprivate) 关键字才能改变它们的默认权限。</p>\n<p>编译器在编译 Module 的时候都是对里面的源文件进行单独编译，这样的话编译器就无法确切的知道被 internal 修饰的 class、function、property 究竟有没有被 overridden。一旦我们开启 Whole Module Optimization 的优化选项，编译器就会同时对整个 Module 的所有源文件进行编译，这个时候编译器就可以知道哪些被 internal 修饰的 class、function、property 没有被 overridden，从而把它们的权限从 internal 修改为 final。这样的话，就可以减少 dynamic dispatch 的发生从而提高效率。</p>\n<p>开启编译优化选项的步骤如下：Xcode -&gt; Build Settings -&gt; Swift Compiler -&gt; Optimization Level。</p>\n<p><img src=\"http://i.imgur.com/0AxWEVA.jpg\"></p>\n<hr>\n<p><strong>参考文献</strong></p>\n<ol>\n<li><p><a href=\"https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/\">https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/</a></p>\n</li>\n<li><p><a href=\"https://developer.apple.com/swift/blog/?id=27\">https://developer.apple.com/swift/blog/?id=27</a></p>\n</li>\n<li><p><a href=\"https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations\">https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations</a></p>\n</li>\n</ol>\n"},{"title":"Swift High-Performance Tip 3：@objc 和 dynamic","author":"帕帕","date":"2018-05-24T18:48:01.000Z","thumbnail":"https://images.unsplash.com/photo-1507358522600-9f71e620c44e?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=9606de2cffd6c619093871ef2d1c0e6f&auto=format&fit=crop&w=160&q=100","_content":"\n### @objc\n\n@objc 的作用是为了让 Objective-C 能够调用 Swift 的代码。其中的关键是 @objc 会生成一段 thunk 代码，Objective-C 通过这段 thunk 代码来间接调用 Swift 代码。如果是 Swift 来调用被 @objc 修饰的方法的时候，此时是不需要经过 thunk 代码就能直接调用的。\n\n所以我们可以想象，如果方法变得复杂或者被 @objc 修饰的方法数量变得越来越多会发生什么事？答案就是 thunk 代码变得越来越多，最后会导致我们的包大小也变得越来越大。并且动态链接器（dynamic linker）还需要整理这些 thunk 代码，最后导致加载时间也会变得越来越长。\n\n在 Swift3 的时候，编译器会推断出你的方法不是 Swift 专用的（比如有元组、结构体），就会默认给你的方法增加 @objc 的修饰。这种方式就导致了在 Swift3 的时候，会生成大量的 thunk 代码，并且这其中的大部分代码都不会被使用。所以 Swift4 默认是不做 @objc 的推断，只有我们手动添加了 @objc 之后，Objective-C 才能调用我们的 Swift 代码。 \n\n### dynamic\n\nSwift 的方法是通过 vtable 来调用的，使用 vtable 要比 Objective-C 的 runtime 更高效。\n\n而使用 dynamic 来修饰的方法，代表这个方法是可以被动态调用的。而由于目前 Swfit 还没有实现自己的 runtime 机制，所以动态调用只能够在 Objective-C 去调用。在  Swift4 使用 dynamic 修饰一个方法的时候，编译器会要求你还需要使用 @objc 去修饰。这是为了明确的告诉编译器这个方法是由 Objective-C 的 runtime 来调用的，同时也是为了兼容以后可能会出现的 Swift runtime 机制。\n\n由于目前使用 @objc dynamic 修饰的方法并不在 Swift 实例对象的 vtable 里面，所以 Swift 来调用该方法的时候依旧需要通过 thunk 代码来调用。\n\n### 总结\n\n![此图出自 https://swiftunboxed.com/interop/objc-dynamic/](https://swiftunboxed.com/images/native-objc-dynamic.png)\n\n通过上图我们知道：\n\n> 除非明确的知道会在 Objective-C 中调用这段代码，否则别使用 @objc；\n> 除非明确的知道该方法需要被 Objective-C 的 runtime 动态调用，否则别使用 @objc dynamic。\n\n\n---\n\n**参考文献**\n\n1. https://swiftunboxed.com/interop/objc-dynamic/\n\n2. https://github.com/apple/swift-evolution/blob/master/proposals/0160-objc-inference.md\n\n\n","source":"_posts/Swift-High-Performance-Tip 3：@objc-和-dynamic.md","raw":"---\ntitle: Swift High-Performance Tip 3：@objc 和 dynamic\nauthor: 帕帕\ndate: 2018-05-24 18:48:01 +0800\ncategories: 技术\ntags: [iOS, Swift]\nthumbnail: https://images.unsplash.com/photo-1507358522600-9f71e620c44e?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=9606de2cffd6c619093871ef2d1c0e6f&auto=format&fit=crop&w=160&q=100\n---\n\n### @objc\n\n@objc 的作用是为了让 Objective-C 能够调用 Swift 的代码。其中的关键是 @objc 会生成一段 thunk 代码，Objective-C 通过这段 thunk 代码来间接调用 Swift 代码。如果是 Swift 来调用被 @objc 修饰的方法的时候，此时是不需要经过 thunk 代码就能直接调用的。\n\n所以我们可以想象，如果方法变得复杂或者被 @objc 修饰的方法数量变得越来越多会发生什么事？答案就是 thunk 代码变得越来越多，最后会导致我们的包大小也变得越来越大。并且动态链接器（dynamic linker）还需要整理这些 thunk 代码，最后导致加载时间也会变得越来越长。\n\n在 Swift3 的时候，编译器会推断出你的方法不是 Swift 专用的（比如有元组、结构体），就会默认给你的方法增加 @objc 的修饰。这种方式就导致了在 Swift3 的时候，会生成大量的 thunk 代码，并且这其中的大部分代码都不会被使用。所以 Swift4 默认是不做 @objc 的推断，只有我们手动添加了 @objc 之后，Objective-C 才能调用我们的 Swift 代码。 \n\n### dynamic\n\nSwift 的方法是通过 vtable 来调用的，使用 vtable 要比 Objective-C 的 runtime 更高效。\n\n而使用 dynamic 来修饰的方法，代表这个方法是可以被动态调用的。而由于目前 Swfit 还没有实现自己的 runtime 机制，所以动态调用只能够在 Objective-C 去调用。在  Swift4 使用 dynamic 修饰一个方法的时候，编译器会要求你还需要使用 @objc 去修饰。这是为了明确的告诉编译器这个方法是由 Objective-C 的 runtime 来调用的，同时也是为了兼容以后可能会出现的 Swift runtime 机制。\n\n由于目前使用 @objc dynamic 修饰的方法并不在 Swift 实例对象的 vtable 里面，所以 Swift 来调用该方法的时候依旧需要通过 thunk 代码来调用。\n\n### 总结\n\n![此图出自 https://swiftunboxed.com/interop/objc-dynamic/](https://swiftunboxed.com/images/native-objc-dynamic.png)\n\n通过上图我们知道：\n\n> 除非明确的知道会在 Objective-C 中调用这段代码，否则别使用 @objc；\n> 除非明确的知道该方法需要被 Objective-C 的 runtime 动态调用，否则别使用 @objc dynamic。\n\n\n---\n\n**参考文献**\n\n1. https://swiftunboxed.com/interop/objc-dynamic/\n\n2. https://github.com/apple/swift-evolution/blob/master/proposals/0160-objc-inference.md\n\n\n","slug":"Swift-High-Performance-Tip 3：@objc-和-dynamic","published":1,"updated":"2022-04-20T07:08:33.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxeb000o6enq43nv1yrw","content":"<h3 id=\"objc\"><a href=\"#objc\" class=\"headerlink\" title=\"@objc\"></a>@objc</h3><p>@objc 的作用是为了让 Objective-C 能够调用 Swift 的代码。其中的关键是 @objc 会生成一段 thunk 代码，Objective-C 通过这段 thunk 代码来间接调用 Swift 代码。如果是 Swift 来调用被 @objc 修饰的方法的时候，此时是不需要经过 thunk 代码就能直接调用的。</p>\n<p>所以我们可以想象，如果方法变得复杂或者被 @objc 修饰的方法数量变得越来越多会发生什么事？答案就是 thunk 代码变得越来越多，最后会导致我们的包大小也变得越来越大。并且动态链接器（dynamic linker）还需要整理这些 thunk 代码，最后导致加载时间也会变得越来越长。</p>\n<p>在 Swift3 的时候，编译器会推断出你的方法不是 Swift 专用的（比如有元组、结构体），就会默认给你的方法增加 @objc 的修饰。这种方式就导致了在 Swift3 的时候，会生成大量的 thunk 代码，并且这其中的大部分代码都不会被使用。所以 Swift4 默认是不做 @objc 的推断，只有我们手动添加了 @objc 之后，Objective-C 才能调用我们的 Swift 代码。 </p>\n<h3 id=\"dynamic\"><a href=\"#dynamic\" class=\"headerlink\" title=\"dynamic\"></a>dynamic</h3><p>Swift 的方法是通过 vtable 来调用的，使用 vtable 要比 Objective-C 的 runtime 更高效。</p>\n<p>而使用 dynamic 来修饰的方法，代表这个方法是可以被动态调用的。而由于目前 Swfit 还没有实现自己的 runtime 机制，所以动态调用只能够在 Objective-C 去调用。在  Swift4 使用 dynamic 修饰一个方法的时候，编译器会要求你还需要使用 @objc 去修饰。这是为了明确的告诉编译器这个方法是由 Objective-C 的 runtime 来调用的，同时也是为了兼容以后可能会出现的 Swift runtime 机制。</p>\n<p>由于目前使用 @objc dynamic 修饰的方法并不在 Swift 实例对象的 vtable 里面，所以 Swift 来调用该方法的时候依旧需要通过 thunk 代码来调用。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><img src=\"https://swiftunboxed.com/images/native-objc-dynamic.png\" alt=\"此图出自 https://swiftunboxed.com/interop/objc-dynamic/\"></p>\n<p>通过上图我们知道：</p>\n<blockquote>\n<p>除非明确的知道会在 Objective-C 中调用这段代码，否则别使用 @objc；<br>除非明确的知道该方法需要被 Objective-C 的 runtime 动态调用，否则别使用 @objc dynamic。</p>\n</blockquote>\n<hr>\n<p><strong>参考文献</strong></p>\n<ol>\n<li><p><a href=\"https://swiftunboxed.com/interop/objc-dynamic/\">https://swiftunboxed.com/interop/objc-dynamic/</a></p>\n</li>\n<li><p><a href=\"https://github.com/apple/swift-evolution/blob/master/proposals/0160-objc-inference.md\">https://github.com/apple/swift-evolution/blob/master/proposals/0160-objc-inference.md</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"objc\"><a href=\"#objc\" class=\"headerlink\" title=\"@objc\"></a>@objc</h3><p>@objc 的作用是为了让 Objective-C 能够调用 Swift 的代码。其中的关键是 @objc 会生成一段 thunk 代码，Objective-C 通过这段 thunk 代码来间接调用 Swift 代码。如果是 Swift 来调用被 @objc 修饰的方法的时候，此时是不需要经过 thunk 代码就能直接调用的。</p>\n<p>所以我们可以想象，如果方法变得复杂或者被 @objc 修饰的方法数量变得越来越多会发生什么事？答案就是 thunk 代码变得越来越多，最后会导致我们的包大小也变得越来越大。并且动态链接器（dynamic linker）还需要整理这些 thunk 代码，最后导致加载时间也会变得越来越长。</p>\n<p>在 Swift3 的时候，编译器会推断出你的方法不是 Swift 专用的（比如有元组、结构体），就会默认给你的方法增加 @objc 的修饰。这种方式就导致了在 Swift3 的时候，会生成大量的 thunk 代码，并且这其中的大部分代码都不会被使用。所以 Swift4 默认是不做 @objc 的推断，只有我们手动添加了 @objc 之后，Objective-C 才能调用我们的 Swift 代码。 </p>\n<h3 id=\"dynamic\"><a href=\"#dynamic\" class=\"headerlink\" title=\"dynamic\"></a>dynamic</h3><p>Swift 的方法是通过 vtable 来调用的，使用 vtable 要比 Objective-C 的 runtime 更高效。</p>\n<p>而使用 dynamic 来修饰的方法，代表这个方法是可以被动态调用的。而由于目前 Swfit 还没有实现自己的 runtime 机制，所以动态调用只能够在 Objective-C 去调用。在  Swift4 使用 dynamic 修饰一个方法的时候，编译器会要求你还需要使用 @objc 去修饰。这是为了明确的告诉编译器这个方法是由 Objective-C 的 runtime 来调用的，同时也是为了兼容以后可能会出现的 Swift runtime 机制。</p>\n<p>由于目前使用 @objc dynamic 修饰的方法并不在 Swift 实例对象的 vtable 里面，所以 Swift 来调用该方法的时候依旧需要通过 thunk 代码来调用。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><img src=\"https://swiftunboxed.com/images/native-objc-dynamic.png\" alt=\"此图出自 https://swiftunboxed.com/interop/objc-dynamic/\"></p>\n<p>通过上图我们知道：</p>\n<blockquote>\n<p>除非明确的知道会在 Objective-C 中调用这段代码，否则别使用 @objc；<br>除非明确的知道该方法需要被 Objective-C 的 runtime 动态调用，否则别使用 @objc dynamic。</p>\n</blockquote>\n<hr>\n<p><strong>参考文献</strong></p>\n<ol>\n<li><p><a href=\"https://swiftunboxed.com/interop/objc-dynamic/\">https://swiftunboxed.com/interop/objc-dynamic/</a></p>\n</li>\n<li><p><a href=\"https://github.com/apple/swift-evolution/blob/master/proposals/0160-objc-inference.md\">https://github.com/apple/swift-evolution/blob/master/proposals/0160-objc-inference.md</a></p>\n</li>\n</ol>\n"},{"title":"UIScrollView 的偏移问题","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1514464750060-00e6e34c8b8c?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3749c47dd7beec20102c6b32fc19833a&auto=format&fit=crop&w=160&q=100","date":"2019-09-27T17:40:01.000Z","_content":"\n\n## 被控制的 UIScrollView\n\n在 UIViewController 中有个属性：`automaticallyAdjustsScrollViewInsets`，这个属性是用来控制 UIScrollView 的偏移行为的。\n\n> |                                                              |\n> | ------------------------------------------------------------ |\n> | The default value of this property is `true`, which lets container view controllers know that they should adjust the scroll view insets of this view controller’s view to account for screen areas consumed by a status bar, search bar, navigation bar, toolbar, or tab bar. Set this property to `false` if your view controller implementation manages its own scroll view inset adjustments. |\n> |                                                              |\n\n官方文档的意思当在 UIViewController 上添加  UIScrollView 的时候，会根据当前页面的 status bar、 search bar、navigation bar、toolbar 或 tab bar 来修改 UIScrollView 的内容区域。但是这个阶段的 UIViewController 比较蠢，不管任何情况下都会修改 UIScrollView 的偏移量。\n\n比如我们现在有个 UINavigationController，然后添加一个 UIScrollView，然后在 UIScrollView 上面添加一个红色的方块，代码如下：\n\n```Swift\nlet scrollView = UIScrollView()\nscrollView.backgroundColor = .blue\nscrollView.translatesAutoresizingMaskIntoConstraints = false\n// 这里强制设置 contentSize 只是为了让 scrollView 能滚动起来\nscrollView.contentSize = CGSize.init(width: view.frame.size.width, height: 1000)\nview.addSubview(scrollView)\n// ⚠️ 这里是直接跟 view 的 topAnchor 产生约束\nscrollView.topAnchor.constraint(equalTo: view.topAnchor).isActive = true\nscrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true\nscrollView.leftAnchor.constraint(equalTo: view.leftAnchor).isActive = true\nscrollView.rightAnchor.constraint(equalTo: view.rightAnchor).isActive = true\n\nlet redView = UIView()\nredView.backgroundColor = .red\nredView.translatesAutoresizingMaskIntoConstraints = false\nscrollView.addSubview(redView)\nredView.centerXAnchor.constraint(equalTo: scrollView.centerXAnchor).isActive = true\nredView.topAnchor.constraint(equalTo: scrollView.topAnchor).isActive = true\nredView.widthAnchor.constraint(equalToConstant: 100).isActive = true\nredView.heightAnchor.constraint(equalToConstant: 100).isActive = true\n```\n\n<img src=\"https://i.imgur.com/OnQDx7E.png\" alt=\"图一：iOS 10 模拟器效果\" style=\"zoom:50%;\" />\n\n\n\n当我们把 UIScrollView 的 topAnchor 修改为跟 UIViewController 的 topLayoutGuide 发生约束：\n\n```Swift\nscrollView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor).isActive = true\n```\n\n\n\n<img src=\"https://i.imgur.com/dwklB0X.png\" alt=\"图二：iOS 10 模拟器效果\" style=\"zoom:50%;\" />\n\n我们发现最终的效果是 UIScrollView 也发生了偏移，而且这个偏移是根据你顶部的 status bar 和 navigation bar 的高度来决定的。所以在 iOS 10 及以下的版本的时候，添加到 UIViewController 的 UIScrollView 总是会发生偏移。但是你可以通过把刚才说的那个属性 `automaticallyAdjustsScrollViewInsets`设置成 false，UIViewController 就不会让你的 UIScrollView 发生偏移。但是这个属性会影响到所有添加到 UIViewController 上的 UIScrollView，如果有些想要发生偏移，有些不想发生偏移的时候就需要把 `automaticallyAdjustsScrollViewInsets`设置成 false，然后通过代码单独去为每个 UIScrollView 设置不同的 contentInset。\n\n这种被控制的生活很不是滋味，于是随着 iOS 系统来到 11 之后，UIScrollView 终于夺回了自己的偏移控制权。UIViewController 的`automaticallyAdjustsScrollViewInsets`终于被废弃了，取而代之的是 UIScrollView 自己的`contentInsetAdjustmentBehavior`。\n\n## 自由的 UIScrollView\n\n>This property specifies how the safe area insets are used to modify the content area of the scroll view. The default value of this property is [UIScrollView.ContentInsetAdjustmentBehavior.automatic](apple-reference-documentation://hs7dxiWRRh).\n\nUIScrollView 的`contentInsetAdjustmentBehavior`的默认行为是`automatic`，这和 iOS 10 默认行为的最大区别就是它会判断 UIScrollView 是被添加到哪个位置，然后根据这个位置来判断是否需要修改 UIScrollView 的偏移量。\n\n还是拿上面图二的情况来讲，在 iOS 11 及 iOS 11 之后，我们还是照样只修改  UIScrollView 的 topAnchor：\n\n```swift\nscrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor).isActive = true\n```\n\n<img src=\"https://i.imgur.com/co1D7xr.png\" alt=\"图三：iOS 12 模拟器效果\" style=\"zoom:50%;\" />\n\n此时我们发现 UIScrollView 并没有发生偏移，这也是因为 iOS 11 之后引入来 safeArea 的概念之后带来的 UI 方面的优化。\n\n`contentInsetAdjustmentBehavior`还有两个值，其中`always`对应了`automaticallyAdjustsScrollViewInsets`的`true`,`never`对应了`automaticallyAdjustsScrollViewInsets`的`false`。\n\n至于`scrollableAxes`，它其实就是根据 UIScrollView 的滚动方向来决定在哪个轴上使用 sa feArea。\n\n通过`contentInsetAdjustmentBehavior`我们就可以为 UIViewController 上的每一个 UIScrollView 定制它们的偏移行为。","source":"_posts/UIScrollView-的偏移问题.md","raw":"---\ntitle: UIScrollView 的偏移问题\ntags:\n  - iOS\nauthor: 帕帕\ncategories: 技术\nthumbnail: >-\n  https://images.unsplash.com/photo-1514464750060-00e6e34c8b8c?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3749c47dd7beec20102c6b32fc19833a&auto=format&fit=crop&w=160&q=100\ndate: 2019-09-27 17:40:01\n---\n\n\n## 被控制的 UIScrollView\n\n在 UIViewController 中有个属性：`automaticallyAdjustsScrollViewInsets`，这个属性是用来控制 UIScrollView 的偏移行为的。\n\n> |                                                              |\n> | ------------------------------------------------------------ |\n> | The default value of this property is `true`, which lets container view controllers know that they should adjust the scroll view insets of this view controller’s view to account for screen areas consumed by a status bar, search bar, navigation bar, toolbar, or tab bar. Set this property to `false` if your view controller implementation manages its own scroll view inset adjustments. |\n> |                                                              |\n\n官方文档的意思当在 UIViewController 上添加  UIScrollView 的时候，会根据当前页面的 status bar、 search bar、navigation bar、toolbar 或 tab bar 来修改 UIScrollView 的内容区域。但是这个阶段的 UIViewController 比较蠢，不管任何情况下都会修改 UIScrollView 的偏移量。\n\n比如我们现在有个 UINavigationController，然后添加一个 UIScrollView，然后在 UIScrollView 上面添加一个红色的方块，代码如下：\n\n```Swift\nlet scrollView = UIScrollView()\nscrollView.backgroundColor = .blue\nscrollView.translatesAutoresizingMaskIntoConstraints = false\n// 这里强制设置 contentSize 只是为了让 scrollView 能滚动起来\nscrollView.contentSize = CGSize.init(width: view.frame.size.width, height: 1000)\nview.addSubview(scrollView)\n// ⚠️ 这里是直接跟 view 的 topAnchor 产生约束\nscrollView.topAnchor.constraint(equalTo: view.topAnchor).isActive = true\nscrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true\nscrollView.leftAnchor.constraint(equalTo: view.leftAnchor).isActive = true\nscrollView.rightAnchor.constraint(equalTo: view.rightAnchor).isActive = true\n\nlet redView = UIView()\nredView.backgroundColor = .red\nredView.translatesAutoresizingMaskIntoConstraints = false\nscrollView.addSubview(redView)\nredView.centerXAnchor.constraint(equalTo: scrollView.centerXAnchor).isActive = true\nredView.topAnchor.constraint(equalTo: scrollView.topAnchor).isActive = true\nredView.widthAnchor.constraint(equalToConstant: 100).isActive = true\nredView.heightAnchor.constraint(equalToConstant: 100).isActive = true\n```\n\n<img src=\"https://i.imgur.com/OnQDx7E.png\" alt=\"图一：iOS 10 模拟器效果\" style=\"zoom:50%;\" />\n\n\n\n当我们把 UIScrollView 的 topAnchor 修改为跟 UIViewController 的 topLayoutGuide 发生约束：\n\n```Swift\nscrollView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor).isActive = true\n```\n\n\n\n<img src=\"https://i.imgur.com/dwklB0X.png\" alt=\"图二：iOS 10 模拟器效果\" style=\"zoom:50%;\" />\n\n我们发现最终的效果是 UIScrollView 也发生了偏移，而且这个偏移是根据你顶部的 status bar 和 navigation bar 的高度来决定的。所以在 iOS 10 及以下的版本的时候，添加到 UIViewController 的 UIScrollView 总是会发生偏移。但是你可以通过把刚才说的那个属性 `automaticallyAdjustsScrollViewInsets`设置成 false，UIViewController 就不会让你的 UIScrollView 发生偏移。但是这个属性会影响到所有添加到 UIViewController 上的 UIScrollView，如果有些想要发生偏移，有些不想发生偏移的时候就需要把 `automaticallyAdjustsScrollViewInsets`设置成 false，然后通过代码单独去为每个 UIScrollView 设置不同的 contentInset。\n\n这种被控制的生活很不是滋味，于是随着 iOS 系统来到 11 之后，UIScrollView 终于夺回了自己的偏移控制权。UIViewController 的`automaticallyAdjustsScrollViewInsets`终于被废弃了，取而代之的是 UIScrollView 自己的`contentInsetAdjustmentBehavior`。\n\n## 自由的 UIScrollView\n\n>This property specifies how the safe area insets are used to modify the content area of the scroll view. The default value of this property is [UIScrollView.ContentInsetAdjustmentBehavior.automatic](apple-reference-documentation://hs7dxiWRRh).\n\nUIScrollView 的`contentInsetAdjustmentBehavior`的默认行为是`automatic`，这和 iOS 10 默认行为的最大区别就是它会判断 UIScrollView 是被添加到哪个位置，然后根据这个位置来判断是否需要修改 UIScrollView 的偏移量。\n\n还是拿上面图二的情况来讲，在 iOS 11 及 iOS 11 之后，我们还是照样只修改  UIScrollView 的 topAnchor：\n\n```swift\nscrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor).isActive = true\n```\n\n<img src=\"https://i.imgur.com/co1D7xr.png\" alt=\"图三：iOS 12 模拟器效果\" style=\"zoom:50%;\" />\n\n此时我们发现 UIScrollView 并没有发生偏移，这也是因为 iOS 11 之后引入来 safeArea 的概念之后带来的 UI 方面的优化。\n\n`contentInsetAdjustmentBehavior`还有两个值，其中`always`对应了`automaticallyAdjustsScrollViewInsets`的`true`,`never`对应了`automaticallyAdjustsScrollViewInsets`的`false`。\n\n至于`scrollableAxes`，它其实就是根据 UIScrollView 的滚动方向来决定在哪个轴上使用 sa feArea。\n\n通过`contentInsetAdjustmentBehavior`我们就可以为 UIViewController 上的每一个 UIScrollView 定制它们的偏移行为。","slug":"UIScrollView-的偏移问题","published":1,"updated":"2022-04-20T07:08:33.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxed000r6enq3962cbb2","content":"<h2 id=\"被控制的-UIScrollView\"><a href=\"#被控制的-UIScrollView\" class=\"headerlink\" title=\"被控制的 UIScrollView\"></a>被控制的 UIScrollView</h2><p>在 UIViewController 中有个属性：<code>automaticallyAdjustsScrollViewInsets</code>，这个属性是用来控制 UIScrollView 的偏移行为的。</p>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>The default value of this property is <code>true</code>, which lets container view controllers know that they should adjust the scroll view insets of this view controller’s view to account for screen areas consumed by a status bar, search bar, navigation bar, toolbar, or tab bar. Set this property to <code>false</code> if your view controller implementation manages its own scroll view inset adjustments.</td>\n</tr>\n<tr>\n<td></td>\n</tr>\n</tbody></table>\n</blockquote>\n<p>官方文档的意思当在 UIViewController 上添加  UIScrollView 的时候，会根据当前页面的 status bar、 search bar、navigation bar、toolbar 或 tab bar 来修改 UIScrollView 的内容区域。但是这个阶段的 UIViewController 比较蠢，不管任何情况下都会修改 UIScrollView 的偏移量。</p>\n<p>比如我们现在有个 UINavigationController，然后添加一个 UIScrollView，然后在 UIScrollView 上面添加一个红色的方块，代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> scrollView <span class=\"operator\">=</span> <span class=\"type\">UIScrollView</span>()</span><br><span class=\"line\">scrollView.backgroundColor <span class=\"operator\">=</span> .blue</span><br><span class=\"line\">scrollView.translatesAutoresizingMaskIntoConstraints <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\">// 这里强制设置 contentSize 只是为了让 scrollView 能滚动起来</span></span><br><span class=\"line\">scrollView.contentSize <span class=\"operator\">=</span> <span class=\"type\">CGSize</span>.<span class=\"keyword\">init</span>(width: view.frame.size.width, height: <span class=\"number\">1000</span>)</span><br><span class=\"line\">view.addSubview(scrollView)</span><br><span class=\"line\"><span class=\"comment\">// ⚠️ 这里是直接跟 view 的 topAnchor 产生约束</span></span><br><span class=\"line\">scrollView.topAnchor.constraint(equalTo: view.topAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">scrollView.leftAnchor.constraint(equalTo: view.leftAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">scrollView.rightAnchor.constraint(equalTo: view.rightAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> redView <span class=\"operator\">=</span> <span class=\"type\">UIView</span>()</span><br><span class=\"line\">redView.backgroundColor <span class=\"operator\">=</span> .red</span><br><span class=\"line\">redView.translatesAutoresizingMaskIntoConstraints <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\">scrollView.addSubview(redView)</span><br><span class=\"line\">redView.centerXAnchor.constraint(equalTo: scrollView.centerXAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">redView.topAnchor.constraint(equalTo: scrollView.topAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">redView.widthAnchor.constraint(equalToConstant: <span class=\"number\">100</span>).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">redView.heightAnchor.constraint(equalToConstant: <span class=\"number\">100</span>).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"https://i.imgur.com/OnQDx7E.png\" alt=\"图一：iOS 10 模拟器效果\" style=\"zoom:50%;\" />\n\n\n\n<p>当我们把 UIScrollView 的 topAnchor 修改为跟 UIViewController 的 topLayoutGuide 发生约束：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrollView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n\n\n<img src=\"https://i.imgur.com/dwklB0X.png\" alt=\"图二：iOS 10 模拟器效果\" style=\"zoom:50%;\" />\n\n<p>我们发现最终的效果是 UIScrollView 也发生了偏移，而且这个偏移是根据你顶部的 status bar 和 navigation bar 的高度来决定的。所以在 iOS 10 及以下的版本的时候，添加到 UIViewController 的 UIScrollView 总是会发生偏移。但是你可以通过把刚才说的那个属性 <code>automaticallyAdjustsScrollViewInsets</code>设置成 false，UIViewController 就不会让你的 UIScrollView 发生偏移。但是这个属性会影响到所有添加到 UIViewController 上的 UIScrollView，如果有些想要发生偏移，有些不想发生偏移的时候就需要把 <code>automaticallyAdjustsScrollViewInsets</code>设置成 false，然后通过代码单独去为每个 UIScrollView 设置不同的 contentInset。</p>\n<p>这种被控制的生活很不是滋味，于是随着 iOS 系统来到 11 之后，UIScrollView 终于夺回了自己的偏移控制权。UIViewController 的<code>automaticallyAdjustsScrollViewInsets</code>终于被废弃了，取而代之的是 UIScrollView 自己的<code>contentInsetAdjustmentBehavior</code>。</p>\n<h2 id=\"自由的-UIScrollView\"><a href=\"#自由的-UIScrollView\" class=\"headerlink\" title=\"自由的 UIScrollView\"></a>自由的 UIScrollView</h2><blockquote>\n<p>This property specifies how the safe area insets are used to modify the content area of the scroll view. The default value of this property is <a href=\"apple-reference-documentation://hs7dxiWRRh\">UIScrollView.ContentInsetAdjustmentBehavior.automatic</a>.</p>\n</blockquote>\n<p>UIScrollView 的<code>contentInsetAdjustmentBehavior</code>的默认行为是<code>automatic</code>，这和 iOS 10 默认行为的最大区别就是它会判断 UIScrollView 是被添加到哪个位置，然后根据这个位置来判断是否需要修改 UIScrollView 的偏移量。</p>\n<p>还是拿上面图二的情况来讲，在 iOS 11 及 iOS 11 之后，我们还是照样只修改  UIScrollView 的 topAnchor：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"https://i.imgur.com/co1D7xr.png\" alt=\"图三：iOS 12 模拟器效果\" style=\"zoom:50%;\" />\n\n<p>此时我们发现 UIScrollView 并没有发生偏移，这也是因为 iOS 11 之后引入来 safeArea 的概念之后带来的 UI 方面的优化。</p>\n<p><code>contentInsetAdjustmentBehavior</code>还有两个值，其中<code>always</code>对应了<code>automaticallyAdjustsScrollViewInsets</code>的<code>true</code>,<code>never</code>对应了<code>automaticallyAdjustsScrollViewInsets</code>的<code>false</code>。</p>\n<p>至于<code>scrollableAxes</code>，它其实就是根据 UIScrollView 的滚动方向来决定在哪个轴上使用 sa feArea。</p>\n<p>通过<code>contentInsetAdjustmentBehavior</code>我们就可以为 UIViewController 上的每一个 UIScrollView 定制它们的偏移行为。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"被控制的-UIScrollView\"><a href=\"#被控制的-UIScrollView\" class=\"headerlink\" title=\"被控制的 UIScrollView\"></a>被控制的 UIScrollView</h2><p>在 UIViewController 中有个属性：<code>automaticallyAdjustsScrollViewInsets</code>，这个属性是用来控制 UIScrollView 的偏移行为的。</p>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>The default value of this property is <code>true</code>, which lets container view controllers know that they should adjust the scroll view insets of this view controller’s view to account for screen areas consumed by a status bar, search bar, navigation bar, toolbar, or tab bar. Set this property to <code>false</code> if your view controller implementation manages its own scroll view inset adjustments.</td>\n</tr>\n<tr>\n<td></td>\n</tr>\n</tbody></table>\n</blockquote>\n<p>官方文档的意思当在 UIViewController 上添加  UIScrollView 的时候，会根据当前页面的 status bar、 search bar、navigation bar、toolbar 或 tab bar 来修改 UIScrollView 的内容区域。但是这个阶段的 UIViewController 比较蠢，不管任何情况下都会修改 UIScrollView 的偏移量。</p>\n<p>比如我们现在有个 UINavigationController，然后添加一个 UIScrollView，然后在 UIScrollView 上面添加一个红色的方块，代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> scrollView <span class=\"operator\">=</span> <span class=\"type\">UIScrollView</span>()</span><br><span class=\"line\">scrollView.backgroundColor <span class=\"operator\">=</span> .blue</span><br><span class=\"line\">scrollView.translatesAutoresizingMaskIntoConstraints <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\">// 这里强制设置 contentSize 只是为了让 scrollView 能滚动起来</span></span><br><span class=\"line\">scrollView.contentSize <span class=\"operator\">=</span> <span class=\"type\">CGSize</span>.<span class=\"keyword\">init</span>(width: view.frame.size.width, height: <span class=\"number\">1000</span>)</span><br><span class=\"line\">view.addSubview(scrollView)</span><br><span class=\"line\"><span class=\"comment\">// ⚠️ 这里是直接跟 view 的 topAnchor 产生约束</span></span><br><span class=\"line\">scrollView.topAnchor.constraint(equalTo: view.topAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">scrollView.leftAnchor.constraint(equalTo: view.leftAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">scrollView.rightAnchor.constraint(equalTo: view.rightAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> redView <span class=\"operator\">=</span> <span class=\"type\">UIView</span>()</span><br><span class=\"line\">redView.backgroundColor <span class=\"operator\">=</span> .red</span><br><span class=\"line\">redView.translatesAutoresizingMaskIntoConstraints <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\">scrollView.addSubview(redView)</span><br><span class=\"line\">redView.centerXAnchor.constraint(equalTo: scrollView.centerXAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">redView.topAnchor.constraint(equalTo: scrollView.topAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">redView.widthAnchor.constraint(equalToConstant: <span class=\"number\">100</span>).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">redView.heightAnchor.constraint(equalToConstant: <span class=\"number\">100</span>).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"https://i.imgur.com/OnQDx7E.png\" alt=\"图一：iOS 10 模拟器效果\" style=\"zoom:50%;\" />\n\n\n\n<p>当我们把 UIScrollView 的 topAnchor 修改为跟 UIViewController 的 topLayoutGuide 发生约束：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrollView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n\n\n<img src=\"https://i.imgur.com/dwklB0X.png\" alt=\"图二：iOS 10 模拟器效果\" style=\"zoom:50%;\" />\n\n<p>我们发现最终的效果是 UIScrollView 也发生了偏移，而且这个偏移是根据你顶部的 status bar 和 navigation bar 的高度来决定的。所以在 iOS 10 及以下的版本的时候，添加到 UIViewController 的 UIScrollView 总是会发生偏移。但是你可以通过把刚才说的那个属性 <code>automaticallyAdjustsScrollViewInsets</code>设置成 false，UIViewController 就不会让你的 UIScrollView 发生偏移。但是这个属性会影响到所有添加到 UIViewController 上的 UIScrollView，如果有些想要发生偏移，有些不想发生偏移的时候就需要把 <code>automaticallyAdjustsScrollViewInsets</code>设置成 false，然后通过代码单独去为每个 UIScrollView 设置不同的 contentInset。</p>\n<p>这种被控制的生活很不是滋味，于是随着 iOS 系统来到 11 之后，UIScrollView 终于夺回了自己的偏移控制权。UIViewController 的<code>automaticallyAdjustsScrollViewInsets</code>终于被废弃了，取而代之的是 UIScrollView 自己的<code>contentInsetAdjustmentBehavior</code>。</p>\n<h2 id=\"自由的-UIScrollView\"><a href=\"#自由的-UIScrollView\" class=\"headerlink\" title=\"自由的 UIScrollView\"></a>自由的 UIScrollView</h2><blockquote>\n<p>This property specifies how the safe area insets are used to modify the content area of the scroll view. The default value of this property is <a href=\"apple-reference-documentation://hs7dxiWRRh\">UIScrollView.ContentInsetAdjustmentBehavior.automatic</a>.</p>\n</blockquote>\n<p>UIScrollView 的<code>contentInsetAdjustmentBehavior</code>的默认行为是<code>automatic</code>，这和 iOS 10 默认行为的最大区别就是它会判断 UIScrollView 是被添加到哪个位置，然后根据这个位置来判断是否需要修改 UIScrollView 的偏移量。</p>\n<p>还是拿上面图二的情况来讲，在 iOS 11 及 iOS 11 之后，我们还是照样只修改  UIScrollView 的 topAnchor：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"https://i.imgur.com/co1D7xr.png\" alt=\"图三：iOS 12 模拟器效果\" style=\"zoom:50%;\" />\n\n<p>此时我们发现 UIScrollView 并没有发生偏移，这也是因为 iOS 11 之后引入来 safeArea 的概念之后带来的 UI 方面的优化。</p>\n<p><code>contentInsetAdjustmentBehavior</code>还有两个值，其中<code>always</code>对应了<code>automaticallyAdjustsScrollViewInsets</code>的<code>true</code>,<code>never</code>对应了<code>automaticallyAdjustsScrollViewInsets</code>的<code>false</code>。</p>\n<p>至于<code>scrollableAxes</code>，它其实就是根据 UIScrollView 的滚动方向来决定在哪个轴上使用 sa feArea。</p>\n<p>通过<code>contentInsetAdjustmentBehavior</code>我们就可以为 UIViewController 上的每一个 UIScrollView 定制它们的偏移行为。</p>\n"},{"title":"Vim Tip","subtitle":"记录日常中使用的 Vim 命令，经常更新","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n## 1、替换第n1行到第n2行的内容\n\n```Vim\n:n1,n2/origin/replace/g\n```\n\n## 2、替换整个文件的内容\n\n```Vim\n:%s/origin/replace/g\n```\n\n## 3、移动n1-n2行(包括n1,n2)到n3行之下\n\n```Vim\nn1,n2 m n3     \n```\n\n## 4、复制n1-n2行(包括n1,n2)到n3行之下\n\n```Vim\n:n1,n2 co n3\n```\n\n## 5、删除文件的空行\n\n```Vim\n:g/^$/d\n```\n\n## 6、在文本中插入一个1到100的序列（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\n:r!seq 100\n```\n\n## 7、在当前的每一行文字前面增加“序号. ”（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\n:let i=1 | g /^/ s//\\=i.\". \"/ | let i+=1\n```\n\n## 8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\nvim\n:n **/*.java\n:argdo %s/apache/eclipse/ge | update \n```\n\n","source":"_posts/Vim-Tip.md","raw":"---\ntitle: Vim Tip\nsubtitle: 记录日常中使用的 Vim 命令，经常更新\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: 技术\ntags: [tip]\n---\n\n## 1、替换第n1行到第n2行的内容\n\n```Vim\n:n1,n2/origin/replace/g\n```\n\n## 2、替换整个文件的内容\n\n```Vim\n:%s/origin/replace/g\n```\n\n## 3、移动n1-n2行(包括n1,n2)到n3行之下\n\n```Vim\nn1,n2 m n3     \n```\n\n## 4、复制n1-n2行(包括n1,n2)到n3行之下\n\n```Vim\n:n1,n2 co n3\n```\n\n## 5、删除文件的空行\n\n```Vim\n:g/^$/d\n```\n\n## 6、在文本中插入一个1到100的序列（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\n:r!seq 100\n```\n\n## 7、在当前的每一行文字前面增加“序号. ”（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\n:let i=1 | g /^/ s//\\=i.\". \"/ | let i+=1\n```\n\n## 8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\nvim\n:n **/*.java\n:argdo %s/apache/eclipse/ge | update \n```\n\n","slug":"Vim-Tip","published":1,"updated":"2022-04-20T07:08:33.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxee000w6enqbz4ihccu","content":"<h2 id=\"1、替换第n1行到第n2行的内容\"><a href=\"#1、替换第n1行到第n2行的内容\" class=\"headerlink\" title=\"1、替换第n1行到第n2行的内容\"></a>1、替换第n1行到第n2行的内容</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:n1,n2/origin/replace/g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、替换整个文件的内容\"><a href=\"#2、替换整个文件的内容\" class=\"headerlink\" title=\"2、替换整个文件的内容\"></a>2、替换整个文件的内容</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:%s/origin/replace/g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3、移动n1-n2行-包括n1-n2-到n3行之下\"><a href=\"#3、移动n1-n2行-包括n1-n2-到n3行之下\" class=\"headerlink\" title=\"3、移动n1-n2行(包括n1,n2)到n3行之下\"></a>3、移动n1-n2行(包括n1,n2)到n3行之下</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n1,n2 <span class=\"keyword\">m</span> n3     </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4、复制n1-n2行-包括n1-n2-到n3行之下\"><a href=\"#4、复制n1-n2行-包括n1-n2-到n3行之下\" class=\"headerlink\" title=\"4、复制n1-n2行(包括n1,n2)到n3行之下\"></a>4、复制n1-n2行(包括n1,n2)到n3行之下</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:n1,n2 <span class=\"keyword\">co</span> n3</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5、删除文件的空行\"><a href=\"#5、删除文件的空行\" class=\"headerlink\" title=\"5、删除文件的空行\"></a>5、删除文件的空行</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:g/^$/d</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\"></a>6、在文本中插入一个1到100的序列（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:r!seq <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7、在当前的每一行文字前面增加“序号-”（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#7、在当前的每一行文字前面增加“序号-”（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"7、在当前的每一行文字前面增加“序号. ”（来自池老师《说，谁才是最帅的编程工具？》）\"></a>7、在当前的每一行文字前面增加“序号. ”（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:<span class=\"keyword\">let</span> i=<span class=\"number\">1</span> | g /^/ s//\\=i.<span class=\"string\">&quot;. &quot;</span>/ | <span class=\"keyword\">let</span> i+=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8、当前目录下（包括子文件夹）所有后缀为-java-的文件中的-apache-替换成-eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#8、当前目录下（包括子文件夹）所有后缀为-java-的文件中的-apache-替换成-eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\"></a>8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">vim</span></span><br><span class=\"line\">:n **/*.java</span><br><span class=\"line\">:<span class=\"keyword\">argdo</span> %s/apache/eclipse/ge | <span class=\"keyword\">update</span> </span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1、替换第n1行到第n2行的内容\"><a href=\"#1、替换第n1行到第n2行的内容\" class=\"headerlink\" title=\"1、替换第n1行到第n2行的内容\"></a>1、替换第n1行到第n2行的内容</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:n1,n2/origin/replace/g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、替换整个文件的内容\"><a href=\"#2、替换整个文件的内容\" class=\"headerlink\" title=\"2、替换整个文件的内容\"></a>2、替换整个文件的内容</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:%s/origin/replace/g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3、移动n1-n2行-包括n1-n2-到n3行之下\"><a href=\"#3、移动n1-n2行-包括n1-n2-到n3行之下\" class=\"headerlink\" title=\"3、移动n1-n2行(包括n1,n2)到n3行之下\"></a>3、移动n1-n2行(包括n1,n2)到n3行之下</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n1,n2 <span class=\"keyword\">m</span> n3     </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4、复制n1-n2行-包括n1-n2-到n3行之下\"><a href=\"#4、复制n1-n2行-包括n1-n2-到n3行之下\" class=\"headerlink\" title=\"4、复制n1-n2行(包括n1,n2)到n3行之下\"></a>4、复制n1-n2行(包括n1,n2)到n3行之下</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:n1,n2 <span class=\"keyword\">co</span> n3</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5、删除文件的空行\"><a href=\"#5、删除文件的空行\" class=\"headerlink\" title=\"5、删除文件的空行\"></a>5、删除文件的空行</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:g/^$/d</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\"></a>6、在文本中插入一个1到100的序列（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:r!seq <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7、在当前的每一行文字前面增加“序号-”（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#7、在当前的每一行文字前面增加“序号-”（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"7、在当前的每一行文字前面增加“序号. ”（来自池老师《说，谁才是最帅的编程工具？》）\"></a>7、在当前的每一行文字前面增加“序号. ”（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:<span class=\"keyword\">let</span> i=<span class=\"number\">1</span> | g /^/ s//\\=i.<span class=\"string\">&quot;. &quot;</span>/ | <span class=\"keyword\">let</span> i+=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8、当前目录下（包括子文件夹）所有后缀为-java-的文件中的-apache-替换成-eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#8、当前目录下（包括子文件夹）所有后缀为-java-的文件中的-apache-替换成-eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\"></a>8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">vim</span></span><br><span class=\"line\">:n **/*.java</span><br><span class=\"line\">:<span class=\"keyword\">argdo</span> %s/apache/eclipse/ge | <span class=\"keyword\">update</span> </span><br></pre></td></tr></table></figure>\n\n"},{"title":"include 和 import 的区别","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n今天我们来了解下面这几种包含文件的方式有什么特点和区别：\n\n```Swift\n#include \"fiel\"\n#include <file>\n#import \"file\"\n#import <file>\n@import Module\n```\n\n---\n\n## 一、#include\n\n学过 C 语言的人都知道，#include 其实是一个预处理命令。它会在预处理的时候简单的把被 #include 包含的文件内容进行复制粘贴。我们来看看下面的代码：\n\n```C\n// A.h\nvoid sampleA() {\n  // A code\n}\n\n```\n\n```C\n// B.h\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们使用 gcc -E B.h 命令来看看经过预处理后的文件内容大概如下：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n我们可以看到经过预处理之后，A.h 文件中的内容被直接复制并粘贴到 B.h 文件中来。如果我们在 B.h 文件中多次包含了 A.h 文件，会出现什么情况？比如：\n\n```C\n// A.h\nvoid sampleA() {\n  // A code\n}\n```\n\n```C\n// B.h\n#include \"A.h\"\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n经过预处理之后的内容大概如下：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 3 \"B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\nA.h 文件中的 sampleA() 函数出现了两次，所以我们需要利用其他的一些预处理命令来规避这种情况，看看下面的代码：\n\n```C\n// A.h\n#ifndef FILE_A\n#define FILE_A\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```C\n// B.h\n#include \"A.h\"\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们再来看看增加了这些预处理命令之后的预处理文件内容：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n\n\n\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n\n\nvoid sampleB() {\n\n}\n```\n\nOK，这就正常了。如果我们在 A.h 中包含 B.h，然后又在 B.h 中包含 A.h，具体代码如下：\n\n```C\n// A.h\n#include \"B.h\"\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```\n// B.h\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们再来看看经过 gcc -E B.h 处理之后的文件内容：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\n...\n...\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\n...\n...\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\n./A.h:1:10: error: #include nested too deeply\n#include \"B.h\"\n         ^\n\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n...\n...\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n1 error generated.\n```\n\n我们发现 A.h 和 B.h 重复出现，这是因为这个时候 A.h 和 B.h 文件互相引用导致的。从理论上来讲，这个时候会无限循环下去，直至世界终结。在这里最后会出现一句 *1 error generated.*的提示是 gcc 强行中断了这个预处理的过程，所以我们才能看到这样的结果。那我们可以怎么做？当然是利用前面说的预处理命令来避免循环引用的问题。看下面的代码：\n\n```C\n// A.h\n#ifndef FILE_A\n#define FILE_A\n\n#include \"B.h\"\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```C\n// B.h\n#ifndef FILE_B\n#define FILE_B\n\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n#endif\n```\n\n这个时候使用 gcc -E B.h 就可以正常的进行预处理，最后的结果如下：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n\n\n\n# 1 \"./A.h\" 1\n\n\n\n# 1 \"./B.h\" 1\n# 5 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 5 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n所以C程序员总是需要通过各种手段（比如：[#pragma once](https://en.wikipedia.org/wiki/Pragma_once)）来防范此类事件的发生。\n\n\n## 二、#import\n\n我们在文件中通过#import来导入 iAd Framework：\n![](http://i.imgur.com/nLPSsNN.jpg)\n\n\n编译报错：\n![](http://i.imgur.com/XBXD8wu.jpg)\n\n需要重新导入和链接 Framework：\n![](http://i.imgur.com/rUnKJGb.jpg)\n![](http://i.imgur.com/XuxVI6b.jpg)\n\n编译成功：\n![](http://i.imgur.com/QvyQunr.jpg)\n\n从上面的过程中我们就知道在 Objective-C 项目中使用 #import 需要注意导入和链接 Framework，否则是会报错的。\n\n预处理器在碰到 #import 命令的时候，它会采用递归的方式把被所有头文件的内容复制并粘贴到当前文件中，如果文件依赖层次比较深就会造成预处理后的文件内容体积大幅度变大。\n\n比如导入 UIKit 的时候只需要一行代码：\n\n```Swift\n#import <UIKit/UIKit.h>\n```\n\n预处理之后会变成200多行（UIKit.h 文件有200多行代码）：\n\n```Swift\n#import <UIKit/UIKitDefines.h>\n\n#if __has_include(<UIKit/UIAccelerometer.h>)\n#import <UIKit/UIAccelerometer.h>\n.....\n#import <UIKit/UIRegion.h>\n#endif\n```\n\n接下来还需要递归的把每个头文件的内容展开，最后的结果就是一行代码变成超过11000行代码。如果有多个文件都包含来 UIKit 的头文件，这样就会让每个文件的体积都会变得很大，编译过程也会变得越来越慢。这种递归的方式会让项目的编译时间变成：*M source files + N headers => M x N compile time*。\n\n所以这个时候有一个优化方法就是把项目中频繁被引用的文件放到 PCH（Pre-Compile Header）文件中。PCH 会被编译一次并且会被缓存，这就可以缩短编译时间，我们也不需要在不同的文件里面添加import语法。\n\n当然，PCH 也有自己的缺点：\n\n* 维护负担：随着项目变得越来越复杂，我们就会不停的往PCH文件加入内容，内容一旦变多就会变得不好维护。（这也是我们平常在项目中要避免在 ViewController 做太多事情的，要研究 MVVM的缘故。）\n\n* 命名空间污染\n\n\n最后，给大家提供一个例子看看 #import 编译出来之后的文件内容：\n\n```C\n// A.h\n#import \"B.h\"\n \nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```C\n// B.h\n#import \"A.h\"\n#import \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n使用 gcc -E B.h 进行预处理之后的内容如下：\n\n```C\n\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n我们在B.h中有两个 #import \"A.h\"，但是这些内容跟我们之前在 A.h 和 B.h 文件中使用 #include 和其他预处理命令之后的处理结果很相似，所以我们就明白了 #import 大概做了什么事。\n\n## 三、@import\n\n在2012年的 LLVM 大会上，苹果的 Doug Gregor 首次提出了 Objective-C 中的 Module。使用 @import 方式导入有几个好处：\n\n* 不需要像 #import 一样得手动去链接 Framework，@import会自动去链接\n\n* @import 工作方式和 PCH 很像，但是 @import 要比 PCH 的效率高出许多\n\n* @import 导入 Modul 优化文件体积变大、编译速度变慢的问题\n\n* 可以部分导入（@import Framework.A）或全部导入（@import Framework）\n\n所以，建议大家尽量使用 @import 来导入文件。如果你以前的项目用的是 #import，那么你也不需要担心，我们只通过 Build Settings 开启 Modules 选项（看下图），#import 和 #include 会自动被映射成 @import，所以你不需要更改原来的代码也能享受 @import带来的好处。\n\n![](http://i.imgur.com/l7ZMUy6.jpg)\n\n详细内容可以看看苹果2013年的 [Advances in Objective-C](https://developer.apple.com/videos/play/wwdc2013/404/)，里面就详细介绍了 Module。\n\n## 四、文件路径\n\n接下来我们来了解一下 *#include <file>* 和 *#include \"file\"*：\n\n* \\#include \\<file>: 表示编译器会直接到系统设定的目录下寻找指定的文件。\n\n* \\#include \"file\": 表示编译器会到当前的目录下寻找指定的文件，如果找不到，则会去系统设定的目录下寻找指定的文件。\n\n---\n参考文献：\n\n1. https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html\n\n2. http://stackoverflow.com/questions/18947516/import-vs-import-ios-7\n\n3. https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7\n\n","source":"_posts/include和import的区别.md","raw":"---\ntitle: include 和 import 的区别\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: 技术 \ntags: [iOS]\n---\n\n今天我们来了解下面这几种包含文件的方式有什么特点和区别：\n\n```Swift\n#include \"fiel\"\n#include <file>\n#import \"file\"\n#import <file>\n@import Module\n```\n\n---\n\n## 一、#include\n\n学过 C 语言的人都知道，#include 其实是一个预处理命令。它会在预处理的时候简单的把被 #include 包含的文件内容进行复制粘贴。我们来看看下面的代码：\n\n```C\n// A.h\nvoid sampleA() {\n  // A code\n}\n\n```\n\n```C\n// B.h\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们使用 gcc -E B.h 命令来看看经过预处理后的文件内容大概如下：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n我们可以看到经过预处理之后，A.h 文件中的内容被直接复制并粘贴到 B.h 文件中来。如果我们在 B.h 文件中多次包含了 A.h 文件，会出现什么情况？比如：\n\n```C\n// A.h\nvoid sampleA() {\n  // A code\n}\n```\n\n```C\n// B.h\n#include \"A.h\"\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n经过预处理之后的内容大概如下：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 3 \"B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\nA.h 文件中的 sampleA() 函数出现了两次，所以我们需要利用其他的一些预处理命令来规避这种情况，看看下面的代码：\n\n```C\n// A.h\n#ifndef FILE_A\n#define FILE_A\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```C\n// B.h\n#include \"A.h\"\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们再来看看增加了这些预处理命令之后的预处理文件内容：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n\n\n\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n\n\nvoid sampleB() {\n\n}\n```\n\nOK，这就正常了。如果我们在 A.h 中包含 B.h，然后又在 B.h 中包含 A.h，具体代码如下：\n\n```C\n// A.h\n#include \"B.h\"\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```\n// B.h\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们再来看看经过 gcc -E B.h 处理之后的文件内容：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\n...\n...\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\n...\n...\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\n./A.h:1:10: error: #include nested too deeply\n#include \"B.h\"\n         ^\n\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n...\n...\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n1 error generated.\n```\n\n我们发现 A.h 和 B.h 重复出现，这是因为这个时候 A.h 和 B.h 文件互相引用导致的。从理论上来讲，这个时候会无限循环下去，直至世界终结。在这里最后会出现一句 *1 error generated.*的提示是 gcc 强行中断了这个预处理的过程，所以我们才能看到这样的结果。那我们可以怎么做？当然是利用前面说的预处理命令来避免循环引用的问题。看下面的代码：\n\n```C\n// A.h\n#ifndef FILE_A\n#define FILE_A\n\n#include \"B.h\"\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```C\n// B.h\n#ifndef FILE_B\n#define FILE_B\n\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n#endif\n```\n\n这个时候使用 gcc -E B.h 就可以正常的进行预处理，最后的结果如下：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n\n\n\n# 1 \"./A.h\" 1\n\n\n\n# 1 \"./B.h\" 1\n# 5 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 5 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n所以C程序员总是需要通过各种手段（比如：[#pragma once](https://en.wikipedia.org/wiki/Pragma_once)）来防范此类事件的发生。\n\n\n## 二、#import\n\n我们在文件中通过#import来导入 iAd Framework：\n![](http://i.imgur.com/nLPSsNN.jpg)\n\n\n编译报错：\n![](http://i.imgur.com/XBXD8wu.jpg)\n\n需要重新导入和链接 Framework：\n![](http://i.imgur.com/rUnKJGb.jpg)\n![](http://i.imgur.com/XuxVI6b.jpg)\n\n编译成功：\n![](http://i.imgur.com/QvyQunr.jpg)\n\n从上面的过程中我们就知道在 Objective-C 项目中使用 #import 需要注意导入和链接 Framework，否则是会报错的。\n\n预处理器在碰到 #import 命令的时候，它会采用递归的方式把被所有头文件的内容复制并粘贴到当前文件中，如果文件依赖层次比较深就会造成预处理后的文件内容体积大幅度变大。\n\n比如导入 UIKit 的时候只需要一行代码：\n\n```Swift\n#import <UIKit/UIKit.h>\n```\n\n预处理之后会变成200多行（UIKit.h 文件有200多行代码）：\n\n```Swift\n#import <UIKit/UIKitDefines.h>\n\n#if __has_include(<UIKit/UIAccelerometer.h>)\n#import <UIKit/UIAccelerometer.h>\n.....\n#import <UIKit/UIRegion.h>\n#endif\n```\n\n接下来还需要递归的把每个头文件的内容展开，最后的结果就是一行代码变成超过11000行代码。如果有多个文件都包含来 UIKit 的头文件，这样就会让每个文件的体积都会变得很大，编译过程也会变得越来越慢。这种递归的方式会让项目的编译时间变成：*M source files + N headers => M x N compile time*。\n\n所以这个时候有一个优化方法就是把项目中频繁被引用的文件放到 PCH（Pre-Compile Header）文件中。PCH 会被编译一次并且会被缓存，这就可以缩短编译时间，我们也不需要在不同的文件里面添加import语法。\n\n当然，PCH 也有自己的缺点：\n\n* 维护负担：随着项目变得越来越复杂，我们就会不停的往PCH文件加入内容，内容一旦变多就会变得不好维护。（这也是我们平常在项目中要避免在 ViewController 做太多事情的，要研究 MVVM的缘故。）\n\n* 命名空间污染\n\n\n最后，给大家提供一个例子看看 #import 编译出来之后的文件内容：\n\n```C\n// A.h\n#import \"B.h\"\n \nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```C\n// B.h\n#import \"A.h\"\n#import \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n使用 gcc -E B.h 进行预处理之后的内容如下：\n\n```C\n\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n我们在B.h中有两个 #import \"A.h\"，但是这些内容跟我们之前在 A.h 和 B.h 文件中使用 #include 和其他预处理命令之后的处理结果很相似，所以我们就明白了 #import 大概做了什么事。\n\n## 三、@import\n\n在2012年的 LLVM 大会上，苹果的 Doug Gregor 首次提出了 Objective-C 中的 Module。使用 @import 方式导入有几个好处：\n\n* 不需要像 #import 一样得手动去链接 Framework，@import会自动去链接\n\n* @import 工作方式和 PCH 很像，但是 @import 要比 PCH 的效率高出许多\n\n* @import 导入 Modul 优化文件体积变大、编译速度变慢的问题\n\n* 可以部分导入（@import Framework.A）或全部导入（@import Framework）\n\n所以，建议大家尽量使用 @import 来导入文件。如果你以前的项目用的是 #import，那么你也不需要担心，我们只通过 Build Settings 开启 Modules 选项（看下图），#import 和 #include 会自动被映射成 @import，所以你不需要更改原来的代码也能享受 @import带来的好处。\n\n![](http://i.imgur.com/l7ZMUy6.jpg)\n\n详细内容可以看看苹果2013年的 [Advances in Objective-C](https://developer.apple.com/videos/play/wwdc2013/404/)，里面就详细介绍了 Module。\n\n## 四、文件路径\n\n接下来我们来了解一下 *#include <file>* 和 *#include \"file\"*：\n\n* \\#include \\<file>: 表示编译器会直接到系统设定的目录下寻找指定的文件。\n\n* \\#include \"file\": 表示编译器会到当前的目录下寻找指定的文件，如果找不到，则会去系统设定的目录下寻找指定的文件。\n\n---\n参考文献：\n\n1. https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html\n\n2. http://stackoverflow.com/questions/18947516/import-vs-import-ios-7\n\n3. https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7\n\n","slug":"include和import的区别","published":1,"updated":"2022-04-20T07:08:33.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxeg000z6enqhauj1v5g","content":"<p>今天我们来了解下面这几种包含文件的方式有什么特点和区别：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include <span class=\"string\">&quot;fiel&quot;</span></span><br><span class=\"line\">#include <span class=\"operator\">&lt;</span>file<span class=\"operator\">&gt;</span></span><br><span class=\"line\">#<span class=\"keyword\">import</span> &quot;file&quot;</span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;file&gt;</span><br><span class=\"line\"><span class=\"meta\">@import</span> <span class=\"type\">Module</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"一、-include\"><a href=\"#一、-include\" class=\"headerlink\" title=\"一、#include\"></a>一、#include</h2><p>学过 C 语言的人都知道，#include 其实是一个预处理命令。它会在预处理的时候简单的把被 #include 包含的文件内容进行复制粘贴。我们来看看下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们使用 gcc -E B.h 命令来看看经过预处理后的文件内容大概如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到经过预处理之后，A.h 文件中的内容被直接复制并粘贴到 B.h 文件中来。如果我们在 B.h 文件中多次包含了 A.h 文件，会出现什么情况？比如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经过预处理之后的内容大概如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">3</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>A.h 文件中的 sampleA() 函数出现了两次，所以我们需要利用其他的一些预处理命令来规避这种情况，看看下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> FILE_A</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FILE_A</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再来看看增加了这些预处理命令之后的预处理文件内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OK，这就正常了。如果我们在 A.h 中包含 B.h，然后又在 B.h 中包含 A.h，具体代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;B.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// B.h</span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\">  // B code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再来看看经过 gcc -E B.h 处理之后的文件内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\">In file included from ./B.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">In file included from ./A.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">In file included from ./B.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">In file included from ./A.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">In file included from ./B.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">In file included from ./A.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">./A.h:<span class=\"number\">1</span>:<span class=\"number\">10</span>: error: <span class=\"meta\">#<span class=\"keyword\">include</span> nested too deeply</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;B.h&quot;</span></span></span><br><span class=\"line\">         ^</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1</span> error generated.</span><br></pre></td></tr></table></figure>\n\n<p>我们发现 A.h 和 B.h 重复出现，这是因为这个时候 A.h 和 B.h 文件互相引用导致的。从理论上来讲，这个时候会无限循环下去，直至世界终结。在这里最后会出现一句 *1 error generated.*的提示是 gcc 强行中断了这个预处理的过程，所以我们才能看到这样的结果。那我们可以怎么做？当然是利用前面说的预处理命令来避免循环引用的问题。看下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> FILE_A</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FILE_A</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;B.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> FILE_B</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FILE_B</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这个时候使用 gcc -E B.h 就可以正常的进行预处理，最后的结果如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">5</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">5</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以C程序员总是需要通过各种手段（比如：<a href=\"https://en.wikipedia.org/wiki/Pragma_once\">#pragma once</a>）来防范此类事件的发生。</p>\n<h2 id=\"二、-import\"><a href=\"#二、-import\" class=\"headerlink\" title=\"二、#import\"></a>二、#import</h2><p>我们在文件中通过#import来导入 iAd Framework：<br><img src=\"http://i.imgur.com/nLPSsNN.jpg\"></p>\n<p>编译报错：<br><img src=\"http://i.imgur.com/XBXD8wu.jpg\"></p>\n<p>需要重新导入和链接 Framework：<br><img src=\"http://i.imgur.com/rUnKJGb.jpg\"><br><img src=\"http://i.imgur.com/XuxVI6b.jpg\"></p>\n<p>编译成功：<br><img src=\"http://i.imgur.com/QvyQunr.jpg\"></p>\n<p>从上面的过程中我们就知道在 Objective-C 项目中使用 #import 需要注意导入和链接 Framework，否则是会报错的。</p>\n<p>预处理器在碰到 #import 命令的时候，它会采用递归的方式把被所有头文件的内容复制并粘贴到当前文件中，如果文件依赖层次比较深就会造成预处理后的文件内容体积大幅度变大。</p>\n<p>比如导入 UIKit 的时候只需要一行代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">import</span> &lt;UIKit/UIKit.h&gt;</span><br></pre></td></tr></table></figure>\n\n<p>预处理之后会变成200多行（UIKit.h 文件有200多行代码）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">import</span> &lt;UIKit/UIKitDefines.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">#if</span> __has_include(<span class=\"operator\">&lt;</span><span class=\"type\">UIKit</span><span class=\"operator\">/</span><span class=\"type\">UIAccelerometer</span>.h<span class=\"operator\">&gt;</span>)</span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;UIKit/UIAccelerometer.h&gt;</span><br><span class=\"line\"><span class=\"operator\">.....</span></span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;UIKit/UIRegion.h&gt;</span><br><span class=\"line\"><span class=\"keyword\">#endif</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来还需要递归的把每个头文件的内容展开，最后的结果就是一行代码变成超过11000行代码。如果有多个文件都包含来 UIKit 的头文件，这样就会让每个文件的体积都会变得很大，编译过程也会变得越来越慢。这种递归的方式会让项目的编译时间变成：<em>M source files + N headers &#x3D;&gt; M x N compile time</em>。</p>\n<p>所以这个时候有一个优化方法就是把项目中频繁被引用的文件放到 PCH（Pre-Compile Header）文件中。PCH 会被编译一次并且会被缓存，这就可以缩短编译时间，我们也不需要在不同的文件里面添加import语法。</p>\n<p>当然，PCH 也有自己的缺点：</p>\n<ul>\n<li><p>维护负担：随着项目变得越来越复杂，我们就会不停的往PCH文件加入内容，内容一旦变多就会变得不好维护。（这也是我们平常在项目中要避免在 ViewController 做太多事情的，要研究 MVVM的缘故。）</p>\n</li>\n<li><p>命名空间污染</p>\n</li>\n</ul>\n<p>最后，给大家提供一个例子看看 #import 编译出来之后的文件内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;B.h&quot;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 gcc -E B.h 进行预处理之后的内容如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在B.h中有两个 #import “A.h”，但是这些内容跟我们之前在 A.h 和 B.h 文件中使用 #include 和其他预处理命令之后的处理结果很相似，所以我们就明白了 #import 大概做了什么事。</p>\n<h2 id=\"三、-import\"><a href=\"#三、-import\" class=\"headerlink\" title=\"三、@import\"></a>三、@import</h2><p>在2012年的 LLVM 大会上，苹果的 Doug Gregor 首次提出了 Objective-C 中的 Module。使用 @import 方式导入有几个好处：</p>\n<ul>\n<li><p>不需要像 #import 一样得手动去链接 Framework，@import会自动去链接</p>\n</li>\n<li><p>@import 工作方式和 PCH 很像，但是 @import 要比 PCH 的效率高出许多</p>\n</li>\n<li><p>@import 导入 Modul 优化文件体积变大、编译速度变慢的问题</p>\n</li>\n<li><p>可以部分导入（@import Framework.A）或全部导入（@import Framework）</p>\n</li>\n</ul>\n<p>所以，建议大家尽量使用 @import 来导入文件。如果你以前的项目用的是 #import，那么你也不需要担心，我们只通过 Build Settings 开启 Modules 选项（看下图），#import 和 #include 会自动被映射成 @import，所以你不需要更改原来的代码也能享受 @import带来的好处。</p>\n<p><img src=\"http://i.imgur.com/l7ZMUy6.jpg\"></p>\n<p>详细内容可以看看苹果2013年的 <a href=\"https://developer.apple.com/videos/play/wwdc2013/404/\">Advances in Objective-C</a>，里面就详细介绍了 Module。</p>\n<h2 id=\"四、文件路径\"><a href=\"#四、文件路径\" class=\"headerlink\" title=\"四、文件路径\"></a>四、文件路径</h2><p>接下来我们来了解一下 <em>#include <file></em> 和 *#include “file”*：</p>\n<ul>\n<li><p>#include &lt;file&gt;: 表示编译器会直接到系统设定的目录下寻找指定的文件。</p>\n</li>\n<li><p>#include “file”: 表示编译器会到当前的目录下寻找指定的文件，如果找不到，则会去系统设定的目录下寻找指定的文件。</p>\n</li>\n</ul>\n<hr>\n<p>参考文献：</p>\n<ol>\n<li><p><a href=\"https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html\">https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html</a></p>\n</li>\n<li><p><a href=\"http://stackoverflow.com/questions/18947516/import-vs-import-ios-7\">http://stackoverflow.com/questions/18947516/import-vs-import-ios-7</a></p>\n</li>\n<li><p><a href=\"https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7\">https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>今天我们来了解下面这几种包含文件的方式有什么特点和区别：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include <span class=\"string\">&quot;fiel&quot;</span></span><br><span class=\"line\">#include <span class=\"operator\">&lt;</span>file<span class=\"operator\">&gt;</span></span><br><span class=\"line\">#<span class=\"keyword\">import</span> &quot;file&quot;</span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;file&gt;</span><br><span class=\"line\"><span class=\"meta\">@import</span> <span class=\"type\">Module</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"一、-include\"><a href=\"#一、-include\" class=\"headerlink\" title=\"一、#include\"></a>一、#include</h2><p>学过 C 语言的人都知道，#include 其实是一个预处理命令。它会在预处理的时候简单的把被 #include 包含的文件内容进行复制粘贴。我们来看看下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们使用 gcc -E B.h 命令来看看经过预处理后的文件内容大概如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到经过预处理之后，A.h 文件中的内容被直接复制并粘贴到 B.h 文件中来。如果我们在 B.h 文件中多次包含了 A.h 文件，会出现什么情况？比如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经过预处理之后的内容大概如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">3</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>A.h 文件中的 sampleA() 函数出现了两次，所以我们需要利用其他的一些预处理命令来规避这种情况，看看下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> FILE_A</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FILE_A</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再来看看增加了这些预处理命令之后的预处理文件内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OK，这就正常了。如果我们在 A.h 中包含 B.h，然后又在 B.h 中包含 A.h，具体代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;B.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// B.h</span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\">  // B code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再来看看经过 gcc -E B.h 处理之后的文件内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\">In file included from ./B.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">In file included from ./A.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">In file included from ./B.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">In file included from ./A.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">In file included from ./B.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">In file included from ./A.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">./A.h:<span class=\"number\">1</span>:<span class=\"number\">10</span>: error: <span class=\"meta\">#<span class=\"keyword\">include</span> nested too deeply</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;B.h&quot;</span></span></span><br><span class=\"line\">         ^</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1</span> error generated.</span><br></pre></td></tr></table></figure>\n\n<p>我们发现 A.h 和 B.h 重复出现，这是因为这个时候 A.h 和 B.h 文件互相引用导致的。从理论上来讲，这个时候会无限循环下去，直至世界终结。在这里最后会出现一句 *1 error generated.*的提示是 gcc 强行中断了这个预处理的过程，所以我们才能看到这样的结果。那我们可以怎么做？当然是利用前面说的预处理命令来避免循环引用的问题。看下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> FILE_A</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FILE_A</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;B.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> FILE_B</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FILE_B</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这个时候使用 gcc -E B.h 就可以正常的进行预处理，最后的结果如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">5</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">5</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以C程序员总是需要通过各种手段（比如：<a href=\"https://en.wikipedia.org/wiki/Pragma_once\">#pragma once</a>）来防范此类事件的发生。</p>\n<h2 id=\"二、-import\"><a href=\"#二、-import\" class=\"headerlink\" title=\"二、#import\"></a>二、#import</h2><p>我们在文件中通过#import来导入 iAd Framework：<br><img src=\"http://i.imgur.com/nLPSsNN.jpg\"></p>\n<p>编译报错：<br><img src=\"http://i.imgur.com/XBXD8wu.jpg\"></p>\n<p>需要重新导入和链接 Framework：<br><img src=\"http://i.imgur.com/rUnKJGb.jpg\"><br><img src=\"http://i.imgur.com/XuxVI6b.jpg\"></p>\n<p>编译成功：<br><img src=\"http://i.imgur.com/QvyQunr.jpg\"></p>\n<p>从上面的过程中我们就知道在 Objective-C 项目中使用 #import 需要注意导入和链接 Framework，否则是会报错的。</p>\n<p>预处理器在碰到 #import 命令的时候，它会采用递归的方式把被所有头文件的内容复制并粘贴到当前文件中，如果文件依赖层次比较深就会造成预处理后的文件内容体积大幅度变大。</p>\n<p>比如导入 UIKit 的时候只需要一行代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">import</span> &lt;UIKit/UIKit.h&gt;</span><br></pre></td></tr></table></figure>\n\n<p>预处理之后会变成200多行（UIKit.h 文件有200多行代码）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">import</span> &lt;UIKit/UIKitDefines.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">#if</span> __has_include(<span class=\"operator\">&lt;</span><span class=\"type\">UIKit</span><span class=\"operator\">/</span><span class=\"type\">UIAccelerometer</span>.h<span class=\"operator\">&gt;</span>)</span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;UIKit/UIAccelerometer.h&gt;</span><br><span class=\"line\"><span class=\"operator\">.....</span></span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;UIKit/UIRegion.h&gt;</span><br><span class=\"line\"><span class=\"keyword\">#endif</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来还需要递归的把每个头文件的内容展开，最后的结果就是一行代码变成超过11000行代码。如果有多个文件都包含来 UIKit 的头文件，这样就会让每个文件的体积都会变得很大，编译过程也会变得越来越慢。这种递归的方式会让项目的编译时间变成：<em>M source files + N headers &#x3D;&gt; M x N compile time</em>。</p>\n<p>所以这个时候有一个优化方法就是把项目中频繁被引用的文件放到 PCH（Pre-Compile Header）文件中。PCH 会被编译一次并且会被缓存，这就可以缩短编译时间，我们也不需要在不同的文件里面添加import语法。</p>\n<p>当然，PCH 也有自己的缺点：</p>\n<ul>\n<li><p>维护负担：随着项目变得越来越复杂，我们就会不停的往PCH文件加入内容，内容一旦变多就会变得不好维护。（这也是我们平常在项目中要避免在 ViewController 做太多事情的，要研究 MVVM的缘故。）</p>\n</li>\n<li><p>命名空间污染</p>\n</li>\n</ul>\n<p>最后，给大家提供一个例子看看 #import 编译出来之后的文件内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;B.h&quot;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 gcc -E B.h 进行预处理之后的内容如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在B.h中有两个 #import “A.h”，但是这些内容跟我们之前在 A.h 和 B.h 文件中使用 #include 和其他预处理命令之后的处理结果很相似，所以我们就明白了 #import 大概做了什么事。</p>\n<h2 id=\"三、-import\"><a href=\"#三、-import\" class=\"headerlink\" title=\"三、@import\"></a>三、@import</h2><p>在2012年的 LLVM 大会上，苹果的 Doug Gregor 首次提出了 Objective-C 中的 Module。使用 @import 方式导入有几个好处：</p>\n<ul>\n<li><p>不需要像 #import 一样得手动去链接 Framework，@import会自动去链接</p>\n</li>\n<li><p>@import 工作方式和 PCH 很像，但是 @import 要比 PCH 的效率高出许多</p>\n</li>\n<li><p>@import 导入 Modul 优化文件体积变大、编译速度变慢的问题</p>\n</li>\n<li><p>可以部分导入（@import Framework.A）或全部导入（@import Framework）</p>\n</li>\n</ul>\n<p>所以，建议大家尽量使用 @import 来导入文件。如果你以前的项目用的是 #import，那么你也不需要担心，我们只通过 Build Settings 开启 Modules 选项（看下图），#import 和 #include 会自动被映射成 @import，所以你不需要更改原来的代码也能享受 @import带来的好处。</p>\n<p><img src=\"http://i.imgur.com/l7ZMUy6.jpg\"></p>\n<p>详细内容可以看看苹果2013年的 <a href=\"https://developer.apple.com/videos/play/wwdc2013/404/\">Advances in Objective-C</a>，里面就详细介绍了 Module。</p>\n<h2 id=\"四、文件路径\"><a href=\"#四、文件路径\" class=\"headerlink\" title=\"四、文件路径\"></a>四、文件路径</h2><p>接下来我们来了解一下 <em>#include <file></em> 和 *#include “file”*：</p>\n<ul>\n<li><p>#include &lt;file&gt;: 表示编译器会直接到系统设定的目录下寻找指定的文件。</p>\n</li>\n<li><p>#include “file”: 表示编译器会到当前的目录下寻找指定的文件，如果找不到，则会去系统设定的目录下寻找指定的文件。</p>\n</li>\n</ul>\n<hr>\n<p>参考文献：</p>\n<ol>\n<li><p><a href=\"https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html\">https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html</a></p>\n</li>\n<li><p><a href=\"http://stackoverflow.com/questions/18947516/import-vs-import-ios-7\">http://stackoverflow.com/questions/18947516/import-vs-import-ios-7</a></p>\n</li>\n<li><p><a href=\"https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7\">https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7</a></p>\n</li>\n</ol>\n"},{"title":"redux 之页面跳转","author":"帕帕","date":"2018-02-26T17:48:56.000Z","thumbnail":"https://images.unsplash.com/photo-1493235431945-90c060301e41?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=0279978342b1a6b4f3e0e00a0784c2e3&auto=format&fit=crop&w=160&q=100","_content":"\n最近正在用 React Native 重构整个项目，我们用了 **[react-native-navigation](https://github.com/krystofcelba/react-native-navigation#rn52)** 这个库来作为项目的导航控制器。\n所以，我们平常会把页面跳转逻辑的时候放在 Screen 里面的，比如:\n\n```Javascript\nclass FirstScreen extends React.Component {\n    \n    // 点击事件\n    _someAction = () => {\n        this.props.navigator.push({\n          screen: 'example.SecondScreen',\n        });\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n一般情况下，上面的写法没有问题。但是直到我们碰到这样一个需求的时候就抓瞎了：点击一个 PDF 文件，如果 PDF 文件没有下载就先去下载，下载完成之后自动跳转到 PDF 阅读器。由于用了 redux 之后，我们就增加一个 finished 的 state 来判断是否已经下载完成。示例代码如下：\n\n```Javascript\nclass ExampleScreen extends React.Component {\n\n    componentWillReceiveProps = (nextProps) => {\n        // 这里判断下载状态是否已完成，完成的话就去跳转\n        if (nextProps.finished === true) {\n            // 这里需要重置一下状态，不然其他 state 发生变化会多次触发页面的跳转\n            this.props.dispatch(resetFinished());\n            this.props.navigator.push({\n              screen: 'example.PDFScreen',\n            });\n        }\n    }\n    \n    // 点击事件\n    _someAction = () => {\n        // openPDF() 这个 action 会自动去下载 PDF 文件，然后修改 finished 的状态\n        this.props.dispatch(openPDF());\n    }\n    \n    render = () => {\n        ...\n    }\n}\n\nconst mapStateToProps = state => {\n  return {\n    finished: state.finished\n  }\n};\n\nexport default connect(mapStateToProps)(ExampleScreen);\n```\n\n上面的做法是可以实现我们的需求，但是这种写法很蛋疼。因为当你在调用用 openPDF() 的时候，你以为后面的事不需要你操心，然后这个时候有人告诉你还需要在其他地方增加一个中间状态去补充 openPDF() 的后续逻辑处理。\n\n经过讨论之后，我们决定改成用 callback 的方式来实现：\n\n```Javascript\nclass ExampleScreen extends React.Component {\n\n    // 点击事件\n    _someAction = () => {\n        // openPDF() 是一个异步 action\n        this.props.dispatch(openPDF(callback: () => {\n            this.props.navigator.push({\n              screen: 'example.PDFScreen',\n            });\n        }));\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n使用 callback 的好处就是去掉了一个烦人的中间状态，并且从阅读体验来说很容易让读者明白这个点击事件在干什么。但是在 redux 的 action 方法中增加一个 callback 的调用，看起来也有点不伦不类的。虽然我认为 callback 和其他参数具有相同的法律地位。\n\n其实最好的实现是，这个点击事件应该连页面的跳转逻辑也不需要处理：\n\n```Javascript\nclass ExampleScreen extends React.Component {\n\n    // 点击事件，这个事件只做一件事就是去 dispatch 一个 openPDF() 的 action\n    _someAction = () => {\n        this.props.dispatch(openPDF());\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n像上面这种实现，我们也就只能在 openPDF() 里动手脚了：\n\n```Javascript\n// action.js\nexport const openPDF = await () => {\n    return dispatch => {\n        // 异步下载 PDF\n        async downloadPDF();\n        // 完成之后通过 router 去实现页面跳转\n        dispatch(openRouter('PDFScreen'));\n    };\n}\n```\n\n> 这里就不再详细说 router 的实现细节了，因为网上有很多现成的资料。（PS: 主要是我也还没看到这一块）\n\n从页面（Screen）的角度来说，我认为这样的处理是最合适的。因为 Screen 只需要关注本页面的 state 和 action，至于跳转的逻辑交给后面的 action 来处理是最好的。\n\n\n\n\n","source":"_posts/redux-之页面跳转.md","raw":"---\ntitle: redux 之页面跳转\nauthor: 帕帕\ndate: 2018-02-26 17:48:56 +0800\ncategories: 技术\ntags: [RN, redux]\nthumbnail: https://images.unsplash.com/photo-1493235431945-90c060301e41?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=0279978342b1a6b4f3e0e00a0784c2e3&auto=format&fit=crop&w=160&q=100\n---\n\n最近正在用 React Native 重构整个项目，我们用了 **[react-native-navigation](https://github.com/krystofcelba/react-native-navigation#rn52)** 这个库来作为项目的导航控制器。\n所以，我们平常会把页面跳转逻辑的时候放在 Screen 里面的，比如:\n\n```Javascript\nclass FirstScreen extends React.Component {\n    \n    // 点击事件\n    _someAction = () => {\n        this.props.navigator.push({\n          screen: 'example.SecondScreen',\n        });\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n一般情况下，上面的写法没有问题。但是直到我们碰到这样一个需求的时候就抓瞎了：点击一个 PDF 文件，如果 PDF 文件没有下载就先去下载，下载完成之后自动跳转到 PDF 阅读器。由于用了 redux 之后，我们就增加一个 finished 的 state 来判断是否已经下载完成。示例代码如下：\n\n```Javascript\nclass ExampleScreen extends React.Component {\n\n    componentWillReceiveProps = (nextProps) => {\n        // 这里判断下载状态是否已完成，完成的话就去跳转\n        if (nextProps.finished === true) {\n            // 这里需要重置一下状态，不然其他 state 发生变化会多次触发页面的跳转\n            this.props.dispatch(resetFinished());\n            this.props.navigator.push({\n              screen: 'example.PDFScreen',\n            });\n        }\n    }\n    \n    // 点击事件\n    _someAction = () => {\n        // openPDF() 这个 action 会自动去下载 PDF 文件，然后修改 finished 的状态\n        this.props.dispatch(openPDF());\n    }\n    \n    render = () => {\n        ...\n    }\n}\n\nconst mapStateToProps = state => {\n  return {\n    finished: state.finished\n  }\n};\n\nexport default connect(mapStateToProps)(ExampleScreen);\n```\n\n上面的做法是可以实现我们的需求，但是这种写法很蛋疼。因为当你在调用用 openPDF() 的时候，你以为后面的事不需要你操心，然后这个时候有人告诉你还需要在其他地方增加一个中间状态去补充 openPDF() 的后续逻辑处理。\n\n经过讨论之后，我们决定改成用 callback 的方式来实现：\n\n```Javascript\nclass ExampleScreen extends React.Component {\n\n    // 点击事件\n    _someAction = () => {\n        // openPDF() 是一个异步 action\n        this.props.dispatch(openPDF(callback: () => {\n            this.props.navigator.push({\n              screen: 'example.PDFScreen',\n            });\n        }));\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n使用 callback 的好处就是去掉了一个烦人的中间状态，并且从阅读体验来说很容易让读者明白这个点击事件在干什么。但是在 redux 的 action 方法中增加一个 callback 的调用，看起来也有点不伦不类的。虽然我认为 callback 和其他参数具有相同的法律地位。\n\n其实最好的实现是，这个点击事件应该连页面的跳转逻辑也不需要处理：\n\n```Javascript\nclass ExampleScreen extends React.Component {\n\n    // 点击事件，这个事件只做一件事就是去 dispatch 一个 openPDF() 的 action\n    _someAction = () => {\n        this.props.dispatch(openPDF());\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n像上面这种实现，我们也就只能在 openPDF() 里动手脚了：\n\n```Javascript\n// action.js\nexport const openPDF = await () => {\n    return dispatch => {\n        // 异步下载 PDF\n        async downloadPDF();\n        // 完成之后通过 router 去实现页面跳转\n        dispatch(openRouter('PDFScreen'));\n    };\n}\n```\n\n> 这里就不再详细说 router 的实现细节了，因为网上有很多现成的资料。（PS: 主要是我也还没看到这一块）\n\n从页面（Screen）的角度来说，我认为这样的处理是最合适的。因为 Screen 只需要关注本页面的 state 和 action，至于跳转的逻辑交给后面的 action 来处理是最好的。\n\n\n\n\n","slug":"redux-之页面跳转","published":1,"updated":"2022-04-20T07:08:33.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxeh00136enq71h9exp0","content":"<p>最近正在用 React Native 重构整个项目，我们用了 <strong><a href=\"https://github.com/krystofcelba/react-native-navigation#rn52\">react-native-navigation</a></strong> 这个库来作为项目的导航控制器。<br>所以，我们平常会把页面跳转逻辑的时候放在 Screen 里面的，比如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FirstScreen</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 点击事件</span></span><br><span class=\"line\">    _someAction = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">navigator</span>.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">          <span class=\"attr\">screen</span>: <span class=\"string\">&#x27;example.SecondScreen&#x27;</span>,</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一般情况下，上面的写法没有问题。但是直到我们碰到这样一个需求的时候就抓瞎了：点击一个 PDF 文件，如果 PDF 文件没有下载就先去下载，下载完成之后自动跳转到 PDF 阅读器。由于用了 redux 之后，我们就增加一个 finished 的 state 来判断是否已经下载完成。示例代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExampleScreen</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillReceiveProps = <span class=\"function\">(<span class=\"params\">nextProps</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里判断下载状态是否已完成，完成的话就去跳转</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextProps.<span class=\"property\">finished</span> === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里需要重置一下状态，不然其他 state 发生变化会多次触发页面的跳转</span></span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">dispatch</span>(<span class=\"title function_\">resetFinished</span>());</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">navigator</span>.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">              <span class=\"attr\">screen</span>: <span class=\"string\">&#x27;example.PDFScreen&#x27;</span>,</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 点击事件</span></span><br><span class=\"line\">    _someAction = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// openPDF() 这个 action 会自动去下载 PDF 文件，然后修改 finished 的状态</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">dispatch</span>(<span class=\"title function_\">openPDF</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">mapStateToProps</span> = state =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">finished</span>: state.<span class=\"property\">finished</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">connect</span>(mapStateToProps)(<span class=\"title class_\">ExampleScreen</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面的做法是可以实现我们的需求，但是这种写法很蛋疼。因为当你在调用用 openPDF() 的时候，你以为后面的事不需要你操心，然后这个时候有人告诉你还需要在其他地方增加一个中间状态去补充 openPDF() 的后续逻辑处理。</p>\n<p>经过讨论之后，我们决定改成用 callback 的方式来实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExampleScreen</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 点击事件</span></span><br><span class=\"line\">    _someAction = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// openPDF() 是一个异步 action</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">dispatch</span>(<span class=\"title function_\">openPDF</span>(<span class=\"attr\">callback</span>: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">navigator</span>.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">              <span class=\"attr\">screen</span>: <span class=\"string\">&#x27;example.PDFScreen&#x27;</span>,</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 callback 的好处就是去掉了一个烦人的中间状态，并且从阅读体验来说很容易让读者明白这个点击事件在干什么。但是在 redux 的 action 方法中增加一个 callback 的调用，看起来也有点不伦不类的。虽然我认为 callback 和其他参数具有相同的法律地位。</p>\n<p>其实最好的实现是，这个点击事件应该连页面的跳转逻辑也不需要处理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExampleScreen</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 点击事件，这个事件只做一件事就是去 dispatch 一个 openPDF() 的 action</span></span><br><span class=\"line\">    _someAction = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">dispatch</span>(<span class=\"title function_\">openPDF</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>像上面这种实现，我们也就只能在 openPDF() 里动手脚了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// action.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> openPDF = <span class=\"keyword\">await</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">dispatch</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 异步下载 PDF</span></span><br><span class=\"line\">        <span class=\"keyword\">async</span> <span class=\"title function_\">downloadPDF</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 完成之后通过 router 去实现页面跳转</span></span><br><span class=\"line\">        <span class=\"title function_\">dispatch</span>(<span class=\"title function_\">openRouter</span>(<span class=\"string\">&#x27;PDFScreen&#x27;</span>));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里就不再详细说 router 的实现细节了，因为网上有很多现成的资料。（PS: 主要是我也还没看到这一块）</p>\n</blockquote>\n<p>从页面（Screen）的角度来说，我认为这样的处理是最合适的。因为 Screen 只需要关注本页面的 state 和 action，至于跳转的逻辑交给后面的 action 来处理是最好的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近正在用 React Native 重构整个项目，我们用了 <strong><a href=\"https://github.com/krystofcelba/react-native-navigation#rn52\">react-native-navigation</a></strong> 这个库来作为项目的导航控制器。<br>所以，我们平常会把页面跳转逻辑的时候放在 Screen 里面的，比如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FirstScreen</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 点击事件</span></span><br><span class=\"line\">    _someAction = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">navigator</span>.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">          <span class=\"attr\">screen</span>: <span class=\"string\">&#x27;example.SecondScreen&#x27;</span>,</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一般情况下，上面的写法没有问题。但是直到我们碰到这样一个需求的时候就抓瞎了：点击一个 PDF 文件，如果 PDF 文件没有下载就先去下载，下载完成之后自动跳转到 PDF 阅读器。由于用了 redux 之后，我们就增加一个 finished 的 state 来判断是否已经下载完成。示例代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExampleScreen</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillReceiveProps = <span class=\"function\">(<span class=\"params\">nextProps</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里判断下载状态是否已完成，完成的话就去跳转</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextProps.<span class=\"property\">finished</span> === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里需要重置一下状态，不然其他 state 发生变化会多次触发页面的跳转</span></span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">dispatch</span>(<span class=\"title function_\">resetFinished</span>());</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">navigator</span>.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">              <span class=\"attr\">screen</span>: <span class=\"string\">&#x27;example.PDFScreen&#x27;</span>,</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 点击事件</span></span><br><span class=\"line\">    _someAction = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// openPDF() 这个 action 会自动去下载 PDF 文件，然后修改 finished 的状态</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">dispatch</span>(<span class=\"title function_\">openPDF</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">mapStateToProps</span> = state =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">finished</span>: state.<span class=\"property\">finished</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">connect</span>(mapStateToProps)(<span class=\"title class_\">ExampleScreen</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面的做法是可以实现我们的需求，但是这种写法很蛋疼。因为当你在调用用 openPDF() 的时候，你以为后面的事不需要你操心，然后这个时候有人告诉你还需要在其他地方增加一个中间状态去补充 openPDF() 的后续逻辑处理。</p>\n<p>经过讨论之后，我们决定改成用 callback 的方式来实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExampleScreen</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 点击事件</span></span><br><span class=\"line\">    _someAction = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// openPDF() 是一个异步 action</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">dispatch</span>(<span class=\"title function_\">openPDF</span>(<span class=\"attr\">callback</span>: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">navigator</span>.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">              <span class=\"attr\">screen</span>: <span class=\"string\">&#x27;example.PDFScreen&#x27;</span>,</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 callback 的好处就是去掉了一个烦人的中间状态，并且从阅读体验来说很容易让读者明白这个点击事件在干什么。但是在 redux 的 action 方法中增加一个 callback 的调用，看起来也有点不伦不类的。虽然我认为 callback 和其他参数具有相同的法律地位。</p>\n<p>其实最好的实现是，这个点击事件应该连页面的跳转逻辑也不需要处理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExampleScreen</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 点击事件，这个事件只做一件事就是去 dispatch 一个 openPDF() 的 action</span></span><br><span class=\"line\">    _someAction = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">dispatch</span>(<span class=\"title function_\">openPDF</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>像上面这种实现，我们也就只能在 openPDF() 里动手脚了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// action.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> openPDF = <span class=\"keyword\">await</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">dispatch</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 异步下载 PDF</span></span><br><span class=\"line\">        <span class=\"keyword\">async</span> <span class=\"title function_\">downloadPDF</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 完成之后通过 router 去实现页面跳转</span></span><br><span class=\"line\">        <span class=\"title function_\">dispatch</span>(<span class=\"title function_\">openRouter</span>(<span class=\"string\">&#x27;PDFScreen&#x27;</span>));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里就不再详细说 router 的实现细节了，因为网上有很多现成的资料。（PS: 主要是我也还没看到这一块）</p>\n</blockquote>\n<p>从页面（Screen）的角度来说，我认为这样的处理是最合适的。因为 Screen 只需要关注本页面的 state 和 action，至于跳转的逻辑交给后面的 action 来处理是最好的。</p>\n"},{"title":"self 在 block 中的引用计数变化","author":"帕帕","date":"2018-04-19T11:34:51.000Z","thumbnail":"https://images.unsplash.com/photo-1462303966430-8a4708fd729e?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=c9dd0952e673c518403fb8d4c28f93b5&auto=format&fit=crop&w=160&q=60","_content":"\n\n相信大家在 Objective-C 中都会通过 `__waek` 的修饰符来保证 block 和 self 不会互相引用，代码如下:\n\n```Objective-C\n__weak typeof(self) weakSelf = self;\nself.block = ^{\n    __strong typeof(self) strongSelf = self;\n    ...\n}\n```\n\n但是你思考过 self 在这一段旅程中的引用计数变化么，接下来我会通过三个例子来展示这一段旅程是怎样的？\n\n\n```Objective-C\n// 🌰1\nNSLog(@\"Before block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\nself.block = ^{\n    self;\n    NSLog(@\"Within block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\n};\nself.block();\nNSLog(@\"After block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\n\n\n// 🌰2\n__weak typeof(self) weakSelf = self;\nNSLog(@\"Before block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\nself.block = ^{\n    weakSelf;\n    NSLog(@\"Within block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));\n};\nself.block();\nNSLog(@\"After block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\n\n\n// 🌰3\n__weak typeof(self) weakSelf = self;\nNSLog(@\"Before block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\nself.block = ^{\n    __strong typeof(self) strongSelf = weakSelf;\n    NSLog(@\"Within block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));\n};\nself.block();\nNSLog(@\"After block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\n```\n\n我们可以通过 Clang 对上面的三个例子做一下编译，通过编译后的 C 代码（接下来所展示代码都是经过简化），我们可以推导出 self 的引用计数变化。\n\n---\n\n🌰1 的 C 代码如下：\n\n```Objective-C\n// Block 结构体。这个大家可以通过其他的资料去看看，我们今天主要是来探寻一下 self 的旅程，这里就不对 Block 本身做更详细的介绍\nstruct __block_impl {\n  void *isa;\n  int Flags;\n  int Reserved;\n  void *FuncPtr;\n};\n\n// ^{} 的实现\nstruct __BlockTest__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __BlockTest__test_block_desc_0* Desc;\n    BlockTest *const __strong self;\n    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __strong _self, int flags=0) : self(_self) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n// Block 方法\nstatic void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) {\n    BlockTest *const __strong self = __cself->self; // bound by copy\n    self;\n}\n\n// Block 的 copy 操作\nstatic void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) {_Block_object_assign((void*)&dst->self, (void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n// Block 的 dispose 操作\nstatic void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) {_Block_object_dispose((void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n// 描述 Block 的 copy 和 dispose\nstatic struct __BlockTest__test_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);\n    void (*dispose)(struct __BlockTest__test_block_impl_0*);\n} __BlockTest__test_block_desc_0_DATA = { 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0};\n\n// 方法主体\nstatic void _I_BlockTest_test(BlockTest * self, SEL _cmd) {\n    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(\"setBlock:\"), ((void (*)())&__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &__BlockTest__test_block_desc_0_DATA, self, 570425344)));\n    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(\"block\"))();\n\n}\n```\n\n1. 在方法主体里面首先会构造一个 `__BlockTest__test_block_impl_0` 的结构体，该结构体捕获了 self；\n2. `__BlockTest__test_block_impl_0` 的构造函数中使用了 `__strong` 来捕获 self，所以我们知道在构造的时候默认是使用 `__strong` 来捕获外部的对象变量，此时 self 的引用计数应该要 +1；\n3. Block 被构造出来之后需要被赋值给 self，我们知道在 ARC 模式下此时的 Block 会执行 Copy 操作，从 `_NSConcreteStackBlock` 变成 `_NSMallocBlock`；\n4. Block 通过 `__BlockTest__test_block_desc_0_DATA` 找到 Copy 方法的具体实现 `__BlockTest__test_block_copy_0`，从上面的代码中我们知道该方法的实现是通过 `_Block_object_assign` 来实现的（对于这个方法的实现细节暂时还没有找到更相信的资料，有知道的可以麻烦告诉一下），通过名字我们可以猜测出该方法只是把捕获的变量地址直接拷贝一份到堆内存中，但是不会引起引用计数的变化；\n5. 当 Block 被真正执行的时候会通过 `__block_impl` 的 `FuncPtr` 找到真正的实现代码 `__BlockTest__test_block_func_0`，我们观察到在这个方法里面有这样一句代码 `BlockTest *const __strong self = __cself->self`，很明显此时 self 的引用计数会 +1，当该 `__BlockTest__test_block_func_0` 执行完毕之后还是会释放 self 的，此时引用计数会 -1；\n\n从上面的分析过程中，我们知道由于 Block 在构造的时候默认就对捕获的 self 进行了强引用，导致 self 的引用计数 +1；而又由于 self 持有了 Block，所以这里就造成了循环引用的问题。\n\n我们来看 🌰2 能不能解决这个问题？\n\n---\n\n🌰2 的 C 代码如下：\n\n```Objective-C\n// ^{} 结构体\nstruct __BlockTest__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __BlockTest__test_block_desc_0* Desc;\n    BlockTest *const __weak weakSelf;\n    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n// Block 方法\nstatic void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) {\n    BlockTest *const __weak weakSelf = __cself->weakSelf; // bound by copy\n    weakSelf;\n}\n\n// Block 的 copy 操作\nstatic void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) {_Block_object_assign((void*)&dst->weakSelf, (void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n// Block 的 dispose 操作\nstatic void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) {_Block_object_dispose((void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n// 描述 Block 的 copy 和 dispose\nstatic struct __BlockTest__test_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);\n    void (*dispose)(struct __BlockTest__test_block_impl_0*);\n} __BlockTest__test_block_desc_0_DATA = { 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0};\n\n// 方法主体\nstatic void _I_BlockTest_test(BlockTest * self, SEL _cmd) {\n    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;\n    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(\"setBlock:\"), ((void (*)())&__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));\n    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(\"block\"))();\n}\n```\n\n1. 方法主体会先用 `__weak` 初始化一个 weakSelf，此时 self 的引用计数是不会发生变化的；之后会构造一个`__BlockTest__test_block_impl_0` 的结构体，该结构体捕获了 weakSelf；\n2. `__BlockTest__test_block_impl_0` 的构造函数中使用了 `__weak` 来捕获 weakSelf，所以我们知道此时 self 的引用计数应该要也是不会发生变化的；\n3. 然后把该结构体赋值给 self.block，block 结构体被从栈复制到堆的时候使用了 `_Block_object_assign`，所以此时 self 的引用计数不会发生变化\n4. 然后 block 在被执行的时候做了一下 `__weak` 的操作 `BlockTest *const __weak weakSelf = __cself->weakSelf`，这时候 self 的引用计数也不会发生变化\n5. 由于 block 对 weakSelf 没有强引用，所以在 block 执行完成之后也不需要做释放 weakSelf 的工作\n\n所以，在该例子中 block 无法强引用 weakSelf，weakSelf 的引用计数没有发生任何变化。由于 self 没有被 block 强应用，所以当 self 要被释放的时候，block 也会被释放，这就解决了我们 🌰1 中的循环引用的问题。但是在 block 方法执行的过程中，self 对象有可能已经被释放了，此时如果你还去使用 weakSelf 就有可能造成奔溃的情况。\n\n---\n\n🌰3 的 C 代码如下：\n\n```Objective-C\nstruct __BlockTest__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __BlockTest__test_block_desc_0* Desc;\n    BlockTest *const __weak weakSelf;\n    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) {\n    BlockTest *const __weak weakSelf = __cself->weakSelf; // bound by copy\n    __attribute__((objc_ownership(strong))) typeof(self) strongSelf = weakSelf;    \n}\n\nstatic void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) {_Block_object_assign((void*)&dst->weakSelf, (void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) {_Block_object_dispose((void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic struct __BlockTest__test_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);\n    void (*dispose)(struct __BlockTest__test_block_impl_0*);\n} __BlockTest__test_block_desc_0_DATA = { 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0};\n\nstatic void _I_BlockTest_test(BlockTest * self, SEL _cmd) {\n    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;\n    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(\"setBlock:\"), ((void (*)())&__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));\n    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(\"block\"))();  \n}\n```\n\n\n前面的步骤都跟 🌰2 中的一样，关键是在 Block 的方法实现里面有点不一样。我们来看看 `__BlockTest__test_block_func_0`，它首先调用了 `BlockTest *const __weak weakSelf = __cself->weakSelf`， 所以它此时的引用计数不会发生变化；但是接下来又用 `objc_ownership(strong)` 来强引用 weakSelf，所以此时 self 的引用计数 +1。这就保证了在函数执行的过程中，Block 会一直持有 self，知道 Block 执行完毕之后会释放 weakSelf。\n\n所以 🌰3 完美的解决了循环应用和直接使用 `__weak` 可能导致奔溃的问题。\n\n---\n\n最后，说一下关于 _Block_object_assign 的猜想：\n\n```\n_Block_object_assign((void*)&dst->weakSelf, (void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);\n```\n\n通过上面的例子，我们知道 Block 在构造的时候就会对捕获的变量进行内存管理（强引用和弱引用），所以当 Block 在做 Copy 操作的时候其实没有必要对它捕获的变量再做一遍内存管理了。这也应该是 Block 的 Copy 操作使用了 `_Block_object_assign` 这种不会导致引用计数发生变化的方式来实现的原因。\n\n\n\n\n","source":"_posts/self-在-block-中的引用计数变化.md","raw":"---\ntitle: self 在 block 中的引用计数变化\nauthor: 帕帕\ndate: 2018-04-19 11:34:51 +0800\ncategories: 技术 \ntags: [iOS, Objective-C, Block]\nthumbnail: https://images.unsplash.com/photo-1462303966430-8a4708fd729e?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=c9dd0952e673c518403fb8d4c28f93b5&auto=format&fit=crop&w=160&q=60\n---\n\n\n相信大家在 Objective-C 中都会通过 `__waek` 的修饰符来保证 block 和 self 不会互相引用，代码如下:\n\n```Objective-C\n__weak typeof(self) weakSelf = self;\nself.block = ^{\n    __strong typeof(self) strongSelf = self;\n    ...\n}\n```\n\n但是你思考过 self 在这一段旅程中的引用计数变化么，接下来我会通过三个例子来展示这一段旅程是怎样的？\n\n\n```Objective-C\n// 🌰1\nNSLog(@\"Before block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\nself.block = ^{\n    self;\n    NSLog(@\"Within block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\n};\nself.block();\nNSLog(@\"After block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\n\n\n// 🌰2\n__weak typeof(self) weakSelf = self;\nNSLog(@\"Before block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\nself.block = ^{\n    weakSelf;\n    NSLog(@\"Within block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));\n};\nself.block();\nNSLog(@\"After block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\n\n\n// 🌰3\n__weak typeof(self) weakSelf = self;\nNSLog(@\"Before block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\nself.block = ^{\n    __strong typeof(self) strongSelf = weakSelf;\n    NSLog(@\"Within block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));\n};\nself.block();\nNSLog(@\"After block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\n```\n\n我们可以通过 Clang 对上面的三个例子做一下编译，通过编译后的 C 代码（接下来所展示代码都是经过简化），我们可以推导出 self 的引用计数变化。\n\n---\n\n🌰1 的 C 代码如下：\n\n```Objective-C\n// Block 结构体。这个大家可以通过其他的资料去看看，我们今天主要是来探寻一下 self 的旅程，这里就不对 Block 本身做更详细的介绍\nstruct __block_impl {\n  void *isa;\n  int Flags;\n  int Reserved;\n  void *FuncPtr;\n};\n\n// ^{} 的实现\nstruct __BlockTest__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __BlockTest__test_block_desc_0* Desc;\n    BlockTest *const __strong self;\n    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __strong _self, int flags=0) : self(_self) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n// Block 方法\nstatic void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) {\n    BlockTest *const __strong self = __cself->self; // bound by copy\n    self;\n}\n\n// Block 的 copy 操作\nstatic void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) {_Block_object_assign((void*)&dst->self, (void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n// Block 的 dispose 操作\nstatic void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) {_Block_object_dispose((void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n// 描述 Block 的 copy 和 dispose\nstatic struct __BlockTest__test_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);\n    void (*dispose)(struct __BlockTest__test_block_impl_0*);\n} __BlockTest__test_block_desc_0_DATA = { 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0};\n\n// 方法主体\nstatic void _I_BlockTest_test(BlockTest * self, SEL _cmd) {\n    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(\"setBlock:\"), ((void (*)())&__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &__BlockTest__test_block_desc_0_DATA, self, 570425344)));\n    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(\"block\"))();\n\n}\n```\n\n1. 在方法主体里面首先会构造一个 `__BlockTest__test_block_impl_0` 的结构体，该结构体捕获了 self；\n2. `__BlockTest__test_block_impl_0` 的构造函数中使用了 `__strong` 来捕获 self，所以我们知道在构造的时候默认是使用 `__strong` 来捕获外部的对象变量，此时 self 的引用计数应该要 +1；\n3. Block 被构造出来之后需要被赋值给 self，我们知道在 ARC 模式下此时的 Block 会执行 Copy 操作，从 `_NSConcreteStackBlock` 变成 `_NSMallocBlock`；\n4. Block 通过 `__BlockTest__test_block_desc_0_DATA` 找到 Copy 方法的具体实现 `__BlockTest__test_block_copy_0`，从上面的代码中我们知道该方法的实现是通过 `_Block_object_assign` 来实现的（对于这个方法的实现细节暂时还没有找到更相信的资料，有知道的可以麻烦告诉一下），通过名字我们可以猜测出该方法只是把捕获的变量地址直接拷贝一份到堆内存中，但是不会引起引用计数的变化；\n5. 当 Block 被真正执行的时候会通过 `__block_impl` 的 `FuncPtr` 找到真正的实现代码 `__BlockTest__test_block_func_0`，我们观察到在这个方法里面有这样一句代码 `BlockTest *const __strong self = __cself->self`，很明显此时 self 的引用计数会 +1，当该 `__BlockTest__test_block_func_0` 执行完毕之后还是会释放 self 的，此时引用计数会 -1；\n\n从上面的分析过程中，我们知道由于 Block 在构造的时候默认就对捕获的 self 进行了强引用，导致 self 的引用计数 +1；而又由于 self 持有了 Block，所以这里就造成了循环引用的问题。\n\n我们来看 🌰2 能不能解决这个问题？\n\n---\n\n🌰2 的 C 代码如下：\n\n```Objective-C\n// ^{} 结构体\nstruct __BlockTest__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __BlockTest__test_block_desc_0* Desc;\n    BlockTest *const __weak weakSelf;\n    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n// Block 方法\nstatic void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) {\n    BlockTest *const __weak weakSelf = __cself->weakSelf; // bound by copy\n    weakSelf;\n}\n\n// Block 的 copy 操作\nstatic void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) {_Block_object_assign((void*)&dst->weakSelf, (void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n// Block 的 dispose 操作\nstatic void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) {_Block_object_dispose((void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n// 描述 Block 的 copy 和 dispose\nstatic struct __BlockTest__test_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);\n    void (*dispose)(struct __BlockTest__test_block_impl_0*);\n} __BlockTest__test_block_desc_0_DATA = { 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0};\n\n// 方法主体\nstatic void _I_BlockTest_test(BlockTest * self, SEL _cmd) {\n    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;\n    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(\"setBlock:\"), ((void (*)())&__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));\n    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(\"block\"))();\n}\n```\n\n1. 方法主体会先用 `__weak` 初始化一个 weakSelf，此时 self 的引用计数是不会发生变化的；之后会构造一个`__BlockTest__test_block_impl_0` 的结构体，该结构体捕获了 weakSelf；\n2. `__BlockTest__test_block_impl_0` 的构造函数中使用了 `__weak` 来捕获 weakSelf，所以我们知道此时 self 的引用计数应该要也是不会发生变化的；\n3. 然后把该结构体赋值给 self.block，block 结构体被从栈复制到堆的时候使用了 `_Block_object_assign`，所以此时 self 的引用计数不会发生变化\n4. 然后 block 在被执行的时候做了一下 `__weak` 的操作 `BlockTest *const __weak weakSelf = __cself->weakSelf`，这时候 self 的引用计数也不会发生变化\n5. 由于 block 对 weakSelf 没有强引用，所以在 block 执行完成之后也不需要做释放 weakSelf 的工作\n\n所以，在该例子中 block 无法强引用 weakSelf，weakSelf 的引用计数没有发生任何变化。由于 self 没有被 block 强应用，所以当 self 要被释放的时候，block 也会被释放，这就解决了我们 🌰1 中的循环引用的问题。但是在 block 方法执行的过程中，self 对象有可能已经被释放了，此时如果你还去使用 weakSelf 就有可能造成奔溃的情况。\n\n---\n\n🌰3 的 C 代码如下：\n\n```Objective-C\nstruct __BlockTest__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __BlockTest__test_block_desc_0* Desc;\n    BlockTest *const __weak weakSelf;\n    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) {\n    BlockTest *const __weak weakSelf = __cself->weakSelf; // bound by copy\n    __attribute__((objc_ownership(strong))) typeof(self) strongSelf = weakSelf;    \n}\n\nstatic void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) {_Block_object_assign((void*)&dst->weakSelf, (void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) {_Block_object_dispose((void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic struct __BlockTest__test_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);\n    void (*dispose)(struct __BlockTest__test_block_impl_0*);\n} __BlockTest__test_block_desc_0_DATA = { 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0};\n\nstatic void _I_BlockTest_test(BlockTest * self, SEL _cmd) {\n    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;\n    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(\"setBlock:\"), ((void (*)())&__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));\n    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(\"block\"))();  \n}\n```\n\n\n前面的步骤都跟 🌰2 中的一样，关键是在 Block 的方法实现里面有点不一样。我们来看看 `__BlockTest__test_block_func_0`，它首先调用了 `BlockTest *const __weak weakSelf = __cself->weakSelf`， 所以它此时的引用计数不会发生变化；但是接下来又用 `objc_ownership(strong)` 来强引用 weakSelf，所以此时 self 的引用计数 +1。这就保证了在函数执行的过程中，Block 会一直持有 self，知道 Block 执行完毕之后会释放 weakSelf。\n\n所以 🌰3 完美的解决了循环应用和直接使用 `__weak` 可能导致奔溃的问题。\n\n---\n\n最后，说一下关于 _Block_object_assign 的猜想：\n\n```\n_Block_object_assign((void*)&dst->weakSelf, (void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);\n```\n\n通过上面的例子，我们知道 Block 在构造的时候就会对捕获的变量进行内存管理（强引用和弱引用），所以当 Block 在做 Copy 操作的时候其实没有必要对它捕获的变量再做一遍内存管理了。这也应该是 Block 的 Copy 操作使用了 `_Block_object_assign` 这种不会导致引用计数发生变化的方式来实现的原因。\n\n\n\n\n","slug":"self-在-block-中的引用计数变化","published":1,"updated":"2022-04-20T07:08:33.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxei00166enqe4073dk2","content":"<p>相信大家在 Objective-C 中都会通过 <code>__waek</code> 的修饰符来保证 block 和 self 不会互相引用，代码如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak typeof(self) weakSelf = self;</span><br><span class=\"line\">self.block = ^&#123;</span><br><span class=\"line\">    __strong typeof(self) strongSelf = self;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是你思考过 self 在这一段旅程中的引用计数变化么，接下来我会通过三个例子来展示这一段旅程是怎样的？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 🌰1</span><br><span class=\"line\">NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\">self.block = ^&#123;</span><br><span class=\"line\">    self;</span><br><span class=\"line\">    NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">self.block();</span><br><span class=\"line\">NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 🌰2</span><br><span class=\"line\">__weak typeof(self) weakSelf = self;</span><br><span class=\"line\">NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\">self.block = ^&#123;</span><br><span class=\"line\">    weakSelf;</span><br><span class=\"line\">    NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">self.block();</span><br><span class=\"line\">NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 🌰3</span><br><span class=\"line\">__weak typeof(self) weakSelf = self;</span><br><span class=\"line\">NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\">self.block = ^&#123;</span><br><span class=\"line\">    __strong typeof(self) strongSelf = weakSelf;</span><br><span class=\"line\">    NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">self.block();</span><br><span class=\"line\">NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过 Clang 对上面的三个例子做一下编译，通过编译后的 C 代码（接下来所展示代码都是经过简化），我们可以推导出 self 的引用计数变化。</p>\n<hr>\n<p>🌰1 的 C 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Block 结构体。这个大家可以通过其他的资料去看看，我们今天主要是来探寻一下 self 的旅程，这里就不对 Block 本身做更详细的介绍</span><br><span class=\"line\">struct __block_impl &#123;</span><br><span class=\"line\">  void *isa;</span><br><span class=\"line\">  int Flags;</span><br><span class=\"line\">  int Reserved;</span><br><span class=\"line\">  void *FuncPtr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// ^&#123;&#125; 的实现</span><br><span class=\"line\">struct __BlockTest__test_block_impl_0 &#123;</span><br><span class=\"line\">    struct __block_impl impl;</span><br><span class=\"line\">    struct __BlockTest__test_block_desc_0* Desc;</span><br><span class=\"line\">    BlockTest *const __strong self;</span><br><span class=\"line\">    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __strong _self, int flags=0) : self(_self) &#123;</span><br><span class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">        impl.Flags = flags;</span><br><span class=\"line\">        impl.FuncPtr = fp;</span><br><span class=\"line\">        Desc = desc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 方法</span><br><span class=\"line\">static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">    BlockTest *const __strong self = __cself-&gt;self; // bound by copy</span><br><span class=\"line\">    self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 的 copy 操作</span><br><span class=\"line\">static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 的 dispose 操作</span><br><span class=\"line\">static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 描述 Block 的 copy 和 dispose</span><br><span class=\"line\">static struct __BlockTest__test_block_desc_0 &#123;</span><br><span class=\"line\">    size_t reserved;</span><br><span class=\"line\">    size_t Block_size;</span><br><span class=\"line\">    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">    void (*dispose)(struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法主体</span><br><span class=\"line\">static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123;</span><br><span class=\"line\">    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, self, 570425344)));</span><br><span class=\"line\">    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>在方法主体里面首先会构造一个 <code>__BlockTest__test_block_impl_0</code> 的结构体，该结构体捕获了 self；</li>\n<li><code>__BlockTest__test_block_impl_0</code> 的构造函数中使用了 <code>__strong</code> 来捕获 self，所以我们知道在构造的时候默认是使用 <code>__strong</code> 来捕获外部的对象变量，此时 self 的引用计数应该要 +1；</li>\n<li>Block 被构造出来之后需要被赋值给 self，我们知道在 ARC 模式下此时的 Block 会执行 Copy 操作，从 <code>_NSConcreteStackBlock</code> 变成 <code>_NSMallocBlock</code>；</li>\n<li>Block 通过 <code>__BlockTest__test_block_desc_0_DATA</code> 找到 Copy 方法的具体实现 <code>__BlockTest__test_block_copy_0</code>，从上面的代码中我们知道该方法的实现是通过 <code>_Block_object_assign</code> 来实现的（对于这个方法的实现细节暂时还没有找到更相信的资料，有知道的可以麻烦告诉一下），通过名字我们可以猜测出该方法只是把捕获的变量地址直接拷贝一份到堆内存中，但是不会引起引用计数的变化；</li>\n<li>当 Block 被真正执行的时候会通过 <code>__block_impl</code> 的 <code>FuncPtr</code> 找到真正的实现代码 <code>__BlockTest__test_block_func_0</code>，我们观察到在这个方法里面有这样一句代码 <code>BlockTest *const __strong self = __cself-&gt;self</code>，很明显此时 self 的引用计数会 +1，当该 <code>__BlockTest__test_block_func_0</code> 执行完毕之后还是会释放 self 的，此时引用计数会 -1；</li>\n</ol>\n<p>从上面的分析过程中，我们知道由于 Block 在构造的时候默认就对捕获的 self 进行了强引用，导致 self 的引用计数 +1；而又由于 self 持有了 Block，所以这里就造成了循环引用的问题。</p>\n<p>我们来看 🌰2 能不能解决这个问题？</p>\n<hr>\n<p>🌰2 的 C 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ^&#123;&#125; 结构体</span><br><span class=\"line\">struct __BlockTest__test_block_impl_0 &#123;</span><br><span class=\"line\">    struct __block_impl impl;</span><br><span class=\"line\">    struct __BlockTest__test_block_desc_0* Desc;</span><br><span class=\"line\">    BlockTest *const __weak weakSelf;</span><br><span class=\"line\">    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123;</span><br><span class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">        impl.Flags = flags;</span><br><span class=\"line\">        impl.FuncPtr = fp;</span><br><span class=\"line\">        Desc = desc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 方法</span><br><span class=\"line\">static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">    BlockTest *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy</span><br><span class=\"line\">    weakSelf;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 的 copy 操作</span><br><span class=\"line\">static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 的 dispose 操作</span><br><span class=\"line\">static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 描述 Block 的 copy 和 dispose</span><br><span class=\"line\">static struct __BlockTest__test_block_desc_0 &#123;</span><br><span class=\"line\">    size_t reserved;</span><br><span class=\"line\">    size_t Block_size;</span><br><span class=\"line\">    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">    void (*dispose)(struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法主体</span><br><span class=\"line\">static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123;</span><br><span class=\"line\">    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;</span><br><span class=\"line\">    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));</span><br><span class=\"line\">    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>方法主体会先用 <code>__weak</code> 初始化一个 weakSelf，此时 self 的引用计数是不会发生变化的；之后会构造一个<code>__BlockTest__test_block_impl_0</code> 的结构体，该结构体捕获了 weakSelf；</li>\n<li><code>__BlockTest__test_block_impl_0</code> 的构造函数中使用了 <code>__weak</code> 来捕获 weakSelf，所以我们知道此时 self 的引用计数应该要也是不会发生变化的；</li>\n<li>然后把该结构体赋值给 self.block，block 结构体被从栈复制到堆的时候使用了 <code>_Block_object_assign</code>，所以此时 self 的引用计数不会发生变化</li>\n<li>然后 block 在被执行的时候做了一下 <code>__weak</code> 的操作 <code>BlockTest *const __weak weakSelf = __cself-&gt;weakSelf</code>，这时候 self 的引用计数也不会发生变化</li>\n<li>由于 block 对 weakSelf 没有强引用，所以在 block 执行完成之后也不需要做释放 weakSelf 的工作</li>\n</ol>\n<p>所以，在该例子中 block 无法强引用 weakSelf，weakSelf 的引用计数没有发生任何变化。由于 self 没有被 block 强应用，所以当 self 要被释放的时候，block 也会被释放，这就解决了我们 🌰1 中的循环引用的问题。但是在 block 方法执行的过程中，self 对象有可能已经被释放了，此时如果你还去使用 weakSelf 就有可能造成奔溃的情况。</p>\n<hr>\n<p>🌰3 的 C 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __BlockTest__test_block_impl_0 &#123;</span><br><span class=\"line\">    struct __block_impl impl;</span><br><span class=\"line\">    struct __BlockTest__test_block_desc_0* Desc;</span><br><span class=\"line\">    BlockTest *const __weak weakSelf;</span><br><span class=\"line\">    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123;</span><br><span class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">        impl.Flags = flags;</span><br><span class=\"line\">        impl.FuncPtr = fp;</span><br><span class=\"line\">        Desc = desc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">    BlockTest *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy</span><br><span class=\"line\">    __attribute__((objc_ownership(strong))) typeof(self) strongSelf = weakSelf;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static struct __BlockTest__test_block_desc_0 &#123;</span><br><span class=\"line\">    size_t reserved;</span><br><span class=\"line\">    size_t Block_size;</span><br><span class=\"line\">    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">    void (*dispose)(struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123;</span><br><span class=\"line\">    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;</span><br><span class=\"line\">    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));</span><br><span class=\"line\">    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>前面的步骤都跟 🌰2 中的一样，关键是在 Block 的方法实现里面有点不一样。我们来看看 <code>__BlockTest__test_block_func_0</code>，它首先调用了 <code>BlockTest *const __weak weakSelf = __cself-&gt;weakSelf</code>， 所以它此时的引用计数不会发生变化；但是接下来又用 <code>objc_ownership(strong)</code> 来强引用 weakSelf，所以此时 self 的引用计数 +1。这就保证了在函数执行的过程中，Block 会一直持有 self，知道 Block 执行完毕之后会释放 weakSelf。</p>\n<p>所以 🌰3 完美的解决了循环应用和直接使用 <code>__weak</code> 可能导致奔溃的问题。</p>\n<hr>\n<p>最后，说一下关于 _Block_object_assign 的猜想：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br></pre></td></tr></table></figure>\n\n<p>通过上面的例子，我们知道 Block 在构造的时候就会对捕获的变量进行内存管理（强引用和弱引用），所以当 Block 在做 Copy 操作的时候其实没有必要对它捕获的变量再做一遍内存管理了。这也应该是 Block 的 Copy 操作使用了 <code>_Block_object_assign</code> 这种不会导致引用计数发生变化的方式来实现的原因。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>相信大家在 Objective-C 中都会通过 <code>__waek</code> 的修饰符来保证 block 和 self 不会互相引用，代码如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak typeof(self) weakSelf = self;</span><br><span class=\"line\">self.block = ^&#123;</span><br><span class=\"line\">    __strong typeof(self) strongSelf = self;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是你思考过 self 在这一段旅程中的引用计数变化么，接下来我会通过三个例子来展示这一段旅程是怎样的？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 🌰1</span><br><span class=\"line\">NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\">self.block = ^&#123;</span><br><span class=\"line\">    self;</span><br><span class=\"line\">    NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">self.block();</span><br><span class=\"line\">NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 🌰2</span><br><span class=\"line\">__weak typeof(self) weakSelf = self;</span><br><span class=\"line\">NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\">self.block = ^&#123;</span><br><span class=\"line\">    weakSelf;</span><br><span class=\"line\">    NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">self.block();</span><br><span class=\"line\">NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 🌰3</span><br><span class=\"line\">__weak typeof(self) weakSelf = self;</span><br><span class=\"line\">NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\">self.block = ^&#123;</span><br><span class=\"line\">    __strong typeof(self) strongSelf = weakSelf;</span><br><span class=\"line\">    NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">self.block();</span><br><span class=\"line\">NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过 Clang 对上面的三个例子做一下编译，通过编译后的 C 代码（接下来所展示代码都是经过简化），我们可以推导出 self 的引用计数变化。</p>\n<hr>\n<p>🌰1 的 C 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Block 结构体。这个大家可以通过其他的资料去看看，我们今天主要是来探寻一下 self 的旅程，这里就不对 Block 本身做更详细的介绍</span><br><span class=\"line\">struct __block_impl &#123;</span><br><span class=\"line\">  void *isa;</span><br><span class=\"line\">  int Flags;</span><br><span class=\"line\">  int Reserved;</span><br><span class=\"line\">  void *FuncPtr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// ^&#123;&#125; 的实现</span><br><span class=\"line\">struct __BlockTest__test_block_impl_0 &#123;</span><br><span class=\"line\">    struct __block_impl impl;</span><br><span class=\"line\">    struct __BlockTest__test_block_desc_0* Desc;</span><br><span class=\"line\">    BlockTest *const __strong self;</span><br><span class=\"line\">    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __strong _self, int flags=0) : self(_self) &#123;</span><br><span class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">        impl.Flags = flags;</span><br><span class=\"line\">        impl.FuncPtr = fp;</span><br><span class=\"line\">        Desc = desc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 方法</span><br><span class=\"line\">static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">    BlockTest *const __strong self = __cself-&gt;self; // bound by copy</span><br><span class=\"line\">    self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 的 copy 操作</span><br><span class=\"line\">static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 的 dispose 操作</span><br><span class=\"line\">static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 描述 Block 的 copy 和 dispose</span><br><span class=\"line\">static struct __BlockTest__test_block_desc_0 &#123;</span><br><span class=\"line\">    size_t reserved;</span><br><span class=\"line\">    size_t Block_size;</span><br><span class=\"line\">    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">    void (*dispose)(struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法主体</span><br><span class=\"line\">static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123;</span><br><span class=\"line\">    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, self, 570425344)));</span><br><span class=\"line\">    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>在方法主体里面首先会构造一个 <code>__BlockTest__test_block_impl_0</code> 的结构体，该结构体捕获了 self；</li>\n<li><code>__BlockTest__test_block_impl_0</code> 的构造函数中使用了 <code>__strong</code> 来捕获 self，所以我们知道在构造的时候默认是使用 <code>__strong</code> 来捕获外部的对象变量，此时 self 的引用计数应该要 +1；</li>\n<li>Block 被构造出来之后需要被赋值给 self，我们知道在 ARC 模式下此时的 Block 会执行 Copy 操作，从 <code>_NSConcreteStackBlock</code> 变成 <code>_NSMallocBlock</code>；</li>\n<li>Block 通过 <code>__BlockTest__test_block_desc_0_DATA</code> 找到 Copy 方法的具体实现 <code>__BlockTest__test_block_copy_0</code>，从上面的代码中我们知道该方法的实现是通过 <code>_Block_object_assign</code> 来实现的（对于这个方法的实现细节暂时还没有找到更相信的资料，有知道的可以麻烦告诉一下），通过名字我们可以猜测出该方法只是把捕获的变量地址直接拷贝一份到堆内存中，但是不会引起引用计数的变化；</li>\n<li>当 Block 被真正执行的时候会通过 <code>__block_impl</code> 的 <code>FuncPtr</code> 找到真正的实现代码 <code>__BlockTest__test_block_func_0</code>，我们观察到在这个方法里面有这样一句代码 <code>BlockTest *const __strong self = __cself-&gt;self</code>，很明显此时 self 的引用计数会 +1，当该 <code>__BlockTest__test_block_func_0</code> 执行完毕之后还是会释放 self 的，此时引用计数会 -1；</li>\n</ol>\n<p>从上面的分析过程中，我们知道由于 Block 在构造的时候默认就对捕获的 self 进行了强引用，导致 self 的引用计数 +1；而又由于 self 持有了 Block，所以这里就造成了循环引用的问题。</p>\n<p>我们来看 🌰2 能不能解决这个问题？</p>\n<hr>\n<p>🌰2 的 C 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ^&#123;&#125; 结构体</span><br><span class=\"line\">struct __BlockTest__test_block_impl_0 &#123;</span><br><span class=\"line\">    struct __block_impl impl;</span><br><span class=\"line\">    struct __BlockTest__test_block_desc_0* Desc;</span><br><span class=\"line\">    BlockTest *const __weak weakSelf;</span><br><span class=\"line\">    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123;</span><br><span class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">        impl.Flags = flags;</span><br><span class=\"line\">        impl.FuncPtr = fp;</span><br><span class=\"line\">        Desc = desc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 方法</span><br><span class=\"line\">static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">    BlockTest *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy</span><br><span class=\"line\">    weakSelf;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 的 copy 操作</span><br><span class=\"line\">static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 的 dispose 操作</span><br><span class=\"line\">static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 描述 Block 的 copy 和 dispose</span><br><span class=\"line\">static struct __BlockTest__test_block_desc_0 &#123;</span><br><span class=\"line\">    size_t reserved;</span><br><span class=\"line\">    size_t Block_size;</span><br><span class=\"line\">    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">    void (*dispose)(struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法主体</span><br><span class=\"line\">static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123;</span><br><span class=\"line\">    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;</span><br><span class=\"line\">    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));</span><br><span class=\"line\">    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>方法主体会先用 <code>__weak</code> 初始化一个 weakSelf，此时 self 的引用计数是不会发生变化的；之后会构造一个<code>__BlockTest__test_block_impl_0</code> 的结构体，该结构体捕获了 weakSelf；</li>\n<li><code>__BlockTest__test_block_impl_0</code> 的构造函数中使用了 <code>__weak</code> 来捕获 weakSelf，所以我们知道此时 self 的引用计数应该要也是不会发生变化的；</li>\n<li>然后把该结构体赋值给 self.block，block 结构体被从栈复制到堆的时候使用了 <code>_Block_object_assign</code>，所以此时 self 的引用计数不会发生变化</li>\n<li>然后 block 在被执行的时候做了一下 <code>__weak</code> 的操作 <code>BlockTest *const __weak weakSelf = __cself-&gt;weakSelf</code>，这时候 self 的引用计数也不会发生变化</li>\n<li>由于 block 对 weakSelf 没有强引用，所以在 block 执行完成之后也不需要做释放 weakSelf 的工作</li>\n</ol>\n<p>所以，在该例子中 block 无法强引用 weakSelf，weakSelf 的引用计数没有发生任何变化。由于 self 没有被 block 强应用，所以当 self 要被释放的时候，block 也会被释放，这就解决了我们 🌰1 中的循环引用的问题。但是在 block 方法执行的过程中，self 对象有可能已经被释放了，此时如果你还去使用 weakSelf 就有可能造成奔溃的情况。</p>\n<hr>\n<p>🌰3 的 C 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __BlockTest__test_block_impl_0 &#123;</span><br><span class=\"line\">    struct __block_impl impl;</span><br><span class=\"line\">    struct __BlockTest__test_block_desc_0* Desc;</span><br><span class=\"line\">    BlockTest *const __weak weakSelf;</span><br><span class=\"line\">    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123;</span><br><span class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">        impl.Flags = flags;</span><br><span class=\"line\">        impl.FuncPtr = fp;</span><br><span class=\"line\">        Desc = desc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">    BlockTest *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy</span><br><span class=\"line\">    __attribute__((objc_ownership(strong))) typeof(self) strongSelf = weakSelf;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static struct __BlockTest__test_block_desc_0 &#123;</span><br><span class=\"line\">    size_t reserved;</span><br><span class=\"line\">    size_t Block_size;</span><br><span class=\"line\">    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">    void (*dispose)(struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123;</span><br><span class=\"line\">    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;</span><br><span class=\"line\">    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));</span><br><span class=\"line\">    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>前面的步骤都跟 🌰2 中的一样，关键是在 Block 的方法实现里面有点不一样。我们来看看 <code>__BlockTest__test_block_func_0</code>，它首先调用了 <code>BlockTest *const __weak weakSelf = __cself-&gt;weakSelf</code>， 所以它此时的引用计数不会发生变化；但是接下来又用 <code>objc_ownership(strong)</code> 来强引用 weakSelf，所以此时 self 的引用计数 +1。这就保证了在函数执行的过程中，Block 会一直持有 self，知道 Block 执行完毕之后会释放 weakSelf。</p>\n<p>所以 🌰3 完美的解决了循环应用和直接使用 <code>__weak</code> 可能导致奔溃的问题。</p>\n<hr>\n<p>最后，说一下关于 _Block_object_assign 的猜想：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br></pre></td></tr></table></figure>\n\n<p>通过上面的例子，我们知道 Block 在构造的时候就会对捕获的变量进行内存管理（强引用和弱引用），所以当 Block 在做 Copy 操作的时候其实没有必要对它捕获的变量再做一遍内存管理了。这也应该是 Block 的 Copy 操作使用了 <code>_Block_object_assign</code> 这种不会导致引用计数发生变化的方式来实现的原因。</p>\n"},{"title":"初步了解 GCD","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n## GCD 简介\n\nGCD(Grand Central Dispatch) 是苹果提供的一套多线程编程技术。想象一下，如果让你编写一个可以高效的跑在不同计算机、不同内核的应用程序，你会怎么做呢？你要看看硬件是什么，看看有有多少个内核，想想用什么算法，想想在什么时候去切换线程...总之，你要做的东西多了去了。而 GCD 帮我们屏蔽了这些技术细节，但是如果要用好 GCD 的话，还是要多了解一些知识点。\n\n## Dispatch 对象和内存管理\n\n在 Objective-C 里面，所有的 dispatch 对象都是 Objective-C 对象，所以他们同样适用引用技术的内存管理。如果你是使用 ARC 的话，dispatch 对象会向普通的 Objective-C 对象一样自动进行 retain 和 release 操作；如果你是使用 MRC，要记住使用 dispatch_retain 和 dispatch_release 来进行管理。\n\n## 常用 API\n\n### dispatch_queue_t（调度队列）\n\n```Swift\npublic func dispatch_queue_create(label: UnsafePointer<Int8>, _ attr: dispatch_queue_attr_t!) -> dispatch_queue_t!\n```\n\n在 GCD 中只能通过上面的 API 来创建调度队列，我们可以通过创建各种各样的 Block 形式的任务并由该调度队列来决定如何去执行这些 Block 任务。上面创建调度队列的函数需要两个参数：\n\n* label: 这个参数是用来给你创建的调度队列进行命名的，特别是在调试的时候你可以通过该参数来判断是哪个调度队列的任务在执行。\n* attr: 这个参数只有 DISPATCH_QUEUE_SERIAL 和 DISPATCH_QUEUE_CONCURRENT 两种值（在 Objective-C 中这个参数可以为 NULL，这个时候默认是 DISPATCH_QUEUE_SERIAL）。DISPATCH_QUEUE_SERIAL 是告诉调度队列以串行的方式去执行任务，DISPATCH_QUEUE_CONCURRENT 是告诉调度队列以并发的方式去执行任务。\n\n当然我们还可以通过下面的方法来获取系统已经创建好的调度队列：\n\n```Swift\n// 获取全局队列\npublic func dispatch_get_global_queue(identifier: Int, _ flags: UInt) -> dispatch_queue_t!\n```\n```Swift\n// 获取主线程的com.apple.main-thread (serial)队列\npublic func dispatch_get_main_queue() -> dispatch_queue_t!\n```\n\n注意，所有 pending 状态的 Block 任务都会持有该调度队列的引用，所以我们不需要显示的去持有调度队列，而调度队列会在所有的 Block 任务都从 pending 变为 finished 之后才会被释放。\n\n总之，现在大家要知道的是我们可以把不同的 Block任务提交到调度队列，具体的细节和实现看看后面内容。\n\n### dispatch_sync 和 dispatch_async（同步和异步）\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建调度队列\nprint(\"Begin Sync\")\n// 同步调用\ndispatch_sync(queue) {\n    // Block任务\n    print(\"Execute Block Task1\")   \n}\ndispatch_sync(queue) {\n    // Block任务\n    print(\"Execute Block Task2\")   \n}\nprint(\"After Sync\")\n```\n\n这段代码的输出结果如下：\n\n```Swift\nBegin Sync\nExecute Block Task1\nExecute Block Task2\nAfter Sync\n```\n\n上面的例子就是我们平常对 dispatch_sync 的用法，并且我们可以看到第一个 Block 任务执行之后才会执行第二个 Block 任务。dispatch_sync 需要等待 Block的任务执行完成之后，才能继续往后执行。但是使用 dispatch_sync 的时候，有几点是需要注意的：\n\n1. 当调用 dispatch_sync 方法的时候，系统默认情况下会在当前线程去执行调度队列里的任务，只有在一些特殊情况下才会把调度队列的任务分配到其他线程去执行。所以我们就知道，线程和调度队列并不是一对一的关系。至于为什么默认情况下会在当前线程去执行调度队列里的任务，我的猜测是为了性能。大家想一想，dispatch_sync 会同步执行 Block任务， Block任务没有结束的情况下，后面的代码是无法执行的。基于这样一个同步的机制，GCD 还有必要先把当前线程挂起，然后去创建新线程，然后切换到新的线程去执行调度队列里的任务，然后再把线程切换到当前线程，然后再让当前线程恢复么？结论是没有必要。\n\n2. 你不能够在当前的串行调度队列的任务里面去添加新的任务到当前的调度队列里面，否则会造成死锁。这句话怎么理解呢，我们来来看看下面的例子：\n    \n```Swift\n// 例1\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n// 同步调用\ndispatch_sync(queue) {\n    // Block1\n    print(\"Begin Execute Block Task1\")\n    dispatch_sync(queue) {\n        // Block2\n        print(\"Execute Block Task2\")   \n    }\n    print(\"End Execute Block Task1\")\n}\n\n// 例1的结果\nBegin Execute Block Task1\n    \n```\n\n为什么 Block1 后面的 print 和 Block2 的 print 都不执行了呢？首先我们要知道被 DISPATCH_QUEUE_SERIAL 声明的调度队列是串行调度队列，串行调度队列里的任务是同时只能有一个任务在执行，并且当前任务没有执行完成，下一个任务也无法执行。上面的例子中会先输出 Block1 中的 *Begin Execute Block Task1*，然后这个时候再把 Block2 添加到同一个串行调度队列中去。这个时候的 Block1 还没有执行完成，它需要等 dispatch_sync 的 Block2 执行完成之后才能继续执行，而 Block2 又必须等待 Block1 执行完成之后才能执行，所以这个时候就造成 Block1 等着 Block2，Block2 等着 Block1 的死锁。\n\n我们再把调度队列属性改为 DISPAT_QUEUE_CONCURRENT，然后再看看执行结果是什么：\n\n\n```Swift\n// 例2\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n// 同步调用\ndispatch_sync(queue) {\n    // Block1\n    print(\"Begin Execute Block Task1\")\n    dispatch_sync(queue) {\n        // Block2\n        print(\"Execute Block Task2\")   \n    }\n    print(\"End Execute Block Task1\")\n}\n```\n    \n```Swift\n// 例2的结果\nBegin Execute Block Task1\nExecute Block Task2\nEnd Execute Block Task1\n```\n\n被 DISPATCH_QUEUE_CONCURRENT 声明的并发调度队列就没有这种死锁的问题。并发调度队列里的任务是不会霸占资源不放的，每一个任务执行一个时间片段之后会把资源交出来给别的任务去执行。所以例2中的 Block1 虽然需要等待 Block2 执行完成之后才能继续执行，但是当 Block1 在等待的过程中，是可以把资源释放出来交给 Block2 去执行，Block2 执行完成之后 Block1 就可以继续执行了。所以，这个时候就不会造成死锁来。\n\n再来看看下面的例子会不会造成死锁：\n\n```Swift\noverride func viewDidLoad() {\n    dispatch_sync(dispatch_get_main_queue()) {\n        print(\"Excute Block Task\")\n    }\n}\n```\n    \n答案是会的。给大家一点提示，主线程的默认调度队列是串行（DISPATCH_QUEUE_SERIAL）的，viewDidLoad() 是在主线程的调度队列 com.apple.main-thread (serial) 执行的。\n\n上面的例子主要是希望大家理解串行和并发的概念，同时要明白造成死锁的原因。而要解决死锁一般可以用 DISPATCH_QUEUE_CONCURRENT 或接下来我们要讲的 dispatch_async 来解决。\n\n通过对 dispatch_sync 的了解，我们可以利用 dispatch_async 很快的写出异步代码：\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建调度队列\nprint(\"Begin Async\")\n// 异步调用\ndispatch_async(queue) {\n    // Block1\n    print(\"Execute Block Task1\")   \n}\ndispatch_async(queue) {\n    // Block2\n    print(\"Execute Block Task2\")   \n}\nprint(\"After Async\")\n```\n\n这个例子的结果有好几种：\n\n```Swift\n// 结果1\nBegin Async\nAfter Async\nExecute Block Task1\nExEcute Block Task2\n```\n```Swift\n// 结果2\nBegin Async\nExecute Block Task1\nExEcute Block Task2\nAfter Async\n```\n\n上面只是列出来两种可能，但实际上还有其他的可能。当我们调用 dispatch_async 的时候，它总是会在 Block 任务被提交之后马上返回，而不会傻傻的等待 Block 任务执行完成。由于上面创建的是串行调度队列，所以我们可以保证 Block1 要比 Block2 优先执行，但是 After Async 就无法确定是在 Block1 的前后还是 Block2 的前后。\n\n如果我们把上面的 DISPATCH_QUEUE_SERIAL 改成 DISPATCH_QUEUE_CONCURRENT，那我们就无法确定 After Async、Block1 和 Block2 这三者的执行顺序了。\n\n我们刚才说到用 dispatch_async 可以解决死锁的问题，那它是怎么解决的呢？\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n// 异步调用\ndispatch_async(queue) {\n    // Block1\n    print(\"Begin Execute Block Task1\")\n    dispatch_async(queue) {\n        // Block2\n        print(\"Execute Block Task2\")   \n    }\n    print(\"End Execute Block Task1\")\n}\n```\n\n上面的例子会优先输出 Block1 的 *Begin Execute Block Task1* 之后，通过 dispatch_async 把 Block2 提交到串行队列里面，然后又马上返回到 Block1 去输出 *End Execute Block Task1*，这个时候的 Block1 就结束了，接下来就开始执行 Block2。所以上面的代码是不会造成死锁的，虽然上面的例子也是创建了一个串行调度队列，但是该调度队列只是保证了 Block1 要比 Block2 优先执行。\n\n### dispatch_once\n\n写过 Objective-C 的人都知道，dispatch_once 一般会被用来创建单例对象：\n\n```Swift\n@implementation Single\n+ (Single *)sharedInstance {\n    static Single * _single = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        _single = [[Single alloc] init];\n    });\n    return _single; \n}\n@end\n```\n\n这是由于 dispatch_once 是线程安全且只会执行一次，所以才会被用来作为单例的实现。这里需要注意的是 dispatch_once_t 必须是静态的或全局的才能保证 dispatch_once 的 Block 只会被执行一次，所以上面的代码用了 static 来修饰 dispatch_once_t。\n\n### dispatch_apply\n\n```Swift\npublic func dispatch_apply(iterations: Int, _ queue: dispatch_queue_t!, _ block: (Int) -> Void)\n```\n\n其中的 interations 是表明要执行多少次 block，block 中的 Int 是该 Block 被执行的序号。调用这个方法的时候要注意该方法跟 dispatch_sync 一样会阻塞当前线程，所以我们需要注意在主线程中调用该方法。\n\n### dispatch_after\n\n```Swift\npublic func dispatch_after(when: dispatch_time_t, _ queue: dispatch_queue_t, _ block: dispatch_block_t)\n```\n\n调用这个方法的时候需要注意的是 when 这个参数，你需要通过 dispatch_time 或 dispatch_walltime 来创建。并且该方法是异步执行的，并不会阻塞当前线程。\n\n一般的写法如下：\n\n```Swift\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(5 * NSEC_PER_SEC)), queue) {\n    print(\"5s \\(NSThread.currentThread())\")\n}\n```\n\n### dispatch_group_t\n\ndispatch_group_t 是用来做聚合同步的，它可以用来跟踪你提交的所有任务（即使是在不同的调度队列也可以）的完成状态。\n\n接下来我们来看看 dispatch group 的一些常见用法：\n\n```Swift\n// 创建 dispatch_group_t 对象\nlet group = dispatch_group_create()\n\n// 创建串行队列\nlet serialQueue = dispatch_queue_create(\"Serial Queue\", DISPATCH_QUEUE_SERIAL)\n\n// 提交两个 Block 任务到 serialQueue，同时关联 serialQueue 和 group 的关系\ndispatch_group_async(group, serialQueue) {\n    print(\"Execute Block1 within Serial Queue\")\n}\ndispatch_group_async(group, serialQueue) {\n    print(\"Execute Block2 within Serial Queue\")\n}\n\n// 创建并发队列，并提交 Block 任务，同时关联该并发队列和 group 的关系\ndispatch_group_async(group, dispatch_queue_create(\"Concurrent Queue\", DISPATCH_QUEUE_CONCURRENT)) {\n    print(\"Execute Block within Concurrent Queue\")\n}\n\n// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发\ndispatch_group_notify(group, dispatch_queue_create(\"Finished\")) {\n    print(\"Finished\")\n}\n```\n\n注意，关联到 group 的方法只有 dispatch_group_async 而没有 dispatch_group_sync。\n\n但是还有另外一种方法可以让我们关联一个普通的任务：\n\n```Swift\n// 创建 dispatch_group_t 对象\nlet group = dispatch_group_create()\n\n// 使用 dispatch_group_enter 和 dispatch_group_leave 的话，我们不需要调用\n// dispatch_group_async 也能关联一个任务到 group 上\ndispatch_group_enter(group)\nself.executeTask {\n    // 执行代码\n    \n    dispatch_group_leave(group)\n}\n\n// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发\ndispatch_group_notify(group, dispatch_queue_create(\"Finished\")) {\n    print(\"Finished\")\n}\n```\n\n使用 dispatch_group_enter 和 dispatch_group_leave 的时候，它们必须成双成对出现，否则 dispatch_group_notify 是不会被调用的。\n\n接下来我们还要了解一下 dispatch_group_wait：\n\n```Swift\npublic func dispatch_group_wait(group: dispatch_group_t, _ timeout: dispatch_time_t) -> Int\n```\n\ndispatch_group_wait 可以指定一个 timeout 的参数，当 group 的任务没有在规定的时间内完成，它会返回一个非零的值，当 group 的任务能够在规定的时间内完成就返回0。同时，大家要注意这个方法会挂起当前线程，所以在主线程的时候要慎重使用该方法。\n\n### dispatch_barrier_t\n\n我们先来试想一个场景，假如现在有多个线程要去读取一份文件的内容，同时又有其他线程想要去更新该文件的内容，那么就有可能会发生你读错文件内容的现象。这个时候我们可以把所有读写操作都放到我们之前学习的串行队列去执行，但是我们都知道同时有多个线程去读取一份文件内容是没有问题的。\n\n使用 dispatch barrier 可以解决上面的问题：\n\n```Swift\n// 创建操作文件的并发队列\nlet queue = dispatch_queue_create(\"File\", DISPATCH_QUEUE_CONCURRENT)\ndispatch_async(queue) {\n    // Read1\n}\ndispatch_async(queue) {\n    // Read2\n}\ndispatch_barrier_async(queue) {\n    // Write\n}\ndispatch_async(queue) {\n    // Read3\n}\n```\n\n通过 dispatch_barrier_async 或 dispatch_barrier_sync 提交的任务会等待当前队列里正在执行的任务执行完毕才会执行，并且其他还没有执行的任务都必须等待提交到 dispatch barrier 的任务执行完毕之后才会开始执行。所以上面的代码中，当 Write 任务被提交的时候，如果当前队列中只有 Read1 在执行，那么 Write 会等待 Read1 执行完成之后才会执行，Read2  和 Read3 都必须等待 Write 执行完之后才会执行。另外，上面的代码中创建的是并发队列，因为如果是串行队列的话就没有必要用 dispatch barrier 了。\n\n### dispatch_semaphore_t\n\ndispatch semaphore 是一个效率非常高的传统计数信号量，所以我们一般可以用这个来控制最大的并发数量。\n\n```Swift\n// 创建初始值为2的信号量，最大并发数量为2\nlet semaphore = dispatch_semaphore_create(2)\n// 创建并发队列\nlet queue = dispatch_queue_create(\"Semaphore\", DISPATCH_QUEUE_CONCURRENT)\n// 创建100个并发任务\nfor index in 1...100 {\n    // 这个方法会进行信号量减1的操作，并且如果信号量减1之后的结果小于0的话，该方法会造成线程的挂起直\n    // 到该信号量进行加1操作才会恢复，所以在主线程要注意该方法的使用。\n    // 注意：这个方法要放在 dispatch_async 外面，否则系统依旧会创建超过2个线程同时来处理该调度队列\n    // 的任务\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)\n    dispatch_async(queue) {\n        \n        // 释放资源，信号量增加1\n        dispatch_semaphore_signal(semaphore)\n    }\n}\n```\n\n## 其他\n\nGCD 在 Swift3 的语法跟现在的语法不太一样了，有兴趣的可以自行去了解。在未来可能会考虑把本文章的代码都用 Swift3 的语法来重新写一下。\n\n\n\n\n","source":"_posts/初步了解GCD.md","raw":"---\ntitle: 初步了解 GCD\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: 技术 \ntags: [iOS, GCD]\n---\n\n## GCD 简介\n\nGCD(Grand Central Dispatch) 是苹果提供的一套多线程编程技术。想象一下，如果让你编写一个可以高效的跑在不同计算机、不同内核的应用程序，你会怎么做呢？你要看看硬件是什么，看看有有多少个内核，想想用什么算法，想想在什么时候去切换线程...总之，你要做的东西多了去了。而 GCD 帮我们屏蔽了这些技术细节，但是如果要用好 GCD 的话，还是要多了解一些知识点。\n\n## Dispatch 对象和内存管理\n\n在 Objective-C 里面，所有的 dispatch 对象都是 Objective-C 对象，所以他们同样适用引用技术的内存管理。如果你是使用 ARC 的话，dispatch 对象会向普通的 Objective-C 对象一样自动进行 retain 和 release 操作；如果你是使用 MRC，要记住使用 dispatch_retain 和 dispatch_release 来进行管理。\n\n## 常用 API\n\n### dispatch_queue_t（调度队列）\n\n```Swift\npublic func dispatch_queue_create(label: UnsafePointer<Int8>, _ attr: dispatch_queue_attr_t!) -> dispatch_queue_t!\n```\n\n在 GCD 中只能通过上面的 API 来创建调度队列，我们可以通过创建各种各样的 Block 形式的任务并由该调度队列来决定如何去执行这些 Block 任务。上面创建调度队列的函数需要两个参数：\n\n* label: 这个参数是用来给你创建的调度队列进行命名的，特别是在调试的时候你可以通过该参数来判断是哪个调度队列的任务在执行。\n* attr: 这个参数只有 DISPATCH_QUEUE_SERIAL 和 DISPATCH_QUEUE_CONCURRENT 两种值（在 Objective-C 中这个参数可以为 NULL，这个时候默认是 DISPATCH_QUEUE_SERIAL）。DISPATCH_QUEUE_SERIAL 是告诉调度队列以串行的方式去执行任务，DISPATCH_QUEUE_CONCURRENT 是告诉调度队列以并发的方式去执行任务。\n\n当然我们还可以通过下面的方法来获取系统已经创建好的调度队列：\n\n```Swift\n// 获取全局队列\npublic func dispatch_get_global_queue(identifier: Int, _ flags: UInt) -> dispatch_queue_t!\n```\n```Swift\n// 获取主线程的com.apple.main-thread (serial)队列\npublic func dispatch_get_main_queue() -> dispatch_queue_t!\n```\n\n注意，所有 pending 状态的 Block 任务都会持有该调度队列的引用，所以我们不需要显示的去持有调度队列，而调度队列会在所有的 Block 任务都从 pending 变为 finished 之后才会被释放。\n\n总之，现在大家要知道的是我们可以把不同的 Block任务提交到调度队列，具体的细节和实现看看后面内容。\n\n### dispatch_sync 和 dispatch_async（同步和异步）\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建调度队列\nprint(\"Begin Sync\")\n// 同步调用\ndispatch_sync(queue) {\n    // Block任务\n    print(\"Execute Block Task1\")   \n}\ndispatch_sync(queue) {\n    // Block任务\n    print(\"Execute Block Task2\")   \n}\nprint(\"After Sync\")\n```\n\n这段代码的输出结果如下：\n\n```Swift\nBegin Sync\nExecute Block Task1\nExecute Block Task2\nAfter Sync\n```\n\n上面的例子就是我们平常对 dispatch_sync 的用法，并且我们可以看到第一个 Block 任务执行之后才会执行第二个 Block 任务。dispatch_sync 需要等待 Block的任务执行完成之后，才能继续往后执行。但是使用 dispatch_sync 的时候，有几点是需要注意的：\n\n1. 当调用 dispatch_sync 方法的时候，系统默认情况下会在当前线程去执行调度队列里的任务，只有在一些特殊情况下才会把调度队列的任务分配到其他线程去执行。所以我们就知道，线程和调度队列并不是一对一的关系。至于为什么默认情况下会在当前线程去执行调度队列里的任务，我的猜测是为了性能。大家想一想，dispatch_sync 会同步执行 Block任务， Block任务没有结束的情况下，后面的代码是无法执行的。基于这样一个同步的机制，GCD 还有必要先把当前线程挂起，然后去创建新线程，然后切换到新的线程去执行调度队列里的任务，然后再把线程切换到当前线程，然后再让当前线程恢复么？结论是没有必要。\n\n2. 你不能够在当前的串行调度队列的任务里面去添加新的任务到当前的调度队列里面，否则会造成死锁。这句话怎么理解呢，我们来来看看下面的例子：\n    \n```Swift\n// 例1\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n// 同步调用\ndispatch_sync(queue) {\n    // Block1\n    print(\"Begin Execute Block Task1\")\n    dispatch_sync(queue) {\n        // Block2\n        print(\"Execute Block Task2\")   \n    }\n    print(\"End Execute Block Task1\")\n}\n\n// 例1的结果\nBegin Execute Block Task1\n    \n```\n\n为什么 Block1 后面的 print 和 Block2 的 print 都不执行了呢？首先我们要知道被 DISPATCH_QUEUE_SERIAL 声明的调度队列是串行调度队列，串行调度队列里的任务是同时只能有一个任务在执行，并且当前任务没有执行完成，下一个任务也无法执行。上面的例子中会先输出 Block1 中的 *Begin Execute Block Task1*，然后这个时候再把 Block2 添加到同一个串行调度队列中去。这个时候的 Block1 还没有执行完成，它需要等 dispatch_sync 的 Block2 执行完成之后才能继续执行，而 Block2 又必须等待 Block1 执行完成之后才能执行，所以这个时候就造成 Block1 等着 Block2，Block2 等着 Block1 的死锁。\n\n我们再把调度队列属性改为 DISPAT_QUEUE_CONCURRENT，然后再看看执行结果是什么：\n\n\n```Swift\n// 例2\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n// 同步调用\ndispatch_sync(queue) {\n    // Block1\n    print(\"Begin Execute Block Task1\")\n    dispatch_sync(queue) {\n        // Block2\n        print(\"Execute Block Task2\")   \n    }\n    print(\"End Execute Block Task1\")\n}\n```\n    \n```Swift\n// 例2的结果\nBegin Execute Block Task1\nExecute Block Task2\nEnd Execute Block Task1\n```\n\n被 DISPATCH_QUEUE_CONCURRENT 声明的并发调度队列就没有这种死锁的问题。并发调度队列里的任务是不会霸占资源不放的，每一个任务执行一个时间片段之后会把资源交出来给别的任务去执行。所以例2中的 Block1 虽然需要等待 Block2 执行完成之后才能继续执行，但是当 Block1 在等待的过程中，是可以把资源释放出来交给 Block2 去执行，Block2 执行完成之后 Block1 就可以继续执行了。所以，这个时候就不会造成死锁来。\n\n再来看看下面的例子会不会造成死锁：\n\n```Swift\noverride func viewDidLoad() {\n    dispatch_sync(dispatch_get_main_queue()) {\n        print(\"Excute Block Task\")\n    }\n}\n```\n    \n答案是会的。给大家一点提示，主线程的默认调度队列是串行（DISPATCH_QUEUE_SERIAL）的，viewDidLoad() 是在主线程的调度队列 com.apple.main-thread (serial) 执行的。\n\n上面的例子主要是希望大家理解串行和并发的概念，同时要明白造成死锁的原因。而要解决死锁一般可以用 DISPATCH_QUEUE_CONCURRENT 或接下来我们要讲的 dispatch_async 来解决。\n\n通过对 dispatch_sync 的了解，我们可以利用 dispatch_async 很快的写出异步代码：\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建调度队列\nprint(\"Begin Async\")\n// 异步调用\ndispatch_async(queue) {\n    // Block1\n    print(\"Execute Block Task1\")   \n}\ndispatch_async(queue) {\n    // Block2\n    print(\"Execute Block Task2\")   \n}\nprint(\"After Async\")\n```\n\n这个例子的结果有好几种：\n\n```Swift\n// 结果1\nBegin Async\nAfter Async\nExecute Block Task1\nExEcute Block Task2\n```\n```Swift\n// 结果2\nBegin Async\nExecute Block Task1\nExEcute Block Task2\nAfter Async\n```\n\n上面只是列出来两种可能，但实际上还有其他的可能。当我们调用 dispatch_async 的时候，它总是会在 Block 任务被提交之后马上返回，而不会傻傻的等待 Block 任务执行完成。由于上面创建的是串行调度队列，所以我们可以保证 Block1 要比 Block2 优先执行，但是 After Async 就无法确定是在 Block1 的前后还是 Block2 的前后。\n\n如果我们把上面的 DISPATCH_QUEUE_SERIAL 改成 DISPATCH_QUEUE_CONCURRENT，那我们就无法确定 After Async、Block1 和 Block2 这三者的执行顺序了。\n\n我们刚才说到用 dispatch_async 可以解决死锁的问题，那它是怎么解决的呢？\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n// 异步调用\ndispatch_async(queue) {\n    // Block1\n    print(\"Begin Execute Block Task1\")\n    dispatch_async(queue) {\n        // Block2\n        print(\"Execute Block Task2\")   \n    }\n    print(\"End Execute Block Task1\")\n}\n```\n\n上面的例子会优先输出 Block1 的 *Begin Execute Block Task1* 之后，通过 dispatch_async 把 Block2 提交到串行队列里面，然后又马上返回到 Block1 去输出 *End Execute Block Task1*，这个时候的 Block1 就结束了，接下来就开始执行 Block2。所以上面的代码是不会造成死锁的，虽然上面的例子也是创建了一个串行调度队列，但是该调度队列只是保证了 Block1 要比 Block2 优先执行。\n\n### dispatch_once\n\n写过 Objective-C 的人都知道，dispatch_once 一般会被用来创建单例对象：\n\n```Swift\n@implementation Single\n+ (Single *)sharedInstance {\n    static Single * _single = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        _single = [[Single alloc] init];\n    });\n    return _single; \n}\n@end\n```\n\n这是由于 dispatch_once 是线程安全且只会执行一次，所以才会被用来作为单例的实现。这里需要注意的是 dispatch_once_t 必须是静态的或全局的才能保证 dispatch_once 的 Block 只会被执行一次，所以上面的代码用了 static 来修饰 dispatch_once_t。\n\n### dispatch_apply\n\n```Swift\npublic func dispatch_apply(iterations: Int, _ queue: dispatch_queue_t!, _ block: (Int) -> Void)\n```\n\n其中的 interations 是表明要执行多少次 block，block 中的 Int 是该 Block 被执行的序号。调用这个方法的时候要注意该方法跟 dispatch_sync 一样会阻塞当前线程，所以我们需要注意在主线程中调用该方法。\n\n### dispatch_after\n\n```Swift\npublic func dispatch_after(when: dispatch_time_t, _ queue: dispatch_queue_t, _ block: dispatch_block_t)\n```\n\n调用这个方法的时候需要注意的是 when 这个参数，你需要通过 dispatch_time 或 dispatch_walltime 来创建。并且该方法是异步执行的，并不会阻塞当前线程。\n\n一般的写法如下：\n\n```Swift\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(5 * NSEC_PER_SEC)), queue) {\n    print(\"5s \\(NSThread.currentThread())\")\n}\n```\n\n### dispatch_group_t\n\ndispatch_group_t 是用来做聚合同步的，它可以用来跟踪你提交的所有任务（即使是在不同的调度队列也可以）的完成状态。\n\n接下来我们来看看 dispatch group 的一些常见用法：\n\n```Swift\n// 创建 dispatch_group_t 对象\nlet group = dispatch_group_create()\n\n// 创建串行队列\nlet serialQueue = dispatch_queue_create(\"Serial Queue\", DISPATCH_QUEUE_SERIAL)\n\n// 提交两个 Block 任务到 serialQueue，同时关联 serialQueue 和 group 的关系\ndispatch_group_async(group, serialQueue) {\n    print(\"Execute Block1 within Serial Queue\")\n}\ndispatch_group_async(group, serialQueue) {\n    print(\"Execute Block2 within Serial Queue\")\n}\n\n// 创建并发队列，并提交 Block 任务，同时关联该并发队列和 group 的关系\ndispatch_group_async(group, dispatch_queue_create(\"Concurrent Queue\", DISPATCH_QUEUE_CONCURRENT)) {\n    print(\"Execute Block within Concurrent Queue\")\n}\n\n// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发\ndispatch_group_notify(group, dispatch_queue_create(\"Finished\")) {\n    print(\"Finished\")\n}\n```\n\n注意，关联到 group 的方法只有 dispatch_group_async 而没有 dispatch_group_sync。\n\n但是还有另外一种方法可以让我们关联一个普通的任务：\n\n```Swift\n// 创建 dispatch_group_t 对象\nlet group = dispatch_group_create()\n\n// 使用 dispatch_group_enter 和 dispatch_group_leave 的话，我们不需要调用\n// dispatch_group_async 也能关联一个任务到 group 上\ndispatch_group_enter(group)\nself.executeTask {\n    // 执行代码\n    \n    dispatch_group_leave(group)\n}\n\n// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发\ndispatch_group_notify(group, dispatch_queue_create(\"Finished\")) {\n    print(\"Finished\")\n}\n```\n\n使用 dispatch_group_enter 和 dispatch_group_leave 的时候，它们必须成双成对出现，否则 dispatch_group_notify 是不会被调用的。\n\n接下来我们还要了解一下 dispatch_group_wait：\n\n```Swift\npublic func dispatch_group_wait(group: dispatch_group_t, _ timeout: dispatch_time_t) -> Int\n```\n\ndispatch_group_wait 可以指定一个 timeout 的参数，当 group 的任务没有在规定的时间内完成，它会返回一个非零的值，当 group 的任务能够在规定的时间内完成就返回0。同时，大家要注意这个方法会挂起当前线程，所以在主线程的时候要慎重使用该方法。\n\n### dispatch_barrier_t\n\n我们先来试想一个场景，假如现在有多个线程要去读取一份文件的内容，同时又有其他线程想要去更新该文件的内容，那么就有可能会发生你读错文件内容的现象。这个时候我们可以把所有读写操作都放到我们之前学习的串行队列去执行，但是我们都知道同时有多个线程去读取一份文件内容是没有问题的。\n\n使用 dispatch barrier 可以解决上面的问题：\n\n```Swift\n// 创建操作文件的并发队列\nlet queue = dispatch_queue_create(\"File\", DISPATCH_QUEUE_CONCURRENT)\ndispatch_async(queue) {\n    // Read1\n}\ndispatch_async(queue) {\n    // Read2\n}\ndispatch_barrier_async(queue) {\n    // Write\n}\ndispatch_async(queue) {\n    // Read3\n}\n```\n\n通过 dispatch_barrier_async 或 dispatch_barrier_sync 提交的任务会等待当前队列里正在执行的任务执行完毕才会执行，并且其他还没有执行的任务都必须等待提交到 dispatch barrier 的任务执行完毕之后才会开始执行。所以上面的代码中，当 Write 任务被提交的时候，如果当前队列中只有 Read1 在执行，那么 Write 会等待 Read1 执行完成之后才会执行，Read2  和 Read3 都必须等待 Write 执行完之后才会执行。另外，上面的代码中创建的是并发队列，因为如果是串行队列的话就没有必要用 dispatch barrier 了。\n\n### dispatch_semaphore_t\n\ndispatch semaphore 是一个效率非常高的传统计数信号量，所以我们一般可以用这个来控制最大的并发数量。\n\n```Swift\n// 创建初始值为2的信号量，最大并发数量为2\nlet semaphore = dispatch_semaphore_create(2)\n// 创建并发队列\nlet queue = dispatch_queue_create(\"Semaphore\", DISPATCH_QUEUE_CONCURRENT)\n// 创建100个并发任务\nfor index in 1...100 {\n    // 这个方法会进行信号量减1的操作，并且如果信号量减1之后的结果小于0的话，该方法会造成线程的挂起直\n    // 到该信号量进行加1操作才会恢复，所以在主线程要注意该方法的使用。\n    // 注意：这个方法要放在 dispatch_async 外面，否则系统依旧会创建超过2个线程同时来处理该调度队列\n    // 的任务\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)\n    dispatch_async(queue) {\n        \n        // 释放资源，信号量增加1\n        dispatch_semaphore_signal(semaphore)\n    }\n}\n```\n\n## 其他\n\nGCD 在 Swift3 的语法跟现在的语法不太一样了，有兴趣的可以自行去了解。在未来可能会考虑把本文章的代码都用 Swift3 的语法来重新写一下。\n\n\n\n\n","slug":"初步了解GCD","published":1,"updated":"2022-04-20T07:08:33.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxej001a6enqbp9h9x5b","content":"<h2 id=\"GCD-简介\"><a href=\"#GCD-简介\" class=\"headerlink\" title=\"GCD 简介\"></a>GCD 简介</h2><p>GCD(Grand Central Dispatch) 是苹果提供的一套多线程编程技术。想象一下，如果让你编写一个可以高效的跑在不同计算机、不同内核的应用程序，你会怎么做呢？你要看看硬件是什么，看看有有多少个内核，想想用什么算法，想想在什么时候去切换线程…总之，你要做的东西多了去了。而 GCD 帮我们屏蔽了这些技术细节，但是如果要用好 GCD 的话，还是要多了解一些知识点。</p>\n<h2 id=\"Dispatch-对象和内存管理\"><a href=\"#Dispatch-对象和内存管理\" class=\"headerlink\" title=\"Dispatch 对象和内存管理\"></a>Dispatch 对象和内存管理</h2><p>在 Objective-C 里面，所有的 dispatch 对象都是 Objective-C 对象，所以他们同样适用引用技术的内存管理。如果你是使用 ARC 的话，dispatch 对象会向普通的 Objective-C 对象一样自动进行 retain 和 release 操作；如果你是使用 MRC，要记住使用 dispatch_retain 和 dispatch_release 来进行管理。</p>\n<h2 id=\"常用-API\"><a href=\"#常用-API\" class=\"headerlink\" title=\"常用 API\"></a>常用 API</h2><h3 id=\"dispatch-queue-t（调度队列）\"><a href=\"#dispatch-queue-t（调度队列）\" class=\"headerlink\" title=\"dispatch_queue_t（调度队列）\"></a>dispatch_queue_t（调度队列）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_queue_create</span>(<span class=\"params\">label</span>: <span class=\"type\">UnsafePointer</span>&lt;<span class=\"type\">Int8</span>&gt;, <span class=\"keyword\">_</span> <span class=\"params\">attr</span>: dispatch_queue_attr_t<span class=\"operator\">!</span>) -&gt; dispatch_queue_t<span class=\"operator\">!</span></span><br></pre></td></tr></table></figure>\n\n<p>在 GCD 中只能通过上面的 API 来创建调度队列，我们可以通过创建各种各样的 Block 形式的任务并由该调度队列来决定如何去执行这些 Block 任务。上面创建调度队列的函数需要两个参数：</p>\n<ul>\n<li>label: 这个参数是用来给你创建的调度队列进行命名的，特别是在调试的时候你可以通过该参数来判断是哪个调度队列的任务在执行。</li>\n<li>attr: 这个参数只有 DISPATCH_QUEUE_SERIAL 和 DISPATCH_QUEUE_CONCURRENT 两种值（在 Objective-C 中这个参数可以为 NULL，这个时候默认是 DISPATCH_QUEUE_SERIAL）。DISPATCH_QUEUE_SERIAL 是告诉调度队列以串行的方式去执行任务，DISPATCH_QUEUE_CONCURRENT 是告诉调度队列以并发的方式去执行任务。</li>\n</ul>\n<p>当然我们还可以通过下面的方法来获取系统已经创建好的调度队列：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取全局队列</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_get_global_queue</span>(<span class=\"params\">identifier</span>: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> <span class=\"params\">flags</span>: <span class=\"type\">UInt</span>) -&gt; dispatch_queue_t<span class=\"operator\">!</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取主线程的com.apple.main-thread (serial)队列</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_get_main_queue</span>() -&gt; dispatch_queue_t<span class=\"operator\">!</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，所有 pending 状态的 Block 任务都会持有该调度队列的引用，所以我们不需要显示的去持有调度队列，而调度队列会在所有的 Block 任务都从 pending 变为 finished 之后才会被释放。</p>\n<p>总之，现在大家要知道的是我们可以把不同的 Block任务提交到调度队列，具体的细节和实现看看后面内容。</p>\n<h3 id=\"dispatch-sync-和-dispatch-async（同步和异步）\"><a href=\"#dispatch-sync-和-dispatch-async（同步和异步）\" class=\"headerlink\" title=\"dispatch_sync 和 dispatch_async（同步和异步）\"></a>dispatch_sync 和 dispatch_async（同步和异步）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建调度队列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Sync&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block任务</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task1&quot;</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block任务</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;After Sync&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的输出结果如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Sync</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Sync</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的例子就是我们平常对 dispatch_sync 的用法，并且我们可以看到第一个 Block 任务执行之后才会执行第二个 Block 任务。dispatch_sync 需要等待 Block的任务执行完成之后，才能继续往后执行。但是使用 dispatch_sync 的时候，有几点是需要注意的：</p>\n<ol>\n<li><p>当调用 dispatch_sync 方法的时候，系统默认情况下会在当前线程去执行调度队列里的任务，只有在一些特殊情况下才会把调度队列的任务分配到其他线程去执行。所以我们就知道，线程和调度队列并不是一对一的关系。至于为什么默认情况下会在当前线程去执行调度队列里的任务，我的猜测是为了性能。大家想一想，dispatch_sync 会同步执行 Block任务， Block任务没有结束的情况下，后面的代码是无法执行的。基于这样一个同步的机制，GCD 还有必要先把当前线程挂起，然后去创建新线程，然后切换到新的线程去执行调度队列里的任务，然后再把线程切换到当前线程，然后再让当前线程恢复么？结论是没有必要。</p>\n</li>\n<li><p>你不能够在当前的串行调度队列的任务里面去添加新的任务到当前的调度队列里面，否则会造成死锁。这句话怎么理解呢，我们来来看看下面的例子：</p>\n</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Execute Block Task1&quot;</span>)</span><br><span class=\"line\">    dispatch_sync(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Execute Block Task1&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例1的结果</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n<p>为什么 Block1 后面的 print 和 Block2 的 print 都不执行了呢？首先我们要知道被 DISPATCH_QUEUE_SERIAL 声明的调度队列是串行调度队列，串行调度队列里的任务是同时只能有一个任务在执行，并且当前任务没有执行完成，下一个任务也无法执行。上面的例子中会先输出 Block1 中的 <em>Begin Execute Block Task1</em>，然后这个时候再把 Block2 添加到同一个串行调度队列中去。这个时候的 Block1 还没有执行完成，它需要等 dispatch_sync 的 Block2 执行完成之后才能继续执行，而 Block2 又必须等待 Block1 执行完成之后才能执行，所以这个时候就造成 Block1 等着 Block2，Block2 等着 Block1 的死锁。</p>\n<p>我们再把调度队列属性改为 DISPAT_QUEUE_CONCURRENT，然后再看看执行结果是什么：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Execute Block Task1&quot;</span>)</span><br><span class=\"line\">    dispatch_sync(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Execute Block Task1&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2的结果</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">End</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br></pre></td></tr></table></figure>\n\n<p>被 DISPATCH_QUEUE_CONCURRENT 声明的并发调度队列就没有这种死锁的问题。并发调度队列里的任务是不会霸占资源不放的，每一个任务执行一个时间片段之后会把资源交出来给别的任务去执行。所以例2中的 Block1 虽然需要等待 Block2 执行完成之后才能继续执行，但是当 Block1 在等待的过程中，是可以把资源释放出来交给 Block2 去执行，Block2 执行完成之后 Block1 就可以继续执行了。所以，这个时候就不会造成死锁来。</p>\n<p>再来看看下面的例子会不会造成死锁：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">viewDidLoad</span>() &#123;</span><br><span class=\"line\">    dispatch_sync(dispatch_get_main_queue()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Excute Block Task&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案是会的。给大家一点提示，主线程的默认调度队列是串行（DISPATCH_QUEUE_SERIAL）的，viewDidLoad() 是在主线程的调度队列 com.apple.main-thread (serial) 执行的。</p>\n<p>上面的例子主要是希望大家理解串行和并发的概念，同时要明白造成死锁的原因。而要解决死锁一般可以用 DISPATCH_QUEUE_CONCURRENT 或接下来我们要讲的 dispatch_async 来解决。</p>\n<p>通过对 dispatch_sync 的了解，我们可以利用 dispatch_async 很快的写出异步代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建调度队列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Async&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 异步调用</span></span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task1&quot;</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block2</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;After Async&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这个例子的结果有好几种：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结果1</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">ExEcute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结果2</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">ExEcute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Async</span></span><br></pre></td></tr></table></figure>\n\n<p>上面只是列出来两种可能，但实际上还有其他的可能。当我们调用 dispatch_async 的时候，它总是会在 Block 任务被提交之后马上返回，而不会傻傻的等待 Block 任务执行完成。由于上面创建的是串行调度队列，所以我们可以保证 Block1 要比 Block2 优先执行，但是 After Async 就无法确定是在 Block1 的前后还是 Block2 的前后。</p>\n<p>如果我们把上面的 DISPATCH_QUEUE_SERIAL 改成 DISPATCH_QUEUE_CONCURRENT，那我们就无法确定 After Async、Block1 和 Block2 这三者的执行顺序了。</p>\n<p>我们刚才说到用 dispatch_async 可以解决死锁的问题，那它是怎么解决的呢？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 异步调用</span></span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Execute Block Task1&quot;</span>)</span><br><span class=\"line\">    dispatch_async(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Execute Block Task1&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子会优先输出 Block1 的 <em>Begin Execute Block Task1</em> 之后，通过 dispatch_async 把 Block2 提交到串行队列里面，然后又马上返回到 Block1 去输出 <em>End Execute Block Task1</em>，这个时候的 Block1 就结束了，接下来就开始执行 Block2。所以上面的代码是不会造成死锁的，虽然上面的例子也是创建了一个串行调度队列，但是该调度队列只是保证了 Block1 要比 Block2 优先执行。</p>\n<h3 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h3><p>写过 Objective-C 的人都知道，dispatch_once 一般会被用来创建单例对象：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@implementation</span> <span class=\"type\">Single</span></span><br><span class=\"line\"><span class=\"operator\">+</span> (<span class=\"type\">Single</span> <span class=\"operator\">*</span>)sharedInstance &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">Single</span> <span class=\"operator\">*</span> _single <span class=\"operator\">=</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(<span class=\"operator\">&amp;</span>onceToken, <span class=\"operator\">^</span>&#123;</span><br><span class=\"line\">        _single <span class=\"operator\">=</span> [[<span class=\"type\">Single</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _single; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>这是由于 dispatch_once 是线程安全且只会执行一次，所以才会被用来作为单例的实现。这里需要注意的是 dispatch_once_t 必须是静态的或全局的才能保证 dispatch_once 的 Block 只会被执行一次，所以上面的代码用了 static 来修饰 dispatch_once_t。</p>\n<h3 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_apply</span>(<span class=\"params\">iterations</span>: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> <span class=\"params\">queue</span>: dispatch_queue_t<span class=\"operator\">!</span>, <span class=\"keyword\">_</span> <span class=\"params\">block</span>: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Void</span>)</span><br></pre></td></tr></table></figure>\n\n<p>其中的 interations 是表明要执行多少次 block，block 中的 Int 是该 Block 被执行的序号。调用这个方法的时候要注意该方法跟 dispatch_sync 一样会阻塞当前线程，所以我们需要注意在主线程中调用该方法。</p>\n<h3 id=\"dispatch-after\"><a href=\"#dispatch-after\" class=\"headerlink\" title=\"dispatch_after\"></a>dispatch_after</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_after</span>(<span class=\"params\">when</span>: dispatch_time_t, <span class=\"keyword\">_</span> <span class=\"params\">queue</span>: dispatch_queue_t, <span class=\"keyword\">_</span> <span class=\"params\">block</span>: dispatch_block_t)</span><br></pre></td></tr></table></figure>\n\n<p>调用这个方法的时候需要注意的是 when 这个参数，你需要通过 dispatch_time 或 dispatch_walltime 来创建。并且该方法是异步执行的，并不会阻塞当前线程。</p>\n<p>一般的写法如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_after(dispatch_time(<span class=\"type\">DISPATCH_TIME_NOW</span>, <span class=\"type\">Int64</span>(<span class=\"number\">5</span> <span class=\"operator\">*</span> <span class=\"type\">NSEC_PER_SEC</span>)), queue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;5s <span class=\"subst\">\\(NSThread.currentThread())</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dispatch-group-t\"><a href=\"#dispatch-group-t\" class=\"headerlink\" title=\"dispatch_group_t\"></a>dispatch_group_t</h3><p>dispatch_group_t 是用来做聚合同步的，它可以用来跟踪你提交的所有任务（即使是在不同的调度队列也可以）的完成状态。</p>\n<p>接下来我们来看看 dispatch group 的一些常见用法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 dispatch_group_t 对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> group <span class=\"operator\">=</span> dispatch_group_create()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建串行队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> serialQueue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;Serial Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提交两个 Block 任务到 serialQueue，同时关联 serialQueue 和 group 的关系</span></span><br><span class=\"line\">dispatch_group_async(group, serialQueue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block1 within Serial Queue&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_group_async(group, serialQueue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block2 within Serial Queue&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并发队列，并提交 Block 任务，同时关联该并发队列和 group 的关系</span></span><br><span class=\"line\">dispatch_group_async(group, dispatch_queue_create(<span class=\"string\">&quot;Concurrent Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block within Concurrent Queue&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发</span></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_queue_create(<span class=\"string\">&quot;Finished&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Finished&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，关联到 group 的方法只有 dispatch_group_async 而没有 dispatch_group_sync。</p>\n<p>但是还有另外一种方法可以让我们关联一个普通的任务：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 dispatch_group_t 对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> group <span class=\"operator\">=</span> dispatch_group_create()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 dispatch_group_enter 和 dispatch_group_leave 的话，我们不需要调用</span></span><br><span class=\"line\"><span class=\"comment\">// dispatch_group_async 也能关联一个任务到 group 上</span></span><br><span class=\"line\">dispatch_group_enter(group)</span><br><span class=\"line\"><span class=\"keyword\">self</span>.executeTask &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行代码</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_group_leave(group)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发</span></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_queue_create(<span class=\"string\">&quot;Finished&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Finished&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 dispatch_group_enter 和 dispatch_group_leave 的时候，它们必须成双成对出现，否则 dispatch_group_notify 是不会被调用的。</p>\n<p>接下来我们还要了解一下 dispatch_group_wait：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_group_wait</span>(<span class=\"params\">group</span>: dispatch_group_t, <span class=\"keyword\">_</span> <span class=\"params\">timeout</span>: dispatch_time_t) -&gt; <span class=\"type\">Int</span></span><br></pre></td></tr></table></figure>\n\n<p>dispatch_group_wait 可以指定一个 timeout 的参数，当 group 的任务没有在规定的时间内完成，它会返回一个非零的值，当 group 的任务能够在规定的时间内完成就返回0。同时，大家要注意这个方法会挂起当前线程，所以在主线程的时候要慎重使用该方法。</p>\n<h3 id=\"dispatch-barrier-t\"><a href=\"#dispatch-barrier-t\" class=\"headerlink\" title=\"dispatch_barrier_t\"></a>dispatch_barrier_t</h3><p>我们先来试想一个场景，假如现在有多个线程要去读取一份文件的内容，同时又有其他线程想要去更新该文件的内容，那么就有可能会发生你读错文件内容的现象。这个时候我们可以把所有读写操作都放到我们之前学习的串行队列去执行，但是我们都知道同时有多个线程去读取一份文件内容是没有问题的。</p>\n<p>使用 dispatch barrier 可以解决上面的问题：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建操作文件的并发队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;File&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_barrier_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Write</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过 dispatch_barrier_async 或 dispatch_barrier_sync 提交的任务会等待当前队列里正在执行的任务执行完毕才会执行，并且其他还没有执行的任务都必须等待提交到 dispatch barrier 的任务执行完毕之后才会开始执行。所以上面的代码中，当 Write 任务被提交的时候，如果当前队列中只有 Read1 在执行，那么 Write 会等待 Read1 执行完成之后才会执行，Read2  和 Read3 都必须等待 Write 执行完之后才会执行。另外，上面的代码中创建的是并发队列，因为如果是串行队列的话就没有必要用 dispatch barrier 了。</p>\n<h3 id=\"dispatch-semaphore-t\"><a href=\"#dispatch-semaphore-t\" class=\"headerlink\" title=\"dispatch_semaphore_t\"></a>dispatch_semaphore_t</h3><p>dispatch semaphore 是一个效率非常高的传统计数信号量，所以我们一般可以用这个来控制最大的并发数量。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建初始值为2的信号量，最大并发数量为2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> semaphore <span class=\"operator\">=</span> dispatch_semaphore_create(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建并发队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;Semaphore&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建100个并发任务</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> <span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">100</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个方法会进行信号量减1的操作，并且如果信号量减1之后的结果小于0的话，该方法会造成线程的挂起直</span></span><br><span class=\"line\">    <span class=\"comment\">// 到该信号量进行加1操作才会恢复，所以在主线程要注意该方法的使用。</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意：这个方法要放在 dispatch_async 外面，否则系统依旧会创建超过2个线程同时来处理该调度队列</span></span><br><span class=\"line\">    <span class=\"comment\">// 的任务</span></span><br><span class=\"line\">    dispatch_semaphore_wait(semaphore, <span class=\"type\">DISPATCH_TIME_FOREVER</span>)</span><br><span class=\"line\">    dispatch_async(queue) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 释放资源，信号量增加1</span></span><br><span class=\"line\">        dispatch_semaphore_signal(semaphore)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>GCD 在 Swift3 的语法跟现在的语法不太一样了，有兴趣的可以自行去了解。在未来可能会考虑把本文章的代码都用 Swift3 的语法来重新写一下。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"GCD-简介\"><a href=\"#GCD-简介\" class=\"headerlink\" title=\"GCD 简介\"></a>GCD 简介</h2><p>GCD(Grand Central Dispatch) 是苹果提供的一套多线程编程技术。想象一下，如果让你编写一个可以高效的跑在不同计算机、不同内核的应用程序，你会怎么做呢？你要看看硬件是什么，看看有有多少个内核，想想用什么算法，想想在什么时候去切换线程…总之，你要做的东西多了去了。而 GCD 帮我们屏蔽了这些技术细节，但是如果要用好 GCD 的话，还是要多了解一些知识点。</p>\n<h2 id=\"Dispatch-对象和内存管理\"><a href=\"#Dispatch-对象和内存管理\" class=\"headerlink\" title=\"Dispatch 对象和内存管理\"></a>Dispatch 对象和内存管理</h2><p>在 Objective-C 里面，所有的 dispatch 对象都是 Objective-C 对象，所以他们同样适用引用技术的内存管理。如果你是使用 ARC 的话，dispatch 对象会向普通的 Objective-C 对象一样自动进行 retain 和 release 操作；如果你是使用 MRC，要记住使用 dispatch_retain 和 dispatch_release 来进行管理。</p>\n<h2 id=\"常用-API\"><a href=\"#常用-API\" class=\"headerlink\" title=\"常用 API\"></a>常用 API</h2><h3 id=\"dispatch-queue-t（调度队列）\"><a href=\"#dispatch-queue-t（调度队列）\" class=\"headerlink\" title=\"dispatch_queue_t（调度队列）\"></a>dispatch_queue_t（调度队列）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_queue_create</span>(<span class=\"params\">label</span>: <span class=\"type\">UnsafePointer</span>&lt;<span class=\"type\">Int8</span>&gt;, <span class=\"keyword\">_</span> <span class=\"params\">attr</span>: dispatch_queue_attr_t<span class=\"operator\">!</span>) -&gt; dispatch_queue_t<span class=\"operator\">!</span></span><br></pre></td></tr></table></figure>\n\n<p>在 GCD 中只能通过上面的 API 来创建调度队列，我们可以通过创建各种各样的 Block 形式的任务并由该调度队列来决定如何去执行这些 Block 任务。上面创建调度队列的函数需要两个参数：</p>\n<ul>\n<li>label: 这个参数是用来给你创建的调度队列进行命名的，特别是在调试的时候你可以通过该参数来判断是哪个调度队列的任务在执行。</li>\n<li>attr: 这个参数只有 DISPATCH_QUEUE_SERIAL 和 DISPATCH_QUEUE_CONCURRENT 两种值（在 Objective-C 中这个参数可以为 NULL，这个时候默认是 DISPATCH_QUEUE_SERIAL）。DISPATCH_QUEUE_SERIAL 是告诉调度队列以串行的方式去执行任务，DISPATCH_QUEUE_CONCURRENT 是告诉调度队列以并发的方式去执行任务。</li>\n</ul>\n<p>当然我们还可以通过下面的方法来获取系统已经创建好的调度队列：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取全局队列</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_get_global_queue</span>(<span class=\"params\">identifier</span>: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> <span class=\"params\">flags</span>: <span class=\"type\">UInt</span>) -&gt; dispatch_queue_t<span class=\"operator\">!</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取主线程的com.apple.main-thread (serial)队列</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_get_main_queue</span>() -&gt; dispatch_queue_t<span class=\"operator\">!</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，所有 pending 状态的 Block 任务都会持有该调度队列的引用，所以我们不需要显示的去持有调度队列，而调度队列会在所有的 Block 任务都从 pending 变为 finished 之后才会被释放。</p>\n<p>总之，现在大家要知道的是我们可以把不同的 Block任务提交到调度队列，具体的细节和实现看看后面内容。</p>\n<h3 id=\"dispatch-sync-和-dispatch-async（同步和异步）\"><a href=\"#dispatch-sync-和-dispatch-async（同步和异步）\" class=\"headerlink\" title=\"dispatch_sync 和 dispatch_async（同步和异步）\"></a>dispatch_sync 和 dispatch_async（同步和异步）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建调度队列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Sync&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block任务</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task1&quot;</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block任务</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;After Sync&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的输出结果如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Sync</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Sync</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的例子就是我们平常对 dispatch_sync 的用法，并且我们可以看到第一个 Block 任务执行之后才会执行第二个 Block 任务。dispatch_sync 需要等待 Block的任务执行完成之后，才能继续往后执行。但是使用 dispatch_sync 的时候，有几点是需要注意的：</p>\n<ol>\n<li><p>当调用 dispatch_sync 方法的时候，系统默认情况下会在当前线程去执行调度队列里的任务，只有在一些特殊情况下才会把调度队列的任务分配到其他线程去执行。所以我们就知道，线程和调度队列并不是一对一的关系。至于为什么默认情况下会在当前线程去执行调度队列里的任务，我的猜测是为了性能。大家想一想，dispatch_sync 会同步执行 Block任务， Block任务没有结束的情况下，后面的代码是无法执行的。基于这样一个同步的机制，GCD 还有必要先把当前线程挂起，然后去创建新线程，然后切换到新的线程去执行调度队列里的任务，然后再把线程切换到当前线程，然后再让当前线程恢复么？结论是没有必要。</p>\n</li>\n<li><p>你不能够在当前的串行调度队列的任务里面去添加新的任务到当前的调度队列里面，否则会造成死锁。这句话怎么理解呢，我们来来看看下面的例子：</p>\n</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Execute Block Task1&quot;</span>)</span><br><span class=\"line\">    dispatch_sync(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Execute Block Task1&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例1的结果</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n<p>为什么 Block1 后面的 print 和 Block2 的 print 都不执行了呢？首先我们要知道被 DISPATCH_QUEUE_SERIAL 声明的调度队列是串行调度队列，串行调度队列里的任务是同时只能有一个任务在执行，并且当前任务没有执行完成，下一个任务也无法执行。上面的例子中会先输出 Block1 中的 <em>Begin Execute Block Task1</em>，然后这个时候再把 Block2 添加到同一个串行调度队列中去。这个时候的 Block1 还没有执行完成，它需要等 dispatch_sync 的 Block2 执行完成之后才能继续执行，而 Block2 又必须等待 Block1 执行完成之后才能执行，所以这个时候就造成 Block1 等着 Block2，Block2 等着 Block1 的死锁。</p>\n<p>我们再把调度队列属性改为 DISPAT_QUEUE_CONCURRENT，然后再看看执行结果是什么：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Execute Block Task1&quot;</span>)</span><br><span class=\"line\">    dispatch_sync(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Execute Block Task1&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2的结果</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">End</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br></pre></td></tr></table></figure>\n\n<p>被 DISPATCH_QUEUE_CONCURRENT 声明的并发调度队列就没有这种死锁的问题。并发调度队列里的任务是不会霸占资源不放的，每一个任务执行一个时间片段之后会把资源交出来给别的任务去执行。所以例2中的 Block1 虽然需要等待 Block2 执行完成之后才能继续执行，但是当 Block1 在等待的过程中，是可以把资源释放出来交给 Block2 去执行，Block2 执行完成之后 Block1 就可以继续执行了。所以，这个时候就不会造成死锁来。</p>\n<p>再来看看下面的例子会不会造成死锁：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">viewDidLoad</span>() &#123;</span><br><span class=\"line\">    dispatch_sync(dispatch_get_main_queue()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Excute Block Task&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案是会的。给大家一点提示，主线程的默认调度队列是串行（DISPATCH_QUEUE_SERIAL）的，viewDidLoad() 是在主线程的调度队列 com.apple.main-thread (serial) 执行的。</p>\n<p>上面的例子主要是希望大家理解串行和并发的概念，同时要明白造成死锁的原因。而要解决死锁一般可以用 DISPATCH_QUEUE_CONCURRENT 或接下来我们要讲的 dispatch_async 来解决。</p>\n<p>通过对 dispatch_sync 的了解，我们可以利用 dispatch_async 很快的写出异步代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建调度队列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Async&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 异步调用</span></span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task1&quot;</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block2</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;After Async&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这个例子的结果有好几种：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结果1</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">ExEcute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结果2</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">ExEcute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Async</span></span><br></pre></td></tr></table></figure>\n\n<p>上面只是列出来两种可能，但实际上还有其他的可能。当我们调用 dispatch_async 的时候，它总是会在 Block 任务被提交之后马上返回，而不会傻傻的等待 Block 任务执行完成。由于上面创建的是串行调度队列，所以我们可以保证 Block1 要比 Block2 优先执行，但是 After Async 就无法确定是在 Block1 的前后还是 Block2 的前后。</p>\n<p>如果我们把上面的 DISPATCH_QUEUE_SERIAL 改成 DISPATCH_QUEUE_CONCURRENT，那我们就无法确定 After Async、Block1 和 Block2 这三者的执行顺序了。</p>\n<p>我们刚才说到用 dispatch_async 可以解决死锁的问题，那它是怎么解决的呢？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 异步调用</span></span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Execute Block Task1&quot;</span>)</span><br><span class=\"line\">    dispatch_async(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Execute Block Task1&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子会优先输出 Block1 的 <em>Begin Execute Block Task1</em> 之后，通过 dispatch_async 把 Block2 提交到串行队列里面，然后又马上返回到 Block1 去输出 <em>End Execute Block Task1</em>，这个时候的 Block1 就结束了，接下来就开始执行 Block2。所以上面的代码是不会造成死锁的，虽然上面的例子也是创建了一个串行调度队列，但是该调度队列只是保证了 Block1 要比 Block2 优先执行。</p>\n<h3 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h3><p>写过 Objective-C 的人都知道，dispatch_once 一般会被用来创建单例对象：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@implementation</span> <span class=\"type\">Single</span></span><br><span class=\"line\"><span class=\"operator\">+</span> (<span class=\"type\">Single</span> <span class=\"operator\">*</span>)sharedInstance &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">Single</span> <span class=\"operator\">*</span> _single <span class=\"operator\">=</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(<span class=\"operator\">&amp;</span>onceToken, <span class=\"operator\">^</span>&#123;</span><br><span class=\"line\">        _single <span class=\"operator\">=</span> [[<span class=\"type\">Single</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _single; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>这是由于 dispatch_once 是线程安全且只会执行一次，所以才会被用来作为单例的实现。这里需要注意的是 dispatch_once_t 必须是静态的或全局的才能保证 dispatch_once 的 Block 只会被执行一次，所以上面的代码用了 static 来修饰 dispatch_once_t。</p>\n<h3 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_apply</span>(<span class=\"params\">iterations</span>: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> <span class=\"params\">queue</span>: dispatch_queue_t<span class=\"operator\">!</span>, <span class=\"keyword\">_</span> <span class=\"params\">block</span>: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Void</span>)</span><br></pre></td></tr></table></figure>\n\n<p>其中的 interations 是表明要执行多少次 block，block 中的 Int 是该 Block 被执行的序号。调用这个方法的时候要注意该方法跟 dispatch_sync 一样会阻塞当前线程，所以我们需要注意在主线程中调用该方法。</p>\n<h3 id=\"dispatch-after\"><a href=\"#dispatch-after\" class=\"headerlink\" title=\"dispatch_after\"></a>dispatch_after</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_after</span>(<span class=\"params\">when</span>: dispatch_time_t, <span class=\"keyword\">_</span> <span class=\"params\">queue</span>: dispatch_queue_t, <span class=\"keyword\">_</span> <span class=\"params\">block</span>: dispatch_block_t)</span><br></pre></td></tr></table></figure>\n\n<p>调用这个方法的时候需要注意的是 when 这个参数，你需要通过 dispatch_time 或 dispatch_walltime 来创建。并且该方法是异步执行的，并不会阻塞当前线程。</p>\n<p>一般的写法如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_after(dispatch_time(<span class=\"type\">DISPATCH_TIME_NOW</span>, <span class=\"type\">Int64</span>(<span class=\"number\">5</span> <span class=\"operator\">*</span> <span class=\"type\">NSEC_PER_SEC</span>)), queue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;5s <span class=\"subst\">\\(NSThread.currentThread())</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dispatch-group-t\"><a href=\"#dispatch-group-t\" class=\"headerlink\" title=\"dispatch_group_t\"></a>dispatch_group_t</h3><p>dispatch_group_t 是用来做聚合同步的，它可以用来跟踪你提交的所有任务（即使是在不同的调度队列也可以）的完成状态。</p>\n<p>接下来我们来看看 dispatch group 的一些常见用法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 dispatch_group_t 对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> group <span class=\"operator\">=</span> dispatch_group_create()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建串行队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> serialQueue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;Serial Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提交两个 Block 任务到 serialQueue，同时关联 serialQueue 和 group 的关系</span></span><br><span class=\"line\">dispatch_group_async(group, serialQueue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block1 within Serial Queue&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_group_async(group, serialQueue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block2 within Serial Queue&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并发队列，并提交 Block 任务，同时关联该并发队列和 group 的关系</span></span><br><span class=\"line\">dispatch_group_async(group, dispatch_queue_create(<span class=\"string\">&quot;Concurrent Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block within Concurrent Queue&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发</span></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_queue_create(<span class=\"string\">&quot;Finished&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Finished&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，关联到 group 的方法只有 dispatch_group_async 而没有 dispatch_group_sync。</p>\n<p>但是还有另外一种方法可以让我们关联一个普通的任务：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 dispatch_group_t 对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> group <span class=\"operator\">=</span> dispatch_group_create()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 dispatch_group_enter 和 dispatch_group_leave 的话，我们不需要调用</span></span><br><span class=\"line\"><span class=\"comment\">// dispatch_group_async 也能关联一个任务到 group 上</span></span><br><span class=\"line\">dispatch_group_enter(group)</span><br><span class=\"line\"><span class=\"keyword\">self</span>.executeTask &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行代码</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_group_leave(group)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发</span></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_queue_create(<span class=\"string\">&quot;Finished&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Finished&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 dispatch_group_enter 和 dispatch_group_leave 的时候，它们必须成双成对出现，否则 dispatch_group_notify 是不会被调用的。</p>\n<p>接下来我们还要了解一下 dispatch_group_wait：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_group_wait</span>(<span class=\"params\">group</span>: dispatch_group_t, <span class=\"keyword\">_</span> <span class=\"params\">timeout</span>: dispatch_time_t) -&gt; <span class=\"type\">Int</span></span><br></pre></td></tr></table></figure>\n\n<p>dispatch_group_wait 可以指定一个 timeout 的参数，当 group 的任务没有在规定的时间内完成，它会返回一个非零的值，当 group 的任务能够在规定的时间内完成就返回0。同时，大家要注意这个方法会挂起当前线程，所以在主线程的时候要慎重使用该方法。</p>\n<h3 id=\"dispatch-barrier-t\"><a href=\"#dispatch-barrier-t\" class=\"headerlink\" title=\"dispatch_barrier_t\"></a>dispatch_barrier_t</h3><p>我们先来试想一个场景，假如现在有多个线程要去读取一份文件的内容，同时又有其他线程想要去更新该文件的内容，那么就有可能会发生你读错文件内容的现象。这个时候我们可以把所有读写操作都放到我们之前学习的串行队列去执行，但是我们都知道同时有多个线程去读取一份文件内容是没有问题的。</p>\n<p>使用 dispatch barrier 可以解决上面的问题：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建操作文件的并发队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;File&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_barrier_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Write</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过 dispatch_barrier_async 或 dispatch_barrier_sync 提交的任务会等待当前队列里正在执行的任务执行完毕才会执行，并且其他还没有执行的任务都必须等待提交到 dispatch barrier 的任务执行完毕之后才会开始执行。所以上面的代码中，当 Write 任务被提交的时候，如果当前队列中只有 Read1 在执行，那么 Write 会等待 Read1 执行完成之后才会执行，Read2  和 Read3 都必须等待 Write 执行完之后才会执行。另外，上面的代码中创建的是并发队列，因为如果是串行队列的话就没有必要用 dispatch barrier 了。</p>\n<h3 id=\"dispatch-semaphore-t\"><a href=\"#dispatch-semaphore-t\" class=\"headerlink\" title=\"dispatch_semaphore_t\"></a>dispatch_semaphore_t</h3><p>dispatch semaphore 是一个效率非常高的传统计数信号量，所以我们一般可以用这个来控制最大的并发数量。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建初始值为2的信号量，最大并发数量为2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> semaphore <span class=\"operator\">=</span> dispatch_semaphore_create(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建并发队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;Semaphore&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建100个并发任务</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> <span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">100</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个方法会进行信号量减1的操作，并且如果信号量减1之后的结果小于0的话，该方法会造成线程的挂起直</span></span><br><span class=\"line\">    <span class=\"comment\">// 到该信号量进行加1操作才会恢复，所以在主线程要注意该方法的使用。</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意：这个方法要放在 dispatch_async 外面，否则系统依旧会创建超过2个线程同时来处理该调度队列</span></span><br><span class=\"line\">    <span class=\"comment\">// 的任务</span></span><br><span class=\"line\">    dispatch_semaphore_wait(semaphore, <span class=\"type\">DISPATCH_TIME_FOREVER</span>)</span><br><span class=\"line\">    dispatch_async(queue) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 释放资源，信号量增加1</span></span><br><span class=\"line\">        dispatch_semaphore_signal(semaphore)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>GCD 在 Swift3 的语法跟现在的语法不太一样了，有兴趣的可以自行去了解。在未来可能会考虑把本文章的代码都用 Swift3 的语法来重新写一下。</p>\n"},{"title":"如何在 iOS 上自定义 React Native Component","author":"帕帕","date":"2018-03-19T17:22:09.000Z","thumbnail":"https://images.unsplash.com/photo-1508921234172-b68ed335b3e6?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=92e40b3819e4c173debf1500f27c9b60&auto=format&fit=crop&w=160&q=60","_content":"\n当我们要在 iOS 端实现一个 React Native 可用的 Component，比如：\n\n```ReactNative\n<MapView onRegionChange={(event) => {}} zoomLevel={2} />\n```\n\n那么我们基本上就是要解决下面这三个问题：\n\n* 如何把 iOS 上的 UI 暴露给 React Native 端？\n* 如何在 React Native 给 iOS 的 UI 传值？\n* 如何在 React Native 中响应 iOS 的事件？\n\n> 这三个问题可以在[官方文档](https://facebook.github.io/react-native/docs/native-components-ios.html)找到答案。\n    \n## 如何把 iOS 上的 UI 暴露给 React Native 端\n\n首先你需要创建一个继承自 `RCTViewManager` 的子类：\n\n```iOS\n// RNTMapManager.m\n#import <MapKit/MapKit.h>\n#import <React/RCTViewManager.h>\n\n// 继承 RCTViewManager\n@interface RNTMapManager : RCTViewManager\n@end\n\n\n@implementation RNTMapManager\n\n// 调用 RCT_EXPORT_MODULE 暴露该类的名字给 React Native 使用。如果你想自定义\n// 暴露给 React Native 的名字时，你需要 RCT_EXPORT_MODULE(YOUR_CUSTOM_NAME)。\nRCT_EXPORT_MODULE()\n\n// 由于 RCTViewManager 是 NSObject，所以这里必须需要实现该方法来告诉\n// React Native 去使用哪个 UIView\n- (UIView *)view\n{\n  return [MKMapView new];\n}\n\n@end\n```\n\n这样我们就可以在 React Native 使用 MapView 了：\n\n```ReactNative\n// MapView.js\n\nimport { requireNativeComponent } from 'react-native';\n\n// requireNativeComponent 会自动把 iOS 上的 RNTMapManager 解析成 RNTMap。\n// 如果去掉 iOS 上的 Manager 后缀会有什么影响？嗯，没有任何影响。\nmodule.exports = requireNativeComponent('RNTMap', null);\n\n\n// MyApp.js\nimport MapView from './MapView.js';\n\n...\n\nrender() {\n  return <MapView />;\n}\n```\n\n## 如何在 React Native 给 iOS 的 UI 传值\n\n如果需要传值给 iOS 上的 UI，那么需要使用另外一个宏：\n\n```iOS\nRCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)\n```\n\n这时候就可以在 React Native 上使用了：\n\n```ReactNative\n<MapView zoomEnable={true} />\n```\n\n这里需要注意的是，`RCT_EXPORT_VIEW_PROPERTY` 所暴露的属性必须是之前我们说的 UIView（即继承于 `RCTViewManager` 并通过 `- (UIView *)view;` 返回的 View）已经存在的属性。\n\n除了上面的宏 `RCT_EXPORT_VIEW_PROPERTY` 可以暴露属性给 React Native 使用之外还有下面 5 种（这里先挖个坑，回头研究一下再说说下面五种的作用和区别）：\n\n* RCT_REMAP_VIEW_PROPERTY\n* RCT_CUSTOM_VIEW_PROPERTY\n* RCT_EXPORT_SHADOW_PROPERTY\n* RCT_REMAP_SHADOW_PROPERTY\n* RCT_CUSTOM_SHADOW_PROPERTY\n\n## 如何在 React Native 中响应 iOS 的事件\n\n要想在 React Native 中响应 iOS 的事件，只需要暴露用 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 定义的属性即可，代码如下：\n\n```iOS\n// RNTMapView.h\n#import <MapKit/MapKit.h>\n#import <React/RCTComponent.h>\n\n// 由于 MKMapView 没有任何 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的\n// 属性，所以这里需要定义 MKMapView 的子类 RNTMapView\n@interface RNTMapView: MKMapView\n\n// 需要暴露给 React Native 的事件属性\n@property (nonatomic, copy) RCTBubblingEventBlock onRegionChange;\n\n@end\n\n\n// RNTMapView.m\n#import \"RNTMapView.h\"\n\n@implementation RNTMapView\n\n@end\n```\n\n然后我们需要在 `RCTViewManager` 中暴露 `onRegionChange` 给 React Native 使用：\n\n```iOS\n// RNTMapManager.m\n#import <MapKit/MapKit.h>\n#import <React/RCTViewManager.h>\n\n#import \"RNTMapView.h\"\n\n@interface RNTMapManager : RCTViewManager <MKMapViewDelegate>\n@end\n\n@implementation RNTMapManager\n\nRCT_EXPORT_MODULE()\n// 暴露 RNTMapView 中的 `onRegionChange` 属性\nRCT_EXPORT_VIEW_PROPERTY(onRegionChange, RCTBubblingEventBlock)\n\n- (UIView *)view {\n    // 这里需要返回 RNTMapView 而不是 MKMapView\n    return [RNTMapView new];\n}\n\n@end\n```\n\n> 重要的事说三遍：\n> 使用 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的事件都必须加上前缀 `on`，否则 React Native 无法接收到事件\n> 使用 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的事件都必须加上前缀 `on`，否则 React Native 无法接收到事件\n> 使用 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的事件都必须加上前缀 `on`，否则 React Native 无法接收到事件\n\n\n","source":"_posts/如何在-iOS-上自定义-React-Native-Component.md","raw":"---\ntitle: 如何在 iOS 上自定义 React Native Component\nauthor: 帕帕\ndate: 2018-03-19 17:22:09\ncategories: 技术\ntags: [iOS, RN]\nthumbnail: https://images.unsplash.com/photo-1508921234172-b68ed335b3e6?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=92e40b3819e4c173debf1500f27c9b60&auto=format&fit=crop&w=160&q=60\n---\n\n当我们要在 iOS 端实现一个 React Native 可用的 Component，比如：\n\n```ReactNative\n<MapView onRegionChange={(event) => {}} zoomLevel={2} />\n```\n\n那么我们基本上就是要解决下面这三个问题：\n\n* 如何把 iOS 上的 UI 暴露给 React Native 端？\n* 如何在 React Native 给 iOS 的 UI 传值？\n* 如何在 React Native 中响应 iOS 的事件？\n\n> 这三个问题可以在[官方文档](https://facebook.github.io/react-native/docs/native-components-ios.html)找到答案。\n    \n## 如何把 iOS 上的 UI 暴露给 React Native 端\n\n首先你需要创建一个继承自 `RCTViewManager` 的子类：\n\n```iOS\n// RNTMapManager.m\n#import <MapKit/MapKit.h>\n#import <React/RCTViewManager.h>\n\n// 继承 RCTViewManager\n@interface RNTMapManager : RCTViewManager\n@end\n\n\n@implementation RNTMapManager\n\n// 调用 RCT_EXPORT_MODULE 暴露该类的名字给 React Native 使用。如果你想自定义\n// 暴露给 React Native 的名字时，你需要 RCT_EXPORT_MODULE(YOUR_CUSTOM_NAME)。\nRCT_EXPORT_MODULE()\n\n// 由于 RCTViewManager 是 NSObject，所以这里必须需要实现该方法来告诉\n// React Native 去使用哪个 UIView\n- (UIView *)view\n{\n  return [MKMapView new];\n}\n\n@end\n```\n\n这样我们就可以在 React Native 使用 MapView 了：\n\n```ReactNative\n// MapView.js\n\nimport { requireNativeComponent } from 'react-native';\n\n// requireNativeComponent 会自动把 iOS 上的 RNTMapManager 解析成 RNTMap。\n// 如果去掉 iOS 上的 Manager 后缀会有什么影响？嗯，没有任何影响。\nmodule.exports = requireNativeComponent('RNTMap', null);\n\n\n// MyApp.js\nimport MapView from './MapView.js';\n\n...\n\nrender() {\n  return <MapView />;\n}\n```\n\n## 如何在 React Native 给 iOS 的 UI 传值\n\n如果需要传值给 iOS 上的 UI，那么需要使用另外一个宏：\n\n```iOS\nRCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)\n```\n\n这时候就可以在 React Native 上使用了：\n\n```ReactNative\n<MapView zoomEnable={true} />\n```\n\n这里需要注意的是，`RCT_EXPORT_VIEW_PROPERTY` 所暴露的属性必须是之前我们说的 UIView（即继承于 `RCTViewManager` 并通过 `- (UIView *)view;` 返回的 View）已经存在的属性。\n\n除了上面的宏 `RCT_EXPORT_VIEW_PROPERTY` 可以暴露属性给 React Native 使用之外还有下面 5 种（这里先挖个坑，回头研究一下再说说下面五种的作用和区别）：\n\n* RCT_REMAP_VIEW_PROPERTY\n* RCT_CUSTOM_VIEW_PROPERTY\n* RCT_EXPORT_SHADOW_PROPERTY\n* RCT_REMAP_SHADOW_PROPERTY\n* RCT_CUSTOM_SHADOW_PROPERTY\n\n## 如何在 React Native 中响应 iOS 的事件\n\n要想在 React Native 中响应 iOS 的事件，只需要暴露用 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 定义的属性即可，代码如下：\n\n```iOS\n// RNTMapView.h\n#import <MapKit/MapKit.h>\n#import <React/RCTComponent.h>\n\n// 由于 MKMapView 没有任何 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的\n// 属性，所以这里需要定义 MKMapView 的子类 RNTMapView\n@interface RNTMapView: MKMapView\n\n// 需要暴露给 React Native 的事件属性\n@property (nonatomic, copy) RCTBubblingEventBlock onRegionChange;\n\n@end\n\n\n// RNTMapView.m\n#import \"RNTMapView.h\"\n\n@implementation RNTMapView\n\n@end\n```\n\n然后我们需要在 `RCTViewManager` 中暴露 `onRegionChange` 给 React Native 使用：\n\n```iOS\n// RNTMapManager.m\n#import <MapKit/MapKit.h>\n#import <React/RCTViewManager.h>\n\n#import \"RNTMapView.h\"\n\n@interface RNTMapManager : RCTViewManager <MKMapViewDelegate>\n@end\n\n@implementation RNTMapManager\n\nRCT_EXPORT_MODULE()\n// 暴露 RNTMapView 中的 `onRegionChange` 属性\nRCT_EXPORT_VIEW_PROPERTY(onRegionChange, RCTBubblingEventBlock)\n\n- (UIView *)view {\n    // 这里需要返回 RNTMapView 而不是 MKMapView\n    return [RNTMapView new];\n}\n\n@end\n```\n\n> 重要的事说三遍：\n> 使用 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的事件都必须加上前缀 `on`，否则 React Native 无法接收到事件\n> 使用 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的事件都必须加上前缀 `on`，否则 React Native 无法接收到事件\n> 使用 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的事件都必须加上前缀 `on`，否则 React Native 无法接收到事件\n\n\n","slug":"如何在-iOS-上自定义-React-Native-Component","published":1,"updated":"2022-04-20T07:08:33.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxek001d6enqatufhq4l","content":"<p>当我们要在 iOS 端实现一个 React Native 可用的 Component，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;MapView onRegionChange=&#123;(event) =&gt; &#123;&#125;&#125; zoomLevel=&#123;2&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>那么我们基本上就是要解决下面这三个问题：</p>\n<ul>\n<li>如何把 iOS 上的 UI 暴露给 React Native 端？</li>\n<li>如何在 React Native 给 iOS 的 UI 传值？</li>\n<li>如何在 React Native 中响应 iOS 的事件？</li>\n</ul>\n<blockquote>\n<p>这三个问题可以在<a href=\"https://facebook.github.io/react-native/docs/native-components-ios.html\">官方文档</a>找到答案。</p>\n</blockquote>\n<h2 id=\"如何把-iOS-上的-UI-暴露给-React-Native-端\"><a href=\"#如何把-iOS-上的-UI-暴露给-React-Native-端\" class=\"headerlink\" title=\"如何把 iOS 上的 UI 暴露给 React Native 端\"></a>如何把 iOS 上的 UI 暴露给 React Native 端</h2><p>首先你需要创建一个继承自 <code>RCTViewManager</code> 的子类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RNTMapManager.m</span><br><span class=\"line\">#import &lt;MapKit/MapKit.h&gt;</span><br><span class=\"line\">#import &lt;React/RCTViewManager.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 继承 RCTViewManager</span><br><span class=\"line\">@interface RNTMapManager : RCTViewManager</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@implementation RNTMapManager</span><br><span class=\"line\"></span><br><span class=\"line\">// 调用 RCT_EXPORT_MODULE 暴露该类的名字给 React Native 使用。如果你想自定义</span><br><span class=\"line\">// 暴露给 React Native 的名字时，你需要 RCT_EXPORT_MODULE(YOUR_CUSTOM_NAME)。</span><br><span class=\"line\">RCT_EXPORT_MODULE()</span><br><span class=\"line\"></span><br><span class=\"line\">// 由于 RCTViewManager 是 NSObject，所以这里必须需要实现该方法来告诉</span><br><span class=\"line\">// React Native 去使用哪个 UIView</span><br><span class=\"line\">- (UIView *)view</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return [MKMapView new];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就可以在 React Native 使用 MapView 了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// MapView.js</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; requireNativeComponent &#125; from &#x27;react-native&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">// requireNativeComponent 会自动把 iOS 上的 RNTMapManager 解析成 RNTMap。</span><br><span class=\"line\">// 如果去掉 iOS 上的 Manager 后缀会有什么影响？嗯，没有任何影响。</span><br><span class=\"line\">module.exports = requireNativeComponent(&#x27;RNTMap&#x27;, null);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// MyApp.js</span><br><span class=\"line\">import MapView from &#x27;./MapView.js&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">render() &#123;</span><br><span class=\"line\">  return &lt;MapView /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何在-React-Native-给-iOS-的-UI-传值\"><a href=\"#如何在-React-Native-给-iOS-的-UI-传值\" class=\"headerlink\" title=\"如何在 React Native 给 iOS 的 UI 传值\"></a>如何在 React Native 给 iOS 的 UI 传值</h2><p>如果需要传值给 iOS 上的 UI，那么需要使用另外一个宏：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)</span><br></pre></td></tr></table></figure>\n\n<p>这时候就可以在 React Native 上使用了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;MapView zoomEnable=&#123;true&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意的是，<code>RCT_EXPORT_VIEW_PROPERTY</code> 所暴露的属性必须是之前我们说的 UIView（即继承于 <code>RCTViewManager</code> 并通过 <code>- (UIView *)view;</code> 返回的 View）已经存在的属性。</p>\n<p>除了上面的宏 <code>RCT_EXPORT_VIEW_PROPERTY</code> 可以暴露属性给 React Native 使用之外还有下面 5 种（这里先挖个坑，回头研究一下再说说下面五种的作用和区别）：</p>\n<ul>\n<li>RCT_REMAP_VIEW_PROPERTY</li>\n<li>RCT_CUSTOM_VIEW_PROPERTY</li>\n<li>RCT_EXPORT_SHADOW_PROPERTY</li>\n<li>RCT_REMAP_SHADOW_PROPERTY</li>\n<li>RCT_CUSTOM_SHADOW_PROPERTY</li>\n</ul>\n<h2 id=\"如何在-React-Native-中响应-iOS-的事件\"><a href=\"#如何在-React-Native-中响应-iOS-的事件\" class=\"headerlink\" title=\"如何在 React Native 中响应 iOS 的事件\"></a>如何在 React Native 中响应 iOS 的事件</h2><p>要想在 React Native 中响应 iOS 的事件，只需要暴露用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 定义的属性即可，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RNTMapView.h</span><br><span class=\"line\">#import &lt;MapKit/MapKit.h&gt;</span><br><span class=\"line\">#import &lt;React/RCTComponent.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 由于 MKMapView 没有任何 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的</span><br><span class=\"line\">// 属性，所以这里需要定义 MKMapView 的子类 RNTMapView</span><br><span class=\"line\">@interface RNTMapView: MKMapView</span><br><span class=\"line\"></span><br><span class=\"line\">// 需要暴露给 React Native 的事件属性</span><br><span class=\"line\">@property (nonatomic, copy) RCTBubblingEventBlock onRegionChange;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// RNTMapView.m</span><br><span class=\"line\">#import &quot;RNTMapView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation RNTMapView</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>然后我们需要在 <code>RCTViewManager</code> 中暴露 <code>onRegionChange</code> 给 React Native 使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RNTMapManager.m</span><br><span class=\"line\">#import &lt;MapKit/MapKit.h&gt;</span><br><span class=\"line\">#import &lt;React/RCTViewManager.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;RNTMapView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface RNTMapManager : RCTViewManager &lt;MKMapViewDelegate&gt;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation RNTMapManager</span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_MODULE()</span><br><span class=\"line\">// 暴露 RNTMapView 中的 `onRegionChange` 属性</span><br><span class=\"line\">RCT_EXPORT_VIEW_PROPERTY(onRegionChange, RCTBubblingEventBlock)</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIView *)view &#123;</span><br><span class=\"line\">    // 这里需要返回 RNTMapView 而不是 MKMapView</span><br><span class=\"line\">    return [RNTMapView new];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>重要的事说三遍：<br>使用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 所定义的事件都必须加上前缀 <code>on</code>，否则 React Native 无法接收到事件<br>使用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 所定义的事件都必须加上前缀 <code>on</code>，否则 React Native 无法接收到事件<br>使用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 所定义的事件都必须加上前缀 <code>on</code>，否则 React Native 无法接收到事件</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>当我们要在 iOS 端实现一个 React Native 可用的 Component，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;MapView onRegionChange=&#123;(event) =&gt; &#123;&#125;&#125; zoomLevel=&#123;2&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>那么我们基本上就是要解决下面这三个问题：</p>\n<ul>\n<li>如何把 iOS 上的 UI 暴露给 React Native 端？</li>\n<li>如何在 React Native 给 iOS 的 UI 传值？</li>\n<li>如何在 React Native 中响应 iOS 的事件？</li>\n</ul>\n<blockquote>\n<p>这三个问题可以在<a href=\"https://facebook.github.io/react-native/docs/native-components-ios.html\">官方文档</a>找到答案。</p>\n</blockquote>\n<h2 id=\"如何把-iOS-上的-UI-暴露给-React-Native-端\"><a href=\"#如何把-iOS-上的-UI-暴露给-React-Native-端\" class=\"headerlink\" title=\"如何把 iOS 上的 UI 暴露给 React Native 端\"></a>如何把 iOS 上的 UI 暴露给 React Native 端</h2><p>首先你需要创建一个继承自 <code>RCTViewManager</code> 的子类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RNTMapManager.m</span><br><span class=\"line\">#import &lt;MapKit/MapKit.h&gt;</span><br><span class=\"line\">#import &lt;React/RCTViewManager.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 继承 RCTViewManager</span><br><span class=\"line\">@interface RNTMapManager : RCTViewManager</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@implementation RNTMapManager</span><br><span class=\"line\"></span><br><span class=\"line\">// 调用 RCT_EXPORT_MODULE 暴露该类的名字给 React Native 使用。如果你想自定义</span><br><span class=\"line\">// 暴露给 React Native 的名字时，你需要 RCT_EXPORT_MODULE(YOUR_CUSTOM_NAME)。</span><br><span class=\"line\">RCT_EXPORT_MODULE()</span><br><span class=\"line\"></span><br><span class=\"line\">// 由于 RCTViewManager 是 NSObject，所以这里必须需要实现该方法来告诉</span><br><span class=\"line\">// React Native 去使用哪个 UIView</span><br><span class=\"line\">- (UIView *)view</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return [MKMapView new];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就可以在 React Native 使用 MapView 了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// MapView.js</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; requireNativeComponent &#125; from &#x27;react-native&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">// requireNativeComponent 会自动把 iOS 上的 RNTMapManager 解析成 RNTMap。</span><br><span class=\"line\">// 如果去掉 iOS 上的 Manager 后缀会有什么影响？嗯，没有任何影响。</span><br><span class=\"line\">module.exports = requireNativeComponent(&#x27;RNTMap&#x27;, null);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// MyApp.js</span><br><span class=\"line\">import MapView from &#x27;./MapView.js&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">render() &#123;</span><br><span class=\"line\">  return &lt;MapView /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何在-React-Native-给-iOS-的-UI-传值\"><a href=\"#如何在-React-Native-给-iOS-的-UI-传值\" class=\"headerlink\" title=\"如何在 React Native 给 iOS 的 UI 传值\"></a>如何在 React Native 给 iOS 的 UI 传值</h2><p>如果需要传值给 iOS 上的 UI，那么需要使用另外一个宏：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)</span><br></pre></td></tr></table></figure>\n\n<p>这时候就可以在 React Native 上使用了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;MapView zoomEnable=&#123;true&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意的是，<code>RCT_EXPORT_VIEW_PROPERTY</code> 所暴露的属性必须是之前我们说的 UIView（即继承于 <code>RCTViewManager</code> 并通过 <code>- (UIView *)view;</code> 返回的 View）已经存在的属性。</p>\n<p>除了上面的宏 <code>RCT_EXPORT_VIEW_PROPERTY</code> 可以暴露属性给 React Native 使用之外还有下面 5 种（这里先挖个坑，回头研究一下再说说下面五种的作用和区别）：</p>\n<ul>\n<li>RCT_REMAP_VIEW_PROPERTY</li>\n<li>RCT_CUSTOM_VIEW_PROPERTY</li>\n<li>RCT_EXPORT_SHADOW_PROPERTY</li>\n<li>RCT_REMAP_SHADOW_PROPERTY</li>\n<li>RCT_CUSTOM_SHADOW_PROPERTY</li>\n</ul>\n<h2 id=\"如何在-React-Native-中响应-iOS-的事件\"><a href=\"#如何在-React-Native-中响应-iOS-的事件\" class=\"headerlink\" title=\"如何在 React Native 中响应 iOS 的事件\"></a>如何在 React Native 中响应 iOS 的事件</h2><p>要想在 React Native 中响应 iOS 的事件，只需要暴露用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 定义的属性即可，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RNTMapView.h</span><br><span class=\"line\">#import &lt;MapKit/MapKit.h&gt;</span><br><span class=\"line\">#import &lt;React/RCTComponent.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 由于 MKMapView 没有任何 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的</span><br><span class=\"line\">// 属性，所以这里需要定义 MKMapView 的子类 RNTMapView</span><br><span class=\"line\">@interface RNTMapView: MKMapView</span><br><span class=\"line\"></span><br><span class=\"line\">// 需要暴露给 React Native 的事件属性</span><br><span class=\"line\">@property (nonatomic, copy) RCTBubblingEventBlock onRegionChange;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// RNTMapView.m</span><br><span class=\"line\">#import &quot;RNTMapView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation RNTMapView</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>然后我们需要在 <code>RCTViewManager</code> 中暴露 <code>onRegionChange</code> 给 React Native 使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RNTMapManager.m</span><br><span class=\"line\">#import &lt;MapKit/MapKit.h&gt;</span><br><span class=\"line\">#import &lt;React/RCTViewManager.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;RNTMapView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface RNTMapManager : RCTViewManager &lt;MKMapViewDelegate&gt;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation RNTMapManager</span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_MODULE()</span><br><span class=\"line\">// 暴露 RNTMapView 中的 `onRegionChange` 属性</span><br><span class=\"line\">RCT_EXPORT_VIEW_PROPERTY(onRegionChange, RCTBubblingEventBlock)</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIView *)view &#123;</span><br><span class=\"line\">    // 这里需要返回 RNTMapView 而不是 MKMapView</span><br><span class=\"line\">    return [RNTMapView new];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>重要的事说三遍：<br>使用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 所定义的事件都必须加上前缀 <code>on</code>，否则 React Native 无法接收到事件<br>使用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 所定义的事件都必须加上前缀 <code>on</code>，否则 React Native 无法接收到事件<br>使用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 所定义的事件都必须加上前缀 <code>on</code>，否则 React Native 无法接收到事件</p>\n</blockquote>\n"},{"title":"如何用 Objective-C 实现一个死锁","date":"2018-04-01T20:29:42.000Z","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1509655172625-03265ba919a1?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=24b01fba0d86b9fa95814c692429379f&auto=format&fit=crop&w=160&q=100","_content":"\n> 当系统存在两个线程及以上的时候，双方都在等待对方停止执行，以获得系统资源，但是没有一方提前退出的时候就叫做死锁。\n\n\n那在 Objective-C 里面如何实现死锁呢：\n\n```Objective-C \nself.lock1 = [NSLock new];\nself.lock2 = [NSLock new];\n    \ndispatch_async(dispatch_queue_create(\"com.papa.task1\", DISPATCH_QUEUE_SERIAL), ^{\n    [self.lock1 lock];\n    NSLog(@\"task1 获得 lock1\");\n    sleep(2);\n    [self.lock2 lock];\n    NSLog(@\"task1 获得 lock2\");\n    [self.lock2 unlock];\n    [self.lock1 unlock];\n});\n\ndispatch_async(dispatch_queue_create(\"com.papa.task2\", DISPATCH_QUEUE_SERIAL), ^{\n    [self.lock2 lock];\n    NSLog(@\"task2 获得 lock2\");\n    sleep(2);\n    [self.lock1 lock];\n    NSLog(@\"task2 获得 lock1\");\n    [self.lock1 unlock];\n    [self.lock2 unlock];\n});\n```\n我们可以看到最后控制台输出的结果是：\n\n```\ntask2 获得 lock2\ntask1 获得 lock1\n```\n\n或\n\n```\ntask2 获得 lock2\ntask1 获得 lock1\n```\n\n为什么是两种结果呢，可以参考我的[「初步了解 GCD」](https://hparis.github.io/blog/2017/09/05/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3GCD/)。\n\n但是不管如何，这两种结果都没有输出 `task1 获得 lock2` 或 `task2 获得 lock1`。我们来分析一下：\n\n* task1 获得 lock1，然后沉睡 2s\n* task2 获得 lock2，然后沉睡 2s\n* task1 经过 2s 的沉睡之后想要去获取 lock2，此时发现 lock2 已经被使用，那就继续等待\n* task2 经过 2s 的沉睡之后想要去获取 lock1，此时发现 lock1 已经被使用，那就继续等待\n* task1 又被唤醒想要去获取 lock2，此时 lock2 依旧没有被 task2 释放，只能继续等待\n* task2 又被唤醒想要去获取 lock1，此时 lock1 依旧没有被 task1 释放，只能继续等待\n* ...\n* ...\n    \n于是 task1 和 task2 都在等待对方释放资源，但是自己也不退出也不释放资源，最终导致死锁的产生。\n\n\n接下来，我们来讨论另外一个例子是不是死锁：\n\n```Objective-C\n// 某个按钮的点击事件\n- (void)onClick:(UIEvent *)event {\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        ...    \n    });\n}\n```\n\n相信大家都知道上面这个例子会导致主线程发生阻塞的现象，但是这是因为死锁造成的么？\n\n> Submits a block to a dispatch queue for synchronous execution. Unlike dispatch_async, this function does not return until the block has finished. Calling this function and targeting the current queue results in deadlock.\n\n在官方文档里面明确的说了，这就是死锁。我们可以把上面的例子“翻译”一下：\n\n```Objective-C\n// 首先进入 onClick 的时候，我们可以认为此时是需要加锁的\n// 某个按钮的点击事件\n- (void)onClick:(UIEvent *)event {\n    [self.lock1 lock];\n    \n    // 此时我们可以认为 dispatch_sync 是在获取 block 里面的 lock2 \n    {\n        [self.lock2 lock];\n        \n        // 放在主线程执行，那么它也需要获得 lock1 \n        [self.lock1 lock];\n        [self.lock1 unlock];\n        \n        [self.lock2 unlock];\n    }\n    \n    [self.lock1 unlock];\n}\n```\n\n我们可以看到其实上面的情况就是两个任务都在同时竞争主线程的资源，并且谁都没有退出最终导致死锁的产生。但是这两个任务并不是普通的两个线程在竞争资源，而是都在主线程上，一个嵌套另外一个。而且这种特殊的情况，在运行的时候会直接导致奔溃，而不像我们一开始的例子一样只是在互相等待。但是既然苹果把这种情况也称为死锁，那我们就当做死锁来看待，毕竟他们都是在竞争系统资源。\n\n","source":"_posts/如何用-Objective-C-实现一个死锁.md","raw":"---\ntitle: 如何用 Objective-C 实现一个死锁\ndate: 2018-04-01 20:29:42 +0800\nauthor: 帕帕\ncategories: 技术\ntags: [iOS, Objective-C, GCD]\nthumbnail: https://images.unsplash.com/photo-1509655172625-03265ba919a1?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=24b01fba0d86b9fa95814c692429379f&auto=format&fit=crop&w=160&q=100\n---\n\n> 当系统存在两个线程及以上的时候，双方都在等待对方停止执行，以获得系统资源，但是没有一方提前退出的时候就叫做死锁。\n\n\n那在 Objective-C 里面如何实现死锁呢：\n\n```Objective-C \nself.lock1 = [NSLock new];\nself.lock2 = [NSLock new];\n    \ndispatch_async(dispatch_queue_create(\"com.papa.task1\", DISPATCH_QUEUE_SERIAL), ^{\n    [self.lock1 lock];\n    NSLog(@\"task1 获得 lock1\");\n    sleep(2);\n    [self.lock2 lock];\n    NSLog(@\"task1 获得 lock2\");\n    [self.lock2 unlock];\n    [self.lock1 unlock];\n});\n\ndispatch_async(dispatch_queue_create(\"com.papa.task2\", DISPATCH_QUEUE_SERIAL), ^{\n    [self.lock2 lock];\n    NSLog(@\"task2 获得 lock2\");\n    sleep(2);\n    [self.lock1 lock];\n    NSLog(@\"task2 获得 lock1\");\n    [self.lock1 unlock];\n    [self.lock2 unlock];\n});\n```\n我们可以看到最后控制台输出的结果是：\n\n```\ntask2 获得 lock2\ntask1 获得 lock1\n```\n\n或\n\n```\ntask2 获得 lock2\ntask1 获得 lock1\n```\n\n为什么是两种结果呢，可以参考我的[「初步了解 GCD」](https://hparis.github.io/blog/2017/09/05/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3GCD/)。\n\n但是不管如何，这两种结果都没有输出 `task1 获得 lock2` 或 `task2 获得 lock1`。我们来分析一下：\n\n* task1 获得 lock1，然后沉睡 2s\n* task2 获得 lock2，然后沉睡 2s\n* task1 经过 2s 的沉睡之后想要去获取 lock2，此时发现 lock2 已经被使用，那就继续等待\n* task2 经过 2s 的沉睡之后想要去获取 lock1，此时发现 lock1 已经被使用，那就继续等待\n* task1 又被唤醒想要去获取 lock2，此时 lock2 依旧没有被 task2 释放，只能继续等待\n* task2 又被唤醒想要去获取 lock1，此时 lock1 依旧没有被 task1 释放，只能继续等待\n* ...\n* ...\n    \n于是 task1 和 task2 都在等待对方释放资源，但是自己也不退出也不释放资源，最终导致死锁的产生。\n\n\n接下来，我们来讨论另外一个例子是不是死锁：\n\n```Objective-C\n// 某个按钮的点击事件\n- (void)onClick:(UIEvent *)event {\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        ...    \n    });\n}\n```\n\n相信大家都知道上面这个例子会导致主线程发生阻塞的现象，但是这是因为死锁造成的么？\n\n> Submits a block to a dispatch queue for synchronous execution. Unlike dispatch_async, this function does not return until the block has finished. Calling this function and targeting the current queue results in deadlock.\n\n在官方文档里面明确的说了，这就是死锁。我们可以把上面的例子“翻译”一下：\n\n```Objective-C\n// 首先进入 onClick 的时候，我们可以认为此时是需要加锁的\n// 某个按钮的点击事件\n- (void)onClick:(UIEvent *)event {\n    [self.lock1 lock];\n    \n    // 此时我们可以认为 dispatch_sync 是在获取 block 里面的 lock2 \n    {\n        [self.lock2 lock];\n        \n        // 放在主线程执行，那么它也需要获得 lock1 \n        [self.lock1 lock];\n        [self.lock1 unlock];\n        \n        [self.lock2 unlock];\n    }\n    \n    [self.lock1 unlock];\n}\n```\n\n我们可以看到其实上面的情况就是两个任务都在同时竞争主线程的资源，并且谁都没有退出最终导致死锁的产生。但是这两个任务并不是普通的两个线程在竞争资源，而是都在主线程上，一个嵌套另外一个。而且这种特殊的情况，在运行的时候会直接导致奔溃，而不像我们一开始的例子一样只是在互相等待。但是既然苹果把这种情况也称为死锁，那我们就当做死锁来看待，毕竟他们都是在竞争系统资源。\n\n","slug":"如何用-Objective-C-实现一个死锁","published":1,"updated":"2022-04-20T07:08:33.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxel001g6enq6voxguwo","content":"<blockquote>\n<p>当系统存在两个线程及以上的时候，双方都在等待对方停止执行，以获得系统资源，但是没有一方提前退出的时候就叫做死锁。</p>\n</blockquote>\n<p>那在 Objective-C 里面如何实现死锁呢：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.lock1 = [NSLock new];</span><br><span class=\"line\">self.lock2 = [NSLock new];</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_async(dispatch_queue_create(&quot;com.papa.task1&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class=\"line\">    [self.lock1 lock];</span><br><span class=\"line\">    NSLog(@&quot;task1 获得 lock1&quot;);</span><br><span class=\"line\">    sleep(2);</span><br><span class=\"line\">    [self.lock2 lock];</span><br><span class=\"line\">    NSLog(@&quot;task1 获得 lock2&quot;);</span><br><span class=\"line\">    [self.lock2 unlock];</span><br><span class=\"line\">    [self.lock1 unlock];</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(dispatch_queue_create(&quot;com.papa.task2&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class=\"line\">    [self.lock2 lock];</span><br><span class=\"line\">    NSLog(@&quot;task2 获得 lock2&quot;);</span><br><span class=\"line\">    sleep(2);</span><br><span class=\"line\">    [self.lock1 lock];</span><br><span class=\"line\">    NSLog(@&quot;task2 获得 lock1&quot;);</span><br><span class=\"line\">    [self.lock1 unlock];</span><br><span class=\"line\">    [self.lock2 unlock];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我们可以看到最后控制台输出的结果是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task2 获得 lock2</span><br><span class=\"line\">task1 获得 lock1</span><br></pre></td></tr></table></figure>\n\n<p>或</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task2 获得 lock2</span><br><span class=\"line\">task1 获得 lock1</span><br></pre></td></tr></table></figure>\n\n<p>为什么是两种结果呢，可以参考我的<a href=\"https://hparis.github.io/blog/2017/09/05/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3GCD/\">「初步了解 GCD」</a>。</p>\n<p>但是不管如何，这两种结果都没有输出 <code>task1 获得 lock2</code> 或 <code>task2 获得 lock1</code>。我们来分析一下：</p>\n<ul>\n<li>task1 获得 lock1，然后沉睡 2s</li>\n<li>task2 获得 lock2，然后沉睡 2s</li>\n<li>task1 经过 2s 的沉睡之后想要去获取 lock2，此时发现 lock2 已经被使用，那就继续等待</li>\n<li>task2 经过 2s 的沉睡之后想要去获取 lock1，此时发现 lock1 已经被使用，那就继续等待</li>\n<li>task1 又被唤醒想要去获取 lock2，此时 lock2 依旧没有被 task2 释放，只能继续等待</li>\n<li>task2 又被唤醒想要去获取 lock1，此时 lock1 依旧没有被 task1 释放，只能继续等待</li>\n<li>…</li>\n<li>…</li>\n</ul>\n<p>于是 task1 和 task2 都在等待对方释放资源，但是自己也不退出也不释放资源，最终导致死锁的产生。</p>\n<p>接下来，我们来讨论另外一个例子是不是死锁：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 某个按钮的点击事件</span><br><span class=\"line\">- (void)onClick:(UIEvent *)event &#123;</span><br><span class=\"line\">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        ...    </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相信大家都知道上面这个例子会导致主线程发生阻塞的现象，但是这是因为死锁造成的么？</p>\n<blockquote>\n<p>Submits a block to a dispatch queue for synchronous execution. Unlike dispatch_async, this function does not return until the block has finished. Calling this function and targeting the current queue results in deadlock.</p>\n</blockquote>\n<p>在官方文档里面明确的说了，这就是死锁。我们可以把上面的例子“翻译”一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 首先进入 onClick 的时候，我们可以认为此时是需要加锁的</span><br><span class=\"line\">// 某个按钮的点击事件</span><br><span class=\"line\">- (void)onClick:(UIEvent *)event &#123;</span><br><span class=\"line\">    [self.lock1 lock];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 此时我们可以认为 dispatch_sync 是在获取 block 里面的 lock2 </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [self.lock2 lock];</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 放在主线程执行，那么它也需要获得 lock1 </span><br><span class=\"line\">        [self.lock1 lock];</span><br><span class=\"line\">        [self.lock1 unlock];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [self.lock2 unlock];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [self.lock1 unlock];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到其实上面的情况就是两个任务都在同时竞争主线程的资源，并且谁都没有退出最终导致死锁的产生。但是这两个任务并不是普通的两个线程在竞争资源，而是都在主线程上，一个嵌套另外一个。而且这种特殊的情况，在运行的时候会直接导致奔溃，而不像我们一开始的例子一样只是在互相等待。但是既然苹果把这种情况也称为死锁，那我们就当做死锁来看待，毕竟他们都是在竞争系统资源。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>当系统存在两个线程及以上的时候，双方都在等待对方停止执行，以获得系统资源，但是没有一方提前退出的时候就叫做死锁。</p>\n</blockquote>\n<p>那在 Objective-C 里面如何实现死锁呢：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.lock1 = [NSLock new];</span><br><span class=\"line\">self.lock2 = [NSLock new];</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_async(dispatch_queue_create(&quot;com.papa.task1&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class=\"line\">    [self.lock1 lock];</span><br><span class=\"line\">    NSLog(@&quot;task1 获得 lock1&quot;);</span><br><span class=\"line\">    sleep(2);</span><br><span class=\"line\">    [self.lock2 lock];</span><br><span class=\"line\">    NSLog(@&quot;task1 获得 lock2&quot;);</span><br><span class=\"line\">    [self.lock2 unlock];</span><br><span class=\"line\">    [self.lock1 unlock];</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(dispatch_queue_create(&quot;com.papa.task2&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class=\"line\">    [self.lock2 lock];</span><br><span class=\"line\">    NSLog(@&quot;task2 获得 lock2&quot;);</span><br><span class=\"line\">    sleep(2);</span><br><span class=\"line\">    [self.lock1 lock];</span><br><span class=\"line\">    NSLog(@&quot;task2 获得 lock1&quot;);</span><br><span class=\"line\">    [self.lock1 unlock];</span><br><span class=\"line\">    [self.lock2 unlock];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我们可以看到最后控制台输出的结果是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task2 获得 lock2</span><br><span class=\"line\">task1 获得 lock1</span><br></pre></td></tr></table></figure>\n\n<p>或</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task2 获得 lock2</span><br><span class=\"line\">task1 获得 lock1</span><br></pre></td></tr></table></figure>\n\n<p>为什么是两种结果呢，可以参考我的<a href=\"https://hparis.github.io/blog/2017/09/05/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3GCD/\">「初步了解 GCD」</a>。</p>\n<p>但是不管如何，这两种结果都没有输出 <code>task1 获得 lock2</code> 或 <code>task2 获得 lock1</code>。我们来分析一下：</p>\n<ul>\n<li>task1 获得 lock1，然后沉睡 2s</li>\n<li>task2 获得 lock2，然后沉睡 2s</li>\n<li>task1 经过 2s 的沉睡之后想要去获取 lock2，此时发现 lock2 已经被使用，那就继续等待</li>\n<li>task2 经过 2s 的沉睡之后想要去获取 lock1，此时发现 lock1 已经被使用，那就继续等待</li>\n<li>task1 又被唤醒想要去获取 lock2，此时 lock2 依旧没有被 task2 释放，只能继续等待</li>\n<li>task2 又被唤醒想要去获取 lock1，此时 lock1 依旧没有被 task1 释放，只能继续等待</li>\n<li>…</li>\n<li>…</li>\n</ul>\n<p>于是 task1 和 task2 都在等待对方释放资源，但是自己也不退出也不释放资源，最终导致死锁的产生。</p>\n<p>接下来，我们来讨论另外一个例子是不是死锁：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 某个按钮的点击事件</span><br><span class=\"line\">- (void)onClick:(UIEvent *)event &#123;</span><br><span class=\"line\">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        ...    </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相信大家都知道上面这个例子会导致主线程发生阻塞的现象，但是这是因为死锁造成的么？</p>\n<blockquote>\n<p>Submits a block to a dispatch queue for synchronous execution. Unlike dispatch_async, this function does not return until the block has finished. Calling this function and targeting the current queue results in deadlock.</p>\n</blockquote>\n<p>在官方文档里面明确的说了，这就是死锁。我们可以把上面的例子“翻译”一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 首先进入 onClick 的时候，我们可以认为此时是需要加锁的</span><br><span class=\"line\">// 某个按钮的点击事件</span><br><span class=\"line\">- (void)onClick:(UIEvent *)event &#123;</span><br><span class=\"line\">    [self.lock1 lock];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 此时我们可以认为 dispatch_sync 是在获取 block 里面的 lock2 </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [self.lock2 lock];</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 放在主线程执行，那么它也需要获得 lock1 </span><br><span class=\"line\">        [self.lock1 lock];</span><br><span class=\"line\">        [self.lock1 unlock];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [self.lock2 unlock];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [self.lock1 unlock];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到其实上面的情况就是两个任务都在同时竞争主线程的资源，并且谁都没有退出最终导致死锁的产生。但是这两个任务并不是普通的两个线程在竞争资源，而是都在主线程上，一个嵌套另外一个。而且这种特殊的情况，在运行的时候会直接导致奔溃，而不像我们一开始的例子一样只是在互相等待。但是既然苹果把这种情况也称为死锁，那我们就当做死锁来看待，毕竟他们都是在竞争系统资源。</p>\n"},{"title":"说说 Objective-C 中的 Copy 操作","date":"2018-03-23T16:35:55.000Z","author":"帕帕","thumbnail":"https://i.imgur.com/svn3AbQs.png","_content":"\n## 浅拷贝（Shallow copies）和深拷贝（Deep copies）\n\n我们都知道 Objective-C 中把 Copy 操作分成两种：`浅拷贝（Shallow copies）`和`深拷贝（Deep copies）`。学过 C 语言的同学应该知道区分这两种操作的区别其实很简单：\n\n> 浅拷贝（Shallow copies）: 指针拷贝，指向的还是同一块内容的地址\n> 深拷贝（Deep copies）: 内容拷贝\n\n\n但是在 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别。我们先来看看 Apple 的官方文档给出的一张图：\n\n![Collections Programming Topics](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png)\n\n通过上图可以看出`浅拷贝`过后，Array 1 和 Array 2 的元素都是相同的指针地址，指向相同的内容；`深拷贝`过后，内容被拷贝一份新的出来，Array 2 的元素的指针地址都和 Array 1 不一样，因为 Array2 的元素的指针地址都指向新的内容。\n\n## immutable 和 mutable 对象的拷贝\n\n在 Objective-C 中一般会用 copy 或 mutableCopy 进行拷贝操作，我们可以通过观察指针变化来确定这两种拷贝操作是`浅复制`还是`深复制`。\n    \n* immutable 对象的复制操作\n\n    ```Objective-C\n    NSString * aName = @\"帕帕\";\n    NSString * bName = [aName copy];\n    NSMutableString * cName = [aName mutableCopy];\n    \n    NSLog(@\"aName 的指针：%p\", aName);\n    NSLog(@\"bName 的指针：%p\", bName);\n    NSLog(@\"cName 的指针：%p\", cName);\n    \n    ```\n\n    输出的结果：\n    \n    ```\n    aName 的指针：0x103d34070\n    bName 的指针：0x103d34070\n    cName 的指针：0x600000250dd0\n    ```\n\n* mutable 对象的复制操作\n\n    ```Objective-C\n    NSMutableString * aName = [NSMutableString stringWithString:@\"帕帕\"];\n    NSString * bName = [aName copy];\n    NSMutableString * cName = [aName mutableCopy];\n    \n    NSLog(@\"aName 的指针：%p\", aName);\n    NSLog(@\"bName 的指针：%p\", bName);\n    NSLog(@\"cName 的指针：%p\", cName);\n    \n    ```\n\n    输出的结果：\n    \n    ```\n    aName 的指针：0x60000025e150\n    bName 的指针：0x600000222900\n    cName 的指针：0x60000025e450\n    ```\n\n通过上面两个例子以及它们的输出结果，我们可以得出下面这个表格：\n\n|  | imutable 对象 | mutable 对象 |\n| :---: | :---: | :---: |\n| copy | 浅复制 | 深复制 |\n| mutableCopy | 深复制| 深复制 |\n\n上面的规则对集合对象也是一样的：NSArray 和 NSMutableArray，NSDictionary 和 NSMutableDictionary，NSSet 和 NSMutableSet\n\n\n## 单层深复制（one-level-deep）\n\n```Objective-C\nNSMutableString * aString = [NSMutableString stringWithString:@\"\bHello\"]\n\nNSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];\nNSArray * bArray = [aArray copy];\n\nNSMutableString * bString = bArray[0];\n[bString appendString:@\" \b帕帕\"];\n    \nNSLog(@\"aArray 的指针：%p\", aName);\nNSLog(@\"bArray 的指针：%p\", bName);\nNSLog(@\"aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@\", aArray[0], aArray[0]);\nNSLog(@\"bArray 第一个元素的指针: %p，\b\b内容：%@\", bArray[0], bArray[0]);\n```\n\n输出结果：\n\n```\naArray 的指针：0x60000025d9a0\nbArray 的指针：0x60000002cf60\naArray \b\u001d\b第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕\nbArray 第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕\n```\n\n从 aArray 到 bArray 的 copy 操作之后，它们的指针地址发生了变化，按照我们之前的理解这是`深拷贝`。`深拷贝`会把 aArray 的元素都拷贝一份，那为什么改变 bArray 的元素的值会导致 aArray 的元素的值也发生了变化呢？\n\n![集合对象的深拷贝](https://i.imgur.com/svn3AbQ.png)\n\n## 完全深复制\n\n那我们要如何做到真正的深复制呢？我们可以简单的把上面的代码改一下：\n\n```Objective-C\nNSMutableString * aString = [NSMutableString stringWithString:@\"\bHello\"]\n\nNSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];\n\n// 只需要改动这一行代码\nNSArray *bArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:aArray]];\n\nNSMutableString * bString = bArray[0];\n[bString appendString:@\" \b帕帕\"];\n    \nNSLog(@\"aArray 的指针：%p\", aName);\nNSLog(@\"bArray 的指针：%p\", bName);\nNSLog(@\"aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@\", aArray[0], aArray[0]);\nNSLog(@\"bArray 第一个元素的指针: %p，\b\b内容：%@\", bArray[0], bArray[0]);\n```\n\n输出结果：\n\n```\naArray 的指针：0x600000259cb0\nbArray 的指针：0x600000030ac0\naArray \b\u001d\b第一个元素的指针: 0x604000452120，\b\b内容：\bHello\nbArray 第一个元素的指针: 0x604000452780，\b\b内容：\bHello \b帕帕\n```\n\n只要先对集合对象分别用 NSKeyedArchiver 和 NSKeyedUnarchiver 就可以真正完成对一个集合对象的深复制。\n\n## Copy 和 内存管理\n\n之前我们说过 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别，那差别在什么地方呢？\n内存中做复制操作是很耗费资源的，而我们都知道 Objective-C 高效的一个原因在于它的内存管理机制是`引用计数`。我们前面分析的`深拷贝`是对内容的拷贝，这一点跟 C 语言的一样。C 语言的`浅拷贝`是指针的拷贝，它依旧做了一次复制操作。而在 Objective-C 中，`浅拷贝`其实只是引用计数的增加，不信的话，我们可以看看下面的例子：\n\n```Objective-C\nNSArray * aArray = [NSArray arrayWithObjects:@\"帕帕\", nil];\nNSLog(@\"aArray 的指针：%p，\b\b引用计数：%ld\", aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));\nNSArray * bArray = [aArray copy];\nNSLog(@\"aArray 的指针：%p，\b\b引用计数：%ld\", aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));\nNSMutableArray * cArray = [aArray mutableCopy];\nNSLog(@\"aArray 的指针：%p，\b\b引用计数：%ld\", aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));\n```\n\n输出结果：\n\n```\naArray 的指针：0x604000443ba0，\b\b引用计数：2\naArray 的指针：0x604000443ba0，\b\b引用计数：3\naArray 的指针：0x604000443ba0，\b\b引用计数：3\n```\n\n为什么 aArray 刚出来的时候的引用计数是 2？因为 `[NSArray arrayWithObjects:@\"帕帕\", nil]` 本身就是一个对象，它的引用计数就是 1；然后我们又定义了 aArray 来引用这个对象，此时它的引用计数就增加了 1，变成了 2；之后我们对 aArray 进行了 copy 操作，发现它的引用计数变成了 3，所以这里的 copy 操作其实相当于 retaion；最有我们对 aArray 进行了 mutableCopy 操作，此时它的引用计数还是 3，没有发生变化，因为这个时候进行了内容复制。\n\n所以在 Objective-C 中对一个 imutable 对象进行的 copy（浅复制）操作，其实都只会引起引用计数的变化，而不会在内存中做出任何拷贝操作，包括指针拷贝。\n\n## NSCopying 和 NSMutableCopying\n\n如果我们有一个自定义的对象，并且对其进行 copy 操作的话，会发生什么：\n\n```Objective-C\n// Person\n@interface Person: NSObject\n@property (nonatomic, copy) NSString * name;\n@end\n@implementation Person\n@end\n\nPerson * aPerson = [Person new];\nPerson * bPerson = [aPerson copy];\n```\n\nXcode 直接奔溃了：\n\n```\n// 崩溃\n*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[Person copyWithZone:]: unrecognized selector sent to instance 0x60000000d5f0'\n```\n\n为什么我们对一个 Person 对象使用了 copy，Xcode 确报的是找不到 `copyWithZone:` 这个 selector 的错误。\n\n这是因为 Objective-C 中规定，一个对象如果想要使用 copy 或 mutableCopy 的操作，必须要实现 `NSCopying` 或 `NSMutableCopying` 这两个协议。这两个协议规定了对象需要实现 `copyWithZone:` 或 `mutableCopyWithZone:` 这两个方法，因为对一个对象做 copy 或 mutableCopy 最后都会去调用这两个方法来做最终的实现。\n上面例子中的集合对象能够使用 copy 和 mutableCopy 操作是也因为它们都实现了 NSCopying 和 NSMutableCopying 协议。\n\n我们来看看如何对一个普通的对象实现 NSCopying 协议：\n\n```Objective-C\n@interface Person: NSObject <NSCopying>\n@property (nonatomic, copy) NSString * name;\n@property (nonatomic, strong) NSMutableArray * mArray;\n@end\n\n@implementation Person\n- (instancetype)copyWithZone:(NSZone *)zone {\n    Person * person = [[self class] new];\n    person.name = [self.name copy];\n    person.mArray = [self.mArray mutableCopy];\n    return person;\n}\n@end\n```\n\n这样，我们就可以愉快的使用 `[Person copy]` 了。当然，这里 Person 的 mArray 也只是`单层深复制`，如果想要实现`完全深复制`的话，我们可以用 NSKeyedArchiver 和 NSKeyedUnarchiver 来完成对 mArray 的`完全深复制`。\n\n## Block 和 Copy\n\n简单说一下，在 Objective-C 中，Block 的 copy 是一种特殊的操作。因为 Block 是一种结构体，它无法实现 NSCopying 或 NSMutableCopying 协议，但是它却可以调用 copy 方法。这是由 Block 的结构体决定的：\n\n![](http://www.devtalking.com/postImages/block-struct.jpg)\n\nBlock 里面的 descriptor 有 copy 的函数指针，当对 Block 执行 copy 操作最后都会通过该函数指针进行真正的操作。这也是 Bloc看不需要实现 NSCopying 和 NSMutableCopying 就能调用 copy 方法的原因。\n\n\n\n参考资料：\n1. https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html\n2. https://www.zybuluo.com/MicroCai/note/50592\n\n","source":"_posts/说说-Objective-C-中的-Copy-操作.md","raw":"---\ntitle: 说说 Objective-C 中的 Copy 操作\ndate: 2018-03-23 16:35:55 +0800\nauthor: 帕帕\ncategories: 技术 \ntags: [iOS, Objective-C]\nthumbnail: https://i.imgur.com/svn3AbQs.png\n---\n\n## 浅拷贝（Shallow copies）和深拷贝（Deep copies）\n\n我们都知道 Objective-C 中把 Copy 操作分成两种：`浅拷贝（Shallow copies）`和`深拷贝（Deep copies）`。学过 C 语言的同学应该知道区分这两种操作的区别其实很简单：\n\n> 浅拷贝（Shallow copies）: 指针拷贝，指向的还是同一块内容的地址\n> 深拷贝（Deep copies）: 内容拷贝\n\n\n但是在 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别。我们先来看看 Apple 的官方文档给出的一张图：\n\n![Collections Programming Topics](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png)\n\n通过上图可以看出`浅拷贝`过后，Array 1 和 Array 2 的元素都是相同的指针地址，指向相同的内容；`深拷贝`过后，内容被拷贝一份新的出来，Array 2 的元素的指针地址都和 Array 1 不一样，因为 Array2 的元素的指针地址都指向新的内容。\n\n## immutable 和 mutable 对象的拷贝\n\n在 Objective-C 中一般会用 copy 或 mutableCopy 进行拷贝操作，我们可以通过观察指针变化来确定这两种拷贝操作是`浅复制`还是`深复制`。\n    \n* immutable 对象的复制操作\n\n    ```Objective-C\n    NSString * aName = @\"帕帕\";\n    NSString * bName = [aName copy];\n    NSMutableString * cName = [aName mutableCopy];\n    \n    NSLog(@\"aName 的指针：%p\", aName);\n    NSLog(@\"bName 的指针：%p\", bName);\n    NSLog(@\"cName 的指针：%p\", cName);\n    \n    ```\n\n    输出的结果：\n    \n    ```\n    aName 的指针：0x103d34070\n    bName 的指针：0x103d34070\n    cName 的指针：0x600000250dd0\n    ```\n\n* mutable 对象的复制操作\n\n    ```Objective-C\n    NSMutableString * aName = [NSMutableString stringWithString:@\"帕帕\"];\n    NSString * bName = [aName copy];\n    NSMutableString * cName = [aName mutableCopy];\n    \n    NSLog(@\"aName 的指针：%p\", aName);\n    NSLog(@\"bName 的指针：%p\", bName);\n    NSLog(@\"cName 的指针：%p\", cName);\n    \n    ```\n\n    输出的结果：\n    \n    ```\n    aName 的指针：0x60000025e150\n    bName 的指针：0x600000222900\n    cName 的指针：0x60000025e450\n    ```\n\n通过上面两个例子以及它们的输出结果，我们可以得出下面这个表格：\n\n|  | imutable 对象 | mutable 对象 |\n| :---: | :---: | :---: |\n| copy | 浅复制 | 深复制 |\n| mutableCopy | 深复制| 深复制 |\n\n上面的规则对集合对象也是一样的：NSArray 和 NSMutableArray，NSDictionary 和 NSMutableDictionary，NSSet 和 NSMutableSet\n\n\n## 单层深复制（one-level-deep）\n\n```Objective-C\nNSMutableString * aString = [NSMutableString stringWithString:@\"\bHello\"]\n\nNSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];\nNSArray * bArray = [aArray copy];\n\nNSMutableString * bString = bArray[0];\n[bString appendString:@\" \b帕帕\"];\n    \nNSLog(@\"aArray 的指针：%p\", aName);\nNSLog(@\"bArray 的指针：%p\", bName);\nNSLog(@\"aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@\", aArray[0], aArray[0]);\nNSLog(@\"bArray 第一个元素的指针: %p，\b\b内容：%@\", bArray[0], bArray[0]);\n```\n\n输出结果：\n\n```\naArray 的指针：0x60000025d9a0\nbArray 的指针：0x60000002cf60\naArray \b\u001d\b第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕\nbArray 第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕\n```\n\n从 aArray 到 bArray 的 copy 操作之后，它们的指针地址发生了变化，按照我们之前的理解这是`深拷贝`。`深拷贝`会把 aArray 的元素都拷贝一份，那为什么改变 bArray 的元素的值会导致 aArray 的元素的值也发生了变化呢？\n\n![集合对象的深拷贝](https://i.imgur.com/svn3AbQ.png)\n\n## 完全深复制\n\n那我们要如何做到真正的深复制呢？我们可以简单的把上面的代码改一下：\n\n```Objective-C\nNSMutableString * aString = [NSMutableString stringWithString:@\"\bHello\"]\n\nNSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];\n\n// 只需要改动这一行代码\nNSArray *bArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:aArray]];\n\nNSMutableString * bString = bArray[0];\n[bString appendString:@\" \b帕帕\"];\n    \nNSLog(@\"aArray 的指针：%p\", aName);\nNSLog(@\"bArray 的指针：%p\", bName);\nNSLog(@\"aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@\", aArray[0], aArray[0]);\nNSLog(@\"bArray 第一个元素的指针: %p，\b\b内容：%@\", bArray[0], bArray[0]);\n```\n\n输出结果：\n\n```\naArray 的指针：0x600000259cb0\nbArray 的指针：0x600000030ac0\naArray \b\u001d\b第一个元素的指针: 0x604000452120，\b\b内容：\bHello\nbArray 第一个元素的指针: 0x604000452780，\b\b内容：\bHello \b帕帕\n```\n\n只要先对集合对象分别用 NSKeyedArchiver 和 NSKeyedUnarchiver 就可以真正完成对一个集合对象的深复制。\n\n## Copy 和 内存管理\n\n之前我们说过 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别，那差别在什么地方呢？\n内存中做复制操作是很耗费资源的，而我们都知道 Objective-C 高效的一个原因在于它的内存管理机制是`引用计数`。我们前面分析的`深拷贝`是对内容的拷贝，这一点跟 C 语言的一样。C 语言的`浅拷贝`是指针的拷贝，它依旧做了一次复制操作。而在 Objective-C 中，`浅拷贝`其实只是引用计数的增加，不信的话，我们可以看看下面的例子：\n\n```Objective-C\nNSArray * aArray = [NSArray arrayWithObjects:@\"帕帕\", nil];\nNSLog(@\"aArray 的指针：%p，\b\b引用计数：%ld\", aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));\nNSArray * bArray = [aArray copy];\nNSLog(@\"aArray 的指针：%p，\b\b引用计数：%ld\", aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));\nNSMutableArray * cArray = [aArray mutableCopy];\nNSLog(@\"aArray 的指针：%p，\b\b引用计数：%ld\", aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));\n```\n\n输出结果：\n\n```\naArray 的指针：0x604000443ba0，\b\b引用计数：2\naArray 的指针：0x604000443ba0，\b\b引用计数：3\naArray 的指针：0x604000443ba0，\b\b引用计数：3\n```\n\n为什么 aArray 刚出来的时候的引用计数是 2？因为 `[NSArray arrayWithObjects:@\"帕帕\", nil]` 本身就是一个对象，它的引用计数就是 1；然后我们又定义了 aArray 来引用这个对象，此时它的引用计数就增加了 1，变成了 2；之后我们对 aArray 进行了 copy 操作，发现它的引用计数变成了 3，所以这里的 copy 操作其实相当于 retaion；最有我们对 aArray 进行了 mutableCopy 操作，此时它的引用计数还是 3，没有发生变化，因为这个时候进行了内容复制。\n\n所以在 Objective-C 中对一个 imutable 对象进行的 copy（浅复制）操作，其实都只会引起引用计数的变化，而不会在内存中做出任何拷贝操作，包括指针拷贝。\n\n## NSCopying 和 NSMutableCopying\n\n如果我们有一个自定义的对象，并且对其进行 copy 操作的话，会发生什么：\n\n```Objective-C\n// Person\n@interface Person: NSObject\n@property (nonatomic, copy) NSString * name;\n@end\n@implementation Person\n@end\n\nPerson * aPerson = [Person new];\nPerson * bPerson = [aPerson copy];\n```\n\nXcode 直接奔溃了：\n\n```\n// 崩溃\n*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[Person copyWithZone:]: unrecognized selector sent to instance 0x60000000d5f0'\n```\n\n为什么我们对一个 Person 对象使用了 copy，Xcode 确报的是找不到 `copyWithZone:` 这个 selector 的错误。\n\n这是因为 Objective-C 中规定，一个对象如果想要使用 copy 或 mutableCopy 的操作，必须要实现 `NSCopying` 或 `NSMutableCopying` 这两个协议。这两个协议规定了对象需要实现 `copyWithZone:` 或 `mutableCopyWithZone:` 这两个方法，因为对一个对象做 copy 或 mutableCopy 最后都会去调用这两个方法来做最终的实现。\n上面例子中的集合对象能够使用 copy 和 mutableCopy 操作是也因为它们都实现了 NSCopying 和 NSMutableCopying 协议。\n\n我们来看看如何对一个普通的对象实现 NSCopying 协议：\n\n```Objective-C\n@interface Person: NSObject <NSCopying>\n@property (nonatomic, copy) NSString * name;\n@property (nonatomic, strong) NSMutableArray * mArray;\n@end\n\n@implementation Person\n- (instancetype)copyWithZone:(NSZone *)zone {\n    Person * person = [[self class] new];\n    person.name = [self.name copy];\n    person.mArray = [self.mArray mutableCopy];\n    return person;\n}\n@end\n```\n\n这样，我们就可以愉快的使用 `[Person copy]` 了。当然，这里 Person 的 mArray 也只是`单层深复制`，如果想要实现`完全深复制`的话，我们可以用 NSKeyedArchiver 和 NSKeyedUnarchiver 来完成对 mArray 的`完全深复制`。\n\n## Block 和 Copy\n\n简单说一下，在 Objective-C 中，Block 的 copy 是一种特殊的操作。因为 Block 是一种结构体，它无法实现 NSCopying 或 NSMutableCopying 协议，但是它却可以调用 copy 方法。这是由 Block 的结构体决定的：\n\n![](http://www.devtalking.com/postImages/block-struct.jpg)\n\nBlock 里面的 descriptor 有 copy 的函数指针，当对 Block 执行 copy 操作最后都会通过该函数指针进行真正的操作。这也是 Bloc看不需要实现 NSCopying 和 NSMutableCopying 就能调用 copy 方法的原因。\n\n\n\n参考资料：\n1. https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html\n2. https://www.zybuluo.com/MicroCai/note/50592\n\n","slug":"说说-Objective-C-中的-Copy-操作","published":1,"updated":"2022-04-20T07:08:33.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl28gjxem001k6enq9ejwcp45","content":"<h2 id=\"浅拷贝（Shallow-copies）和深拷贝（Deep-copies）\"><a href=\"#浅拷贝（Shallow-copies）和深拷贝（Deep-copies）\" class=\"headerlink\" title=\"浅拷贝（Shallow copies）和深拷贝（Deep copies）\"></a>浅拷贝（Shallow copies）和深拷贝（Deep copies）</h2><p>我们都知道 Objective-C 中把 Copy 操作分成两种：<code>浅拷贝（Shallow copies）</code>和<code>深拷贝（Deep copies）</code>。学过 C 语言的同学应该知道区分这两种操作的区别其实很简单：</p>\n<blockquote>\n<p>浅拷贝（Shallow copies）: 指针拷贝，指向的还是同一块内容的地址<br>深拷贝（Deep copies）: 内容拷贝</p>\n</blockquote>\n<p>但是在 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别。我们先来看看 Apple 的官方文档给出的一张图：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png\" alt=\"Collections Programming Topics\"></p>\n<p>通过上图可以看出<code>浅拷贝</code>过后，Array 1 和 Array 2 的元素都是相同的指针地址，指向相同的内容；<code>深拷贝</code>过后，内容被拷贝一份新的出来，Array 2 的元素的指针地址都和 Array 1 不一样，因为 Array2 的元素的指针地址都指向新的内容。</p>\n<h2 id=\"immutable-和-mutable-对象的拷贝\"><a href=\"#immutable-和-mutable-对象的拷贝\" class=\"headerlink\" title=\"immutable 和 mutable 对象的拷贝\"></a>immutable 和 mutable 对象的拷贝</h2><p>在 Objective-C 中一般会用 copy 或 mutableCopy 进行拷贝操作，我们可以通过观察指针变化来确定这两种拷贝操作是<code>浅复制</code>还是<code>深复制</code>。</p>\n<ul>\n<li><p>immutable 对象的复制操作</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSString * aName = @&quot;帕帕&quot;;</span><br><span class=\"line\">NSString * bName = [aName copy];</span><br><span class=\"line\">NSMutableString * cName = [aName mutableCopy];</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;aName 的指针：%p&quot;, aName);</span><br><span class=\"line\">NSLog(@&quot;bName 的指针：%p&quot;, bName);</span><br><span class=\"line\">NSLog(@&quot;cName 的指针：%p&quot;, cName);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>  输出的结果：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aName 的指针：0x103d34070</span><br><span class=\"line\">bName 的指针：0x103d34070</span><br><span class=\"line\">cName 的指针：0x600000250dd0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>mutable 对象的复制操作</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableString * aName = [NSMutableString stringWithString:@&quot;帕帕&quot;];</span><br><span class=\"line\">NSString * bName = [aName copy];</span><br><span class=\"line\">NSMutableString * cName = [aName mutableCopy];</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;aName 的指针：%p&quot;, aName);</span><br><span class=\"line\">NSLog(@&quot;bName 的指针：%p&quot;, bName);</span><br><span class=\"line\">NSLog(@&quot;cName 的指针：%p&quot;, cName);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>  输出的结果：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aName 的指针：0x60000025e150</span><br><span class=\"line\">bName 的指针：0x600000222900</span><br><span class=\"line\">cName 的指针：0x60000025e450</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>通过上面两个例子以及它们的输出结果，我们可以得出下面这个表格：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">imutable 对象</th>\n<th align=\"center\">mutable 对象</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">copy</td>\n<td align=\"center\">浅复制</td>\n<td align=\"center\">深复制</td>\n</tr>\n<tr>\n<td align=\"center\">mutableCopy</td>\n<td align=\"center\">深复制</td>\n<td align=\"center\">深复制</td>\n</tr>\n</tbody></table>\n<p>上面的规则对集合对象也是一样的：NSArray 和 NSMutableArray，NSDictionary 和 NSMutableDictionary，NSSet 和 NSMutableSet</p>\n<h2 id=\"单层深复制（one-level-deep）\"><a href=\"#单层深复制（one-level-deep）\" class=\"headerlink\" title=\"单层深复制（one-level-deep）\"></a>单层深复制（one-level-deep）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableString * aString = [NSMutableString stringWithString:@&quot;\bHello&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];</span><br><span class=\"line\">NSArray * bArray = [aArray copy];</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableString * bString = bArray[0];</span><br><span class=\"line\">[bString appendString:@&quot; \b帕帕&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p&quot;, aName);</span><br><span class=\"line\">NSLog(@&quot;bArray 的指针：%p&quot;, bName);</span><br><span class=\"line\">NSLog(@&quot;aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@&quot;, aArray[0], aArray[0]);</span><br><span class=\"line\">NSLog(@&quot;bArray 第一个元素的指针: %p，\b\b内容：%@&quot;, bArray[0], bArray[0]);</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aArray 的指针：0x60000025d9a0</span><br><span class=\"line\">bArray 的指针：0x60000002cf60</span><br><span class=\"line\">aArray \b\u001d\b第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕</span><br><span class=\"line\">bArray 第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕</span><br></pre></td></tr></table></figure>\n\n<p>从 aArray 到 bArray 的 copy 操作之后，它们的指针地址发生了变化，按照我们之前的理解这是<code>深拷贝</code>。<code>深拷贝</code>会把 aArray 的元素都拷贝一份，那为什么改变 bArray 的元素的值会导致 aArray 的元素的值也发生了变化呢？</p>\n<p><img src=\"https://i.imgur.com/svn3AbQ.png\" alt=\"集合对象的深拷贝\"></p>\n<h2 id=\"完全深复制\"><a href=\"#完全深复制\" class=\"headerlink\" title=\"完全深复制\"></a>完全深复制</h2><p>那我们要如何做到真正的深复制呢？我们可以简单的把上面的代码改一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableString * aString = [NSMutableString stringWithString:@&quot;\bHello&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];</span><br><span class=\"line\"></span><br><span class=\"line\">// 只需要改动这一行代码</span><br><span class=\"line\">NSArray *bArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:aArray]];</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableString * bString = bArray[0];</span><br><span class=\"line\">[bString appendString:@&quot; \b帕帕&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p&quot;, aName);</span><br><span class=\"line\">NSLog(@&quot;bArray 的指针：%p&quot;, bName);</span><br><span class=\"line\">NSLog(@&quot;aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@&quot;, aArray[0], aArray[0]);</span><br><span class=\"line\">NSLog(@&quot;bArray 第一个元素的指针: %p，\b\b内容：%@&quot;, bArray[0], bArray[0]);</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aArray 的指针：0x600000259cb0</span><br><span class=\"line\">bArray 的指针：0x600000030ac0</span><br><span class=\"line\">aArray \b\u001d\b第一个元素的指针: 0x604000452120，\b\b内容：\bHello</span><br><span class=\"line\">bArray 第一个元素的指针: 0x604000452780，\b\b内容：\bHello \b帕帕</span><br></pre></td></tr></table></figure>\n\n<p>只要先对集合对象分别用 NSKeyedArchiver 和 NSKeyedUnarchiver 就可以真正完成对一个集合对象的深复制。</p>\n<h2 id=\"Copy-和-内存管理\"><a href=\"#Copy-和-内存管理\" class=\"headerlink\" title=\"Copy 和 内存管理\"></a>Copy 和 内存管理</h2><p>之前我们说过 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别，那差别在什么地方呢？<br>内存中做复制操作是很耗费资源的，而我们都知道 Objective-C 高效的一个原因在于它的内存管理机制是<code>引用计数</code>。我们前面分析的<code>深拷贝</code>是对内容的拷贝，这一点跟 C 语言的一样。C 语言的<code>浅拷贝</code>是指针的拷贝，它依旧做了一次复制操作。而在 Objective-C 中，<code>浅拷贝</code>其实只是引用计数的增加，不信的话，我们可以看看下面的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSArray * aArray = [NSArray arrayWithObjects:@&quot;帕帕&quot;, nil];</span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p，\b\b引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));</span><br><span class=\"line\">NSArray * bArray = [aArray copy];</span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p，\b\b引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));</span><br><span class=\"line\">NSMutableArray * cArray = [aArray mutableCopy];</span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p，\b\b引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aArray 的指针：0x604000443ba0，\b\b引用计数：2</span><br><span class=\"line\">aArray 的指针：0x604000443ba0，\b\b引用计数：3</span><br><span class=\"line\">aArray 的指针：0x604000443ba0，\b\b引用计数：3</span><br></pre></td></tr></table></figure>\n\n<p>为什么 aArray 刚出来的时候的引用计数是 2？因为 <code>[NSArray arrayWithObjects:@&quot;帕帕&quot;, nil]</code> 本身就是一个对象，它的引用计数就是 1；然后我们又定义了 aArray 来引用这个对象，此时它的引用计数就增加了 1，变成了 2；之后我们对 aArray 进行了 copy 操作，发现它的引用计数变成了 3，所以这里的 copy 操作其实相当于 retaion；最有我们对 aArray 进行了 mutableCopy 操作，此时它的引用计数还是 3，没有发生变化，因为这个时候进行了内容复制。</p>\n<p>所以在 Objective-C 中对一个 imutable 对象进行的 copy（浅复制）操作，其实都只会引起引用计数的变化，而不会在内存中做出任何拷贝操作，包括指针拷贝。</p>\n<h2 id=\"NSCopying-和-NSMutableCopying\"><a href=\"#NSCopying-和-NSMutableCopying\" class=\"headerlink\" title=\"NSCopying 和 NSMutableCopying\"></a>NSCopying 和 NSMutableCopying</h2><p>如果我们有一个自定义的对象，并且对其进行 copy 操作的话，会发生什么：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Person</span><br><span class=\"line\">@interface Person: NSObject</span><br><span class=\"line\">@property (nonatomic, copy) NSString * name;</span><br><span class=\"line\">@end</span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">Person * aPerson = [Person new];</span><br><span class=\"line\">Person * bPerson = [aPerson copy];</span><br></pre></td></tr></table></figure>\n\n<p>Xcode 直接奔溃了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 崩溃</span><br><span class=\"line\">*** Terminating app due to uncaught exception &#x27;NSInvalidArgumentException&#x27;, reason: &#x27;-[Person copyWithZone:]: unrecognized selector sent to instance 0x60000000d5f0&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>为什么我们对一个 Person 对象使用了 copy，Xcode 确报的是找不到 <code>copyWithZone:</code> 这个 selector 的错误。</p>\n<p>这是因为 Objective-C 中规定，一个对象如果想要使用 copy 或 mutableCopy 的操作，必须要实现 <code>NSCopying</code> 或 <code>NSMutableCopying</code> 这两个协议。这两个协议规定了对象需要实现 <code>copyWithZone:</code> 或 <code>mutableCopyWithZone:</code> 这两个方法，因为对一个对象做 copy 或 mutableCopy 最后都会去调用这两个方法来做最终的实现。<br>上面例子中的集合对象能够使用 copy 和 mutableCopy 操作是也因为它们都实现了 NSCopying 和 NSMutableCopying 协议。</p>\n<p>我们来看看如何对一个普通的对象实现 NSCopying 协议：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Person: NSObject &lt;NSCopying&gt;</span><br><span class=\"line\">@property (nonatomic, copy) NSString * name;</span><br><span class=\"line\">@property (nonatomic, strong) NSMutableArray * mArray;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\">- (instancetype)copyWithZone:(NSZone *)zone &#123;</span><br><span class=\"line\">    Person * person = [[self class] new];</span><br><span class=\"line\">    person.name = [self.name copy];</span><br><span class=\"line\">    person.mArray = [self.mArray mutableCopy];</span><br><span class=\"line\">    return person;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们就可以愉快的使用 <code>[Person copy]</code> 了。当然，这里 Person 的 mArray 也只是<code>单层深复制</code>，如果想要实现<code>完全深复制</code>的话，我们可以用 NSKeyedArchiver 和 NSKeyedUnarchiver 来完成对 mArray 的<code>完全深复制</code>。</p>\n<h2 id=\"Block-和-Copy\"><a href=\"#Block-和-Copy\" class=\"headerlink\" title=\"Block 和 Copy\"></a>Block 和 Copy</h2><p>简单说一下，在 Objective-C 中，Block 的 copy 是一种特殊的操作。因为 Block 是一种结构体，它无法实现 NSCopying 或 NSMutableCopying 协议，但是它却可以调用 copy 方法。这是由 Block 的结构体决定的：</p>\n<p><img src=\"http://www.devtalking.com/postImages/block-struct.jpg\"></p>\n<p>Block 里面的 descriptor 有 copy 的函数指针，当对 Block 执行 copy 操作最后都会通过该函数指针进行真正的操作。这也是 Bloc看不需要实现 NSCopying 和 NSMutableCopying 就能调用 copy 方法的原因。</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html\">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html</a></li>\n<li><a href=\"https://www.zybuluo.com/MicroCai/note/50592\">https://www.zybuluo.com/MicroCai/note/50592</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"浅拷贝（Shallow-copies）和深拷贝（Deep-copies）\"><a href=\"#浅拷贝（Shallow-copies）和深拷贝（Deep-copies）\" class=\"headerlink\" title=\"浅拷贝（Shallow copies）和深拷贝（Deep copies）\"></a>浅拷贝（Shallow copies）和深拷贝（Deep copies）</h2><p>我们都知道 Objective-C 中把 Copy 操作分成两种：<code>浅拷贝（Shallow copies）</code>和<code>深拷贝（Deep copies）</code>。学过 C 语言的同学应该知道区分这两种操作的区别其实很简单：</p>\n<blockquote>\n<p>浅拷贝（Shallow copies）: 指针拷贝，指向的还是同一块内容的地址<br>深拷贝（Deep copies）: 内容拷贝</p>\n</blockquote>\n<p>但是在 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别。我们先来看看 Apple 的官方文档给出的一张图：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png\" alt=\"Collections Programming Topics\"></p>\n<p>通过上图可以看出<code>浅拷贝</code>过后，Array 1 和 Array 2 的元素都是相同的指针地址，指向相同的内容；<code>深拷贝</code>过后，内容被拷贝一份新的出来，Array 2 的元素的指针地址都和 Array 1 不一样，因为 Array2 的元素的指针地址都指向新的内容。</p>\n<h2 id=\"immutable-和-mutable-对象的拷贝\"><a href=\"#immutable-和-mutable-对象的拷贝\" class=\"headerlink\" title=\"immutable 和 mutable 对象的拷贝\"></a>immutable 和 mutable 对象的拷贝</h2><p>在 Objective-C 中一般会用 copy 或 mutableCopy 进行拷贝操作，我们可以通过观察指针变化来确定这两种拷贝操作是<code>浅复制</code>还是<code>深复制</code>。</p>\n<ul>\n<li><p>immutable 对象的复制操作</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSString * aName = @&quot;帕帕&quot;;</span><br><span class=\"line\">NSString * bName = [aName copy];</span><br><span class=\"line\">NSMutableString * cName = [aName mutableCopy];</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;aName 的指针：%p&quot;, aName);</span><br><span class=\"line\">NSLog(@&quot;bName 的指针：%p&quot;, bName);</span><br><span class=\"line\">NSLog(@&quot;cName 的指针：%p&quot;, cName);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>  输出的结果：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aName 的指针：0x103d34070</span><br><span class=\"line\">bName 的指针：0x103d34070</span><br><span class=\"line\">cName 的指针：0x600000250dd0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>mutable 对象的复制操作</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableString * aName = [NSMutableString stringWithString:@&quot;帕帕&quot;];</span><br><span class=\"line\">NSString * bName = [aName copy];</span><br><span class=\"line\">NSMutableString * cName = [aName mutableCopy];</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;aName 的指针：%p&quot;, aName);</span><br><span class=\"line\">NSLog(@&quot;bName 的指针：%p&quot;, bName);</span><br><span class=\"line\">NSLog(@&quot;cName 的指针：%p&quot;, cName);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>  输出的结果：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aName 的指针：0x60000025e150</span><br><span class=\"line\">bName 的指针：0x600000222900</span><br><span class=\"line\">cName 的指针：0x60000025e450</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>通过上面两个例子以及它们的输出结果，我们可以得出下面这个表格：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">imutable 对象</th>\n<th align=\"center\">mutable 对象</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">copy</td>\n<td align=\"center\">浅复制</td>\n<td align=\"center\">深复制</td>\n</tr>\n<tr>\n<td align=\"center\">mutableCopy</td>\n<td align=\"center\">深复制</td>\n<td align=\"center\">深复制</td>\n</tr>\n</tbody></table>\n<p>上面的规则对集合对象也是一样的：NSArray 和 NSMutableArray，NSDictionary 和 NSMutableDictionary，NSSet 和 NSMutableSet</p>\n<h2 id=\"单层深复制（one-level-deep）\"><a href=\"#单层深复制（one-level-deep）\" class=\"headerlink\" title=\"单层深复制（one-level-deep）\"></a>单层深复制（one-level-deep）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableString * aString = [NSMutableString stringWithString:@&quot;\bHello&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];</span><br><span class=\"line\">NSArray * bArray = [aArray copy];</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableString * bString = bArray[0];</span><br><span class=\"line\">[bString appendString:@&quot; \b帕帕&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p&quot;, aName);</span><br><span class=\"line\">NSLog(@&quot;bArray 的指针：%p&quot;, bName);</span><br><span class=\"line\">NSLog(@&quot;aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@&quot;, aArray[0], aArray[0]);</span><br><span class=\"line\">NSLog(@&quot;bArray 第一个元素的指针: %p，\b\b内容：%@&quot;, bArray[0], bArray[0]);</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aArray 的指针：0x60000025d9a0</span><br><span class=\"line\">bArray 的指针：0x60000002cf60</span><br><span class=\"line\">aArray \b\u001d\b第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕</span><br><span class=\"line\">bArray 第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕</span><br></pre></td></tr></table></figure>\n\n<p>从 aArray 到 bArray 的 copy 操作之后，它们的指针地址发生了变化，按照我们之前的理解这是<code>深拷贝</code>。<code>深拷贝</code>会把 aArray 的元素都拷贝一份，那为什么改变 bArray 的元素的值会导致 aArray 的元素的值也发生了变化呢？</p>\n<p><img src=\"https://i.imgur.com/svn3AbQ.png\" alt=\"集合对象的深拷贝\"></p>\n<h2 id=\"完全深复制\"><a href=\"#完全深复制\" class=\"headerlink\" title=\"完全深复制\"></a>完全深复制</h2><p>那我们要如何做到真正的深复制呢？我们可以简单的把上面的代码改一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableString * aString = [NSMutableString stringWithString:@&quot;\bHello&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];</span><br><span class=\"line\"></span><br><span class=\"line\">// 只需要改动这一行代码</span><br><span class=\"line\">NSArray *bArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:aArray]];</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableString * bString = bArray[0];</span><br><span class=\"line\">[bString appendString:@&quot; \b帕帕&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p&quot;, aName);</span><br><span class=\"line\">NSLog(@&quot;bArray 的指针：%p&quot;, bName);</span><br><span class=\"line\">NSLog(@&quot;aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@&quot;, aArray[0], aArray[0]);</span><br><span class=\"line\">NSLog(@&quot;bArray 第一个元素的指针: %p，\b\b内容：%@&quot;, bArray[0], bArray[0]);</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aArray 的指针：0x600000259cb0</span><br><span class=\"line\">bArray 的指针：0x600000030ac0</span><br><span class=\"line\">aArray \b\u001d\b第一个元素的指针: 0x604000452120，\b\b内容：\bHello</span><br><span class=\"line\">bArray 第一个元素的指针: 0x604000452780，\b\b内容：\bHello \b帕帕</span><br></pre></td></tr></table></figure>\n\n<p>只要先对集合对象分别用 NSKeyedArchiver 和 NSKeyedUnarchiver 就可以真正完成对一个集合对象的深复制。</p>\n<h2 id=\"Copy-和-内存管理\"><a href=\"#Copy-和-内存管理\" class=\"headerlink\" title=\"Copy 和 内存管理\"></a>Copy 和 内存管理</h2><p>之前我们说过 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别，那差别在什么地方呢？<br>内存中做复制操作是很耗费资源的，而我们都知道 Objective-C 高效的一个原因在于它的内存管理机制是<code>引用计数</code>。我们前面分析的<code>深拷贝</code>是对内容的拷贝，这一点跟 C 语言的一样。C 语言的<code>浅拷贝</code>是指针的拷贝，它依旧做了一次复制操作。而在 Objective-C 中，<code>浅拷贝</code>其实只是引用计数的增加，不信的话，我们可以看看下面的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSArray * aArray = [NSArray arrayWithObjects:@&quot;帕帕&quot;, nil];</span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p，\b\b引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));</span><br><span class=\"line\">NSArray * bArray = [aArray copy];</span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p，\b\b引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));</span><br><span class=\"line\">NSMutableArray * cArray = [aArray mutableCopy];</span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p，\b\b引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aArray 的指针：0x604000443ba0，\b\b引用计数：2</span><br><span class=\"line\">aArray 的指针：0x604000443ba0，\b\b引用计数：3</span><br><span class=\"line\">aArray 的指针：0x604000443ba0，\b\b引用计数：3</span><br></pre></td></tr></table></figure>\n\n<p>为什么 aArray 刚出来的时候的引用计数是 2？因为 <code>[NSArray arrayWithObjects:@&quot;帕帕&quot;, nil]</code> 本身就是一个对象，它的引用计数就是 1；然后我们又定义了 aArray 来引用这个对象，此时它的引用计数就增加了 1，变成了 2；之后我们对 aArray 进行了 copy 操作，发现它的引用计数变成了 3，所以这里的 copy 操作其实相当于 retaion；最有我们对 aArray 进行了 mutableCopy 操作，此时它的引用计数还是 3，没有发生变化，因为这个时候进行了内容复制。</p>\n<p>所以在 Objective-C 中对一个 imutable 对象进行的 copy（浅复制）操作，其实都只会引起引用计数的变化，而不会在内存中做出任何拷贝操作，包括指针拷贝。</p>\n<h2 id=\"NSCopying-和-NSMutableCopying\"><a href=\"#NSCopying-和-NSMutableCopying\" class=\"headerlink\" title=\"NSCopying 和 NSMutableCopying\"></a>NSCopying 和 NSMutableCopying</h2><p>如果我们有一个自定义的对象，并且对其进行 copy 操作的话，会发生什么：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Person</span><br><span class=\"line\">@interface Person: NSObject</span><br><span class=\"line\">@property (nonatomic, copy) NSString * name;</span><br><span class=\"line\">@end</span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">Person * aPerson = [Person new];</span><br><span class=\"line\">Person * bPerson = [aPerson copy];</span><br></pre></td></tr></table></figure>\n\n<p>Xcode 直接奔溃了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 崩溃</span><br><span class=\"line\">*** Terminating app due to uncaught exception &#x27;NSInvalidArgumentException&#x27;, reason: &#x27;-[Person copyWithZone:]: unrecognized selector sent to instance 0x60000000d5f0&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>为什么我们对一个 Person 对象使用了 copy，Xcode 确报的是找不到 <code>copyWithZone:</code> 这个 selector 的错误。</p>\n<p>这是因为 Objective-C 中规定，一个对象如果想要使用 copy 或 mutableCopy 的操作，必须要实现 <code>NSCopying</code> 或 <code>NSMutableCopying</code> 这两个协议。这两个协议规定了对象需要实现 <code>copyWithZone:</code> 或 <code>mutableCopyWithZone:</code> 这两个方法，因为对一个对象做 copy 或 mutableCopy 最后都会去调用这两个方法来做最终的实现。<br>上面例子中的集合对象能够使用 copy 和 mutableCopy 操作是也因为它们都实现了 NSCopying 和 NSMutableCopying 协议。</p>\n<p>我们来看看如何对一个普通的对象实现 NSCopying 协议：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Person: NSObject &lt;NSCopying&gt;</span><br><span class=\"line\">@property (nonatomic, copy) NSString * name;</span><br><span class=\"line\">@property (nonatomic, strong) NSMutableArray * mArray;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\">- (instancetype)copyWithZone:(NSZone *)zone &#123;</span><br><span class=\"line\">    Person * person = [[self class] new];</span><br><span class=\"line\">    person.name = [self.name copy];</span><br><span class=\"line\">    person.mArray = [self.mArray mutableCopy];</span><br><span class=\"line\">    return person;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们就可以愉快的使用 <code>[Person copy]</code> 了。当然，这里 Person 的 mArray 也只是<code>单层深复制</code>，如果想要实现<code>完全深复制</code>的话，我们可以用 NSKeyedArchiver 和 NSKeyedUnarchiver 来完成对 mArray 的<code>完全深复制</code>。</p>\n<h2 id=\"Block-和-Copy\"><a href=\"#Block-和-Copy\" class=\"headerlink\" title=\"Block 和 Copy\"></a>Block 和 Copy</h2><p>简单说一下，在 Objective-C 中，Block 的 copy 是一种特殊的操作。因为 Block 是一种结构体，它无法实现 NSCopying 或 NSMutableCopying 协议，但是它却可以调用 copy 方法。这是由 Block 的结构体决定的：</p>\n<p><img src=\"http://www.devtalking.com/postImages/block-struct.jpg\"></p>\n<p>Block 里面的 descriptor 有 copy 的函数指针，当对 Block 执行 copy 操作最后都会通过该函数指针进行真正的操作。这也是 Bloc看不需要实现 NSCopying 和 NSMutableCopying 就能调用 copy 方法的原因。</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html\">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html</a></li>\n<li><a href=\"https://www.zybuluo.com/MicroCai/note/50592\">https://www.zybuluo.com/MicroCai/note/50592</a></li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl28gjxdu00016enq7fcwdya8","category_id":"cl28gjxdz00046enq6pnq3a39","_id":"cl28gjxe6000f6enqhsh09wct"},{"post_id":"cl28gjxe5000d6enqeoa752x1","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxea000k6enq94r3fwlg"},{"post_id":"cl28gjxdy00036enq2n1cb83r","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxec000p6enqak8l0fer"},{"post_id":"cl28gjxe6000e6enq0kwu1ztj","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxed000s6enqgxk10kht"},{"post_id":"cl28gjxe9000i6enqe5nefawp","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxef000x6enqh7t4bxg7"},{"post_id":"cl28gjxe100076enq224yhw95","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxeg00106enqax7oh176"},{"post_id":"cl28gjxea000j6enq0jabcl5o","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxeh00146enq3ehn7woo"},{"post_id":"cl28gjxeb000o6enq43nv1yrw","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxei00176enqfigo6kl3"},{"post_id":"cl28gjxe200086enqcvs2c3ar","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxej001b6enqcdhq2jgs"},{"post_id":"cl28gjxed000r6enq3962cbb2","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxek001e6enqdfy99cj3"},{"post_id":"cl28gjxee000w6enqbz4ihccu","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxel001h6enqgvjr4dur"},{"post_id":"cl28gjxe300096enq201807tr","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxem001l6enqgwsv109g"},{"post_id":"cl28gjxeg000z6enqhauj1v5g","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxen001n6enq0nh6h8ce"},{"post_id":"cl28gjxeh00136enq71h9exp0","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxen001q6enq4qv80lq5"},{"post_id":"cl28gjxei00166enqe4073dk2","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxeo001s6enq1k5i8cmv"},{"post_id":"cl28gjxej001a6enqbp9h9x5b","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxeo001v6enq2hnr7suz"},{"post_id":"cl28gjxek001d6enqatufhq4l","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxeo001x6enqdh2nd9j2"},{"post_id":"cl28gjxel001g6enq6voxguwo","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxep00206enq3tvn6qjk"},{"post_id":"cl28gjxem001k6enq9ejwcp45","category_id":"cl28gjxe4000a6enqdcpdhii2","_id":"cl28gjxep00226enq3a0fdnzh"}],"PostTag":[{"post_id":"cl28gjxdu00016enq7fcwdya8","tag_id":"cl28gjxe000056enq0b5sb0xb","_id":"cl28gjxe5000c6enq42z9ciuv"},{"post_id":"cl28gjxe9000i6enqe5nefawp","tag_id":"cl28gjxe4000b6enq4imtejed","_id":"cl28gjxeb000n6enqgagy3qwi"},{"post_id":"cl28gjxe9000i6enqe5nefawp","tag_id":"cl28gjxe7000h6enqajbx2gai","_id":"cl28gjxed000q6enq6mc17isj"},{"post_id":"cl28gjxdy00036enq2n1cb83r","tag_id":"cl28gjxe4000b6enq4imtejed","_id":"cl28gjxee000u6enq9ul99myu"},{"post_id":"cl28gjxdy00036enq2n1cb83r","tag_id":"cl28gjxe7000h6enqajbx2gai","_id":"cl28gjxef000y6enq9lpo179p"},{"post_id":"cl28gjxea000j6enq0jabcl5o","tag_id":"cl28gjxe4000b6enq4imtejed","_id":"cl28gjxeg00116enq8so76rx3"},{"post_id":"cl28gjxea000j6enq0jabcl5o","tag_id":"cl28gjxe7000h6enqajbx2gai","_id":"cl28gjxei00156enq5d0v09fb"},{"post_id":"cl28gjxeb000o6enq43nv1yrw","tag_id":"cl28gjxe4000b6enq4imtejed","_id":"cl28gjxej00186enqeac16aua"},{"post_id":"cl28gjxeb000o6enq43nv1yrw","tag_id":"cl28gjxe7000h6enqajbx2gai","_id":"cl28gjxek001c6enq63g01vkg"},{"post_id":"cl28gjxe100076enq224yhw95","tag_id":"cl28gjxeb000m6enq9ppcfves","_id":"cl28gjxel001f6enqg25d4d34"},{"post_id":"cl28gjxed000r6enq3962cbb2","tag_id":"cl28gjxe4000b6enq4imtejed","_id":"cl28gjxem001j6enqcf7lg8r3"},{"post_id":"cl28gjxe200086enqcvs2c3ar","tag_id":"cl28gjxe4000b6enq4imtejed","_id":"cl28gjxen001m6enq7ibh2vfk"},{"post_id":"cl28gjxeg000z6enqhauj1v5g","tag_id":"cl28gjxe4000b6enq4imtejed","_id":"cl28gjxen001p6enq7smw55yq"},{"post_id":"cl28gjxe300096enq201807tr","tag_id":"cl28gjxe4000b6enq4imtejed","_id":"cl28gjxeo001r6enq8eky668k"},{"post_id":"cl28gjxe5000d6enqeoa752x1","tag_id":"cl28gjxe4000b6enq4imtejed","_id":"cl28gjxeo001u6enqece77cuh"},{"post_id":"cl28gjxe5000d6enqeoa752x1","tag_id":"cl28gjxej00196enq386dg7ra","_id":"cl28gjxeo001w6enq3a7p8noz"},{"post_id":"cl28gjxe6000e6enq0kwu1ztj","tag_id":"cl28gjxel001i6enq1lukaroa","_id":"cl28gjxep001z6enqdq3q0zj8"},{"post_id":"cl28gjxee000w6enqbz4ihccu","tag_id":"cl28gjxel001i6enq1lukaroa","_id":"cl28gjxep00216enq0sgn6jxo"},{"post_id":"cl28gjxeh00136enq71h9exp0","tag_id":"cl28gjxeo001t6enq5254442x","_id":"cl28gjxeq00246enq6vgehkze"},{"post_id":"cl28gjxeh00136enq71h9exp0","tag_id":"cl28gjxep001y6enqgv2ohlzq","_id":"cl28gjxeq00256enqd4ss78gs"},{"post_id":"cl28gjxei00166enqe4073dk2","tag_id":"cl28gjxe4000b6enq4imtejed","_id":"cl28gjxeq00286enqdkk5dir0"},{"post_id":"cl28gjxei00166enqe4073dk2","tag_id":"cl28gjxep00236enq6pji16k6","_id":"cl28gjxeq00296enqayt87c7d"},{"post_id":"cl28gjxei00166enqe4073dk2","tag_id":"cl28gjxeq00266enq7b6y9h2m","_id":"cl28gjxer002b6enq9hz4cn5k"},{"post_id":"cl28gjxej001a6enqbp9h9x5b","tag_id":"cl28gjxe4000b6enq4imtejed","_id":"cl28gjxer002c6enqemuyb2g3"},{"post_id":"cl28gjxej001a6enqbp9h9x5b","tag_id":"cl28gjxeq00276enq1ze80rei","_id":"cl28gjxer002e6enqcnksel5e"},{"post_id":"cl28gjxek001d6enqatufhq4l","tag_id":"cl28gjxe4000b6enq4imtejed","_id":"cl28gjxer002f6enq3huv4a7o"},{"post_id":"cl28gjxek001d6enqatufhq4l","tag_id":"cl28gjxeo001t6enq5254442x","_id":"cl28gjxes002h6enqc3r79wof"},{"post_id":"cl28gjxel001g6enq6voxguwo","tag_id":"cl28gjxe4000b6enq4imtejed","_id":"cl28gjxes002j6enq8d6y136t"},{"post_id":"cl28gjxel001g6enq6voxguwo","tag_id":"cl28gjxep00236enq6pji16k6","_id":"cl28gjxes002k6enqclh49siz"},{"post_id":"cl28gjxel001g6enq6voxguwo","tag_id":"cl28gjxeq00276enq1ze80rei","_id":"cl28gjxet002l6enq2f7cdvxz"},{"post_id":"cl28gjxem001k6enq9ejwcp45","tag_id":"cl28gjxe4000b6enq4imtejed","_id":"cl28gjxet002m6enq7t6z7wsr"},{"post_id":"cl28gjxem001k6enq9ejwcp45","tag_id":"cl28gjxep00236enq6pji16k6","_id":"cl28gjxet002n6enq0jggf5xu"}],"Tag":[{"name":"Raspberry PI","_id":"cl28gjxe000056enq0b5sb0xb"},{"name":"iOS","_id":"cl28gjxe4000b6enq4imtejed"},{"name":"Swift","_id":"cl28gjxe7000h6enqajbx2gai"},{"name":"其他","_id":"cl28gjxeb000m6enq9ppcfves"},{"name":"RAC","_id":"cl28gjxej00196enq386dg7ra"},{"name":"tip","_id":"cl28gjxel001i6enq1lukaroa"},{"name":"RN","_id":"cl28gjxeo001t6enq5254442x"},{"name":"redux","_id":"cl28gjxep001y6enqgv2ohlzq"},{"name":"Objective-C","_id":"cl28gjxep00236enq6pji16k6"},{"name":"Block","_id":"cl28gjxeq00266enq7b6y9h2m"},{"name":"GCD","_id":"cl28gjxeq00276enq1ze80rei"}]}}