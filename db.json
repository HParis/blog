{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","path":"js/third-party/analytics/matomo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_drafts/常用工具.md","hash":"0c0cfb37dbc4385b24c775edb9f86c67ba0c71ee","modified":1680434108224},{"_id":"source/_drafts/字典的存储结构.md","hash":"8fba3ba386cff56788a75b67f9f5ced1323e351a","modified":1673070122483},{"_id":"source/_drafts/浅谈-iOS-架构.md","hash":"9a497784a752cb34b06e907c3e08ef38a7ab7930","modified":1673070122483},{"_id":"source/_drafts/Raspberry-PI-基本使用.md","hash":"9a724c082c2d689866e4edfc8cb8bcb57ed74ae2","modified":1673070122483},{"_id":"source/about/index.md","hash":"60b2ae4c83567f582e9ee3c726e568fa7c59b79a","modified":1675648799456},{"_id":"source/tags/index.md","hash":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1673070122485},{"_id":"source/_posts/Notification-的一些知识点.md","hash":"ae0ed8c010dd04722fec953e7dcdd25c79b0a2b0","modified":1673070122483},{"_id":"source/categories/index.md","hash":"55bee2cb88da438a2e8b1f29b1d7e954c07a9e60","modified":1673070122485},{"_id":"source/_posts/Swift-High-Performance-Tip 2：final和private(fileprivate).md","hash":"76438d026841197040f2529775a332658a462785","modified":1673070122484},{"_id":"source/_posts/Shell-Tip.md","hash":"3b4a197ef122b57dfd5ea26734c6a30e11e0eb0e","modified":1673070122483},{"_id":"source/_posts/Vim-Tip.md","hash":"06835dc2cc01099c72381b80582b6d34b8e1fa06","modified":1673070122484},{"_id":"source/_posts/Swift-High-Performance-Tip 3：@objc-和-dynamic.md","hash":"a13cdf33dfa540f713ec3bc07583d3adc5b23105","modified":1673070122484},{"_id":"source/_posts/Swift-High-Performance-Tip 1：Array和ContiguousArray.md","hash":"3a38b69ca8d7248ece6d53aab2be5bd9421d7387","modified":1673070122483},{"_id":"source/_posts/RAC和内存管理.md","hash":"60dba95639f958176e821c321b806f9c2f6e9691","modified":1673070122483},{"_id":"source/_posts/include和import的区别.md","hash":"86e62dda34dd64f28d3083138387932ce8ae627f","modified":1673070122484},{"_id":"source/_posts/redux-之页面跳转.md","hash":"7d4f19664ac6b8ec3ee786f7ce47cd7b9c3bbbab","modified":1673070122484},{"_id":"source/_posts/UIScrollView-的偏移问题.md","hash":"c5a18167e1e03dd9833e3538eab561fa7fd0d3d4","modified":1673070122484},{"_id":"source/_posts/self-在-block-中的引用计数变化.md","hash":"290856dd224f551942c92c62e33a0a2505215ba4","modified":1673070122484},{"_id":"source/_posts/初步了解GCD.md","hash":"2330b526c01b138b975b7c411196c624d0d01e9b","modified":1673070122484},{"_id":"source/_posts/如何在-iOS-上自定义-React-Native-Component.md","hash":"fa2ebdd3911b3bab49d225fbbdd7bae1b89916f2","modified":1673070122484},{"_id":"source/_posts/如何用-Objective-C-实现一个死锁.md","hash":"7f6a3ff3572aff1d00bb2d313eb4c669504befb3","modified":1673070122484},{"_id":"source/_posts/如何避免-App-被重签名.md","hash":"34283dfdfce5dbe831d61f9a303c059e1caeb29c","modified":1675672796060},{"_id":"source/_posts/说说-Objective-C-中的-Copy-操作.md","hash":"bd63fe7c3c94d66608500074ebd6bf8110fb30a5","modified":1673070122485},{"_id":"source/_posts/线程优先级反转和自旋锁.md","hash":"af3f07ba93b0f943c4df396f4fea980f4ae920c7","modified":1675567361539},{"_id":"themes/next/.gitignore","hash":"417520c4dbbeab9c7e3ab10d944da0886366a0ee","modified":1673071756869},{"_id":"themes/next/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1673071756867},{"_id":"themes/next/.gitattributes","hash":"ec43734985e1cafd53d88ded3020103f7416123c","modified":1673071756867},{"_id":"themes/next/_config.yml","hash":"3205799fc6f50b2093e02bae9b70aa96ba0d2901","modified":1675574210098},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1673071756867},{"_id":"themes/next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1673071756869},{"_id":"themes/next/package.json","hash":"3b8084a2e1cb83ca6bbb1066599ead017c4202f3","modified":1675574210099},{"_id":"themes/next/.stylelintrc","hash":"dedb8dd4d454cb1bb6aba594ef2cbd05ec2427d8","modified":1673071756869},{"_id":"themes/next/README.md","hash":"36c4b25587ca494102323dab5a38de5490451a64","modified":1673071756869},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1673071756869},{"_id":"themes/next/.githooks/install.js","hash":"4d77dbddf2eac1f3fc78f151d12ed22208ed655b","modified":1673071756867},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1673071756878},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"21cbff565a0445d3a880fff1ee417e309740a9ab","modified":1673071756867},{"_id":"themes/next/.githooks/pre-commit","hash":"f473eac1aaaa96c947d67988bbed140bbab1a821","modified":1673071756867},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"330656d93b6c03df9fb1f2f0e3534c971969473b","modified":1673071756867},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"fa76760856429b6421abc54e63b2d3c815372900","modified":1673071756868},{"_id":"themes/next/_vendors.yml","hash":"48ae2854826d6ad46cca5a5fdfcc13f09870c8b2","modified":1675574210098},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1673071756868},{"_id":"themes/next/.github/label-commenter-config.yml","hash":"1097fc47beeacfc1edb0248c27b17bf64bde3565","modified":1673071756868},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1673071756870},{"_id":"themes/next/languages/ar.yml","hash":"46026e98fe279a9db5d68bf91afa5d8e41f9ccfb","modified":1673071756870},{"_id":"themes/next/.github/config.yml","hash":"7984e665e9de481a0e0e51fca5668337713f810b","modified":1673071756868},{"_id":"themes/next/languages/bn.yml","hash":"74133a827c104d1d84509177f283947fe9327a80","modified":1673071756871},{"_id":"themes/next/languages/de.yml","hash":"c4fc18c338309271d1afe737e6c404a6fa313bbc","modified":1673071756871},{"_id":"themes/next/.github/release.yml","hash":"112310b81f959747f8eaafc2ca2150e1dcf916d8","modified":1673071756868},{"_id":"themes/next/languages/es.yml","hash":"8b6d4a8a056df4362d20ae1f6ac7a590dd7246e5","modified":1673071756871},{"_id":"themes/next/.github/labeler.yml","hash":"5c4bc2bd561e6d9b33ee118cc12218c5de46f72d","modified":1673071756868},{"_id":"themes/next/languages/en.yml","hash":"4bbdb4284afe495437cf7817b97b45f60e12d1e4","modified":1673071756871},{"_id":"themes/next/languages/fr.yml","hash":"2436942610e38b73b175cb0f8ed1f8f23d42a7ce","modified":1673071756871},{"_id":"themes/next/languages/it.yml","hash":"4d6efcdaea89dfe751b7707d91858bf33d3538b7","modified":1673071756871},{"_id":"themes/next/languages/ja.yml","hash":"a0906702d3c87d0e1661e300ad0bdf7e679a3d91","modified":1673071756871},{"_id":"themes/next/languages/default.yml","hash":"4bbdb4284afe495437cf7817b97b45f60e12d1e4","modified":1673071756871},{"_id":"themes/next/languages/pt.yml","hash":"fa7c43ec872aee2739b25dd7260e0764ea9e26fd","modified":1673071756872},{"_id":"themes/next/languages/id.yml","hash":"c4bad93b23c7eefa730fd7fec5b05ace3ce9ca4d","modified":1673071756871},{"_id":"themes/next/languages/nl.yml","hash":"8a4da307b4a19e3c96b90a07a2da8dc5d50e5d9e","modified":1673071756871},{"_id":"themes/next/languages/ko.yml","hash":"25ee0d5b9a0464a91af7d2efb33293c09ad5abdf","modified":1673071756871},{"_id":"themes/next/languages/pt-BR.yml","hash":"10d80915c41328f31a4f2d8ac736bba020f373d8","modified":1673071756872},{"_id":"themes/next/languages/si.yml","hash":"034c5a0df49144e8f16ae2300dba9fde58b9329e","modified":1673071756872},{"_id":"themes/next/languages/ru.yml","hash":"16b96783ba363255b4c8156c3e1efebdb37676f8","modified":1673071756872},{"_id":"themes/next/languages/th.yml","hash":"4fac74a39d3906c4a727476be4750530a505933a","modified":1673071756872},{"_id":"themes/next/languages/uk.yml","hash":"fbaed3039ed8605b81422003a4ecb2a6514e339d","modified":1673071756872},{"_id":"themes/next/languages/tr.yml","hash":"890f87f6a33ad8452b771607d4c3ff14810b35fa","modified":1673071756872},{"_id":"themes/next/languages/tk.yml","hash":"37d9af426b040004841273d163059cd49cd67d65","modified":1673071756872},{"_id":"themes/next/languages/vi.yml","hash":"a6ba04c743a5b494ac56612ce6b858d9ae3ae1bd","modified":1673071756872},{"_id":"themes/next/languages/zh-HK.yml","hash":"8ab7219563dab13885840207a86055000d173465","modified":1673071756872},{"_id":"themes/next/languages/fa.yml","hash":"1e256c8df039ddeba66526c5eb2d6c79177a7fc6","modified":1673071756871},{"_id":"themes/next/languages/zh-TW.yml","hash":"9fdce9d316e205fc132b2181254ef3b04007a97d","modified":1673071756872},{"_id":"themes/next/languages/zh-CN.yml","hash":"5cebea74f3198a4a20cacf23069c3b91e4f03d85","modified":1673071756872},{"_id":"themes/next/layout/_layout.njk","hash":"fc0a45112f2dcfc2642404e8934ea32a793c3bd7","modified":1673071756873},{"_id":"themes/next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1673071756877},{"_id":"themes/next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1673071756877},{"_id":"themes/next/layout/page.njk","hash":"b0660b2af0ac7d3fda14ca4d9f2c9e79ef06c6f9","modified":1673071756878},{"_id":"themes/next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1673071756877},{"_id":"themes/next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1673071756878},{"_id":"themes/next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1673071756870},{"_id":"themes/next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1673071756870},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1673071756870},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.yml","hash":"3f19cbf0c2b2fee6bf3788870b842c9ccc1425ca","modified":1673071756867},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.yml","hash":"fbc3062cd4591c8329fab9db72803746f0d11920","modified":1673071756868},{"_id":"themes/next/.github/ISSUE_TEMPLATE/config.yml","hash":"c40ae7903b6cc99f94c9d45ac7ba8c2850bb1309","modified":1673071756868},{"_id":"themes/next/layout/post.njk","hash":"0bfce9f133f501a9a4837257e3b862b3bbca15be","modified":1673071756878},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.yml","hash":"10eca518b91a19984f6a5a912d41222042f61d63","modified":1673071756868},{"_id":"themes/next/.github/workflows/codeql.yml","hash":"8da13d7c325addb6b7c1d9ac3683dafd43e3709a","modified":1673071756868},{"_id":"themes/next/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1673071756891},{"_id":"themes/next/.github/workflows/label-commenter.yml","hash":"434cc0674290958b1e9bbc46c3486f073c0722db","modified":1673071756868},{"_id":"themes/next/.github/workflows/linter.yml","hash":"2ab8720e4b9534e48ba324b73b0b58cb54df689f","modified":1673071756868},{"_id":"themes/next/.github/workflows/lock.yml","hash":"f1bf7f86c11419b63323bd21e388e6bdaf24d27d","modified":1673071756869},{"_id":"themes/next/.github/workflows/labeler.yml","hash":"e9d51e93f239a2d4b69722c69db3463b4baf0f4c","modified":1673071756868},{"_id":"themes/next/.github/workflows/pr-reminder.yml","hash":"3ab3e8d9dc0e1d9bd54f44fba476792fb1ee190d","modified":1673071756869},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1673071756870},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1673071756873},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1673071756870},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"547c62ab14d9e05d2d9116db9048a677fbe1fb6d","modified":1673071756873},{"_id":"themes/next/layout/_macro/post.njk","hash":"7e8268fd5cbd552322b276f52459fd187c2453d2","modified":1673071756873},{"_id":"themes/next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1673071756875},{"_id":"themes/next/.github/workflows/tester.yml","hash":"80a20c3a7522249f051a48239db41d1317e9b552","modified":1673071756869},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1673071756875},{"_id":"themes/next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1673071756873},{"_id":"themes/next/layout/_partials/footer.njk","hash":"c40760b559c516677c8b11a00ba50c011f2079fd","modified":1673071756873},{"_id":"themes/next/docs/zh-CN/README.md","hash":"9bbdbb0656505acceef9b9895a576164175fe888","modified":1673071756870},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"bc719473ed5948ab6859449d60b8d36cfc1542b4","modified":1673071756874},{"_id":"themes/next/layout/_third-party/index.njk","hash":"aa37f8e98208177b63e3328d6e53b022c6edf3b2","modified":1673071756876},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"e7f988ecddb2159313699a00827a45eca5622bd4","modified":1673071756875},{"_id":"themes/next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1673071756874},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1673071756876},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1673071756877},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1673071756877},{"_id":"themes/next/docs/ru/README.md","hash":"ac3c4a7616ea80f0d32d68d6e53233952ba756dc","modified":1673071756870},{"_id":"themes/next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1673071756879},{"_id":"themes/next/scripts/filters/minify.js","hash":"ce8477e7fb226525bae5872cd68a1c2c23ad50c8","modified":1673071756879},{"_id":"themes/next/scripts/filters/post.js","hash":"fdc8a0af90035e89c3fcb754a0eb189b8951a2bc","modified":1673071756879},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1673071756879},{"_id":"themes/next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1673071756879},{"_id":"themes/next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1673071756880},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"226fccbe9c93265e65a300e3cb4bf6f9065cfdd7","modified":1673071756880},{"_id":"themes/next/scripts/events/index.js","hash":"bd9ea82376cd87df611ea3ae077875c7c595a3df","modified":1673071756878},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"fd24abfaba4d91923ddb6aecf0268b216678c8bd","modified":1673071756880},{"_id":"themes/next/scripts/helpers/engine.js","hash":"d292b78485e8e8055712b0ed6de7cf559c5fbdcd","modified":1673071756879},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1673071756880},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1673071756880},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1673071756880},{"_id":"themes/next/scripts/helpers/next-paginator.js","hash":"e86c764b546e4fbb87970cabc4135a56f9ef9fe1","modified":1673071756880},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"9ed799c329abf830f623689d7e136991256a24ca","modified":1673071756880},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1673071756880},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1673071756880},{"_id":"themes/next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1673071756881},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1673071756880},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1673071756880},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1673071756880},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1673071756881},{"_id":"themes/next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1673071756881},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1673071756880},{"_id":"themes/next/source/css/_colors.styl","hash":"3c6798c10cc220d83481cb3f3782e78558cee789","modified":1673071756881},{"_id":"themes/next/source/css/main.styl","hash":"921a58577f411cf4eb5cfd66db0a241f8f88578c","modified":1673071756888},{"_id":"themes/next/source/css/_mixins.styl","hash":"04a07a4dbeb00683d783eff26c44492c35b924e0","modified":1673071756886},{"_id":"themes/next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1673071756888},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1673071756888},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1673071756888},{"_id":"themes/next/source/css/noscript.styl","hash":"dadc81256afb127b77eac6763d5ee0ec9c77f0a3","modified":1673071756888},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1673071756888},{"_id":"themes/next/source/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1673071756888},{"_id":"themes/next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1673071756888},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1673071756888},{"_id":"themes/next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1673071756888},{"_id":"themes/next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1673071756888},{"_id":"themes/next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1673071756888},{"_id":"themes/next/source/js/motion.js","hash":"770d63c26f22705311028a36b52e999cc8a2da82","modified":1673071756889},{"_id":"themes/next/source/js/pjax.js","hash":"90fb7f346f777434ea68ab4e4be1d7b999ad63ac","modified":1673071756889},{"_id":"themes/next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1673071756889},{"_id":"themes/next/source/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1673071756889},{"_id":"themes/next/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1673071756891},{"_id":"themes/next/source/js/utils.js","hash":"af59257e46d25dda62967c35a65e2efcbd90d3bc","modified":1673071756891},{"_id":"themes/next/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1673071756892},{"_id":"themes/next/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1673071756892},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1673071756892},{"_id":"themes/next/test/tags/group-pictures.js","hash":"5c68ae0184f9da6e00ba199f2554d503d8e6da71","modified":1673071756892},{"_id":"themes/next/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1673071756892},{"_id":"themes/next/test/tags/link-grid.js","hash":"43d298fafb7c45a874b766d443843bd26346e689","modified":1673071756892},{"_id":"themes/next/test/tags/note.js","hash":"3dcfcd65bf9f326972ea7571fdb1444200f5d07e","modified":1673071756892},{"_id":"themes/next/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1673071756892},{"_id":"themes/next/test/tags/video.js","hash":"b796fc4dceb20a30e730c322bb5474c0162464cc","modified":1673071756892},{"_id":"themes/next/test/helpers/font.js","hash":"342ef3c6fd2dcca2a8802a516ed6d7f389fd2ca2","modified":1673071756891},{"_id":"themes/next/test/tags/pdf.js","hash":"fd6ea5123560a90f7e7c1eface23dbe1455db25f","modified":1673071756892},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1673071756891},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"5388b157bba4a40b9312f4a45c6678974ccf0837","modified":1673071756873},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1673071756873},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"dd9c4c03e99dfde0dfb8edefcb2c933f2f560efc","modified":1673071756873},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"8da52a144060db1a0a088ccb2e6cc8376d1fce70","modified":1673071756873},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1673071756873},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1673071756874},{"_id":"themes/next/test/helpers/next-url.js","hash":"a91d880cb75e0a8e65a7be4c7362b2c8ebfb7c4f","modified":1673071756891},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1673071756874},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1673071756874},{"_id":"themes/next/test/validate/index.js","hash":"5a95ccc8598667535bd022e988055c0e019f3670","modified":1673071756892},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1673071756874},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1673071756874},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1673071756874},{"_id":"themes/next/test/tags/mermaid.js","hash":"ab77be5f3c6d9a57c7b9dda6decf1906a736fef9","modified":1673071756892},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1673071756874},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1673071756874},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"e0986db00a0201dd3c60570f964829c84ba5bc68","modified":1673071756874},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"e8b8a7c41e9ec612d0c0c73419529d55d1c16256","modified":1673071756874},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1673071756874},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"c1e33b4889f75acc490af3c8bde0ec56c518ff41","modified":1673071756874},{"_id":"themes/next/layout/_partials/post/post-share.njk","hash":"3f28cc4411c0ffc0e41b7970d5ab329c7e46f497","modified":1673071756874},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1673071756875},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1673071756875},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1673071756875},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1673071756875},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":1673071756875},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"f900306497b133e8b098bd9f4b96b93d1d96c185","modified":1673071756875},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"70342218473a6e6aa9148de06bfffe121afb8548","modified":1673071756875},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1673071756875},{"_id":"themes/next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"9dc00fcb0a05899f048eace9f9160b78956655d5","modified":1673071756876},{"_id":"themes/next/layout/_third-party/analytics/matomo.njk","hash":"4e89648a8ec8194c5823064cbca39c938a799006","modified":1673071756876},{"_id":"themes/next/layout/_third-party/analytics/plausible.njk","hash":"ef9f2bb7110507f1c4336800af9157d5fa9765bd","modified":1673071756876},{"_id":"themes/next/layout/_third-party/analytics/umami.njk","hash":"181f69b6718c7a8642a88652260cc0a26084a3ee","modified":1673071756876},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1673071756875},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1673071756876},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1673071756876},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1673071756876},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1673071756876},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1673071756876},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1673071756876},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1673071756876},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1673071756876},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1673071756876},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1673071756877},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1673071756877},{"_id":"themes/next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1673071756876},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"1ebf658690468ea197bdd0416eb7cfa4bd0b083a","modified":1673071756877},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1673071756877},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1673071756877},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1673071756877},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1673071756877},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1673071756877},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1673071756877},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1673071756877},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1673071756877},{"_id":"themes/next/scripts/events/lib/config.js","hash":"9ec51eb61f7fee612ffc5252f489003a0fa301fc","modified":1673071756878},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1673071756878},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"64e4024376b51fe81be7ad80235abdf0a83853bd","modified":1673071756878},{"_id":"themes/next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1673071756878},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"ec996d0673f766167c86df0966e9da1ae036e103","modified":1673071756878},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1673071756878},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1673071756887},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a1418c9dc8c0f1a0ad4ded0f4627c45bf0db1a10","modified":1673071756887},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"5798cfc8f63665031dd3e01debed051628cec319","modified":1673071756878},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1673071756879},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1673071756879},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1673071756887},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"48f4f277946a168d0db1ea02804e85c22ca2c7db","modified":1673071756887},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1673071756879},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1673071756879},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1673071756879},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"a600a98e7436edeb31e291abca359885567df3c9","modified":1673071756879},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1673071756879},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1673071756879},{"_id":"themes/next/source/css/_variables/base.styl","hash":"9845209c54174a42cbff5b5efd5e2e2fb7e60589","modified":1673071756888},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1673071756890},{"_id":"themes/next/source/js/schemes/muse.js","hash":"0c490e9ba82efbb8bdf8465e6b537fafd51e1ed7","modified":1673071756889},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1673071756890},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1673071756890},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"7664491542046df9a3887cf40a06e00c0b4086a9","modified":1673071756881},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"2298e521253b3bf376a2412271bc2a7d305051f3","modified":1673071756881},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1673071756882},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":1673071756883},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"d0a7c99095f490b0d2ed6b1be43d435960798cec","modified":1673071756884},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1673071756883},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1673071756884},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1673071756884},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1673071756885},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1673071756885},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"f4228c759db4a650c8d38745c2edd1dc83c45687","modified":1673071756885},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"782ee1fc5e669d3ddbfeb82b73ad7fe561f1a4fb","modified":1673071756886},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"77b85d4de5ab747e04008ab31200311b29748740","modified":1673071756886},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"9dfe853c901bdc52fc950bacdf15484dbb9bf140","modified":1673071756886},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"fa4fd8f76464e214fb7318f325b13c2b62f4b478","modified":1673071756886},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1673071756885},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"485d23ccb42c0d0c8ead7ea8930dd3e06d79a285","modified":1673071756886},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"fb550935d374e0bdf1097fce187337dc05cad3e1","modified":1673071756886},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1673071756886},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"d856127cd7e0a28a88edf0b2eb860ede9c3fdb60","modified":1673071756886},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"b7f48be3c43bfa393d62142544a5487a67871713","modified":1673071756886},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"7fecfb76420f786d6bf60218a81705bb48fb1d18","modified":1673071756886},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"cef9c5f9524fd01b59b0a89e51904b42cbdedc8c","modified":1673071756887},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1673071756887},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1673071756887},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"ac2dc0ce9c775a83ef7132ae957b54539366ac9c","modified":1673071756887},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1673071756887},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"91dbf3ca5c3a613d4e30618c120da535bf2d0336","modified":1673071756887},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1673071756887},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1673071756887},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"4266eed6f75625bb30ef0280dc5d4093e7c3beb1","modified":1675574210100},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1673071756889},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1673071756889},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1673071756889},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1673071756889},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1673071756890},{"_id":"themes/next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1673071756889},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1673071756890},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1673071756890},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1673071756889},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1673071756890},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1673071756890},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1673071756890},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1673071756890},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1673071756890},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1673071756890},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1673071756891},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1673071756890},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1673071756891},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1673071756891},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1673071756891},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1673071756891},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1673071756891},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1673071756881},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1673071756881},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1673071756881},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"098d4bd034e986fcf7e443eac4fc2193935461b7","modified":1673071756882},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"d757768a58743601d0d84158ba955eb15d4c3c01","modified":1673071756882},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1673071756881},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1673071756881},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1673071756882},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1ecfd64507954810b07a9d21fb5305b5378feda0","modified":1673071756882},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"010c901e4ef49a606f8a350efbf09044e76d2ff3","modified":1673071756882},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1673071756882},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"11497388f124bfbb4001495a67d3629a9f618405","modified":1673071756882},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1673071756882},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"40c9839d3288c3b7de0bf38ac2e18f6c8eba6227","modified":1673071756882},{"_id":"themes/next/source/css/_common/components/third-party/disqusjs.styl","hash":"877a537d5b95beb048142e4fdee6f17e6ef9c7bb","modified":1673071756882},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"04cf4a69537fc14d3b8904f965d283356853847f","modified":1673071756882},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8f094c4ac17e2ab45569b12d157747f9c7333c12","modified":1673071756882},{"_id":"themes/next/source/css/_common/components/third-party/gitter.styl","hash":"35104dc6883a61c31e0e368dac8ac2f697be62fe","modified":1673071756883},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"77550e0d3e029b7458e35d8c5ae1fbd612c9673b","modified":1673071756883},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1673071756883},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1673071756883},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"e72799ce3f9b79753e365b2f8c8ef6c310668d4a","modified":1673071756883},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1673071756883},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1673071756883},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"6e0d0796ef7fbbb62ffdfb448753a850de82c74f","modified":1673071756883},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"b750af2fb833c10c4313b5a4258237161a7833d7","modified":1673071756883},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"a851e9d5aefcd027c95eeb323860b6da70f202d1","modified":1673071756883},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1673071756883},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"0c79462439b1361034a03590cd69a8abb3a678a6","modified":1673071756883},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"da5e88f8debd5ac8d7af5c6ba6240df66104955f","modified":1673071756884},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1673071756884},{"_id":"themes/next/source/css/_common/outline/sidebar/related-posts.styl","hash":"b05908f04ef95f2d91e6eba89b12411c378d050f","modified":1673071756884},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"c6a27beb3f741211a14576026f3b4cfc44cc6407","modified":1673071756884},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1673071756884},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1673071756884},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"9a7c71560fbdc936ad4e736fe15063ea3e8a644b","modified":1673071756884},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"f3506fd0c0303ea365de1c7774d98a1a3f3027cf","modified":1673071756884},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"021a37cf178440cc341940a299d3bca359996c6b","modified":1673071756884},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1673071756884},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"9056be572ec1cfa429abb22be4b45a662d5b0fb1","modified":1673071756885},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1673071756885},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1673071756885},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":1673071756885},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1673071756885},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1673071756885},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"98d4c20aff0f0fcfe1824017fb06ab21ef0d218e","modified":1673071756885},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1673071756885},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"670fc109b56a010b166b86b616823a1aae97a738","modified":1673071756885},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"7a39bcce7274284e87388743db62afc847fe6897","modified":1673071756886},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1673071756886},{"_id":"public/about/index.html","hash":"37dafd533eab2f0cc1dd4f0d5d278b0688af54e0","modified":1677139945194},{"_id":"public/tags/index.html","hash":"4655acd72dc0474339372d31a1b277e64c382095","modified":1677139945194},{"_id":"public/categories/index.html","hash":"88fcf0b3a8412fc9caf9d6ea33891c5f34ba9d04","modified":1677139945194},{"_id":"public/2023/02/06/如何避免-App-被重签名/index.html","hash":"3b96c93d71ed55c5b1e070c2702ae8dbcd210be8","modified":1677139945194},{"_id":"public/2017/09/05/Swift-High-Performance-Tip 2：final和private(fileprivate)/index.html","hash":"02243bf2cc668d390a4a7415128b025cab4234d0","modified":1677139945194},{"_id":"public/categories/技术/index.html","hash":"dd8363a6ec420c0d1e8aa2eec6775024c5e4140f","modified":1677139945194},{"_id":"public/categories/技术/page/2/index.html","hash":"8cc16cd3fbea44488af6dff6bfcc84580224151a","modified":1677139945194},{"_id":"public/archives/index.html","hash":"f6ead285235ec9fab89088d0253d3c2821280e40","modified":1677139945194},{"_id":"public/archives/2017/index.html","hash":"077018c9d5e228f50667a43d94f3c8ae326a7321","modified":1677139945194},{"_id":"public/archives/page/2/index.html","hash":"8f560d41fc7d2fca05b5199bd3f2c8b495df854a","modified":1677139945194},{"_id":"public/archives/2017/09/index.html","hash":"417f5616d4f0e2a080755bcef4274c372a948a28","modified":1677139945194},{"_id":"public/archives/2018/index.html","hash":"67880c0292c31e8895f87d08a705cc2da523bac9","modified":1677139945194},{"_id":"public/archives/2018/02/index.html","hash":"9b476f092270a56024d73359ada78adb8f1c802e","modified":1677139945194},{"_id":"public/archives/2018/03/index.html","hash":"0f33997f1bb11c6c5a153b0143ba7edbf5b40f12","modified":1677139945194},{"_id":"public/archives/2018/04/index.html","hash":"594f7acce016b4ca50bfd2fec90f6b92ac9ab90d","modified":1677139945194},{"_id":"public/archives/2018/05/index.html","hash":"a20b4ac80ceaa8ab828eb1f7f634840bef0c568a","modified":1677139945194},{"_id":"public/archives/2018/11/index.html","hash":"9dd72aff2a3281f9b6a070d164f22b856b551a75","modified":1677139945194},{"_id":"public/archives/2019/index.html","hash":"c1285143dacce669f8587d7273f4936ed561e2af","modified":1677139945194},{"_id":"public/archives/2019/09/index.html","hash":"906f7a8fcc2a73f08a04732725affccd1029f808","modified":1677139945194},{"_id":"public/archives/2023/index.html","hash":"36c0e25ef3b253a1f10440cc2c6281ecde1efc74","modified":1677139945194},{"_id":"public/archives/2023/01/index.html","hash":"8249734fb9f21cc8469652fe15f079b180c618df","modified":1677139945194},{"_id":"public/archives/2023/02/index.html","hash":"6dee3c6d4b3979e8896e3b51b952f59861fe440e","modified":1677139945194},{"_id":"public/tags/iOS/index.html","hash":"5193995475919f30f7723559acf313d8ea7d3ea3","modified":1677139945194},{"_id":"public/tags/iOS/page/2/index.html","hash":"883eb16fa2b01d86a3b0d8b9601a23a1f073c7f8","modified":1677139945194},{"_id":"public/tags/Swift/index.html","hash":"45689be0d91c69a4e43a9f8ef55b99bcf4749dba","modified":1677139945194},{"_id":"public/tags/RAC/index.html","hash":"fb4a74c55f7e57683b1a510a6ec62419e21faab0","modified":1677139945194},{"_id":"public/tags/tip/index.html","hash":"2c4b0df64da6bf92651bc600c47a8bc7ebc66e8a","modified":1677139945194},{"_id":"public/tags/RN/index.html","hash":"0d0e7a4137cf7a99b28331dc0e604e0b94777758","modified":1677139945194},{"_id":"public/tags/redux/index.html","hash":"58ab754fce45194c1292a2fff8aae3a31425480d","modified":1677139945194},{"_id":"public/tags/Objective-C/index.html","hash":"d6b930a132cff9dd4b15859bc798788dfe9470a5","modified":1677139945194},{"_id":"public/tags/Block/index.html","hash":"5e7ca8e1b97cbfe1530ec60d79832f96d8910bdf","modified":1677139945194},{"_id":"public/tags/GCD/index.html","hash":"b0ee7a46585cb026b9b198ad98477eea49ee0de0","modified":1677139945194},{"_id":"public/2023/01/07/线程优先级反转和自旋锁/index.html","hash":"8ca322ed410a710aafcf4a83b896688b0e786ce2","modified":1677139945194},{"_id":"public/2019/09/28/UIScrollView-的偏移问题/index.html","hash":"b9c7ca37cb121fedc52c251bd5f709427232936f","modified":1677139945194},{"_id":"public/2018/11/06/Notification-的一些知识点/index.html","hash":"58261fe18c27600b8940b9ead4117785d9a938e8","modified":1677139945194},{"_id":"public/2018/05/25/Swift-High-Performance-Tip 3：@objc-和-dynamic/index.html","hash":"1d6f78b27901e6f65c4ae4009807e531782b5610","modified":1677139945194},{"_id":"public/2018/04/19/self-在-block-中的引用计数变化/index.html","hash":"7e6e62bb4510d772a94eb7230efa588d346eefd8","modified":1677139945194},{"_id":"public/2018/04/02/如何用-Objective-C-实现一个死锁/index.html","hash":"50a61b37f82bc7ae1c44cd29edeefffd3f1b0917","modified":1677139945194},{"_id":"public/2018/03/24/说说-Objective-C-中的-Copy-操作/index.html","hash":"8363133b6908b53f675ec7315c1bcdf1cb0df80b","modified":1677139945194},{"_id":"public/2018/03/20/如何在-iOS-上自定义-React-Native-Component/index.html","hash":"dcdfb7385dde0e10b9a9002a1db319d6f4915203","modified":1677139945194},{"_id":"public/2018/02/27/redux-之页面跳转/index.html","hash":"87e94b590a9257b3bd3660e07790ad569a5c9161","modified":1677139945194},{"_id":"public/2017/09/05/RAC和内存管理/index.html","hash":"c248cde4e8d2ca8218c2d024df5d2747213f7903","modified":1677139945194},{"_id":"public/2017/09/05/Shell-Tip/index.html","hash":"369c7a52782cad1d13fa551b353963315f9b8a6f","modified":1677139945194},{"_id":"public/2017/09/05/Swift-High-Performance-Tip 1：Array和ContiguousArray/index.html","hash":"3318f50c55d5c9d0a61172a8a5cf68beccacff08","modified":1677139945194},{"_id":"public/2017/09/05/Vim-Tip/index.html","hash":"f937ccb869c64541942d892348d8e0015e1aad2f","modified":1677139945194},{"_id":"public/2017/09/05/include和import的区别/index.html","hash":"12e2844f6cbfa461d48392d27de0c19346cd0ebf","modified":1677139945194},{"_id":"public/2017/09/05/初步了解GCD/index.html","hash":"a761b41b62e1ffd271ca26b87235c8884d170f69","modified":1677139945194},{"_id":"public/index.html","hash":"5c7ac03a4eb3c90aa056cc2d3a3196485e91146c","modified":1677371871600},{"_id":"public/page/2/index.html","hash":"9bcc2c1ab5de470edd2b87e5e68164da8cf83a2d","modified":1677139945194},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1675588374043},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1675588374043},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1675588374043},{"_id":"public/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1675588374043},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1675588374043},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1675588374043},{"_id":"public/css/noscript.css","hash":"4cd5301e478e0e0d4b176740ec314087ec5cb707","modified":1675588374043},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1675588374043},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1675588374043},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1675588374043},{"_id":"public/js/motion.js","hash":"770d63c26f22705311028a36b52e999cc8a2da82","modified":1675588374043},{"_id":"public/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1675588374043},{"_id":"public/js/pjax.js","hash":"90fb7f346f777434ea68ab4e4be1d7b999ad63ac","modified":1675588374043},{"_id":"public/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1675588374043},{"_id":"public/js/schemes/muse.js","hash":"0c490e9ba82efbb8bdf8465e6b537fafd51e1ed7","modified":1675588374043},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1675588374043},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1675588374043},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1675588374043},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1675588374043},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1675588374043},{"_id":"public/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1675588374043},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1675588374043},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1675588374043},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1675588374043},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1675588374043},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1675588374043},{"_id":"public/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1675588374043},{"_id":"public/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1675588374043},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1675588374043},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1675588374043},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1675588374043},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1675588374043},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1675588374043},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1675588374043},{"_id":"public/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1675588374043},{"_id":"public/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1675588374043},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1675588374043},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1675588374043},{"_id":"public/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1675588374043},{"_id":"public/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1675588374043},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1675588374043},{"_id":"public/css/main.css","hash":"5a0807de704fdc4ee01f6819cedb5f4fffe3291a","modified":1675588374043},{"_id":"public/js/utils.js","hash":"af59257e46d25dda62967c35a65e2efcbd90d3bc","modified":1675588374043},{"_id":"source/_posts/关于 iOS 中 View 和 Cell 的思考.md","hash":"9ae71af0327c5037877199e529da4340e8e1c8d7","modified":1677371837395},{"_id":"public/2023/02/23/关于 iOS 中 View 和 Cell 的思考/index.html","hash":"d2b45d65416972f2f41b3fa8c1940904e45a30a6","modified":1677371871600},{"_id":"source/_drafts/iOS 架构中的 Model 层.md","hash":"ab73794c0743c9e276e30c1c99eca4575fbfdb30","modified":1677142752310},{"_id":"source/_drafts/不要使用 UserDefaults.stand.md","hash":"ab73794c0743c9e276e30c1c99eca4575fbfdb30","modified":1677143068694},{"_id":"source/_drafts/如何处理 Model 层.md","hash":"ab73794c0743c9e276e30c1c99eca4575fbfdb30","modified":1677142728197},{"_id":"source/_drafts/为什么有了 ARC 之后还要 autoreleasepool.md","hash":"ab73794c0743c9e276e30c1c99eca4575fbfdb30","modified":1677142411016},{"_id":"source/_drafts/理解 Swift 中 Struct 是线程安全的.md","hash":"ab73794c0743c9e276e30c1c99eca4575fbfdb30","modified":1677143623574},{"_id":"source/_drafts/MVVM Change.drawio","hash":"4014983a8dee260422080f823e71d1bc0883f99e","modified":1680437380413},{"_id":"source/_drafts/MMVM.drawio","hash":"8ecbe178192ed62aab0285e187af225c5b049be6","modified":1680240318664},{"_id":"source/_drafts/Old-MVVM.drawio","hash":"73f73db6252e41e51a6d25a5187ec4222b8b0f80","modified":1680240391748},{"_id":"source/_posts/iOS-中-MVVM-架构的一点思考.md","hash":"d23d75a2fb73c5a1b32ecafa1aadcb60e9d9c17d","modified":1680440468736},{"_id":"source/_drafts/SearchExample.drawio","hash":"e2d39ee07c2dd2b2cca0fa3e1812ad07cf54f24b","modified":1680247370103}],"Category":[{"name":"技术","_id":"cldr5xjcf0004jbse0tiafcq6"},{"name":"Raspberry PI","_id":"cldr5xjcj000hjbseen72d8ih"}],"Data":[],"Page":[{"title":"About","layout":"page","_content":"\n## 工作经历\n\n### 北京微梦创科网络技术有限公司（微博）\n\niOS 高级工程师（2018.12 - 2022.12）\n\n1. 负责日常的产品研发和维护工作\n2. 主导和推动新技术的学习和应用\n3. 搭建客户端的自动化打包流程\n4. 积极主动的对客户端进行优化以及代码重构\n5. 负责客户端的整体质量和架构工作\n6. 为产品部门提供技术支持，指出产品不足之处，帮助改进产品\n\n[![Social案例](https://is3-ssl.mzstatic.com/image/thumb/Purple116/v4/6b/0c/2d/6b0c2d4b-8ee3-6274-0773-285d56324dcf/AppIcon-0-0-1x_U007emarketing-0-0-0-5-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/230x0w.webp)](https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420)\n[Social 案例](https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420)（已经从 AppStore 下架，目前已经使用企业证书重签名并仅对内部员工开放使用）\n\n### 北京品冠天成科技有限公司\n\niOS 高级工程师（2016.08 - 2018.12）\n\n1. 负责日常的产品研发和维护工作\n2. 负责对新技术的研究与应用\n3. 负责代码的重构和封装\n4. 微信小程序以及 React Native 的开发\n\n[![样本通](https://is1-ssl.mzstatic.com/image/thumb/Purple125/v4/d3/9e/07/d39e07f9-991b-03da-c670-e2cc3c30f462/AppIcon-0-0-1x_U007emarketing-0-0-0-7-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/230x0w.webp)](https://apps.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417)\n[样本通](https://apps.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417)\n\n### 北京黑米世纪网络科技有限公司\n\niOS 工程师（2013.03 - 2016.08）\n\n1. Review 团队成员代码，提出指导意见\n2. 负责对进行架构设计、开发、性能分析和优化，分析和发现系统的优化点\n3. 新技术的学习并推动团队成员的技术进步\n4. 为产品部门提供技术支持，提出产品的不足之处，帮助改进产品\n5. 重构代码，封装常用的工具和公司的基础业务\n6. 负责客户端团队的招聘工作\n\n## 教育经历\n\n### 怀化学院\n\n本科 · 计算机科学与技术\n2013 年毕业\n\n## 项目经验\n\n### [Social 案例](https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420)\n\n#### 主导日常的开发和维护，负责整体的架构工作，推动新技术的学习和使用。 2018.12-2022.12\n\n此项目是微博的市场营销团队推出的，最主要的功能是运营人员整理微博的一些广告案例呈现给广告主和代理商，通过一系列的案例展示效果给微博的广告业务引流；另外一个主要功能是给市场营销团队的内部员工提供课程学习、考试、培训相关的业务。我在该项目中主要推动客户端从原来的硬编码布局改成 AutoLayout 的布局方式；后面通过渐进式的迭代把整个项目从 Objective-C 过渡到 Swift，并且实现 Dark Mode 的应用，使用 RxSwift 和 Combine 重构整个项目的数据流，使用 Swift Package 对项目中的代码进行管理和 Module 化。主导了自动化打包流程的开发，对产品的开发流程提出一些建议。\n\n### [样本通](https://itunes.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417?mt=8)\n\n#### 日常开发和维护。 2016.08-2018.12\n\n样本通主要是一款面向企业的产品，主要是能用更丰富的方式来展现各个行业的样本资料，并且为企业的销 售人员提供销售线索和提高销售效率。 最主要的是推动团队成员使用 AutoLayout 而非硬编码的形式来做 UI 布局，推动使用 Swift 来实现新的产品功能。用 CocoaPods 来管理项目的第三方库，把原来项目的各个模块拆分成私有的 Pod 库来管理， 从而方便定制项目的开发。(其他定制项目可以参考该链接:https:// itunes.apple.com/us/developer/beijing-ivymobi-technology-co-ltd/id867985670)\n此项目原来是基于 Cordova 开发，并且实现利用 URL Protocol 实现 Web 页面内容的离线访问。\n\n### [手由宝](https://itunes.apple.com/us/app/shou-you-bao/id1013813188)\n\n#### 负责项目的整体架构以及版本的迭代，把控项目的进度和质量。 2015.04-2016.08\n\n这是一款用来和我们公司自己研发的硬件(手由宝)配套使用的产品，可以将手机上的图片、视频快速存储 在手由宝上，不消耗任何流量。添加文件至共享，共享文件及时送达联网设备，为工作和生活增添色彩。 此项目主要是是使用了 Socket 来和手由宝这个硬件通过的方式来进行数据间的通讯，并且通过 ReactiveCocoa 这个框架来监听从硬件推送过来的数据变化。 同时由于 APP 里面除了跟硬件交互这一块的功能是用 Native 的方式实现的，其他的业务都是基于网页来做的。通过和 Android 工程师一起研究网页和 APP 的交互的原理之后，我编写了 JSAPI(Android 和 iOS 通用)来让网页可以调用本地的功能。比如网页只需要调用对应的 JSAPI 接口即可唤起支付宝或微信进行支付。\n","source":"about/index.md","raw":"title: \"About\"\nlayout: \"page\"\n\n---\n\n## 工作经历\n\n### 北京微梦创科网络技术有限公司（微博）\n\niOS 高级工程师（2018.12 - 2022.12）\n\n1. 负责日常的产品研发和维护工作\n2. 主导和推动新技术的学习和应用\n3. 搭建客户端的自动化打包流程\n4. 积极主动的对客户端进行优化以及代码重构\n5. 负责客户端的整体质量和架构工作\n6. 为产品部门提供技术支持，指出产品不足之处，帮助改进产品\n\n[![Social案例](https://is3-ssl.mzstatic.com/image/thumb/Purple116/v4/6b/0c/2d/6b0c2d4b-8ee3-6274-0773-285d56324dcf/AppIcon-0-0-1x_U007emarketing-0-0-0-5-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/230x0w.webp)](https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420)\n[Social 案例](https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420)（已经从 AppStore 下架，目前已经使用企业证书重签名并仅对内部员工开放使用）\n\n### 北京品冠天成科技有限公司\n\niOS 高级工程师（2016.08 - 2018.12）\n\n1. 负责日常的产品研发和维护工作\n2. 负责对新技术的研究与应用\n3. 负责代码的重构和封装\n4. 微信小程序以及 React Native 的开发\n\n[![样本通](https://is1-ssl.mzstatic.com/image/thumb/Purple125/v4/d3/9e/07/d39e07f9-991b-03da-c670-e2cc3c30f462/AppIcon-0-0-1x_U007emarketing-0-0-0-7-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/230x0w.webp)](https://apps.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417)\n[样本通](https://apps.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417)\n\n### 北京黑米世纪网络科技有限公司\n\niOS 工程师（2013.03 - 2016.08）\n\n1. Review 团队成员代码，提出指导意见\n2. 负责对进行架构设计、开发、性能分析和优化，分析和发现系统的优化点\n3. 新技术的学习并推动团队成员的技术进步\n4. 为产品部门提供技术支持，提出产品的不足之处，帮助改进产品\n5. 重构代码，封装常用的工具和公司的基础业务\n6. 负责客户端团队的招聘工作\n\n## 教育经历\n\n### 怀化学院\n\n本科 · 计算机科学与技术\n2013 年毕业\n\n## 项目经验\n\n### [Social 案例](https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420)\n\n#### 主导日常的开发和维护，负责整体的架构工作，推动新技术的学习和使用。 2018.12-2022.12\n\n此项目是微博的市场营销团队推出的，最主要的功能是运营人员整理微博的一些广告案例呈现给广告主和代理商，通过一系列的案例展示效果给微博的广告业务引流；另外一个主要功能是给市场营销团队的内部员工提供课程学习、考试、培训相关的业务。我在该项目中主要推动客户端从原来的硬编码布局改成 AutoLayout 的布局方式；后面通过渐进式的迭代把整个项目从 Objective-C 过渡到 Swift，并且实现 Dark Mode 的应用，使用 RxSwift 和 Combine 重构整个项目的数据流，使用 Swift Package 对项目中的代码进行管理和 Module 化。主导了自动化打包流程的开发，对产品的开发流程提出一些建议。\n\n### [样本通](https://itunes.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417?mt=8)\n\n#### 日常开发和维护。 2016.08-2018.12\n\n样本通主要是一款面向企业的产品，主要是能用更丰富的方式来展现各个行业的样本资料，并且为企业的销 售人员提供销售线索和提高销售效率。 最主要的是推动团队成员使用 AutoLayout 而非硬编码的形式来做 UI 布局，推动使用 Swift 来实现新的产品功能。用 CocoaPods 来管理项目的第三方库，把原来项目的各个模块拆分成私有的 Pod 库来管理， 从而方便定制项目的开发。(其他定制项目可以参考该链接:https:// itunes.apple.com/us/developer/beijing-ivymobi-technology-co-ltd/id867985670)\n此项目原来是基于 Cordova 开发，并且实现利用 URL Protocol 实现 Web 页面内容的离线访问。\n\n### [手由宝](https://itunes.apple.com/us/app/shou-you-bao/id1013813188)\n\n#### 负责项目的整体架构以及版本的迭代，把控项目的进度和质量。 2015.04-2016.08\n\n这是一款用来和我们公司自己研发的硬件(手由宝)配套使用的产品，可以将手机上的图片、视频快速存储 在手由宝上，不消耗任何流量。添加文件至共享，共享文件及时送达联网设备，为工作和生活增添色彩。 此项目主要是是使用了 Socket 来和手由宝这个硬件通过的方式来进行数据间的通讯，并且通过 ReactiveCocoa 这个框架来监听从硬件推送过来的数据变化。 同时由于 APP 里面除了跟硬件交互这一块的功能是用 Native 的方式实现的，其他的业务都是基于网页来做的。通过和 Android 工程师一起研究网页和 APP 的交互的原理之后，我编写了 JSAPI(Android 和 iOS 通用)来让网页可以调用本地的功能。比如网页只需要调用对应的 JSAPI 接口即可唤起支付宝或微信进行支付。\n","date":"2023-02-06T01:59:59.456Z","updated":"2023-02-06T01:59:59.456Z","path":"about/index.html","_id":"cldr5xjcc0000jbsefauuffro","comments":1,"content":"<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><h3 id=\"北京微梦创科网络技术有限公司（微博）\"><a href=\"#北京微梦创科网络技术有限公司（微博）\" class=\"headerlink\" title=\"北京微梦创科网络技术有限公司（微博）\"></a>北京微梦创科网络技术有限公司（微博）</h3><p>iOS 高级工程师（2018.12 - 2022.12）</p>\n<ol>\n<li>负责日常的产品研发和维护工作</li>\n<li>主导和推动新技术的学习和应用</li>\n<li>搭建客户端的自动化打包流程</li>\n<li>积极主动的对客户端进行优化以及代码重构</li>\n<li>负责客户端的整体质量和架构工作</li>\n<li>为产品部门提供技术支持，指出产品不足之处，帮助改进产品</li>\n</ol>\n<p><a href=\"https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420\"><img src=\"https://is3-ssl.mzstatic.com/image/thumb/Purple116/v4/6b/0c/2d/6b0c2d4b-8ee3-6274-0773-285d56324dcf/AppIcon-0-0-1x_U007emarketing-0-0-0-5-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/230x0w.webp\" alt=\"Social案例\"></a><br><a href=\"https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420\">Social 案例</a>（已经从 AppStore 下架，目前已经使用企业证书重签名并仅对内部员工开放使用）</p>\n<h3 id=\"北京品冠天成科技有限公司\"><a href=\"#北京品冠天成科技有限公司\" class=\"headerlink\" title=\"北京品冠天成科技有限公司\"></a>北京品冠天成科技有限公司</h3><p>iOS 高级工程师（2016.08 - 2018.12）</p>\n<ol>\n<li>负责日常的产品研发和维护工作</li>\n<li>负责对新技术的研究与应用</li>\n<li>负责代码的重构和封装</li>\n<li>微信小程序以及 React Native 的开发</li>\n</ol>\n<p><a href=\"https://apps.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417\"><img src=\"https://is1-ssl.mzstatic.com/image/thumb/Purple125/v4/d3/9e/07/d39e07f9-991b-03da-c670-e2cc3c30f462/AppIcon-0-0-1x_U007emarketing-0-0-0-7-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/230x0w.webp\" alt=\"样本通\"></a><br><a href=\"https://apps.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417\">样本通</a></p>\n<h3 id=\"北京黑米世纪网络科技有限公司\"><a href=\"#北京黑米世纪网络科技有限公司\" class=\"headerlink\" title=\"北京黑米世纪网络科技有限公司\"></a>北京黑米世纪网络科技有限公司</h3><p>iOS 工程师（2013.03 - 2016.08）</p>\n<ol>\n<li>Review 团队成员代码，提出指导意见</li>\n<li>负责对进行架构设计、开发、性能分析和优化，分析和发现系统的优化点</li>\n<li>新技术的学习并推动团队成员的技术进步</li>\n<li>为产品部门提供技术支持，提出产品的不足之处，帮助改进产品</li>\n<li>重构代码，封装常用的工具和公司的基础业务</li>\n<li>负责客户端团队的招聘工作</li>\n</ol>\n<h2 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h2><h3 id=\"怀化学院\"><a href=\"#怀化学院\" class=\"headerlink\" title=\"怀化学院\"></a>怀化学院</h3><p>本科 · 计算机科学与技术<br>2013 年毕业</p>\n<h2 id=\"项目经验\"><a href=\"#项目经验\" class=\"headerlink\" title=\"项目经验\"></a>项目经验</h2><h3 id=\"Social-案例\"><a href=\"#Social-案例\" class=\"headerlink\" title=\"Social 案例\"></a><a href=\"https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420\">Social 案例</a></h3><h4 id=\"主导日常的开发和维护，负责整体的架构工作，推动新技术的学习和使用。-2018-12-2022-12\"><a href=\"#主导日常的开发和维护，负责整体的架构工作，推动新技术的学习和使用。-2018-12-2022-12\" class=\"headerlink\" title=\"主导日常的开发和维护，负责整体的架构工作，推动新技术的学习和使用。 2018.12-2022.12\"></a>主导日常的开发和维护，负责整体的架构工作，推动新技术的学习和使用。 2018.12-2022.12</h4><p>此项目是微博的市场营销团队推出的，最主要的功能是运营人员整理微博的一些广告案例呈现给广告主和代理商，通过一系列的案例展示效果给微博的广告业务引流；另外一个主要功能是给市场营销团队的内部员工提供课程学习、考试、培训相关的业务。我在该项目中主要推动客户端从原来的硬编码布局改成 AutoLayout 的布局方式；后面通过渐进式的迭代把整个项目从 Objective-C 过渡到 Swift，并且实现 Dark Mode 的应用，使用 RxSwift 和 Combine 重构整个项目的数据流，使用 Swift Package 对项目中的代码进行管理和 Module 化。主导了自动化打包流程的开发，对产品的开发流程提出一些建议。</p>\n<h3 id=\"样本通\"><a href=\"#样本通\" class=\"headerlink\" title=\"样本通\"></a><a href=\"https://itunes.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417?mt=8\">样本通</a></h3><h4 id=\"日常开发和维护。-2016-08-2018-12\"><a href=\"#日常开发和维护。-2016-08-2018-12\" class=\"headerlink\" title=\"日常开发和维护。 2016.08-2018.12\"></a>日常开发和维护。 2016.08-2018.12</h4><p>样本通主要是一款面向企业的产品，主要是能用更丰富的方式来展现各个行业的样本资料，并且为企业的销 售人员提供销售线索和提高销售效率。 最主要的是推动团队成员使用 AutoLayout 而非硬编码的形式来做 UI 布局，推动使用 Swift 来实现新的产品功能。用 CocoaPods 来管理项目的第三方库，把原来项目的各个模块拆分成私有的 Pod 库来管理， 从而方便定制项目的开发。(其他定制项目可以参考该链接:https:&#x2F;&#x2F; itunes.apple.com&#x2F;us&#x2F;developer&#x2F;beijing-ivymobi-technology-co-ltd&#x2F;id867985670)<br>此项目原来是基于 Cordova 开发，并且实现利用 URL Protocol 实现 Web 页面内容的离线访问。</p>\n<h3 id=\"手由宝\"><a href=\"#手由宝\" class=\"headerlink\" title=\"手由宝\"></a><a href=\"https://itunes.apple.com/us/app/shou-you-bao/id1013813188\">手由宝</a></h3><h4 id=\"负责项目的整体架构以及版本的迭代，把控项目的进度和质量。-2015-04-2016-08\"><a href=\"#负责项目的整体架构以及版本的迭代，把控项目的进度和质量。-2015-04-2016-08\" class=\"headerlink\" title=\"负责项目的整体架构以及版本的迭代，把控项目的进度和质量。 2015.04-2016.08\"></a>负责项目的整体架构以及版本的迭代，把控项目的进度和质量。 2015.04-2016.08</h4><p>这是一款用来和我们公司自己研发的硬件(手由宝)配套使用的产品，可以将手机上的图片、视频快速存储 在手由宝上，不消耗任何流量。添加文件至共享，共享文件及时送达联网设备，为工作和生活增添色彩。 此项目主要是是使用了 Socket 来和手由宝这个硬件通过的方式来进行数据间的通讯，并且通过 ReactiveCocoa 这个框架来监听从硬件推送过来的数据变化。 同时由于 APP 里面除了跟硬件交互这一块的功能是用 Native 的方式实现的，其他的业务都是基于网页来做的。通过和 Android 工程师一起研究网页和 APP 的交互的原理之后，我编写了 JSAPI(Android 和 iOS 通用)来让网页可以调用本地的功能。比如网页只需要调用对应的 JSAPI 接口即可唤起支付宝或微信进行支付。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><h3 id=\"北京微梦创科网络技术有限公司（微博）\"><a href=\"#北京微梦创科网络技术有限公司（微博）\" class=\"headerlink\" title=\"北京微梦创科网络技术有限公司（微博）\"></a>北京微梦创科网络技术有限公司（微博）</h3><p>iOS 高级工程师（2018.12 - 2022.12）</p>\n<ol>\n<li>负责日常的产品研发和维护工作</li>\n<li>主导和推动新技术的学习和应用</li>\n<li>搭建客户端的自动化打包流程</li>\n<li>积极主动的对客户端进行优化以及代码重构</li>\n<li>负责客户端的整体质量和架构工作</li>\n<li>为产品部门提供技术支持，指出产品不足之处，帮助改进产品</li>\n</ol>\n<p><a href=\"https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420\"><img src=\"https://is3-ssl.mzstatic.com/image/thumb/Purple116/v4/6b/0c/2d/6b0c2d4b-8ee3-6274-0773-285d56324dcf/AppIcon-0-0-1x_U007emarketing-0-0-0-5-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/230x0w.webp\" alt=\"Social案例\"></a><br><a href=\"https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420\">Social 案例</a>（已经从 AppStore 下架，目前已经使用企业证书重签名并仅对内部员工开放使用）</p>\n<h3 id=\"北京品冠天成科技有限公司\"><a href=\"#北京品冠天成科技有限公司\" class=\"headerlink\" title=\"北京品冠天成科技有限公司\"></a>北京品冠天成科技有限公司</h3><p>iOS 高级工程师（2016.08 - 2018.12）</p>\n<ol>\n<li>负责日常的产品研发和维护工作</li>\n<li>负责对新技术的研究与应用</li>\n<li>负责代码的重构和封装</li>\n<li>微信小程序以及 React Native 的开发</li>\n</ol>\n<p><a href=\"https://apps.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417\"><img src=\"https://is1-ssl.mzstatic.com/image/thumb/Purple125/v4/d3/9e/07/d39e07f9-991b-03da-c670-e2cc3c30f462/AppIcon-0-0-1x_U007emarketing-0-0-0-7-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/230x0w.webp\" alt=\"样本通\"></a><br><a href=\"https://apps.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417\">样本通</a></p>\n<h3 id=\"北京黑米世纪网络科技有限公司\"><a href=\"#北京黑米世纪网络科技有限公司\" class=\"headerlink\" title=\"北京黑米世纪网络科技有限公司\"></a>北京黑米世纪网络科技有限公司</h3><p>iOS 工程师（2013.03 - 2016.08）</p>\n<ol>\n<li>Review 团队成员代码，提出指导意见</li>\n<li>负责对进行架构设计、开发、性能分析和优化，分析和发现系统的优化点</li>\n<li>新技术的学习并推动团队成员的技术进步</li>\n<li>为产品部门提供技术支持，提出产品的不足之处，帮助改进产品</li>\n<li>重构代码，封装常用的工具和公司的基础业务</li>\n<li>负责客户端团队的招聘工作</li>\n</ol>\n<h2 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h2><h3 id=\"怀化学院\"><a href=\"#怀化学院\" class=\"headerlink\" title=\"怀化学院\"></a>怀化学院</h3><p>本科 · 计算机科学与技术<br>2013 年毕业</p>\n<h2 id=\"项目经验\"><a href=\"#项目经验\" class=\"headerlink\" title=\"项目经验\"></a>项目经验</h2><h3 id=\"Social-案例\"><a href=\"#Social-案例\" class=\"headerlink\" title=\"Social 案例\"></a><a href=\"https://apps.apple.com/us/app/social%E6%A1%88%E4%BE%8B/id1449218420\">Social 案例</a></h3><h4 id=\"主导日常的开发和维护，负责整体的架构工作，推动新技术的学习和使用。-2018-12-2022-12\"><a href=\"#主导日常的开发和维护，负责整体的架构工作，推动新技术的学习和使用。-2018-12-2022-12\" class=\"headerlink\" title=\"主导日常的开发和维护，负责整体的架构工作，推动新技术的学习和使用。 2018.12-2022.12\"></a>主导日常的开发和维护，负责整体的架构工作，推动新技术的学习和使用。 2018.12-2022.12</h4><p>此项目是微博的市场营销团队推出的，最主要的功能是运营人员整理微博的一些广告案例呈现给广告主和代理商，通过一系列的案例展示效果给微博的广告业务引流；另外一个主要功能是给市场营销团队的内部员工提供课程学习、考试、培训相关的业务。我在该项目中主要推动客户端从原来的硬编码布局改成 AutoLayout 的布局方式；后面通过渐进式的迭代把整个项目从 Objective-C 过渡到 Swift，并且实现 Dark Mode 的应用，使用 RxSwift 和 Combine 重构整个项目的数据流，使用 Swift Package 对项目中的代码进行管理和 Module 化。主导了自动化打包流程的开发，对产品的开发流程提出一些建议。</p>\n<h3 id=\"样本通\"><a href=\"#样本通\" class=\"headerlink\" title=\"样本通\"></a><a href=\"https://itunes.apple.com/us/app/%E6%A0%B7%E6%9C%AC%E9%80%9A-ecatalog/id1160661417?mt=8\">样本通</a></h3><h4 id=\"日常开发和维护。-2016-08-2018-12\"><a href=\"#日常开发和维护。-2016-08-2018-12\" class=\"headerlink\" title=\"日常开发和维护。 2016.08-2018.12\"></a>日常开发和维护。 2016.08-2018.12</h4><p>样本通主要是一款面向企业的产品，主要是能用更丰富的方式来展现各个行业的样本资料，并且为企业的销 售人员提供销售线索和提高销售效率。 最主要的是推动团队成员使用 AutoLayout 而非硬编码的形式来做 UI 布局，推动使用 Swift 来实现新的产品功能。用 CocoaPods 来管理项目的第三方库，把原来项目的各个模块拆分成私有的 Pod 库来管理， 从而方便定制项目的开发。(其他定制项目可以参考该链接:https:&#x2F;&#x2F; itunes.apple.com&#x2F;us&#x2F;developer&#x2F;beijing-ivymobi-technology-co-ltd&#x2F;id867985670)<br>此项目原来是基于 Cordova 开发，并且实现利用 URL Protocol 实现 Web 页面内容的离线访问。</p>\n<h3 id=\"手由宝\"><a href=\"#手由宝\" class=\"headerlink\" title=\"手由宝\"></a><a href=\"https://itunes.apple.com/us/app/shou-you-bao/id1013813188\">手由宝</a></h3><h4 id=\"负责项目的整体架构以及版本的迭代，把控项目的进度和质量。-2015-04-2016-08\"><a href=\"#负责项目的整体架构以及版本的迭代，把控项目的进度和质量。-2015-04-2016-08\" class=\"headerlink\" title=\"负责项目的整体架构以及版本的迭代，把控项目的进度和质量。 2015.04-2016.08\"></a>负责项目的整体架构以及版本的迭代，把控项目的进度和质量。 2015.04-2016.08</h4><p>这是一款用来和我们公司自己研发的硬件(手由宝)配套使用的产品，可以将手机上的图片、视频快速存储 在手由宝上，不消耗任何流量。添加文件至共享，共享文件及时送达联网设备，为工作和生活增添色彩。 此项目主要是是使用了 Socket 来和手由宝这个硬件通过的方式来进行数据间的通讯，并且通过 ReactiveCocoa 这个框架来监听从硬件推送过来的数据变化。 同时由于 APP 里面除了跟硬件交互这一块的功能是用 Native 的方式实现的，其他的业务都是基于网页来做的。通过和 Android 工程师一起研究网页和 APP 的交互的原理之后，我编写了 JSAPI(Android 和 iOS 通用)来让网页可以调用本地的功能。比如网页只需要调用对应的 JSAPI 接口即可唤起支付宝或微信进行支付。</p>\n"},{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"Tags\"\nlayout: \"tags\"\n---\n","date":"2023-01-07T05:42:02.485Z","updated":"2023-01-07T05:42:02.485Z","path":"tags/index.html","comments":1,"_id":"cldr5xjce0002jbse0pys7a10","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Categories","layout":"categories","_content":"","source":"categories/index.md","raw":"title: \"Categories\"\nlayout: \"categories\"\n---\n","date":"2023-01-07T05:42:02.485Z","updated":"2023-01-07T05:42:02.485Z","path":"categories/index.html","comments":1,"_id":"cldr5xjcg0006jbse913p87np","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"字典的存储结构","date":"2018-08-02T15:41:10.000Z","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1517077304055-6e89abbf09b0?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3f799bed83db2959c476e69a3307d39e&auto=format&fit=crop&w=160&q=100","_content":"\n在 Swift 中我们会这样来构造一个字典：\n```Swift\nlet dic = [\"cat\": \"vCat\", \"art\": \"vArt\", \"dog\": \"vDog\", \"rat\": \"vRat\"]\n```\n那如果让你来设计字典的存储结构，你会怎么设计呢？\n\n![](https://i.imgur.com/tmhQb4z.jpg)\n\n从图中可以看出，字典的存储结构其实也是一个数组（注意：数组里的每个元素也都是一个数组）。接下来，我们尝试用 Swift 来构造字典的存储和操作。\n\n## \n\n\n\n\n---\n\n**参考文献**\n\n1. https://adrianmejia.com/blog/2018/04/28/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial/#HashMaps\n\n","source":"_drafts/字典的存储结构.md","raw":"---\ntitle: 字典的存储结构\ndate: 2018-08-02 15:41:10 +0800\nauthor: 帕帕\ncategories: 技术\ntags: [iOS, Swift]\nthumbnail: https://images.unsplash.com/photo-1517077304055-6e89abbf09b0?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3f799bed83db2959c476e69a3307d39e&auto=format&fit=crop&w=160&q=100\n---\n\n在 Swift 中我们会这样来构造一个字典：\n```Swift\nlet dic = [\"cat\": \"vCat\", \"art\": \"vArt\", \"dog\": \"vDog\", \"rat\": \"vRat\"]\n```\n那如果让你来设计字典的存储结构，你会怎么设计呢？\n\n![](https://i.imgur.com/tmhQb4z.jpg)\n\n从图中可以看出，字典的存储结构其实也是一个数组（注意：数组里的每个元素也都是一个数组）。接下来，我们尝试用 Swift 来构造字典的存储和操作。\n\n## \n\n\n\n\n---\n\n**参考文献**\n\n1. https://adrianmejia.com/blog/2018/04/28/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial/#HashMaps\n\n","slug":"字典的存储结构","published":0,"updated":"2023-01-07T05:42:02.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldr5xjcd0001jbse0mk64o6z","content":"<p>在 Swift 中我们会这样来构造一个字典：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dic <span class=\"operator\">=</span> [<span class=\"string\">&quot;cat&quot;</span>: <span class=\"string\">&quot;vCat&quot;</span>, <span class=\"string\">&quot;art&quot;</span>: <span class=\"string\">&quot;vArt&quot;</span>, <span class=\"string\">&quot;dog&quot;</span>: <span class=\"string\">&quot;vDog&quot;</span>, <span class=\"string\">&quot;rat&quot;</span>: <span class=\"string\">&quot;vRat&quot;</span>]</span><br></pre></td></tr></table></figure>\n<p>那如果让你来设计字典的存储结构，你会怎么设计呢？</p>\n<p><img src=\"https://i.imgur.com/tmhQb4z.jpg\"></p>\n<p>从图中可以看出，字典的存储结构其实也是一个数组（注意：数组里的每个元素也都是一个数组）。接下来，我们尝试用 Swift 来构造字典的存储和操作。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><hr>\n<p><strong>参考文献</strong></p>\n<ol>\n<li><a href=\"https://adrianmejia.com/blog/2018/04/28/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial/#HashMaps\">https://adrianmejia.com/blog/2018/04/28/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial/#HashMaps</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>在 Swift 中我们会这样来构造一个字典：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dic <span class=\"operator\">=</span> [<span class=\"string\">&quot;cat&quot;</span>: <span class=\"string\">&quot;vCat&quot;</span>, <span class=\"string\">&quot;art&quot;</span>: <span class=\"string\">&quot;vArt&quot;</span>, <span class=\"string\">&quot;dog&quot;</span>: <span class=\"string\">&quot;vDog&quot;</span>, <span class=\"string\">&quot;rat&quot;</span>: <span class=\"string\">&quot;vRat&quot;</span>]</span><br></pre></td></tr></table></figure>\n<p>那如果让你来设计字典的存储结构，你会怎么设计呢？</p>\n<p><img src=\"https://i.imgur.com/tmhQb4z.jpg\"></p>\n<p>从图中可以看出，字典的存储结构其实也是一个数组（注意：数组里的每个元素也都是一个数组）。接下来，我们尝试用 Swift 来构造字典的存储和操作。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><hr>\n<p><strong>参考文献</strong></p>\n<ol>\n<li><a href=\"https://adrianmejia.com/blog/2018/04/28/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial/#HashMaps\">https://adrianmejia.com/blog/2018/04/28/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial/#HashMaps</a></li>\n</ol>\n"},{"title":"常用工具","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1514443031610-8c063c7a9822?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=73d9a7ce5ba0ed22cb91bdc0506ac9d0&auto=format&fit=crop&w=160&q=10","_content":"\n> 此文章暂未完成....\n\n# Ruby\n\n## 版本管理工具 - rvm\n\n- `$ rvm list` 列出已安装的 ruby 版本\n- `$ rvm list kn=own` 显示 local + remote 的 ruby 版本\n- `$ rvm use [ruby-version]` 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本\n- `$ rvm remove [ruby-version]` 删除 ruby 版本\n\n## 包管理工具 - gem\n\n- `$ gem install [gem-package]` 安装 gem 包\n- `$ gem update` 更新 gem 包\n- `$ gem update --system` 更新 gem 本身\n- `$ gem install [gem-package]` 安装 gem 包\n- `$ gem list` 列出所有安装的 gem 包\n- `$ gem remove [gem-package]` 删除安装过的 gem 包\n\n## 常用工具\n\n### cocoapods\n\n- `$ gem instal cocoapods` 安装 cocoapods\n- `$ pod setup` 初始化 Pod 库\n- `$ pod repo update` 更新 Pod 库\n- `$ pod install` 根据当前目录的 Podfile 文件安装 Pod 库\n- `$ pod update` 更新 Podfile 文件中的 Pod 库\n\n# Python\n\n## 版本管理工具 - pyenv\n\n# JavaScript\n\n## 包管理工具 - npm\n\n# 包管理工具 - brew\n\n- `brew update` 更新 pythpackage\n- `brew cleanup` 移除旧版本\n- `brew cleanup -n` 查看可以清理的旧版本\n- `brew list` 列出已安装的 package\n\nPrivacy Policy We take your privacy very seriously. This policy outlines how we collect, use, and protect your personal information. Information We Collect: We only collect analytical and crash data. This data includes information about how you use our app, device information, and crash reports. We use this data to improve the performance and stability of our app. How We Use Your Information: We use the data we collect to analyze user behavior and improve the performance of our app. We may also use this data to troubleshoot technical issues and improve user experience. How We Protect Your Information: We take appropriate security measures to protect your information from unauthorized access, disclosure, alteration, or destruction. We limit access to your information to those who need it to perform their job functions. We do not sell or share your personal information with third parties.\n","source":"_drafts/常用工具.md","raw":"---\ntitle: 常用工具\nauthor: 帕帕\ncategories: 技术\ntags: [其他]\nthumbnail: https://images.unsplash.com/photo-1514443031610-8c063c7a9822?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=73d9a7ce5ba0ed22cb91bdc0506ac9d0&auto=format&fit=crop&w=160&q=10\n---\n\n> 此文章暂未完成....\n\n# Ruby\n\n## 版本管理工具 - rvm\n\n- `$ rvm list` 列出已安装的 ruby 版本\n- `$ rvm list kn=own` 显示 local + remote 的 ruby 版本\n- `$ rvm use [ruby-version]` 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本\n- `$ rvm remove [ruby-version]` 删除 ruby 版本\n\n## 包管理工具 - gem\n\n- `$ gem install [gem-package]` 安装 gem 包\n- `$ gem update` 更新 gem 包\n- `$ gem update --system` 更新 gem 本身\n- `$ gem install [gem-package]` 安装 gem 包\n- `$ gem list` 列出所有安装的 gem 包\n- `$ gem remove [gem-package]` 删除安装过的 gem 包\n\n## 常用工具\n\n### cocoapods\n\n- `$ gem instal cocoapods` 安装 cocoapods\n- `$ pod setup` 初始化 Pod 库\n- `$ pod repo update` 更新 Pod 库\n- `$ pod install` 根据当前目录的 Podfile 文件安装 Pod 库\n- `$ pod update` 更新 Podfile 文件中的 Pod 库\n\n# Python\n\n## 版本管理工具 - pyenv\n\n# JavaScript\n\n## 包管理工具 - npm\n\n# 包管理工具 - brew\n\n- `brew update` 更新 pythpackage\n- `brew cleanup` 移除旧版本\n- `brew cleanup -n` 查看可以清理的旧版本\n- `brew list` 列出已安装的 package\n\nPrivacy Policy We take your privacy very seriously. This policy outlines how we collect, use, and protect your personal information. Information We Collect: We only collect analytical and crash data. This data includes information about how you use our app, device information, and crash reports. We use this data to improve the performance and stability of our app. How We Use Your Information: We use the data we collect to analyze user behavior and improve the performance of our app. We may also use this data to troubleshoot technical issues and improve user experience. How We Protect Your Information: We take appropriate security measures to protect your information from unauthorized access, disclosure, alteration, or destruction. We limit access to your information to those who need it to perform their job functions. We do not sell or share your personal information with third parties.\n","slug":"常用工具","published":0,"date":"2023-01-07T05:42:02.483Z","updated":"2023-04-02T11:15:08.224Z","_id":"cldr5xjce0003jbse58249kfv","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>此文章暂未完成….</p>\n</blockquote>\n<h1 id=\"Ruby\"><a href=\"#Ruby\" class=\"headerlink\" title=\"Ruby\"></a>Ruby</h1><h2 id=\"版本管理工具-rvm\"><a href=\"#版本管理工具-rvm\" class=\"headerlink\" title=\"版本管理工具 - rvm\"></a>版本管理工具 - rvm</h2><ul>\n<li><code>$ rvm list</code> 列出已安装的 ruby 版本</li>\n<li><code>$ rvm list kn=own</code> 显示 local + remote 的 ruby 版本</li>\n<li><code>$ rvm use [ruby-version]</code> 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本</li>\n<li><code>$ rvm remove [ruby-version]</code> 删除 ruby 版本</li>\n</ul>\n<h2 id=\"包管理工具-gem\"><a href=\"#包管理工具-gem\" class=\"headerlink\" title=\"包管理工具 - gem\"></a>包管理工具 - gem</h2><ul>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem update</code> 更新 gem 包</li>\n<li><code>$ gem update --system</code> 更新 gem 本身</li>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem list</code> 列出所有安装的 gem 包</li>\n<li><code>$ gem remove [gem-package]</code> 删除安装过的 gem 包</li>\n</ul>\n<h2 id=\"常用工具\"><a href=\"#常用工具\" class=\"headerlink\" title=\"常用工具\"></a>常用工具</h2><h3 id=\"cocoapods\"><a href=\"#cocoapods\" class=\"headerlink\" title=\"cocoapods\"></a>cocoapods</h3><ul>\n<li><code>$ gem instal cocoapods</code> 安装 cocoapods</li>\n<li><code>$ pod setup</code> 初始化 Pod 库</li>\n<li><code>$ pod repo update</code> 更新 Pod 库</li>\n<li><code>$ pod install</code> 根据当前目录的 Podfile 文件安装 Pod 库</li>\n<li><code>$ pod update</code> 更新 Podfile 文件中的 Pod 库</li>\n</ul>\n<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h2 id=\"版本管理工具-pyenv\"><a href=\"#版本管理工具-pyenv\" class=\"headerlink\" title=\"版本管理工具 - pyenv\"></a>版本管理工具 - pyenv</h2><h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><h2 id=\"包管理工具-npm\"><a href=\"#包管理工具-npm\" class=\"headerlink\" title=\"包管理工具 - npm\"></a>包管理工具 - npm</h2><h1 id=\"包管理工具-brew\"><a href=\"#包管理工具-brew\" class=\"headerlink\" title=\"包管理工具 - brew\"></a>包管理工具 - brew</h1><ul>\n<li><code>brew update</code> 更新 pythpackage</li>\n<li><code>brew cleanup</code> 移除旧版本</li>\n<li><code>brew cleanup -n</code> 查看可以清理的旧版本</li>\n<li><code>brew list</code> 列出已安装的 package</li>\n</ul>\n<p>Privacy Policy We take your privacy very seriously. This policy outlines how we collect, use, and protect your personal information. Information We Collect: We only collect analytical and crash data. This data includes information about how you use our app, device information, and crash reports. We use this data to improve the performance and stability of our app. How We Use Your Information: We use the data we collect to analyze user behavior and improve the performance of our app. We may also use this data to troubleshoot technical issues and improve user experience. How We Protect Your Information: We take appropriate security measures to protect your information from unauthorized access, disclosure, alteration, or destruction. We limit access to your information to those who need it to perform their job functions. We do not sell or share your personal information with third parties.</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>此文章暂未完成….</p>\n</blockquote>\n<h1 id=\"Ruby\"><a href=\"#Ruby\" class=\"headerlink\" title=\"Ruby\"></a>Ruby</h1><h2 id=\"版本管理工具-rvm\"><a href=\"#版本管理工具-rvm\" class=\"headerlink\" title=\"版本管理工具 - rvm\"></a>版本管理工具 - rvm</h2><ul>\n<li><code>$ rvm list</code> 列出已安装的 ruby 版本</li>\n<li><code>$ rvm list kn=own</code> 显示 local + remote 的 ruby 版本</li>\n<li><code>$ rvm use [ruby-version]</code> 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本</li>\n<li><code>$ rvm remove [ruby-version]</code> 删除 ruby 版本</li>\n</ul>\n<h2 id=\"包管理工具-gem\"><a href=\"#包管理工具-gem\" class=\"headerlink\" title=\"包管理工具 - gem\"></a>包管理工具 - gem</h2><ul>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem update</code> 更新 gem 包</li>\n<li><code>$ gem update --system</code> 更新 gem 本身</li>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem list</code> 列出所有安装的 gem 包</li>\n<li><code>$ gem remove [gem-package]</code> 删除安装过的 gem 包</li>\n</ul>\n<h2 id=\"常用工具\"><a href=\"#常用工具\" class=\"headerlink\" title=\"常用工具\"></a>常用工具</h2><h3 id=\"cocoapods\"><a href=\"#cocoapods\" class=\"headerlink\" title=\"cocoapods\"></a>cocoapods</h3><ul>\n<li><code>$ gem instal cocoapods</code> 安装 cocoapods</li>\n<li><code>$ pod setup</code> 初始化 Pod 库</li>\n<li><code>$ pod repo update</code> 更新 Pod 库</li>\n<li><code>$ pod install</code> 根据当前目录的 Podfile 文件安装 Pod 库</li>\n<li><code>$ pod update</code> 更新 Podfile 文件中的 Pod 库</li>\n</ul>\n<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h2 id=\"版本管理工具-pyenv\"><a href=\"#版本管理工具-pyenv\" class=\"headerlink\" title=\"版本管理工具 - pyenv\"></a>版本管理工具 - pyenv</h2><h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><h2 id=\"包管理工具-npm\"><a href=\"#包管理工具-npm\" class=\"headerlink\" title=\"包管理工具 - npm\"></a>包管理工具 - npm</h2><h1 id=\"包管理工具-brew\"><a href=\"#包管理工具-brew\" class=\"headerlink\" title=\"包管理工具 - brew\"></a>包管理工具 - brew</h1><ul>\n<li><code>brew update</code> 更新 pythpackage</li>\n<li><code>brew cleanup</code> 移除旧版本</li>\n<li><code>brew cleanup -n</code> 查看可以清理的旧版本</li>\n<li><code>brew list</code> 列出已安装的 package</li>\n</ul>\n<p>Privacy Policy We take your privacy very seriously. This policy outlines how we collect, use, and protect your personal information. Information We Collect: We only collect analytical and crash data. This data includes information about how you use our app, device information, and crash reports. We use this data to improve the performance and stability of our app. How We Use Your Information: We use the data we collect to analyze user behavior and improve the performance of our app. We may also use this data to troubleshoot technical issues and improve user experience. How We Protect Your Information: We take appropriate security measures to protect your information from unauthorized access, disclosure, alteration, or destruction. We limit access to your information to those who need it to perform their job functions. We do not sell or share your personal information with third parties.</p>\n"},{"title":"Raspberry PI 基本使用","date":"2018-03-05T22:04:56.000Z","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1507289872412-523fc6b2db5f?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=20ca9d0eba2016344894aec7bb453a2d&auto=format&fit=crop&w=160&q=100","_content":"\n\n## 1. 保证 Raspberry PI 能够在外网使用\n\n```sh\n// 在你的 Raspberry PI 上使用 autossh 来实现不掉线的反向代理：\nautossh -M 5678 -fNR 2018:localhost:22 root@54.219.12.213\n```\n\n```\n// 在你的外网服务器（比如上面例子中的：54.219.12.213）上可以使用 ssh 登录你的 Raspberry PI\nssh -p 2018 pi@127.0.0.1\n```\n\n","source":"_drafts/Raspberry-PI-基本使用.md","raw":"---\ntitle: Raspberry PI 基本使用\ndate: 2018-03-05 22:04:56 +0800\nauthor: 帕帕\ncategories: Raspberry PI\ntags: [Raspberry PI]\nthumbnail: https://images.unsplash.com/photo-1507289872412-523fc6b2db5f?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=20ca9d0eba2016344894aec7bb453a2d&auto=format&fit=crop&w=160&q=100\n---\n\n\n## 1. 保证 Raspberry PI 能够在外网使用\n\n```sh\n// 在你的 Raspberry PI 上使用 autossh 来实现不掉线的反向代理：\nautossh -M 5678 -fNR 2018:localhost:22 root@54.219.12.213\n```\n\n```\n// 在你的外网服务器（比如上面例子中的：54.219.12.213）上可以使用 ssh 登录你的 Raspberry PI\nssh -p 2018 pi@127.0.0.1\n```\n\n","slug":"Raspberry-PI-基本使用","published":0,"updated":"2023-01-07T05:42:02.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldr5xjcg0007jbse5zuxhbby","content":"<h2 id=\"1-保证-Raspberry-PI-能够在外网使用\"><a href=\"#1-保证-Raspberry-PI-能够在外网使用\" class=\"headerlink\" title=\"1. 保证 Raspberry PI 能够在外网使用\"></a>1. 保证 Raspberry PI 能够在外网使用</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在你的 Raspberry PI 上使用 autossh 来实现不掉线的反向代理：</span><br><span class=\"line\">autossh -M 5678 -fNR 2018:localhost:22 root@54.219.12.213</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在你的外网服务器（比如上面例子中的：54.219.12.213）上可以使用 ssh 登录你的 Raspberry PI</span><br><span class=\"line\">ssh -p 2018 pi@127.0.0.1</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-保证-Raspberry-PI-能够在外网使用\"><a href=\"#1-保证-Raspberry-PI-能够在外网使用\" class=\"headerlink\" title=\"1. 保证 Raspberry PI 能够在外网使用\"></a>1. 保证 Raspberry PI 能够在外网使用</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在你的 Raspberry PI 上使用 autossh 来实现不掉线的反向代理：</span><br><span class=\"line\">autossh -M 5678 -fNR 2018:localhost:22 root@54.219.12.213</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在你的外网服务器（比如上面例子中的：54.219.12.213）上可以使用 ssh 登录你的 Raspberry PI</span><br><span class=\"line\">ssh -p 2018 pi@127.0.0.1</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Notification 的一些知识点","date":"2018-11-05T17:55:26.000Z","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1514464750060-00e6e34c8b8c?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3749c47dd7beec20102c6b32fc19833a&auto=format&fit=crop&w=160&q=100","_content":"\n## 重复添加相同观察者\n\n我们先来看看日常开发中我们对 NSNotification 的正常用法，如下：\n```swift\n// 定义通知\nlet TestNotification = NSNotification.Name.init(\"com.papa.test\")\n\n// 测试类\nclass Test {\n\n    init() {\n        NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: TestNotification, object: nil)\n    }\n\n    // 注意\n    deinit {\n        NotificationCenter.default.removeObserver(self)\n    }\n\n    @objc func test(notification: Notification) {\n        print(\"Test\")\n    }\n}\n```\n\n但是如果我们在刚才代码中的 `init` 方法里面对同一个通知多次添加同一个观察者的话，会发生什么？\n```swift\ninit() {\n    NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: TestNotification, object: nil)\n    NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: TestNotification, object: nil)\n}\n\n// 发送 TestNotification 通知\nNotificationCenter.default.post(name: TestNotification, object: nil)\n```\n\n答案是会输出：\n```swift\nTest\nTest\n```\n\n所以我们要尽量避免重复添加观察者，因为这有可能会造成一些未知现象的发生。\n\n## 通知中的线程问题\n \n```swift\n// 定义通知\nlet ThreadNotification = NSNotification.Name.init(\"com.papa.thread\")\n\n// 测试类\nclass Test {\n\n    init() {\n        print(\"Add Observer: \\(Thread.current)\")\n        NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: ThreadNotification, object: nil)\n    }\n\n    // 注意\n    deinit {\n        NotificationCenter.default.removeObserver(self)\n    }\n\n    @objc func test(notification: Notification) {\n        print(\"Receive: \\(Thread.current)\")\n    }\n}\n\nDispatchQueue.init(label: \"com.ps.test.queue\").async {\n    print(\"Post: \\(Thread.current)\")\n    NotificationCenter.default.post(name: ThreadNotification, object: nil)\n}\n\n```\n\n我们来看看观察者是在什么线程上接受到通知的:\n```swift\nAdd Observer: <NSThread: 0x60000147d1c0>{number = 1, name = main}\nPost: <NSThread: 0x600001462640>{number = 3, name = (null)}\nReceive: <NSThread: 0x600001462640>{number = 3, name = (null)}\n```\n\n虽然我们是在主线程中去添加观察者，但是因为我们是在其他线程中去发送通知的，所以最后我们也是在其他线程中接收到通知的。\n\n## 通知中的阻塞问题\n\n```swift\n// 定义通知\nlet SleepNotification = NSNotification.Name.init(\"com.papa.sleep\")\n\n// 测试类\nclass Test {\n\n    init() {\n        NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: SleepNotification, object: nil)\n    }\n\n    // 注意\n    deinit {\n        NotificationCenter.default.removeObserver(self)\n    }\n\n    @objc func test(notification: Notification) {\n        sleep(3)\n    }\n}\n\nlet start = Date()\nNotificationCenter.default.post(name: SleepNotification, object: nil)\nlet end = Date()\nprint(\"相差：\\(end.timeIntervalSince(start))\")\n```\n\n我们可以看到最后相差时间大概是 `3s` ，通过上面的代码我们就知道单 NotificationCenter 去 post 一个通知的时候，它会等待观察者处理完改通知之后才会继续往后执行。所以平常使用过程中我们要注意 post 有可能会阻塞当前线程，特别是在主线程中。","source":"_posts/Notification-的一些知识点.md","raw":"---\ntitle: Notification 的一些知识点\ndate: 2018-11-05 17:55:26 +0800\nauthor: 帕帕\ncategories: 技术\ntags: [iOS]\nthumbnail: https://images.unsplash.com/photo-1514464750060-00e6e34c8b8c?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3749c47dd7beec20102c6b32fc19833a&auto=format&fit=crop&w=160&q=100\n---\n\n## 重复添加相同观察者\n\n我们先来看看日常开发中我们对 NSNotification 的正常用法，如下：\n```swift\n// 定义通知\nlet TestNotification = NSNotification.Name.init(\"com.papa.test\")\n\n// 测试类\nclass Test {\n\n    init() {\n        NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: TestNotification, object: nil)\n    }\n\n    // 注意\n    deinit {\n        NotificationCenter.default.removeObserver(self)\n    }\n\n    @objc func test(notification: Notification) {\n        print(\"Test\")\n    }\n}\n```\n\n但是如果我们在刚才代码中的 `init` 方法里面对同一个通知多次添加同一个观察者的话，会发生什么？\n```swift\ninit() {\n    NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: TestNotification, object: nil)\n    NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: TestNotification, object: nil)\n}\n\n// 发送 TestNotification 通知\nNotificationCenter.default.post(name: TestNotification, object: nil)\n```\n\n答案是会输出：\n```swift\nTest\nTest\n```\n\n所以我们要尽量避免重复添加观察者，因为这有可能会造成一些未知现象的发生。\n\n## 通知中的线程问题\n \n```swift\n// 定义通知\nlet ThreadNotification = NSNotification.Name.init(\"com.papa.thread\")\n\n// 测试类\nclass Test {\n\n    init() {\n        print(\"Add Observer: \\(Thread.current)\")\n        NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: ThreadNotification, object: nil)\n    }\n\n    // 注意\n    deinit {\n        NotificationCenter.default.removeObserver(self)\n    }\n\n    @objc func test(notification: Notification) {\n        print(\"Receive: \\(Thread.current)\")\n    }\n}\n\nDispatchQueue.init(label: \"com.ps.test.queue\").async {\n    print(\"Post: \\(Thread.current)\")\n    NotificationCenter.default.post(name: ThreadNotification, object: nil)\n}\n\n```\n\n我们来看看观察者是在什么线程上接受到通知的:\n```swift\nAdd Observer: <NSThread: 0x60000147d1c0>{number = 1, name = main}\nPost: <NSThread: 0x600001462640>{number = 3, name = (null)}\nReceive: <NSThread: 0x600001462640>{number = 3, name = (null)}\n```\n\n虽然我们是在主线程中去添加观察者，但是因为我们是在其他线程中去发送通知的，所以最后我们也是在其他线程中接收到通知的。\n\n## 通知中的阻塞问题\n\n```swift\n// 定义通知\nlet SleepNotification = NSNotification.Name.init(\"com.papa.sleep\")\n\n// 测试类\nclass Test {\n\n    init() {\n        NotificationCenter.default.addObserver(self, selector: #selector(Test.test(notification:)), name: SleepNotification, object: nil)\n    }\n\n    // 注意\n    deinit {\n        NotificationCenter.default.removeObserver(self)\n    }\n\n    @objc func test(notification: Notification) {\n        sleep(3)\n    }\n}\n\nlet start = Date()\nNotificationCenter.default.post(name: SleepNotification, object: nil)\nlet end = Date()\nprint(\"相差：\\(end.timeIntervalSince(start))\")\n```\n\n我们可以看到最后相差时间大概是 `3s` ，通过上面的代码我们就知道单 NotificationCenter 去 post 一个通知的时候，它会等待观察者处理完改通知之后才会继续往后执行。所以平常使用过程中我们要注意 post 有可能会阻塞当前线程，特别是在主线程中。","slug":"Notification-的一些知识点","published":1,"updated":"2023-01-07T05:42:02.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldr5xjch0009jbseddmp63iu","content":"<h2 id=\"重复添加相同观察者\"><a href=\"#重复添加相同观察者\" class=\"headerlink\" title=\"重复添加相同观察者\"></a>重复添加相同观察者</h2><p>我们先来看看日常开发中我们对 NSNotification 的正常用法，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义通知</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">TestNotification</span> <span class=\"operator\">=</span> <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>.<span class=\"keyword\">init</span>(<span class=\"string\">&quot;com.papa.test&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">TestNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注意</span></span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">func</span> <span class=\"title function_\">test</span>(<span class=\"params\">notification</span>: <span class=\"type\">Notification</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Test&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是如果我们在刚才代码中的 <code>init</code> 方法里面对同一个通知多次添加同一个观察者的话，会发生什么？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">TestNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">TestNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送 TestNotification 通知</span></span><br><span class=\"line\"><span class=\"type\">NotificationCenter</span>.default.post(name: <span class=\"type\">TestNotification</span>, object: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n\n<p>答案是会输出：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Test</span></span><br><span class=\"line\"><span class=\"type\">Test</span></span><br></pre></td></tr></table></figure>\n\n<p>所以我们要尽量避免重复添加观察者，因为这有可能会造成一些未知现象的发生。</p>\n<h2 id=\"通知中的线程问题\"><a href=\"#通知中的线程问题\" class=\"headerlink\" title=\"通知中的线程问题\"></a>通知中的线程问题</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义通知</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">ThreadNotification</span> <span class=\"operator\">=</span> <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>.<span class=\"keyword\">init</span>(<span class=\"string\">&quot;com.papa.thread&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Add Observer: <span class=\"subst\">\\(Thread.current)</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">ThreadNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注意</span></span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">func</span> <span class=\"title function_\">test</span>(<span class=\"params\">notification</span>: <span class=\"type\">Notification</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Receive: <span class=\"subst\">\\(Thread.current)</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">DispatchQueue</span>.<span class=\"keyword\">init</span>(label: <span class=\"string\">&quot;com.ps.test.queue&quot;</span>).async &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Post: <span class=\"subst\">\\(Thread.current)</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.default.post(name: <span class=\"type\">ThreadNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们来看看观察者是在什么线程上接受到通知的:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Add</span> <span class=\"type\">Observer</span>: <span class=\"operator\">&lt;</span><span class=\"type\">NSThread</span>: <span class=\"number\">0x60000147d1c0</span><span class=\"operator\">&gt;</span>&#123;number <span class=\"operator\">=</span> <span class=\"number\">1</span>, name <span class=\"operator\">=</span> main&#125;</span><br><span class=\"line\"><span class=\"type\">Post</span>: <span class=\"operator\">&lt;</span><span class=\"type\">NSThread</span>: <span class=\"number\">0x600001462640</span><span class=\"operator\">&gt;</span>&#123;number <span class=\"operator\">=</span> <span class=\"number\">3</span>, name <span class=\"operator\">=</span> (null)&#125;</span><br><span class=\"line\"><span class=\"type\">Receive</span>: <span class=\"operator\">&lt;</span><span class=\"type\">NSThread</span>: <span class=\"number\">0x600001462640</span><span class=\"operator\">&gt;</span>&#123;number <span class=\"operator\">=</span> <span class=\"number\">3</span>, name <span class=\"operator\">=</span> (null)&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然我们是在主线程中去添加观察者，但是因为我们是在其他线程中去发送通知的，所以最后我们也是在其他线程中接收到通知的。</p>\n<h2 id=\"通知中的阻塞问题\"><a href=\"#通知中的阻塞问题\" class=\"headerlink\" title=\"通知中的阻塞问题\"></a>通知中的阻塞问题</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义通知</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">SleepNotification</span> <span class=\"operator\">=</span> <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>.<span class=\"keyword\">init</span>(<span class=\"string\">&quot;com.papa.sleep&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">SleepNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注意</span></span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">func</span> <span class=\"title function_\">test</span>(<span class=\"params\">notification</span>: <span class=\"type\">Notification</span>) &#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">3</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> start <span class=\"operator\">=</span> <span class=\"type\">Date</span>()</span><br><span class=\"line\"><span class=\"type\">NotificationCenter</span>.default.post(name: <span class=\"type\">SleepNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> end <span class=\"operator\">=</span> <span class=\"type\">Date</span>()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;相差：<span class=\"subst\">\\(end.timeIntervalSince(start))</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到最后相差时间大概是 <code>3s</code> ，通过上面的代码我们就知道单 NotificationCenter 去 post 一个通知的时候，它会等待观察者处理完改通知之后才会继续往后执行。所以平常使用过程中我们要注意 post 有可能会阻塞当前线程，特别是在主线程中。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"重复添加相同观察者\"><a href=\"#重复添加相同观察者\" class=\"headerlink\" title=\"重复添加相同观察者\"></a>重复添加相同观察者</h2><p>我们先来看看日常开发中我们对 NSNotification 的正常用法，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义通知</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">TestNotification</span> <span class=\"operator\">=</span> <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>.<span class=\"keyword\">init</span>(<span class=\"string\">&quot;com.papa.test&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">TestNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注意</span></span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">func</span> <span class=\"title function_\">test</span>(<span class=\"params\">notification</span>: <span class=\"type\">Notification</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Test&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是如果我们在刚才代码中的 <code>init</code> 方法里面对同一个通知多次添加同一个观察者的话，会发生什么？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">TestNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">TestNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送 TestNotification 通知</span></span><br><span class=\"line\"><span class=\"type\">NotificationCenter</span>.default.post(name: <span class=\"type\">TestNotification</span>, object: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n\n<p>答案是会输出：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Test</span></span><br><span class=\"line\"><span class=\"type\">Test</span></span><br></pre></td></tr></table></figure>\n\n<p>所以我们要尽量避免重复添加观察者，因为这有可能会造成一些未知现象的发生。</p>\n<h2 id=\"通知中的线程问题\"><a href=\"#通知中的线程问题\" class=\"headerlink\" title=\"通知中的线程问题\"></a>通知中的线程问题</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义通知</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">ThreadNotification</span> <span class=\"operator\">=</span> <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>.<span class=\"keyword\">init</span>(<span class=\"string\">&quot;com.papa.thread&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Add Observer: <span class=\"subst\">\\(Thread.current)</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">ThreadNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注意</span></span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">func</span> <span class=\"title function_\">test</span>(<span class=\"params\">notification</span>: <span class=\"type\">Notification</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Receive: <span class=\"subst\">\\(Thread.current)</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">DispatchQueue</span>.<span class=\"keyword\">init</span>(label: <span class=\"string\">&quot;com.ps.test.queue&quot;</span>).async &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Post: <span class=\"subst\">\\(Thread.current)</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"type\">NotificationCenter</span>.default.post(name: <span class=\"type\">ThreadNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们来看看观察者是在什么线程上接受到通知的:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Add</span> <span class=\"type\">Observer</span>: <span class=\"operator\">&lt;</span><span class=\"type\">NSThread</span>: <span class=\"number\">0x60000147d1c0</span><span class=\"operator\">&gt;</span>&#123;number <span class=\"operator\">=</span> <span class=\"number\">1</span>, name <span class=\"operator\">=</span> main&#125;</span><br><span class=\"line\"><span class=\"type\">Post</span>: <span class=\"operator\">&lt;</span><span class=\"type\">NSThread</span>: <span class=\"number\">0x600001462640</span><span class=\"operator\">&gt;</span>&#123;number <span class=\"operator\">=</span> <span class=\"number\">3</span>, name <span class=\"operator\">=</span> (null)&#125;</span><br><span class=\"line\"><span class=\"type\">Receive</span>: <span class=\"operator\">&lt;</span><span class=\"type\">NSThread</span>: <span class=\"number\">0x600001462640</span><span class=\"operator\">&gt;</span>&#123;number <span class=\"operator\">=</span> <span class=\"number\">3</span>, name <span class=\"operator\">=</span> (null)&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然我们是在主线程中去添加观察者，但是因为我们是在其他线程中去发送通知的，所以最后我们也是在其他线程中接收到通知的。</p>\n<h2 id=\"通知中的阻塞问题\"><a href=\"#通知中的阻塞问题\" class=\"headerlink\" title=\"通知中的阻塞问题\"></a>通知中的阻塞问题</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义通知</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">SleepNotification</span> <span class=\"operator\">=</span> <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>.<span class=\"keyword\">init</span>(<span class=\"string\">&quot;com.papa.sleep&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.addObserver(<span class=\"keyword\">self</span>, selector: <span class=\"keyword\">#selector</span>(<span class=\"type\">Test</span>.test(notification:)), name: <span class=\"type\">SleepNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注意</span></span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NotificationCenter</span>.default.removeObserver(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">func</span> <span class=\"title function_\">test</span>(<span class=\"params\">notification</span>: <span class=\"type\">Notification</span>) &#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">3</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> start <span class=\"operator\">=</span> <span class=\"type\">Date</span>()</span><br><span class=\"line\"><span class=\"type\">NotificationCenter</span>.default.post(name: <span class=\"type\">SleepNotification</span>, object: <span class=\"literal\">nil</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> end <span class=\"operator\">=</span> <span class=\"type\">Date</span>()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;相差：<span class=\"subst\">\\(end.timeIntervalSince(start))</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到最后相差时间大概是 <code>3s</code> ，通过上面的代码我们就知道单 NotificationCenter 去 post 一个通知的时候，它会等待观察者处理完改通知之后才会继续往后执行。所以平常使用过程中我们要注意 post 有可能会阻塞当前线程，特别是在主线程中。</p>\n"},{"layout":"post","title":"RAC 和内存管理","author":"帕帕","date":"2017-09-05T15:30:56.000Z","thumbnail":"https://images.unsplash.com/photo-1517077304055-6e89abbf09b0?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3f799bed83db2959c476e69a3307d39e&auto=format&fit=crop&w=160&q=100","_content":"\n最近在用 RAC 的时候发现自己对内存管理还是有些困惑，于是自己写了一些代码来验证自己的一些理解。\n在一开始接触 RAC 的时候，我们知道 RAC 对于 block 都是 copy 赋值的。\n\n```Swift\n@implementation RACSignal\n\n#pragma mark Lifecycle\n\n+ (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe {\n    return [RACDynamicSignal createSignal:didSubscribe];\n}\n```\n\n```Swift\n@implementation RACDynamicSignal\n\n#pragma mark Lifecycle\n\n+ (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe {\n    RACDynamicSignal *signal = [[self alloc] init];\n    signal->_didSubscribe = [didSubscribe copy];\n    return [signal setNameWithFormat:@\"+createSignal:\"];\n}\n```\n\n在创建 RACSingal 的时候会调用其子类 RACDynamicSignal 去创建，我们也看到 RACDynamicSignal 对 didSuscribe 这个 block 是进行了 copy。所以大家可能会被要求注意循环引用的问题，于是大家都用 @weakify(target) 和 @strongify(target) 来避免循环引用的问题。那是不是所有用到 RAC 的地方都需要使用这些宏来避免循环引用的问题，不尽然。比如下面这个：\n\n```Swift\n// 场景1\n[RACObserve(self, title) subscribeNext:^(id x) {\n    NSLog(@\"%@\", x);\n}];\n```\n\n接下来，我们来对比以下的几种用法：\n\n```Swift\n@interface ViewController()\n@property (strong, nonatomic) ViewModel * viewModel;\n@end\n\n@implementation ViewController\n\n- (void)viewDidiLoad {\n    [super viewDidLoad];\n\n    self.viewModel = [ViewModel new];\n\n    // 场景2\n    dispatch_async(dispatch_get_main_queue(), ^{\n        self.title = @\"你好\";\n    });\n\n    // 场景3\n    [self.viewModel.titleSignal subscribeNext:^(NSString * title) {\n        self.title = title;\n    }];\n\n    // 场景4\n    [RACObserve(self.viewModel, title) subscribeNext:^(NSString * title)     {\n        self.title = title;\n    }]; \n}\n\n@end\n```\n\n场景2是我们平常都会用到的，而且我们也没有在这种场景下去考虑循环引用的问题，这是因为 dispatch 的 block 不是属于 self 的（至于这个 block 是属于谁的，回头我再查点资料或者请各位指教），所以即使你在 block 使用了 self 也不会有循环应用的问题。\n\n场景3很明显是有循环引用的问题：**self->viewModel->titleSignal->block->self**，这个时候如果我们不做处理的话，那么 self 就永远不会被释放。正确的做法应该是使用 @weakify(self) 和 @strongify(self)：\n\n```Swift\n// 场景3\n@weakify(self);\n[self.viewModel.titleSignal subscribeNext:^(NSString * title) {\n    @strongify(self);\n    self.title = title;\n}];\n```\n\n场景4在我们看来是没有问题的，因为这里看起来只有 **singal->block->self** 的引用，它们之间并没有造成循环引用的问题。我们先来看看 RACObserve 的实现：\n\n```Swift\n#define RACObserve(TARGET, KEYPATH) \\\n({ \\\n_Pragma(\"clang diagnostic push\") \\\n_Pragma(\"clang diagnostic ignored \\\"-Wreceiver-is-weak\\\"\") \\\n__weak id target_ = (TARGET); \\\n[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \\\n_Pragma(\"clang diagnostic pop\") \\\n})\n\n- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak NSObject *)observer;\n```\n\n其实，看到这里你会认为这里只是调用了一个方法创建了一个 Signal，而且这个 Signal 也并不属于任何对象。我们再来看看具体的实现是怎么样的？\n\n```Swift\n- (RACSignal *)rac_valuesAndChangesForKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options observer:(__weak NSObject *)weakObserver {\n    NSObject *strongObserver = weakObserver;\n    keyPath = [keyPath copy];\n\n    NSRecursiveLock *objectLock = [[NSRecursiveLock alloc] init];\n    objectLock.name = @\"org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing\";\n\n    __weak NSObject *weakSelf = self;\n\n    RACSignal *deallocSignal = [[RACSignal zip:@[\n                            self.rac_willDeallocSignal,\n                            strongObserver.rac_willDeallocSignal ?: [RACSignal never]\n    ]] doCompleted:^{\n        // Forces deallocation to wait if the object variables are currently\n        // being read on another thread.\n        [objectLock lock];\n        @onExit {\n            [objectLock unlock];\n        };\n    }];\n\n    return [[[RACSignal createSignal:^ RACDisposable * (id<RACSubscriber> subscriber) {\n        // Hold onto the lock the whole time we're setting up the KVO\n        // observation, because any resurrection that might be caused by our\n        // retaining below must be balanced out by the time -dealloc returns\n        // (if another thread is waiting on the lock above).\n        [objectLock lock];\n        @onExit {\n            [objectLock unlock];\n        };\n    \n        __strong NSObject *observer __attribute__((objc_precise_lifetime)) = weakObserver;\n        __strong NSObject *self __attribute__((objc_precise_lifetime)) = weakSelf;\n    \n        if (self == nil) {\n            [subscriber sendCompleted];\n            return nil;\n        }\n    \n        return [self rac_observeKeyPath:keyPath options:options observer:observer block:^(id value, NSDictionary *change, BOOL causedByDealloc, BOOL affectedOnlyLastComponent) {\n                [subscriber sendNext:RACTuplePack(value, change)];\n        }];\n    }] takeUntil:deallocSignal] setNameWithFormat:@\"%@ -rac_valueAndChangesForKeyPath: %@ options: %lu observer: %@\", self.rac_description, keyPath, (unsigned long)options, strongObserver.rac_description];\n}\n```\n\n重点观察 **deallocSignal** 和 **[signal takeUntile:deallocSignal]**，我们把 deallocSignal 单独拿出来看看：\n\n```Swift\nRACSignal *deallocSignal = [[RACSignal zip:@[\n                        self.rac_willDeallocSignal,\n                        strongObserver.rac_willDeallocSignal ?: [RACSignal never]\n                        ]] doCompleted:^{\n    // Forces deallocation to wait if the object variables are currently\n    // being read on another thread.\n    [objectLock lock];\n    @onExit {\n    [objectLock unlock];\n    };\n}];\n```\n\n这里的 deallocSignal 是只有在 self 和 strongObserve 都将要发生 dealloc 的时候才会触发的。即用 RACObserve 创建的信号只有在其 target 和 observe 都发生 dealloc 的时候才会被 disposable (这个好像是 RAC 用来销毁自己资源的东西)。不明白的童鞋，我们回头来分析一下场景4的代码：\n\n```Swift\n// 场景4\n[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) {\n    self.title = title;\n}];\n```\n\n用 RACObserve 创建的信号看起来只要出了函数体其资源应该就会被回收，但是这个信号其实是只有在 self.viewModel.rac_willDeallocSignal 和 self.rac_willDeallocSignal 都发生的情况下才会被释放。所以场景4的引用关系看起来只有 signal->block->self，但是这个 signal 只有在 self.rac_willDeallocSignal 的时候才会被释放。所以这里如果不打断这种关系的话就会造成循环引用的问题，正确做法应该是：\n\n```Swift\n// 场景4\n@weakify(self);\n[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) {\n    @strongify(self);\n    self.title = title;\n}];\n```\n\n最后，在说一个特别需要注意的，就是 UITableViewCell 和 UICollectionViewCell 复用和 RAC 的问题。\n\n```Swift\n- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return 1000;\n}\n\n- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath {\n    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"TableViewCell\"];\n\n    @weakify(self);\n    [RACObserve(cell.textLabel, text) subscribeNext:^(id x) {\n        @strongify(self);\n        NSLog(@\"%@\", self);\n    }];\n\n    return cell;\n}\n```\n\n我们看到这里的 RACObserve 创建的 Signal 和 self 之间已经去掉了循环引用的问题，所以应该是没有什么问题的。但是结合之前我们对 RACObserve 的理解再仔细分析一下，这里的 Signal 只要 self 没有被 dealloc 的话就不会被释放。虽然每次 UITableViewCell 都会被重用，但是每次重用过程中创建的信号确实无法被 disposable。那我们该怎么做呢？\n\n```Swift\n- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return 1000;\n}\n\n- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath {\n    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"TableViewCell\"];\n\n    @weakify(self);\n    [[RACObserve(cell.textLabel, text) takeUntil:cell.rac_prepareForReuseSignal] subscribeNext:^(id x) {\n        @strongify(self);\n        NSLog(@\"%@\", self);\n    }];\n\n    return cell;\n}\n```\n\n注意，我们在cell里面创建的信号加上 takeUntil:cell.rac_prepareForReuseSignal，这个是让 cell 在每次重用的时候都去 disposable 创建的信号。\n\n以上所说的关于内存的东西我都用 Instrument 的 Allocations 验证过了，但是依旧建议大家自己也去试试。\n\n\n","source":"_posts/RAC和内存管理.md","raw":"---\nlayout: post \ntitle: RAC 和内存管理\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: 技术\ntags: [iOS, RAC]\nthumbnail: https://images.unsplash.com/photo-1517077304055-6e89abbf09b0?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3f799bed83db2959c476e69a3307d39e&auto=format&fit=crop&w=160&q=100\n---\n\n最近在用 RAC 的时候发现自己对内存管理还是有些困惑，于是自己写了一些代码来验证自己的一些理解。\n在一开始接触 RAC 的时候，我们知道 RAC 对于 block 都是 copy 赋值的。\n\n```Swift\n@implementation RACSignal\n\n#pragma mark Lifecycle\n\n+ (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe {\n    return [RACDynamicSignal createSignal:didSubscribe];\n}\n```\n\n```Swift\n@implementation RACDynamicSignal\n\n#pragma mark Lifecycle\n\n+ (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe {\n    RACDynamicSignal *signal = [[self alloc] init];\n    signal->_didSubscribe = [didSubscribe copy];\n    return [signal setNameWithFormat:@\"+createSignal:\"];\n}\n```\n\n在创建 RACSingal 的时候会调用其子类 RACDynamicSignal 去创建，我们也看到 RACDynamicSignal 对 didSuscribe 这个 block 是进行了 copy。所以大家可能会被要求注意循环引用的问题，于是大家都用 @weakify(target) 和 @strongify(target) 来避免循环引用的问题。那是不是所有用到 RAC 的地方都需要使用这些宏来避免循环引用的问题，不尽然。比如下面这个：\n\n```Swift\n// 场景1\n[RACObserve(self, title) subscribeNext:^(id x) {\n    NSLog(@\"%@\", x);\n}];\n```\n\n接下来，我们来对比以下的几种用法：\n\n```Swift\n@interface ViewController()\n@property (strong, nonatomic) ViewModel * viewModel;\n@end\n\n@implementation ViewController\n\n- (void)viewDidiLoad {\n    [super viewDidLoad];\n\n    self.viewModel = [ViewModel new];\n\n    // 场景2\n    dispatch_async(dispatch_get_main_queue(), ^{\n        self.title = @\"你好\";\n    });\n\n    // 场景3\n    [self.viewModel.titleSignal subscribeNext:^(NSString * title) {\n        self.title = title;\n    }];\n\n    // 场景4\n    [RACObserve(self.viewModel, title) subscribeNext:^(NSString * title)     {\n        self.title = title;\n    }]; \n}\n\n@end\n```\n\n场景2是我们平常都会用到的，而且我们也没有在这种场景下去考虑循环引用的问题，这是因为 dispatch 的 block 不是属于 self 的（至于这个 block 是属于谁的，回头我再查点资料或者请各位指教），所以即使你在 block 使用了 self 也不会有循环应用的问题。\n\n场景3很明显是有循环引用的问题：**self->viewModel->titleSignal->block->self**，这个时候如果我们不做处理的话，那么 self 就永远不会被释放。正确的做法应该是使用 @weakify(self) 和 @strongify(self)：\n\n```Swift\n// 场景3\n@weakify(self);\n[self.viewModel.titleSignal subscribeNext:^(NSString * title) {\n    @strongify(self);\n    self.title = title;\n}];\n```\n\n场景4在我们看来是没有问题的，因为这里看起来只有 **singal->block->self** 的引用，它们之间并没有造成循环引用的问题。我们先来看看 RACObserve 的实现：\n\n```Swift\n#define RACObserve(TARGET, KEYPATH) \\\n({ \\\n_Pragma(\"clang diagnostic push\") \\\n_Pragma(\"clang diagnostic ignored \\\"-Wreceiver-is-weak\\\"\") \\\n__weak id target_ = (TARGET); \\\n[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \\\n_Pragma(\"clang diagnostic pop\") \\\n})\n\n- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak NSObject *)observer;\n```\n\n其实，看到这里你会认为这里只是调用了一个方法创建了一个 Signal，而且这个 Signal 也并不属于任何对象。我们再来看看具体的实现是怎么样的？\n\n```Swift\n- (RACSignal *)rac_valuesAndChangesForKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options observer:(__weak NSObject *)weakObserver {\n    NSObject *strongObserver = weakObserver;\n    keyPath = [keyPath copy];\n\n    NSRecursiveLock *objectLock = [[NSRecursiveLock alloc] init];\n    objectLock.name = @\"org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing\";\n\n    __weak NSObject *weakSelf = self;\n\n    RACSignal *deallocSignal = [[RACSignal zip:@[\n                            self.rac_willDeallocSignal,\n                            strongObserver.rac_willDeallocSignal ?: [RACSignal never]\n    ]] doCompleted:^{\n        // Forces deallocation to wait if the object variables are currently\n        // being read on another thread.\n        [objectLock lock];\n        @onExit {\n            [objectLock unlock];\n        };\n    }];\n\n    return [[[RACSignal createSignal:^ RACDisposable * (id<RACSubscriber> subscriber) {\n        // Hold onto the lock the whole time we're setting up the KVO\n        // observation, because any resurrection that might be caused by our\n        // retaining below must be balanced out by the time -dealloc returns\n        // (if another thread is waiting on the lock above).\n        [objectLock lock];\n        @onExit {\n            [objectLock unlock];\n        };\n    \n        __strong NSObject *observer __attribute__((objc_precise_lifetime)) = weakObserver;\n        __strong NSObject *self __attribute__((objc_precise_lifetime)) = weakSelf;\n    \n        if (self == nil) {\n            [subscriber sendCompleted];\n            return nil;\n        }\n    \n        return [self rac_observeKeyPath:keyPath options:options observer:observer block:^(id value, NSDictionary *change, BOOL causedByDealloc, BOOL affectedOnlyLastComponent) {\n                [subscriber sendNext:RACTuplePack(value, change)];\n        }];\n    }] takeUntil:deallocSignal] setNameWithFormat:@\"%@ -rac_valueAndChangesForKeyPath: %@ options: %lu observer: %@\", self.rac_description, keyPath, (unsigned long)options, strongObserver.rac_description];\n}\n```\n\n重点观察 **deallocSignal** 和 **[signal takeUntile:deallocSignal]**，我们把 deallocSignal 单独拿出来看看：\n\n```Swift\nRACSignal *deallocSignal = [[RACSignal zip:@[\n                        self.rac_willDeallocSignal,\n                        strongObserver.rac_willDeallocSignal ?: [RACSignal never]\n                        ]] doCompleted:^{\n    // Forces deallocation to wait if the object variables are currently\n    // being read on another thread.\n    [objectLock lock];\n    @onExit {\n    [objectLock unlock];\n    };\n}];\n```\n\n这里的 deallocSignal 是只有在 self 和 strongObserve 都将要发生 dealloc 的时候才会触发的。即用 RACObserve 创建的信号只有在其 target 和 observe 都发生 dealloc 的时候才会被 disposable (这个好像是 RAC 用来销毁自己资源的东西)。不明白的童鞋，我们回头来分析一下场景4的代码：\n\n```Swift\n// 场景4\n[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) {\n    self.title = title;\n}];\n```\n\n用 RACObserve 创建的信号看起来只要出了函数体其资源应该就会被回收，但是这个信号其实是只有在 self.viewModel.rac_willDeallocSignal 和 self.rac_willDeallocSignal 都发生的情况下才会被释放。所以场景4的引用关系看起来只有 signal->block->self，但是这个 signal 只有在 self.rac_willDeallocSignal 的时候才会被释放。所以这里如果不打断这种关系的话就会造成循环引用的问题，正确做法应该是：\n\n```Swift\n// 场景4\n@weakify(self);\n[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) {\n    @strongify(self);\n    self.title = title;\n}];\n```\n\n最后，在说一个特别需要注意的，就是 UITableViewCell 和 UICollectionViewCell 复用和 RAC 的问题。\n\n```Swift\n- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return 1000;\n}\n\n- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath {\n    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"TableViewCell\"];\n\n    @weakify(self);\n    [RACObserve(cell.textLabel, text) subscribeNext:^(id x) {\n        @strongify(self);\n        NSLog(@\"%@\", self);\n    }];\n\n    return cell;\n}\n```\n\n我们看到这里的 RACObserve 创建的 Signal 和 self 之间已经去掉了循环引用的问题，所以应该是没有什么问题的。但是结合之前我们对 RACObserve 的理解再仔细分析一下，这里的 Signal 只要 self 没有被 dealloc 的话就不会被释放。虽然每次 UITableViewCell 都会被重用，但是每次重用过程中创建的信号确实无法被 disposable。那我们该怎么做呢？\n\n```Swift\n- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return 1000;\n}\n\n- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath {\n    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"TableViewCell\"];\n\n    @weakify(self);\n    [[RACObserve(cell.textLabel, text) takeUntil:cell.rac_prepareForReuseSignal] subscribeNext:^(id x) {\n        @strongify(self);\n        NSLog(@\"%@\", self);\n    }];\n\n    return cell;\n}\n```\n\n注意，我们在cell里面创建的信号加上 takeUntil:cell.rac_prepareForReuseSignal，这个是让 cell 在每次重用的时候都去 disposable 创建的信号。\n\n以上所说的关于内存的东西我都用 Instrument 的 Allocations 验证过了，但是依旧建议大家自己也去试试。\n\n\n","slug":"RAC和内存管理","published":1,"updated":"2023-01-07T05:42:02.483Z","comments":1,"photos":[],"link":"","_id":"cldr5xjci000djbse2k2udjma","content":"<p>最近在用 RAC 的时候发现自己对内存管理还是有些困惑，于是自己写了一些代码来验证自己的一些理解。<br>在一开始接触 RAC 的时候，我们知道 RAC 对于 block 都是 copy 赋值的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@implementation</span> <span class=\"type\">RACSignal</span></span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark <span class=\"type\">Lifecycle</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">+</span> (<span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>)createSignal:(<span class=\"type\">RACDisposable</span> <span class=\"operator\">*</span> (<span class=\"operator\">^</span>)(id<span class=\"operator\">&lt;</span><span class=\"type\">RACSubscriber</span><span class=\"operator\">&gt;</span> subscriber))didSubscribe &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"type\">RACDynamicSignal</span> createSignal:didSubscribe];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@implementation</span> <span class=\"type\">RACDynamicSignal</span></span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark <span class=\"type\">Lifecycle</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">+</span> (<span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>)createSignal:(<span class=\"type\">RACDisposable</span> <span class=\"operator\">*</span> (<span class=\"operator\">^</span>)(id<span class=\"operator\">&lt;</span><span class=\"type\">RACSubscriber</span><span class=\"operator\">&gt;</span> subscriber))didSubscribe &#123;</span><br><span class=\"line\">    <span class=\"type\">RACDynamicSignal</span> <span class=\"operator\">*</span>signal <span class=\"operator\">=</span> [[<span class=\"keyword\">self</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    signal-&gt;_didSubscribe <span class=\"operator\">=</span> [didSubscribe copy];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [signal setNameWithFormat:@<span class=\"string\">&quot;+createSignal:&quot;</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在创建 RACSingal 的时候会调用其子类 RACDynamicSignal 去创建，我们也看到 RACDynamicSignal 对 didSuscribe 这个 block 是进行了 copy。所以大家可能会被要求注意循环引用的问题，于是大家都用 @weakify(target) 和 @strongify(target) 来避免循环引用的问题。那是不是所有用到 RAC 的地方都需要使用这些宏来避免循环引用的问题，不尽然。比如下面这个：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 场景1</span></span><br><span class=\"line\">[<span class=\"type\">RACObserve</span>(<span class=\"keyword\">self</span>, title) subscribeNext:<span class=\"operator\">^</span>(id x) &#123;</span><br><span class=\"line\">    <span class=\"type\">NSLog</span>(@<span class=\"string\">&quot;%@&quot;</span>, x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们来对比以下的几种用法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@interface</span> <span class=\"type\">ViewController</span>()</span><br><span class=\"line\"><span class=\"meta\">@property</span> (strong, nonatomic) <span class=\"type\">ViewModel</span> <span class=\"operator\">*</span> viewModel;</span><br><span class=\"line\"><span class=\"meta\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@implementation</span> <span class=\"type\">ViewController</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> (void)viewDidiLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.viewModel <span class=\"operator\">=</span> [<span class=\"type\">ViewModel</span> new];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 场景2</span></span><br><span class=\"line\">    dispatch_async(dispatch_get_main_queue(), <span class=\"operator\">^</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> @<span class=\"string\">&quot;你好&quot;</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 场景3</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.viewModel.titleSignal subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 场景4</span></span><br><span class=\"line\">    [<span class=\"type\">RACObserve</span>(<span class=\"keyword\">self</span>.viewModel, title) subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title)     &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">    &#125;]; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>场景2是我们平常都会用到的，而且我们也没有在这种场景下去考虑循环引用的问题，这是因为 dispatch 的 block 不是属于 self 的（至于这个 block 是属于谁的，回头我再查点资料或者请各位指教），所以即使你在 block 使用了 self 也不会有循环应用的问题。</p>\n<p>场景3很明显是有循环引用的问题：<strong>self-&gt;viewModel-&gt;titleSignal-&gt;block-&gt;self</strong>，这个时候如果我们不做处理的话，那么 self 就永远不会被释放。正确的做法应该是使用 @weakify(self) 和 @strongify(self)：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 场景3</span></span><br><span class=\"line\"><span class=\"meta\">@weakify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.viewModel.titleSignal subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@strongify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>场景4在我们看来是没有问题的，因为这里看起来只有 <strong>singal-&gt;block-&gt;self</strong> 的引用，它们之间并没有造成循环引用的问题。我们先来看看 RACObserve 的实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define <span class=\"type\">RACObserve</span>(<span class=\"type\">TARGET</span>, <span class=\"type\">KEYPATH</span>) \\</span><br><span class=\"line\">(&#123; \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">&quot;clang diagnostic push&quot;</span>) \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">&quot;clang diagnostic ignored <span class=\"subst\">\\&quot;</span>-Wreceiver-is-weak<span class=\"subst\">\\&quot;</span>&quot;</span>) \\</span><br><span class=\"line\">__weak id target_ <span class=\"operator\">=</span> (<span class=\"type\">TARGET</span>); \\</span><br><span class=\"line\">[target_ rac_valuesForKeyPath:<span class=\"meta\">@keypath</span>(<span class=\"type\">TARGET</span>, <span class=\"type\">KEYPATH</span>) observer:<span class=\"keyword\">self</span>]; \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">&quot;clang diagnostic pop&quot;</span>) \\</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>)rac_valuesForKeyPath:(<span class=\"type\">NSString</span> <span class=\"operator\">*</span>)keyPath observer:(__weak <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>)observer;</span><br></pre></td></tr></table></figure>\n\n<p>其实，看到这里你会认为这里只是调用了一个方法创建了一个 Signal，而且这个 Signal 也并不属于任何对象。我们再来看看具体的实现是怎么样的？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>)rac_valuesAndChangesForKeyPath:(<span class=\"type\">NSString</span> <span class=\"operator\">*</span>)keyPath options:(<span class=\"type\">NSKeyValueObservingOptions</span>)options observer:(__weak <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>)weakObserver &#123;</span><br><span class=\"line\">    <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>strongObserver <span class=\"operator\">=</span> weakObserver;</span><br><span class=\"line\">    keyPath <span class=\"operator\">=</span> [keyPath copy];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">NSRecursiveLock</span> <span class=\"operator\">*</span>objectLock <span class=\"operator\">=</span> [[<span class=\"type\">NSRecursiveLock</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    objectLock.name <span class=\"operator\">=</span> @<span class=\"string\">&quot;org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    __weak <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>weakSelf <span class=\"operator\">=</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>deallocSignal <span class=\"operator\">=</span> [[<span class=\"type\">RACSignal</span> zip:@[</span><br><span class=\"line\">                            <span class=\"keyword\">self</span>.rac_willDeallocSignal,</span><br><span class=\"line\">                            strongObserver.rac_willDeallocSignal <span class=\"operator\">?</span>: [<span class=\"type\">RACSignal</span> never]</span><br><span class=\"line\">    ]] doCompleted:<span class=\"operator\">^</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Forces deallocation to wait if the object variables are currently</span></span><br><span class=\"line\">        <span class=\"comment\">// being read on another thread.</span></span><br><span class=\"line\">        [objectLock lock];</span><br><span class=\"line\">        <span class=\"meta\">@onExit</span> &#123;</span><br><span class=\"line\">            [objectLock unlock];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[[<span class=\"type\">RACSignal</span> createSignal:<span class=\"operator\">^</span> <span class=\"type\">RACDisposable</span> <span class=\"operator\">*</span> (id<span class=\"operator\">&lt;</span><span class=\"type\">RACSubscriber</span><span class=\"operator\">&gt;</span> subscriber) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Hold onto the lock the whole time we&#x27;re setting up the KVO</span></span><br><span class=\"line\">        <span class=\"comment\">// observation, because any resurrection that might be caused by our</span></span><br><span class=\"line\">        <span class=\"comment\">// retaining below must be balanced out by the time -dealloc returns</span></span><br><span class=\"line\">        <span class=\"comment\">// (if another thread is waiting on the lock above).</span></span><br><span class=\"line\">        [objectLock lock];</span><br><span class=\"line\">        <span class=\"meta\">@onExit</span> &#123;</span><br><span class=\"line\">            [objectLock unlock];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">        __strong <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>observer __attribute__((objc_precise_lifetime)) <span class=\"operator\">=</span> weakObserver;</span><br><span class=\"line\">        __strong <span class=\"type\">NSObject</span> <span class=\"operator\">*</span><span class=\"keyword\">self</span> __attribute__((objc_precise_lifetime)) <span class=\"operator\">=</span> weakSelf;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> <span class=\"operator\">==</span> <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">            [subscriber sendCompleted];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> rac_observeKeyPath:keyPath options:options observer:observer block:<span class=\"operator\">^</span>(id value, <span class=\"type\">NSDictionary</span> <span class=\"operator\">*</span>change, <span class=\"type\">BOOL</span> causedByDealloc, <span class=\"type\">BOOL</span> affectedOnlyLastComponent) &#123;</span><br><span class=\"line\">                [subscriber sendNext:<span class=\"type\">RACTuplePack</span>(value, change)];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;] takeUntil:deallocSignal] setNameWithFormat:@<span class=\"string\">&quot;%@ -rac_valueAndChangesForKeyPath: %@ options: %lu observer: %@&quot;</span>, <span class=\"keyword\">self</span>.rac_description, keyPath, (unsigned long)options, strongObserver.rac_description];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重点观察 <strong>deallocSignal</strong> 和 **[signal takeUntile:deallocSignal]**，我们把 deallocSignal 单独拿出来看看：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>deallocSignal <span class=\"operator\">=</span> [[<span class=\"type\">RACSignal</span> zip:@[</span><br><span class=\"line\">                        <span class=\"keyword\">self</span>.rac_willDeallocSignal,</span><br><span class=\"line\">                        strongObserver.rac_willDeallocSignal <span class=\"operator\">?</span>: [<span class=\"type\">RACSignal</span> never]</span><br><span class=\"line\">                        ]] doCompleted:<span class=\"operator\">^</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Forces deallocation to wait if the object variables are currently</span></span><br><span class=\"line\">    <span class=\"comment\">// being read on another thread.</span></span><br><span class=\"line\">    [objectLock lock];</span><br><span class=\"line\">    <span class=\"meta\">@onExit</span> &#123;</span><br><span class=\"line\">    [objectLock unlock];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>这里的 deallocSignal 是只有在 self 和 strongObserve 都将要发生 dealloc 的时候才会触发的。即用 RACObserve 创建的信号只有在其 target 和 observe 都发生 dealloc 的时候才会被 disposable (这个好像是 RAC 用来销毁自己资源的东西)。不明白的童鞋，我们回头来分析一下场景4的代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 场景4</span></span><br><span class=\"line\">[<span class=\"type\">RACObserve</span>(<span class=\"keyword\">self</span>.viewModel, title) subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>用 RACObserve 创建的信号看起来只要出了函数体其资源应该就会被回收，但是这个信号其实是只有在 self.viewModel.rac_willDeallocSignal 和 self.rac_willDeallocSignal 都发生的情况下才会被释放。所以场景4的引用关系看起来只有 signal-&gt;block-&gt;self，但是这个 signal 只有在 self.rac_willDeallocSignal 的时候才会被释放。所以这里如果不打断这种关系的话就会造成循环引用的问题，正确做法应该是：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 场景4</span></span><br><span class=\"line\"><span class=\"meta\">@weakify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">[<span class=\"type\">RACObserve</span>(<span class=\"keyword\">self</span>.viewModel, title) subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@strongify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>最后，在说一个特别需要注意的，就是 UITableViewCell 和 UICollectionViewCell 复用和 RAC 的问题。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">NSInteger</span>)tableView:(nonnull <span class=\"type\">UITableView</span> <span class=\"operator\">*</span>)tableView numberOfRowsInSection:(<span class=\"type\">NSInteger</span>)section &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">UITableViewCell</span> <span class=\"operator\">*</span>)tableView:(nonnull <span class=\"type\">UITableView</span> <span class=\"operator\">*</span>)tableView cellForRowAtIndexPath:(nonnull <span class=\"type\">NSIndexPath</span> <span class=\"operator\">*</span>)indexPath &#123;</span><br><span class=\"line\">    <span class=\"type\">UITableViewCell</span> <span class=\"operator\">*</span> cell <span class=\"operator\">=</span> [tableView dequeueReusableCellWithIdentifier:@<span class=\"string\">&quot;TableViewCell&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@weakify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    [<span class=\"type\">RACObserve</span>(cell.textLabel, text) subscribeNext:<span class=\"operator\">^</span>(id x) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@strongify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(@<span class=\"string\">&quot;%@&quot;</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们看到这里的 RACObserve 创建的 Signal 和 self 之间已经去掉了循环引用的问题，所以应该是没有什么问题的。但是结合之前我们对 RACObserve 的理解再仔细分析一下，这里的 Signal 只要 self 没有被 dealloc 的话就不会被释放。虽然每次 UITableViewCell 都会被重用，但是每次重用过程中创建的信号确实无法被 disposable。那我们该怎么做呢？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">NSInteger</span>)tableView:(nonnull <span class=\"type\">UITableView</span> <span class=\"operator\">*</span>)tableView numberOfRowsInSection:(<span class=\"type\">NSInteger</span>)section &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">UITableViewCell</span> <span class=\"operator\">*</span>)tableView:(nonnull <span class=\"type\">UITableView</span> <span class=\"operator\">*</span>)tableView cellForRowAtIndexPath:(nonnull <span class=\"type\">NSIndexPath</span> <span class=\"operator\">*</span>)indexPath &#123;</span><br><span class=\"line\">    <span class=\"type\">UITableViewCell</span> <span class=\"operator\">*</span> cell <span class=\"operator\">=</span> [tableView dequeueReusableCellWithIdentifier:@<span class=\"string\">&quot;TableViewCell&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@weakify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    [[<span class=\"type\">RACObserve</span>(cell.textLabel, text) takeUntil:cell.rac_prepareForReuseSignal] subscribeNext:<span class=\"operator\">^</span>(id x) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@strongify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(@<span class=\"string\">&quot;%@&quot;</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，我们在cell里面创建的信号加上 takeUntil:cell.rac_prepareForReuseSignal，这个是让 cell 在每次重用的时候都去 disposable 创建的信号。</p>\n<p>以上所说的关于内存的东西我都用 Instrument 的 Allocations 验证过了，但是依旧建议大家自己也去试试。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在用 RAC 的时候发现自己对内存管理还是有些困惑，于是自己写了一些代码来验证自己的一些理解。<br>在一开始接触 RAC 的时候，我们知道 RAC 对于 block 都是 copy 赋值的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@implementation</span> <span class=\"type\">RACSignal</span></span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark <span class=\"type\">Lifecycle</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">+</span> (<span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>)createSignal:(<span class=\"type\">RACDisposable</span> <span class=\"operator\">*</span> (<span class=\"operator\">^</span>)(id<span class=\"operator\">&lt;</span><span class=\"type\">RACSubscriber</span><span class=\"operator\">&gt;</span> subscriber))didSubscribe &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"type\">RACDynamicSignal</span> createSignal:didSubscribe];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@implementation</span> <span class=\"type\">RACDynamicSignal</span></span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark <span class=\"type\">Lifecycle</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">+</span> (<span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>)createSignal:(<span class=\"type\">RACDisposable</span> <span class=\"operator\">*</span> (<span class=\"operator\">^</span>)(id<span class=\"operator\">&lt;</span><span class=\"type\">RACSubscriber</span><span class=\"operator\">&gt;</span> subscriber))didSubscribe &#123;</span><br><span class=\"line\">    <span class=\"type\">RACDynamicSignal</span> <span class=\"operator\">*</span>signal <span class=\"operator\">=</span> [[<span class=\"keyword\">self</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    signal-&gt;_didSubscribe <span class=\"operator\">=</span> [didSubscribe copy];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [signal setNameWithFormat:@<span class=\"string\">&quot;+createSignal:&quot;</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在创建 RACSingal 的时候会调用其子类 RACDynamicSignal 去创建，我们也看到 RACDynamicSignal 对 didSuscribe 这个 block 是进行了 copy。所以大家可能会被要求注意循环引用的问题，于是大家都用 @weakify(target) 和 @strongify(target) 来避免循环引用的问题。那是不是所有用到 RAC 的地方都需要使用这些宏来避免循环引用的问题，不尽然。比如下面这个：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 场景1</span></span><br><span class=\"line\">[<span class=\"type\">RACObserve</span>(<span class=\"keyword\">self</span>, title) subscribeNext:<span class=\"operator\">^</span>(id x) &#123;</span><br><span class=\"line\">    <span class=\"type\">NSLog</span>(@<span class=\"string\">&quot;%@&quot;</span>, x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们来对比以下的几种用法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@interface</span> <span class=\"type\">ViewController</span>()</span><br><span class=\"line\"><span class=\"meta\">@property</span> (strong, nonatomic) <span class=\"type\">ViewModel</span> <span class=\"operator\">*</span> viewModel;</span><br><span class=\"line\"><span class=\"meta\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@implementation</span> <span class=\"type\">ViewController</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> (void)viewDidiLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.viewModel <span class=\"operator\">=</span> [<span class=\"type\">ViewModel</span> new];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 场景2</span></span><br><span class=\"line\">    dispatch_async(dispatch_get_main_queue(), <span class=\"operator\">^</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> @<span class=\"string\">&quot;你好&quot;</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 场景3</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.viewModel.titleSignal subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 场景4</span></span><br><span class=\"line\">    [<span class=\"type\">RACObserve</span>(<span class=\"keyword\">self</span>.viewModel, title) subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title)     &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">    &#125;]; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>场景2是我们平常都会用到的，而且我们也没有在这种场景下去考虑循环引用的问题，这是因为 dispatch 的 block 不是属于 self 的（至于这个 block 是属于谁的，回头我再查点资料或者请各位指教），所以即使你在 block 使用了 self 也不会有循环应用的问题。</p>\n<p>场景3很明显是有循环引用的问题：<strong>self-&gt;viewModel-&gt;titleSignal-&gt;block-&gt;self</strong>，这个时候如果我们不做处理的话，那么 self 就永远不会被释放。正确的做法应该是使用 @weakify(self) 和 @strongify(self)：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 场景3</span></span><br><span class=\"line\"><span class=\"meta\">@weakify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.viewModel.titleSignal subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@strongify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>场景4在我们看来是没有问题的，因为这里看起来只有 <strong>singal-&gt;block-&gt;self</strong> 的引用，它们之间并没有造成循环引用的问题。我们先来看看 RACObserve 的实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define <span class=\"type\">RACObserve</span>(<span class=\"type\">TARGET</span>, <span class=\"type\">KEYPATH</span>) \\</span><br><span class=\"line\">(&#123; \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">&quot;clang diagnostic push&quot;</span>) \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">&quot;clang diagnostic ignored <span class=\"subst\">\\&quot;</span>-Wreceiver-is-weak<span class=\"subst\">\\&quot;</span>&quot;</span>) \\</span><br><span class=\"line\">__weak id target_ <span class=\"operator\">=</span> (<span class=\"type\">TARGET</span>); \\</span><br><span class=\"line\">[target_ rac_valuesForKeyPath:<span class=\"meta\">@keypath</span>(<span class=\"type\">TARGET</span>, <span class=\"type\">KEYPATH</span>) observer:<span class=\"keyword\">self</span>]; \\</span><br><span class=\"line\">_Pragma(<span class=\"string\">&quot;clang diagnostic pop&quot;</span>) \\</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>)rac_valuesForKeyPath:(<span class=\"type\">NSString</span> <span class=\"operator\">*</span>)keyPath observer:(__weak <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>)observer;</span><br></pre></td></tr></table></figure>\n\n<p>其实，看到这里你会认为这里只是调用了一个方法创建了一个 Signal，而且这个 Signal 也并不属于任何对象。我们再来看看具体的实现是怎么样的？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>)rac_valuesAndChangesForKeyPath:(<span class=\"type\">NSString</span> <span class=\"operator\">*</span>)keyPath options:(<span class=\"type\">NSKeyValueObservingOptions</span>)options observer:(__weak <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>)weakObserver &#123;</span><br><span class=\"line\">    <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>strongObserver <span class=\"operator\">=</span> weakObserver;</span><br><span class=\"line\">    keyPath <span class=\"operator\">=</span> [keyPath copy];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">NSRecursiveLock</span> <span class=\"operator\">*</span>objectLock <span class=\"operator\">=</span> [[<span class=\"type\">NSRecursiveLock</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    objectLock.name <span class=\"operator\">=</span> @<span class=\"string\">&quot;org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    __weak <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>weakSelf <span class=\"operator\">=</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>deallocSignal <span class=\"operator\">=</span> [[<span class=\"type\">RACSignal</span> zip:@[</span><br><span class=\"line\">                            <span class=\"keyword\">self</span>.rac_willDeallocSignal,</span><br><span class=\"line\">                            strongObserver.rac_willDeallocSignal <span class=\"operator\">?</span>: [<span class=\"type\">RACSignal</span> never]</span><br><span class=\"line\">    ]] doCompleted:<span class=\"operator\">^</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Forces deallocation to wait if the object variables are currently</span></span><br><span class=\"line\">        <span class=\"comment\">// being read on another thread.</span></span><br><span class=\"line\">        [objectLock lock];</span><br><span class=\"line\">        <span class=\"meta\">@onExit</span> &#123;</span><br><span class=\"line\">            [objectLock unlock];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[[<span class=\"type\">RACSignal</span> createSignal:<span class=\"operator\">^</span> <span class=\"type\">RACDisposable</span> <span class=\"operator\">*</span> (id<span class=\"operator\">&lt;</span><span class=\"type\">RACSubscriber</span><span class=\"operator\">&gt;</span> subscriber) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Hold onto the lock the whole time we&#x27;re setting up the KVO</span></span><br><span class=\"line\">        <span class=\"comment\">// observation, because any resurrection that might be caused by our</span></span><br><span class=\"line\">        <span class=\"comment\">// retaining below must be balanced out by the time -dealloc returns</span></span><br><span class=\"line\">        <span class=\"comment\">// (if another thread is waiting on the lock above).</span></span><br><span class=\"line\">        [objectLock lock];</span><br><span class=\"line\">        <span class=\"meta\">@onExit</span> &#123;</span><br><span class=\"line\">            [objectLock unlock];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">        __strong <span class=\"type\">NSObject</span> <span class=\"operator\">*</span>observer __attribute__((objc_precise_lifetime)) <span class=\"operator\">=</span> weakObserver;</span><br><span class=\"line\">        __strong <span class=\"type\">NSObject</span> <span class=\"operator\">*</span><span class=\"keyword\">self</span> __attribute__((objc_precise_lifetime)) <span class=\"operator\">=</span> weakSelf;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> <span class=\"operator\">==</span> <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">            [subscriber sendCompleted];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> rac_observeKeyPath:keyPath options:options observer:observer block:<span class=\"operator\">^</span>(id value, <span class=\"type\">NSDictionary</span> <span class=\"operator\">*</span>change, <span class=\"type\">BOOL</span> causedByDealloc, <span class=\"type\">BOOL</span> affectedOnlyLastComponent) &#123;</span><br><span class=\"line\">                [subscriber sendNext:<span class=\"type\">RACTuplePack</span>(value, change)];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;] takeUntil:deallocSignal] setNameWithFormat:@<span class=\"string\">&quot;%@ -rac_valueAndChangesForKeyPath: %@ options: %lu observer: %@&quot;</span>, <span class=\"keyword\">self</span>.rac_description, keyPath, (unsigned long)options, strongObserver.rac_description];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重点观察 <strong>deallocSignal</strong> 和 **[signal takeUntile:deallocSignal]**，我们把 deallocSignal 单独拿出来看看：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">RACSignal</span> <span class=\"operator\">*</span>deallocSignal <span class=\"operator\">=</span> [[<span class=\"type\">RACSignal</span> zip:@[</span><br><span class=\"line\">                        <span class=\"keyword\">self</span>.rac_willDeallocSignal,</span><br><span class=\"line\">                        strongObserver.rac_willDeallocSignal <span class=\"operator\">?</span>: [<span class=\"type\">RACSignal</span> never]</span><br><span class=\"line\">                        ]] doCompleted:<span class=\"operator\">^</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Forces deallocation to wait if the object variables are currently</span></span><br><span class=\"line\">    <span class=\"comment\">// being read on another thread.</span></span><br><span class=\"line\">    [objectLock lock];</span><br><span class=\"line\">    <span class=\"meta\">@onExit</span> &#123;</span><br><span class=\"line\">    [objectLock unlock];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>这里的 deallocSignal 是只有在 self 和 strongObserve 都将要发生 dealloc 的时候才会触发的。即用 RACObserve 创建的信号只有在其 target 和 observe 都发生 dealloc 的时候才会被 disposable (这个好像是 RAC 用来销毁自己资源的东西)。不明白的童鞋，我们回头来分析一下场景4的代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 场景4</span></span><br><span class=\"line\">[<span class=\"type\">RACObserve</span>(<span class=\"keyword\">self</span>.viewModel, title) subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>用 RACObserve 创建的信号看起来只要出了函数体其资源应该就会被回收，但是这个信号其实是只有在 self.viewModel.rac_willDeallocSignal 和 self.rac_willDeallocSignal 都发生的情况下才会被释放。所以场景4的引用关系看起来只有 signal-&gt;block-&gt;self，但是这个 signal 只有在 self.rac_willDeallocSignal 的时候才会被释放。所以这里如果不打断这种关系的话就会造成循环引用的问题，正确做法应该是：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 场景4</span></span><br><span class=\"line\"><span class=\"meta\">@weakify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">[<span class=\"type\">RACObserve</span>(<span class=\"keyword\">self</span>.viewModel, title) subscribeNext:<span class=\"operator\">^</span>(<span class=\"type\">NSString</span> <span class=\"operator\">*</span> title) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@strongify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.title <span class=\"operator\">=</span> title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>最后，在说一个特别需要注意的，就是 UITableViewCell 和 UICollectionViewCell 复用和 RAC 的问题。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">NSInteger</span>)tableView:(nonnull <span class=\"type\">UITableView</span> <span class=\"operator\">*</span>)tableView numberOfRowsInSection:(<span class=\"type\">NSInteger</span>)section &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">UITableViewCell</span> <span class=\"operator\">*</span>)tableView:(nonnull <span class=\"type\">UITableView</span> <span class=\"operator\">*</span>)tableView cellForRowAtIndexPath:(nonnull <span class=\"type\">NSIndexPath</span> <span class=\"operator\">*</span>)indexPath &#123;</span><br><span class=\"line\">    <span class=\"type\">UITableViewCell</span> <span class=\"operator\">*</span> cell <span class=\"operator\">=</span> [tableView dequeueReusableCellWithIdentifier:@<span class=\"string\">&quot;TableViewCell&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@weakify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    [<span class=\"type\">RACObserve</span>(cell.textLabel, text) subscribeNext:<span class=\"operator\">^</span>(id x) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@strongify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(@<span class=\"string\">&quot;%@&quot;</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们看到这里的 RACObserve 创建的 Signal 和 self 之间已经去掉了循环引用的问题，所以应该是没有什么问题的。但是结合之前我们对 RACObserve 的理解再仔细分析一下，这里的 Signal 只要 self 没有被 dealloc 的话就不会被释放。虽然每次 UITableViewCell 都会被重用，但是每次重用过程中创建的信号确实无法被 disposable。那我们该怎么做呢？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">NSInteger</span>)tableView:(nonnull <span class=\"type\">UITableView</span> <span class=\"operator\">*</span>)tableView numberOfRowsInSection:(<span class=\"type\">NSInteger</span>)section &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span> (<span class=\"type\">UITableViewCell</span> <span class=\"operator\">*</span>)tableView:(nonnull <span class=\"type\">UITableView</span> <span class=\"operator\">*</span>)tableView cellForRowAtIndexPath:(nonnull <span class=\"type\">NSIndexPath</span> <span class=\"operator\">*</span>)indexPath &#123;</span><br><span class=\"line\">    <span class=\"type\">UITableViewCell</span> <span class=\"operator\">*</span> cell <span class=\"operator\">=</span> [tableView dequeueReusableCellWithIdentifier:@<span class=\"string\">&quot;TableViewCell&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@weakify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    [[<span class=\"type\">RACObserve</span>(cell.textLabel, text) takeUntil:cell.rac_prepareForReuseSignal] subscribeNext:<span class=\"operator\">^</span>(id x) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@strongify</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(@<span class=\"string\">&quot;%@&quot;</span>, <span class=\"keyword\">self</span>);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，我们在cell里面创建的信号加上 takeUntil:cell.rac_prepareForReuseSignal，这个是让 cell 在每次重用的时候都去 disposable 创建的信号。</p>\n<p>以上所说的关于内存的东西我都用 Instrument 的 Allocations 验证过了，但是依旧建议大家自己也去试试。</p>\n"},{"title":"Shell Tip","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n> 记录日常中用到的一些 Bash 脚本，经常更新\n\n## Tip 1 : 修改文件里面的内容\n早上产品有一个小需求就是把工程中的所有网页的标题修改为黑米流量通，可以使用以下命令来实现\n\n```sh\n$ find . -name '*.html' -print0 | xargs -0 sed -i '' -e 's/<title>.*<\\/title>/<title>黑米流量通<\\/title>/g'\n```\n\n* `find`          查找命令，可以用 man find 查看更多的信息\n* `.`             代表当前目录\n* `-name`         find 命令的参数，表示要查找的文件名\n* `-print0`       是一种不换行的输出格式，以 ASCII NUL 字符（也就是\\0）作为分隔符。上面的例子可能是 `a.html\\0b.html\\0c.html`\n* `|`             这是一个管道符，表示把前面命令的输出作为后面命令的输入\n* `xargs`         是用来构造输入参数，并且循环执行每一个参数\n* `-0`            表示让 xargs 使用 ASCII NUL 来分隔参数。上面的例子将被分隔成 `a.html` `b.html` `c.html` 三个参数依次执行\n* `sed`           这是一个流编辑器，如果传的是文件名会把文件内容读入内存，如果只是普通字符串就会把字符串读入内存\n* `-i`            表示要把原来的文件内容做一次备份，后面的 `''` 是表示要备份的文件名字，如果没有文件名字就表示不需要备份\n* `-e`            表示后面的字符串是一个命令，需要被执行\n* `s/old/new/g`   这个是用来替换字符串的命令\n\n## Tip 2 : 查找文件的内容\n把匹配的文件内容的相关文件列出来\n\n```sh\n$ find . -name '*.html' -print0 | xargs -0 grep 'PATTERN'\n```\n\n## Tip 3 : 解决 Homebrew 的权限问题\n查看 Homebrew 的所有权\n\n```sh\n$ ls -al `which brew`\n```\n\n把 Homebrew 的用户和分组修改为 root 和 wheel\n\n```sh\n$ sudo chown root:wheel `which brew`\n```\n\n最后还原 Homebrew 的权限（安全）\n\n```sh\n$ sudo chown : `chown brew`\n```\n\n## Tip 4 : 利用 Shell 生成生成 ICON\n\n```sh\n#!/bin/sh\n#此脚本是用来生成 iPhone 和 iPad 所需 icon 的不同尺寸的，最好是准备一张 1024x1024 的 Icon 图片\n\n\nfilename=\"icon.png\"\n\ndirname=\"icon\"\n\nname_array=(\"Icon-20.png\" \"Icon-20@2x.png\" \"Icon-20@3x.png\"\n\"Icon-29.png\" \"Icon-29@2x.png\" \"Icon-29@3x.png\"\n\"Icon-40.png\" \"Icon-40@2x.png\" \"Icon-40@3x.png\"\n\"Icon-60@2x.png\" \"Icon-60@3x.png\"\n\"Icon-76.png\" \"Icon-76@2x.png\"\n\"Icon-83.5@2x.png\")\nsize_array=(\"20\" \"40\" \"60\"\n\"29\" \"58\" \"87\"\n\"40\" \"80\" \"120\"\n\"120\" \"180\"\n\"76\" \"152\"\n\"167\")\n\nmkdir $dirname\n\nfor ((i=0;i<${#name_array[@]};++i)); do\n    m_dir=$dirname/${name_array[i]}\n    cp $filename $m_dir\n    sips -Z ${size_array[i]} $m_dir\n# 如果图片是 sRGB 的话，使用下面的命令\n#    sips --matchTo '/System/Library/ColorSync/Profiles/sRGB Profile.icc' -Z ${size_array[i]} $m_dir \ndone\n```\n\n## Tip5 : 使用 Python 共享当前目录\n\n利用下面的命令可以暂时开启一个端口号为 8000 的 HTTP 服务，其他人只需要在浏览器输入 `http://ip-address:8000` 即可浏览共享目录下的文件\n\n```sh\n$ python -m SimpleHTTPServer\n```\n\n\n## Tip6 : 加密和解密文件\n\n* 加密\n\n```sh\n$ tar czf - {SRC_DIR} | openssl des3 -salt -k \"{KEY}\" -out {DIST_PACKAGE}.tar.gz\n```\n\n示例：\n\n目录名 `paris_code`，秘钥 `meta#com`，输出包 `paris_code_20161008.tar.gz`\n\n```sh\n$ tar czf - paris_code | openssl des3 -salt -k \"meta#com\" -out paris_code_20161008.tar.gz\n```\n\n* 解密\n\n第一步：获取代码压缩文件包\n\n下载地址 `http://XXXX.com/paris_code_20161008.tar.gz`\n\n第二步：解密文件（OS X / Linux only）\n\n在 Terminal 进入压缩文件包同级目录，输入以下命令：\n\n```sh\n$ openssl des3 -d -k \"meta#com\" -salt -in paris_code_20161008.tar.gz | tar xzf -\n```\n\n## Tip7: iOS 打包命令\n\n```sh\necho \"----------------\"\necho \"Begin Build!\"\nPROJECT_NAME=\"orbit\"\nBUILD_DATE=\"$(date +'%Y%m%d')\"\nBUNDLE_ID=\"com.meta.paris\"\ncd ${WORKSPACE}\n\n#/usr/local/bin/npm install\n\nif [ -d \"${WORKSPACE}/build\" ]; then \n    if ls ${WORKSPACE}/build/**/*.ipa 1> /dev/null 2>&1; then\n        rm -rf ${WORKSPACE}/build/**/*.ipa; \n    fi;\n    if ls ${WORKSPACE}/build/**/*.xcarchive 1> /dev/null 2>&1; then\n        rm -rf ${WORKSPACE}/build/**/*.xcarchive; \n    fi;\nelse \n    mkdir ${WORKSPACE}/build; \nfi;\n\necho \"计算今天的 Build Version\"\nif [ -d \"${WORKSPACE}/build/${BUILD_DATE}\" ]; then \n   #如果不加上面的 if, Jenkins 无法直接执行下面的命令❓\n\tBUILD_DATE_COUNT=$(ls ${WORKSPACE}/build | grep \"^${BUILD_DATE}\" -c)\n    if [ ${BUILD_DATE_COUNT} -lt 10 ]; then\n        BUILD_DATE_COUNT=\"0${BUILD_DATE_COUNT}\"\n    fi;\n\tBUILD_VERSION=\"${BUILD_DATE}${BUILD_DATE_COUNT}\"\nelse \n  \tBUILD_VERSION=${BUILD_DATE}\nfi;\necho \"今天的 Build Version 是 ${BUILD_VERSION}\"\n\nif [ -d \"${WORKSPACE}/build/${BUILD_VERSION}\" ]; then \n    rm -rf ${WORKSPACE}/build/${BUILD_VERSION}; \nfi;\nmkdir ${WORKSPACE}/build/${BUILD_VERSION};\n\nif [ -d \"${WORKSPACE}/Enterprise.plist\" ]; then\n    rm ${WORKSPACE}/Enterprise.plist; \nfi;\n\n#http://www.matrixprojects.net/p/xcodebuild-export-options-plist/\nEnterprise='<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n        <key>teamID</key>\n        <string></string>\n        <key>method</key>\n        <string>app-store</string>\n        <key>uploadSymbols</key>\n        <true/>\n        <key>uploadBitcode</key>\n        <false/>\n</dict>\n</plist>'\necho ${Enterprise} > ${WORKSPACE}/Enterprise.plist\n\nsed -i '' 's/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g' \\\n${WORKSPACE}/${PROJECT_NAME}.xcodeproj/project.pbxproj\n\nsed -i '' 's/DEVELOPMENT_TEAM = .*;/DEVELOPMENT_TEAM = \"\";/g' \\\n${WORKSPACE}/${PROJECT_NAME}.xcodeproj/project.pbxproj\n\n#动态生成 Build Version\nsed -i '' \"/<key>CFBundleVersion<\\/key>/{N;s/<string>.*<\\/string>/<string>${BUILD_VERSION}<\\/string>/g;}\" \\\n${WORKSPACE}/${PROJECT_NAME}/${PROJECT_NAME}-Info.plist\n\nxcodebuild -workspace ${WORKSPACE}/${PROJECT_NAME}.xcworkspace \\\n-scheme ${PROJECT_NAME} -sdk iphoneos \\\nbuild CODE_SIGN_IDENTITY=\"iPhone Distribution: Beijing PS Technology Co., Ltd.\" \\\nPROVISIONING_PROFILE=\"\" \\\n-configuration Release clean archive \\\n-archivePath ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.xcarchive\n\nxcodebuild -exportArchive -exportOptionsPlist ${WORKSPACE}/Enterprise.plist \\\n-archivePath ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.xcarchive \\\n-exportPath ${WORKSPACE}/build/${BUILD_VERSION}/\n\necho \"----------------\"\necho \"Build successfully!\"\n\n\necho \"Begin Upload to itunes...\"\n#Use [shenzhen](https://github.com/nomad/shenzhen) to upload the ipa file to itunes connect.\n/usr/local/bin/ipa distribute:itunesconnect -f ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.ipa -a YourAppleID -p YourPassword -i ${BUNDLE_ID} --upload\necho \"Upload successfully!\"\n```\n\n\n## Tip8: 重置 iOS 模拟器\n\n相信各位在做 iOS 开发的同学都会碰到模拟器上各种神奇的现象，通过重置 iOS 模拟器基本上可以解决大部分问题：\n\n```Sh\n// 退出当前的所有模拟器\n$ osascript -e 'tell application \"iOS Simulator\" to quit'\n$ osascript -e 'tell application \"Simulator\" to quit'\n\n// 清掉之前使用模拟器产生的所有内容\n$ xcrun simctl erase all\n```\n\n## Tip9: 模拟器截图\n\n下面的命令会默认截取第一个启动的模拟器：\n\n```Sh\nxcrun simctl io booted screenshot screenshot.png\n```\n\n当你同时启动了多个模拟器的情况下，需要先查看当前启动的模拟器 ID，然后指定 ID 截图：\n\n```Sh\nxcrun simctl list\nxcrun simctl io B5EEDDC0-CDA3-46A9-A2B6-FA940D693DFC screenshot screenshot.png\n```","source":"_posts/Shell-Tip.md","raw":"---\ntitle: Shell Tip\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: 技术\ntags: [tip] \n---\n\n> 记录日常中用到的一些 Bash 脚本，经常更新\n\n## Tip 1 : 修改文件里面的内容\n早上产品有一个小需求就是把工程中的所有网页的标题修改为黑米流量通，可以使用以下命令来实现\n\n```sh\n$ find . -name '*.html' -print0 | xargs -0 sed -i '' -e 's/<title>.*<\\/title>/<title>黑米流量通<\\/title>/g'\n```\n\n* `find`          查找命令，可以用 man find 查看更多的信息\n* `.`             代表当前目录\n* `-name`         find 命令的参数，表示要查找的文件名\n* `-print0`       是一种不换行的输出格式，以 ASCII NUL 字符（也就是\\0）作为分隔符。上面的例子可能是 `a.html\\0b.html\\0c.html`\n* `|`             这是一个管道符，表示把前面命令的输出作为后面命令的输入\n* `xargs`         是用来构造输入参数，并且循环执行每一个参数\n* `-0`            表示让 xargs 使用 ASCII NUL 来分隔参数。上面的例子将被分隔成 `a.html` `b.html` `c.html` 三个参数依次执行\n* `sed`           这是一个流编辑器，如果传的是文件名会把文件内容读入内存，如果只是普通字符串就会把字符串读入内存\n* `-i`            表示要把原来的文件内容做一次备份，后面的 `''` 是表示要备份的文件名字，如果没有文件名字就表示不需要备份\n* `-e`            表示后面的字符串是一个命令，需要被执行\n* `s/old/new/g`   这个是用来替换字符串的命令\n\n## Tip 2 : 查找文件的内容\n把匹配的文件内容的相关文件列出来\n\n```sh\n$ find . -name '*.html' -print0 | xargs -0 grep 'PATTERN'\n```\n\n## Tip 3 : 解决 Homebrew 的权限问题\n查看 Homebrew 的所有权\n\n```sh\n$ ls -al `which brew`\n```\n\n把 Homebrew 的用户和分组修改为 root 和 wheel\n\n```sh\n$ sudo chown root:wheel `which brew`\n```\n\n最后还原 Homebrew 的权限（安全）\n\n```sh\n$ sudo chown : `chown brew`\n```\n\n## Tip 4 : 利用 Shell 生成生成 ICON\n\n```sh\n#!/bin/sh\n#此脚本是用来生成 iPhone 和 iPad 所需 icon 的不同尺寸的，最好是准备一张 1024x1024 的 Icon 图片\n\n\nfilename=\"icon.png\"\n\ndirname=\"icon\"\n\nname_array=(\"Icon-20.png\" \"Icon-20@2x.png\" \"Icon-20@3x.png\"\n\"Icon-29.png\" \"Icon-29@2x.png\" \"Icon-29@3x.png\"\n\"Icon-40.png\" \"Icon-40@2x.png\" \"Icon-40@3x.png\"\n\"Icon-60@2x.png\" \"Icon-60@3x.png\"\n\"Icon-76.png\" \"Icon-76@2x.png\"\n\"Icon-83.5@2x.png\")\nsize_array=(\"20\" \"40\" \"60\"\n\"29\" \"58\" \"87\"\n\"40\" \"80\" \"120\"\n\"120\" \"180\"\n\"76\" \"152\"\n\"167\")\n\nmkdir $dirname\n\nfor ((i=0;i<${#name_array[@]};++i)); do\n    m_dir=$dirname/${name_array[i]}\n    cp $filename $m_dir\n    sips -Z ${size_array[i]} $m_dir\n# 如果图片是 sRGB 的话，使用下面的命令\n#    sips --matchTo '/System/Library/ColorSync/Profiles/sRGB Profile.icc' -Z ${size_array[i]} $m_dir \ndone\n```\n\n## Tip5 : 使用 Python 共享当前目录\n\n利用下面的命令可以暂时开启一个端口号为 8000 的 HTTP 服务，其他人只需要在浏览器输入 `http://ip-address:8000` 即可浏览共享目录下的文件\n\n```sh\n$ python -m SimpleHTTPServer\n```\n\n\n## Tip6 : 加密和解密文件\n\n* 加密\n\n```sh\n$ tar czf - {SRC_DIR} | openssl des3 -salt -k \"{KEY}\" -out {DIST_PACKAGE}.tar.gz\n```\n\n示例：\n\n目录名 `paris_code`，秘钥 `meta#com`，输出包 `paris_code_20161008.tar.gz`\n\n```sh\n$ tar czf - paris_code | openssl des3 -salt -k \"meta#com\" -out paris_code_20161008.tar.gz\n```\n\n* 解密\n\n第一步：获取代码压缩文件包\n\n下载地址 `http://XXXX.com/paris_code_20161008.tar.gz`\n\n第二步：解密文件（OS X / Linux only）\n\n在 Terminal 进入压缩文件包同级目录，输入以下命令：\n\n```sh\n$ openssl des3 -d -k \"meta#com\" -salt -in paris_code_20161008.tar.gz | tar xzf -\n```\n\n## Tip7: iOS 打包命令\n\n```sh\necho \"----------------\"\necho \"Begin Build!\"\nPROJECT_NAME=\"orbit\"\nBUILD_DATE=\"$(date +'%Y%m%d')\"\nBUNDLE_ID=\"com.meta.paris\"\ncd ${WORKSPACE}\n\n#/usr/local/bin/npm install\n\nif [ -d \"${WORKSPACE}/build\" ]; then \n    if ls ${WORKSPACE}/build/**/*.ipa 1> /dev/null 2>&1; then\n        rm -rf ${WORKSPACE}/build/**/*.ipa; \n    fi;\n    if ls ${WORKSPACE}/build/**/*.xcarchive 1> /dev/null 2>&1; then\n        rm -rf ${WORKSPACE}/build/**/*.xcarchive; \n    fi;\nelse \n    mkdir ${WORKSPACE}/build; \nfi;\n\necho \"计算今天的 Build Version\"\nif [ -d \"${WORKSPACE}/build/${BUILD_DATE}\" ]; then \n   #如果不加上面的 if, Jenkins 无法直接执行下面的命令❓\n\tBUILD_DATE_COUNT=$(ls ${WORKSPACE}/build | grep \"^${BUILD_DATE}\" -c)\n    if [ ${BUILD_DATE_COUNT} -lt 10 ]; then\n        BUILD_DATE_COUNT=\"0${BUILD_DATE_COUNT}\"\n    fi;\n\tBUILD_VERSION=\"${BUILD_DATE}${BUILD_DATE_COUNT}\"\nelse \n  \tBUILD_VERSION=${BUILD_DATE}\nfi;\necho \"今天的 Build Version 是 ${BUILD_VERSION}\"\n\nif [ -d \"${WORKSPACE}/build/${BUILD_VERSION}\" ]; then \n    rm -rf ${WORKSPACE}/build/${BUILD_VERSION}; \nfi;\nmkdir ${WORKSPACE}/build/${BUILD_VERSION};\n\nif [ -d \"${WORKSPACE}/Enterprise.plist\" ]; then\n    rm ${WORKSPACE}/Enterprise.plist; \nfi;\n\n#http://www.matrixprojects.net/p/xcodebuild-export-options-plist/\nEnterprise='<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n        <key>teamID</key>\n        <string></string>\n        <key>method</key>\n        <string>app-store</string>\n        <key>uploadSymbols</key>\n        <true/>\n        <key>uploadBitcode</key>\n        <false/>\n</dict>\n</plist>'\necho ${Enterprise} > ${WORKSPACE}/Enterprise.plist\n\nsed -i '' 's/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g' \\\n${WORKSPACE}/${PROJECT_NAME}.xcodeproj/project.pbxproj\n\nsed -i '' 's/DEVELOPMENT_TEAM = .*;/DEVELOPMENT_TEAM = \"\";/g' \\\n${WORKSPACE}/${PROJECT_NAME}.xcodeproj/project.pbxproj\n\n#动态生成 Build Version\nsed -i '' \"/<key>CFBundleVersion<\\/key>/{N;s/<string>.*<\\/string>/<string>${BUILD_VERSION}<\\/string>/g;}\" \\\n${WORKSPACE}/${PROJECT_NAME}/${PROJECT_NAME}-Info.plist\n\nxcodebuild -workspace ${WORKSPACE}/${PROJECT_NAME}.xcworkspace \\\n-scheme ${PROJECT_NAME} -sdk iphoneos \\\nbuild CODE_SIGN_IDENTITY=\"iPhone Distribution: Beijing PS Technology Co., Ltd.\" \\\nPROVISIONING_PROFILE=\"\" \\\n-configuration Release clean archive \\\n-archivePath ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.xcarchive\n\nxcodebuild -exportArchive -exportOptionsPlist ${WORKSPACE}/Enterprise.plist \\\n-archivePath ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.xcarchive \\\n-exportPath ${WORKSPACE}/build/${BUILD_VERSION}/\n\necho \"----------------\"\necho \"Build successfully!\"\n\n\necho \"Begin Upload to itunes...\"\n#Use [shenzhen](https://github.com/nomad/shenzhen) to upload the ipa file to itunes connect.\n/usr/local/bin/ipa distribute:itunesconnect -f ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.ipa -a YourAppleID -p YourPassword -i ${BUNDLE_ID} --upload\necho \"Upload successfully!\"\n```\n\n\n## Tip8: 重置 iOS 模拟器\n\n相信各位在做 iOS 开发的同学都会碰到模拟器上各种神奇的现象，通过重置 iOS 模拟器基本上可以解决大部分问题：\n\n```Sh\n// 退出当前的所有模拟器\n$ osascript -e 'tell application \"iOS Simulator\" to quit'\n$ osascript -e 'tell application \"Simulator\" to quit'\n\n// 清掉之前使用模拟器产生的所有内容\n$ xcrun simctl erase all\n```\n\n## Tip9: 模拟器截图\n\n下面的命令会默认截取第一个启动的模拟器：\n\n```Sh\nxcrun simctl io booted screenshot screenshot.png\n```\n\n当你同时启动了多个模拟器的情况下，需要先查看当前启动的模拟器 ID，然后指定 ID 截图：\n\n```Sh\nxcrun simctl list\nxcrun simctl io B5EEDDC0-CDA3-46A9-A2B6-FA940D693DFC screenshot screenshot.png\n```","slug":"Shell-Tip","published":1,"updated":"2023-01-07T05:42:02.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldr5xjcj000fjbse8gb56nya","content":"<blockquote>\n<p>记录日常中用到的一些 Bash 脚本，经常更新</p>\n</blockquote>\n<h2 id=\"Tip-1-修改文件里面的内容\"><a href=\"#Tip-1-修改文件里面的内容\" class=\"headerlink\" title=\"Tip 1 : 修改文件里面的内容\"></a>Tip 1 : 修改文件里面的内容</h2><p>早上产品有一个小需求就是把工程中的所有网页的标题修改为黑米流量通，可以使用以下命令来实现</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ find . -name <span class=\"string\">&#x27;*.html&#x27;</span> -print0 | xargs -0 sed -i <span class=\"string\">&#x27;&#x27;</span> -e <span class=\"string\">&#x27;s/&lt;title&gt;.*&lt;\\/title&gt;/&lt;title&gt;黑米流量通&lt;\\/title&gt;/g&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>find</code>          查找命令，可以用 man find 查看更多的信息</li>\n<li><code>.</code>             代表当前目录</li>\n<li><code>-name</code>         find 命令的参数，表示要查找的文件名</li>\n<li><code>-print0</code>       是一种不换行的输出格式，以 ASCII NUL 字符（也就是\\0）作为分隔符。上面的例子可能是 <code>a.html\\0b.html\\0c.html</code></li>\n<li><code>|</code>             这是一个管道符，表示把前面命令的输出作为后面命令的输入</li>\n<li><code>xargs</code>         是用来构造输入参数，并且循环执行每一个参数</li>\n<li><code>-0</code>            表示让 xargs 使用 ASCII NUL 来分隔参数。上面的例子将被分隔成 <code>a.html</code> <code>b.html</code> <code>c.html</code> 三个参数依次执行</li>\n<li><code>sed</code>           这是一个流编辑器，如果传的是文件名会把文件内容读入内存，如果只是普通字符串就会把字符串读入内存</li>\n<li><code>-i</code>            表示要把原来的文件内容做一次备份，后面的 <code>&#39;&#39;</code> 是表示要备份的文件名字，如果没有文件名字就表示不需要备份</li>\n<li><code>-e</code>            表示后面的字符串是一个命令，需要被执行</li>\n<li><code>s/old/new/g</code>   这个是用来替换字符串的命令</li>\n</ul>\n<h2 id=\"Tip-2-查找文件的内容\"><a href=\"#Tip-2-查找文件的内容\" class=\"headerlink\" title=\"Tip 2 : 查找文件的内容\"></a>Tip 2 : 查找文件的内容</h2><p>把匹配的文件内容的相关文件列出来</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ find . -name <span class=\"string\">&#x27;*.html&#x27;</span> -print0 | xargs -0 grep <span class=\"string\">&#x27;PATTERN&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip-3-解决-Homebrew-的权限问题\"><a href=\"#Tip-3-解决-Homebrew-的权限问题\" class=\"headerlink\" title=\"Tip 3 : 解决 Homebrew 的权限问题\"></a>Tip 3 : 解决 Homebrew 的权限问题</h2><p>查看 Homebrew 的所有权</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">ls</span> -al `<span class=\"built_in\">which</span> brew`</span><br></pre></td></tr></table></figure>\n\n<p>把 Homebrew 的用户和分组修改为 root 和 wheel</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo <span class=\"built_in\">chown</span> root:wheel `<span class=\"built_in\">which</span> brew`</span><br></pre></td></tr></table></figure>\n\n<p>最后还原 Homebrew 的权限（安全）</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo <span class=\"built_in\">chown</span> : `<span class=\"built_in\">chown</span> brew`</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip-4-利用-Shell-生成生成-ICON\"><a href=\"#Tip-4-利用-Shell-生成生成-ICON\" class=\"headerlink\" title=\"Tip 4 : 利用 Shell 生成生成 ICON\"></a>Tip 4 : 利用 Shell 生成生成 ICON</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"comment\">#此脚本是用来生成 iPhone 和 iPad 所需 icon 的不同尺寸的，最好是准备一张 1024x1024 的 Icon 图片</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">filename=<span class=\"string\">&quot;icon.png&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">dirname</span>=<span class=\"string\">&quot;icon&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">name_array=(<span class=\"string\">&quot;Icon-20.png&quot;</span> <span class=\"string\">&quot;Icon-20@2x.png&quot;</span> <span class=\"string\">&quot;Icon-20@3x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-29.png&quot;</span> <span class=\"string\">&quot;Icon-29@2x.png&quot;</span> <span class=\"string\">&quot;Icon-29@3x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-40.png&quot;</span> <span class=\"string\">&quot;Icon-40@2x.png&quot;</span> <span class=\"string\">&quot;Icon-40@3x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-60@2x.png&quot;</span> <span class=\"string\">&quot;Icon-60@3x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-76.png&quot;</span> <span class=\"string\">&quot;Icon-76@2x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-83.5@2x.png&quot;</span>)</span><br><span class=\"line\">size_array=(<span class=\"string\">&quot;20&quot;</span> <span class=\"string\">&quot;40&quot;</span> <span class=\"string\">&quot;60&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;29&quot;</span> <span class=\"string\">&quot;58&quot;</span> <span class=\"string\">&quot;87&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;40&quot;</span> <span class=\"string\">&quot;80&quot;</span> <span class=\"string\">&quot;120&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;120&quot;</span> <span class=\"string\">&quot;180&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;76&quot;</span> <span class=\"string\">&quot;152&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;167&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> <span class=\"variable\">$dirname</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> ((i=<span class=\"number\">0</span>;i&lt;<span class=\"variable\">$&#123;#name_array[@]&#125;</span>;++i)); <span class=\"keyword\">do</span></span><br><span class=\"line\">    m_dir=<span class=\"variable\">$dirname</span>/<span class=\"variable\">$&#123;name_array[i]&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">cp</span> <span class=\"variable\">$filename</span> <span class=\"variable\">$m_dir</span></span><br><span class=\"line\">    sips -Z <span class=\"variable\">$&#123;size_array[i]&#125;</span> <span class=\"variable\">$m_dir</span></span><br><span class=\"line\"><span class=\"comment\"># 如果图片是 sRGB 的话，使用下面的命令</span></span><br><span class=\"line\"><span class=\"comment\">#    sips --matchTo &#x27;/System/Library/ColorSync/Profiles/sRGB Profile.icc&#x27; -Z $&#123;size_array[i]&#125; $m_dir </span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip5-使用-Python-共享当前目录\"><a href=\"#Tip5-使用-Python-共享当前目录\" class=\"headerlink\" title=\"Tip5 : 使用 Python 共享当前目录\"></a>Tip5 : 使用 Python 共享当前目录</h2><p>利用下面的命令可以暂时开启一个端口号为 8000 的 HTTP 服务，其他人只需要在浏览器输入 <code>http://ip-address:8000</code> 即可浏览共享目录下的文件</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Tip6-加密和解密文件\"><a href=\"#Tip6-加密和解密文件\" class=\"headerlink\" title=\"Tip6 : 加密和解密文件\"></a>Tip6 : 加密和解密文件</h2><ul>\n<li>加密</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar czf - &#123;SRC_DIR&#125; | openssl des3 -salt -k <span class=\"string\">&quot;&#123;KEY&#125;&quot;</span> -out &#123;DIST_PACKAGE&#125;.tar.gz</span><br></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<p>目录名 <code>paris_code</code>，秘钥 <code>meta#com</code>，输出包 <code>paris_code_20161008.tar.gz</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar czf - paris_code | openssl des3 -salt -k <span class=\"string\">&quot;meta#com&quot;</span> -out paris_code_20161008.tar.gz</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>解密</li>\n</ul>\n<p>第一步：获取代码压缩文件包</p>\n<p>下载地址 <code>http://XXXX.com/paris_code_20161008.tar.gz</code></p>\n<p>第二步：解密文件（OS X &#x2F; Linux only）</p>\n<p>在 Terminal 进入压缩文件包同级目录，输入以下命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ openssl des3 -d -k <span class=\"string\">&quot;meta#com&quot;</span> -salt -<span class=\"keyword\">in</span> paris_code_20161008.tar.gz | tar xzf -</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip7-iOS-打包命令\"><a href=\"#Tip7-iOS-打包命令\" class=\"headerlink\" title=\"Tip7: iOS 打包命令\"></a>Tip7: iOS 打包命令</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;----------------&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Begin Build!&quot;</span></span><br><span class=\"line\">PROJECT_NAME=<span class=\"string\">&quot;orbit&quot;</span></span><br><span class=\"line\">BUILD_DATE=<span class=\"string\">&quot;<span class=\"subst\">$(date +&#x27;%Y%m%d&#x27;)</span>&quot;</span></span><br><span class=\"line\">BUNDLE_ID=<span class=\"string\">&quot;com.meta.paris&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#/usr/local/bin/npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build&quot;</span> ]; <span class=\"keyword\">then</span> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">ls</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/**/*.ipa 1&gt; /dev/null 2&gt;&amp;1; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">rm</span> -rf <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/**/*.ipa; </span><br><span class=\"line\">    <span class=\"keyword\">fi</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">ls</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/**/*.xcarchive 1&gt; /dev/null 2&gt;&amp;1; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">rm</span> -rf <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/**/*.xcarchive; </span><br><span class=\"line\">    <span class=\"keyword\">fi</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">    <span class=\"built_in\">mkdir</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build; </span><br><span class=\"line\"><span class=\"keyword\">fi</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;计算今天的 Build Version&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_DATE&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span> </span><br><span class=\"line\">   <span class=\"comment\">#如果不加上面的 if, Jenkins 无法直接执行下面的命令❓</span></span><br><span class=\"line\">\tBUILD_DATE_COUNT=$(<span class=\"built_in\">ls</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build | grep <span class=\"string\">&quot;^<span class=\"variable\">$&#123;BUILD_DATE&#125;</span>&quot;</span> -c)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"variable\">$&#123;BUILD_DATE_COUNT&#125;</span> -lt 10 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">        BUILD_DATE_COUNT=<span class=\"string\">&quot;0<span class=\"variable\">$&#123;BUILD_DATE_COUNT&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span>;</span><br><span class=\"line\">\tBUILD_VERSION=<span class=\"string\">&quot;<span class=\"variable\">$&#123;BUILD_DATE&#125;</span><span class=\"variable\">$&#123;BUILD_DATE_COUNT&#125;</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">  \tBUILD_VERSION=<span class=\"variable\">$&#123;BUILD_DATE&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span>;</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;今天的 Build Version 是 <span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span> </span><br><span class=\"line\">    <span class=\"built_in\">rm</span> -rf <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>; </span><br><span class=\"line\"><span class=\"keyword\">fi</span>;</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$&#123;WORKSPACE&#125;</span>/Enterprise.plist&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">rm</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/Enterprise.plist; </span><br><span class=\"line\"><span class=\"keyword\">fi</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#http://www.matrixprojects.net/p/xcodebuild-export-options-plist/</span></span><br><span class=\"line\">Enterprise=<span class=\"string\">&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;plist version=&quot;1.0&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;dict&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;key&gt;teamID&lt;/key&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;string&gt;&lt;/string&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;key&gt;method&lt;/key&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;string&gt;app-store&lt;/string&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;key&gt;uploadSymbols&lt;/key&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;true/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;key&gt;uploadBitcode&lt;/key&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;false/&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/dict&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/plist&gt;&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;Enterprise&#125;</span> &gt; <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/Enterprise.plist</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g&#x27;</span> \\</span><br><span class=\"line\"><span class=\"variable\">$&#123;WORKSPACE&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcodeproj/project.pbxproj</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/DEVELOPMENT_TEAM = .*;/DEVELOPMENT_TEAM = &quot;&quot;;/g&#x27;</span> \\</span><br><span class=\"line\"><span class=\"variable\">$&#123;WORKSPACE&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcodeproj/project.pbxproj</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#动态生成 Build Version</span></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&quot;/&lt;key&gt;CFBundleVersion&lt;\\/key&gt;/&#123;N;s/&lt;string&gt;.*&lt;\\/string&gt;/&lt;string&gt;<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>&lt;\\/string&gt;/g;&#125;&quot;</span> \\</span><br><span class=\"line\"><span class=\"variable\">$&#123;WORKSPACE&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>-Info.plist</span><br><span class=\"line\"></span><br><span class=\"line\">xcodebuild -workspace <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcworkspace \\</span><br><span class=\"line\">-scheme <span class=\"variable\">$&#123;PROJECT_NAME&#125;</span> -sdk iphoneos \\</span><br><span class=\"line\">build CODE_SIGN_IDENTITY=<span class=\"string\">&quot;iPhone Distribution: Beijing PS Technology Co., Ltd.&quot;</span> \\</span><br><span class=\"line\">PROVISIONING_PROFILE=<span class=\"string\">&quot;&quot;</span> \\</span><br><span class=\"line\">-configuration Release clean archive \\</span><br><span class=\"line\">-archivePath <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcarchive</span><br><span class=\"line\"></span><br><span class=\"line\">xcodebuild -exportArchive -exportOptionsPlist <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/Enterprise.plist \\</span><br><span class=\"line\">-archivePath <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcarchive \\</span><br><span class=\"line\">-exportPath <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;----------------&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Build successfully!&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Begin Upload to itunes...&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#Use [shenzhen](https://github.com/nomad/shenzhen) to upload the ipa file to itunes connect.</span></span><br><span class=\"line\">/usr/local/bin/ipa distribute:itunesconnect -f <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.ipa -a YourAppleID -p YourPassword -i <span class=\"variable\">$&#123;BUNDLE_ID&#125;</span> --upload</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Upload successfully!&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Tip8-重置-iOS-模拟器\"><a href=\"#Tip8-重置-iOS-模拟器\" class=\"headerlink\" title=\"Tip8: 重置 iOS 模拟器\"></a>Tip8: 重置 iOS 模拟器</h2><p>相信各位在做 iOS 开发的同学都会碰到模拟器上各种神奇的现象，通过重置 iOS 模拟器基本上可以解决大部分问题：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 退出当前的所有模拟器</span><br><span class=\"line\">$ osascript -e <span class=\"string\">&#x27;tell application &quot;iOS Simulator&quot; to quit&#x27;</span></span><br><span class=\"line\">$ osascript -e <span class=\"string\">&#x27;tell application &quot;Simulator&quot; to quit&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">// 清掉之前使用模拟器产生的所有内容</span><br><span class=\"line\">$ xcrun simctl erase all</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip9-模拟器截图\"><a href=\"#Tip9-模拟器截图\" class=\"headerlink\" title=\"Tip9: 模拟器截图\"></a>Tip9: 模拟器截图</h2><p>下面的命令会默认截取第一个启动的模拟器：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcrun simctl io booted screenshot screenshot.png</span><br></pre></td></tr></table></figure>\n\n<p>当你同时启动了多个模拟器的情况下，需要先查看当前启动的模拟器 ID，然后指定 ID 截图：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcrun simctl list</span><br><span class=\"line\">xcrun simctl io B5EEDDC0-CDA3-46A9-A2B6-FA940D693DFC screenshot screenshot.png</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>记录日常中用到的一些 Bash 脚本，经常更新</p>\n</blockquote>\n<h2 id=\"Tip-1-修改文件里面的内容\"><a href=\"#Tip-1-修改文件里面的内容\" class=\"headerlink\" title=\"Tip 1 : 修改文件里面的内容\"></a>Tip 1 : 修改文件里面的内容</h2><p>早上产品有一个小需求就是把工程中的所有网页的标题修改为黑米流量通，可以使用以下命令来实现</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ find . -name <span class=\"string\">&#x27;*.html&#x27;</span> -print0 | xargs -0 sed -i <span class=\"string\">&#x27;&#x27;</span> -e <span class=\"string\">&#x27;s/&lt;title&gt;.*&lt;\\/title&gt;/&lt;title&gt;黑米流量通&lt;\\/title&gt;/g&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>find</code>          查找命令，可以用 man find 查看更多的信息</li>\n<li><code>.</code>             代表当前目录</li>\n<li><code>-name</code>         find 命令的参数，表示要查找的文件名</li>\n<li><code>-print0</code>       是一种不换行的输出格式，以 ASCII NUL 字符（也就是\\0）作为分隔符。上面的例子可能是 <code>a.html\\0b.html\\0c.html</code></li>\n<li><code>|</code>             这是一个管道符，表示把前面命令的输出作为后面命令的输入</li>\n<li><code>xargs</code>         是用来构造输入参数，并且循环执行每一个参数</li>\n<li><code>-0</code>            表示让 xargs 使用 ASCII NUL 来分隔参数。上面的例子将被分隔成 <code>a.html</code> <code>b.html</code> <code>c.html</code> 三个参数依次执行</li>\n<li><code>sed</code>           这是一个流编辑器，如果传的是文件名会把文件内容读入内存，如果只是普通字符串就会把字符串读入内存</li>\n<li><code>-i</code>            表示要把原来的文件内容做一次备份，后面的 <code>&#39;&#39;</code> 是表示要备份的文件名字，如果没有文件名字就表示不需要备份</li>\n<li><code>-e</code>            表示后面的字符串是一个命令，需要被执行</li>\n<li><code>s/old/new/g</code>   这个是用来替换字符串的命令</li>\n</ul>\n<h2 id=\"Tip-2-查找文件的内容\"><a href=\"#Tip-2-查找文件的内容\" class=\"headerlink\" title=\"Tip 2 : 查找文件的内容\"></a>Tip 2 : 查找文件的内容</h2><p>把匹配的文件内容的相关文件列出来</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ find . -name <span class=\"string\">&#x27;*.html&#x27;</span> -print0 | xargs -0 grep <span class=\"string\">&#x27;PATTERN&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip-3-解决-Homebrew-的权限问题\"><a href=\"#Tip-3-解决-Homebrew-的权限问题\" class=\"headerlink\" title=\"Tip 3 : 解决 Homebrew 的权限问题\"></a>Tip 3 : 解决 Homebrew 的权限问题</h2><p>查看 Homebrew 的所有权</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">ls</span> -al `<span class=\"built_in\">which</span> brew`</span><br></pre></td></tr></table></figure>\n\n<p>把 Homebrew 的用户和分组修改为 root 和 wheel</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo <span class=\"built_in\">chown</span> root:wheel `<span class=\"built_in\">which</span> brew`</span><br></pre></td></tr></table></figure>\n\n<p>最后还原 Homebrew 的权限（安全）</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo <span class=\"built_in\">chown</span> : `<span class=\"built_in\">chown</span> brew`</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip-4-利用-Shell-生成生成-ICON\"><a href=\"#Tip-4-利用-Shell-生成生成-ICON\" class=\"headerlink\" title=\"Tip 4 : 利用 Shell 生成生成 ICON\"></a>Tip 4 : 利用 Shell 生成生成 ICON</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"comment\">#此脚本是用来生成 iPhone 和 iPad 所需 icon 的不同尺寸的，最好是准备一张 1024x1024 的 Icon 图片</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">filename=<span class=\"string\">&quot;icon.png&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">dirname</span>=<span class=\"string\">&quot;icon&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">name_array=(<span class=\"string\">&quot;Icon-20.png&quot;</span> <span class=\"string\">&quot;Icon-20@2x.png&quot;</span> <span class=\"string\">&quot;Icon-20@3x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-29.png&quot;</span> <span class=\"string\">&quot;Icon-29@2x.png&quot;</span> <span class=\"string\">&quot;Icon-29@3x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-40.png&quot;</span> <span class=\"string\">&quot;Icon-40@2x.png&quot;</span> <span class=\"string\">&quot;Icon-40@3x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-60@2x.png&quot;</span> <span class=\"string\">&quot;Icon-60@3x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-76.png&quot;</span> <span class=\"string\">&quot;Icon-76@2x.png&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Icon-83.5@2x.png&quot;</span>)</span><br><span class=\"line\">size_array=(<span class=\"string\">&quot;20&quot;</span> <span class=\"string\">&quot;40&quot;</span> <span class=\"string\">&quot;60&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;29&quot;</span> <span class=\"string\">&quot;58&quot;</span> <span class=\"string\">&quot;87&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;40&quot;</span> <span class=\"string\">&quot;80&quot;</span> <span class=\"string\">&quot;120&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;120&quot;</span> <span class=\"string\">&quot;180&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;76&quot;</span> <span class=\"string\">&quot;152&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;167&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> <span class=\"variable\">$dirname</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> ((i=<span class=\"number\">0</span>;i&lt;<span class=\"variable\">$&#123;#name_array[@]&#125;</span>;++i)); <span class=\"keyword\">do</span></span><br><span class=\"line\">    m_dir=<span class=\"variable\">$dirname</span>/<span class=\"variable\">$&#123;name_array[i]&#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">cp</span> <span class=\"variable\">$filename</span> <span class=\"variable\">$m_dir</span></span><br><span class=\"line\">    sips -Z <span class=\"variable\">$&#123;size_array[i]&#125;</span> <span class=\"variable\">$m_dir</span></span><br><span class=\"line\"><span class=\"comment\"># 如果图片是 sRGB 的话，使用下面的命令</span></span><br><span class=\"line\"><span class=\"comment\">#    sips --matchTo &#x27;/System/Library/ColorSync/Profiles/sRGB Profile.icc&#x27; -Z $&#123;size_array[i]&#125; $m_dir </span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip5-使用-Python-共享当前目录\"><a href=\"#Tip5-使用-Python-共享当前目录\" class=\"headerlink\" title=\"Tip5 : 使用 Python 共享当前目录\"></a>Tip5 : 使用 Python 共享当前目录</h2><p>利用下面的命令可以暂时开启一个端口号为 8000 的 HTTP 服务，其他人只需要在浏览器输入 <code>http://ip-address:8000</code> 即可浏览共享目录下的文件</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Tip6-加密和解密文件\"><a href=\"#Tip6-加密和解密文件\" class=\"headerlink\" title=\"Tip6 : 加密和解密文件\"></a>Tip6 : 加密和解密文件</h2><ul>\n<li>加密</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar czf - &#123;SRC_DIR&#125; | openssl des3 -salt -k <span class=\"string\">&quot;&#123;KEY&#125;&quot;</span> -out &#123;DIST_PACKAGE&#125;.tar.gz</span><br></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<p>目录名 <code>paris_code</code>，秘钥 <code>meta#com</code>，输出包 <code>paris_code_20161008.tar.gz</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar czf - paris_code | openssl des3 -salt -k <span class=\"string\">&quot;meta#com&quot;</span> -out paris_code_20161008.tar.gz</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>解密</li>\n</ul>\n<p>第一步：获取代码压缩文件包</p>\n<p>下载地址 <code>http://XXXX.com/paris_code_20161008.tar.gz</code></p>\n<p>第二步：解密文件（OS X &#x2F; Linux only）</p>\n<p>在 Terminal 进入压缩文件包同级目录，输入以下命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ openssl des3 -d -k <span class=\"string\">&quot;meta#com&quot;</span> -salt -<span class=\"keyword\">in</span> paris_code_20161008.tar.gz | tar xzf -</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip7-iOS-打包命令\"><a href=\"#Tip7-iOS-打包命令\" class=\"headerlink\" title=\"Tip7: iOS 打包命令\"></a>Tip7: iOS 打包命令</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;----------------&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Begin Build!&quot;</span></span><br><span class=\"line\">PROJECT_NAME=<span class=\"string\">&quot;orbit&quot;</span></span><br><span class=\"line\">BUILD_DATE=<span class=\"string\">&quot;<span class=\"subst\">$(date +&#x27;%Y%m%d&#x27;)</span>&quot;</span></span><br><span class=\"line\">BUNDLE_ID=<span class=\"string\">&quot;com.meta.paris&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#/usr/local/bin/npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build&quot;</span> ]; <span class=\"keyword\">then</span> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">ls</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/**/*.ipa 1&gt; /dev/null 2&gt;&amp;1; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">rm</span> -rf <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/**/*.ipa; </span><br><span class=\"line\">    <span class=\"keyword\">fi</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">ls</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/**/*.xcarchive 1&gt; /dev/null 2&gt;&amp;1; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">rm</span> -rf <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/**/*.xcarchive; </span><br><span class=\"line\">    <span class=\"keyword\">fi</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">    <span class=\"built_in\">mkdir</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build; </span><br><span class=\"line\"><span class=\"keyword\">fi</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;计算今天的 Build Version&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_DATE&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span> </span><br><span class=\"line\">   <span class=\"comment\">#如果不加上面的 if, Jenkins 无法直接执行下面的命令❓</span></span><br><span class=\"line\">\tBUILD_DATE_COUNT=$(<span class=\"built_in\">ls</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build | grep <span class=\"string\">&quot;^<span class=\"variable\">$&#123;BUILD_DATE&#125;</span>&quot;</span> -c)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"variable\">$&#123;BUILD_DATE_COUNT&#125;</span> -lt 10 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">        BUILD_DATE_COUNT=<span class=\"string\">&quot;0<span class=\"variable\">$&#123;BUILD_DATE_COUNT&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span>;</span><br><span class=\"line\">\tBUILD_VERSION=<span class=\"string\">&quot;<span class=\"variable\">$&#123;BUILD_DATE&#125;</span><span class=\"variable\">$&#123;BUILD_DATE_COUNT&#125;</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">  \tBUILD_VERSION=<span class=\"variable\">$&#123;BUILD_DATE&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span>;</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;今天的 Build Version 是 <span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>&quot;</span> ]; <span class=\"keyword\">then</span> </span><br><span class=\"line\">    <span class=\"built_in\">rm</span> -rf <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>; </span><br><span class=\"line\"><span class=\"keyword\">fi</span>;</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -d <span class=\"string\">&quot;<span class=\"variable\">$&#123;WORKSPACE&#125;</span>/Enterprise.plist&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">rm</span> <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/Enterprise.plist; </span><br><span class=\"line\"><span class=\"keyword\">fi</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#http://www.matrixprojects.net/p/xcodebuild-export-options-plist/</span></span><br><span class=\"line\">Enterprise=<span class=\"string\">&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;plist version=&quot;1.0&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;dict&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;key&gt;teamID&lt;/key&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;string&gt;&lt;/string&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;key&gt;method&lt;/key&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;string&gt;app-store&lt;/string&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;key&gt;uploadSymbols&lt;/key&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;true/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;key&gt;uploadBitcode&lt;/key&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;false/&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/dict&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/plist&gt;&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;Enterprise&#125;</span> &gt; <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/Enterprise.plist</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g&#x27;</span> \\</span><br><span class=\"line\"><span class=\"variable\">$&#123;WORKSPACE&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcodeproj/project.pbxproj</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/DEVELOPMENT_TEAM = .*;/DEVELOPMENT_TEAM = &quot;&quot;;/g&#x27;</span> \\</span><br><span class=\"line\"><span class=\"variable\">$&#123;WORKSPACE&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcodeproj/project.pbxproj</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#动态生成 Build Version</span></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&quot;/&lt;key&gt;CFBundleVersion&lt;\\/key&gt;/&#123;N;s/&lt;string&gt;.*&lt;\\/string&gt;/&lt;string&gt;<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>&lt;\\/string&gt;/g;&#125;&quot;</span> \\</span><br><span class=\"line\"><span class=\"variable\">$&#123;WORKSPACE&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>-Info.plist</span><br><span class=\"line\"></span><br><span class=\"line\">xcodebuild -workspace <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcworkspace \\</span><br><span class=\"line\">-scheme <span class=\"variable\">$&#123;PROJECT_NAME&#125;</span> -sdk iphoneos \\</span><br><span class=\"line\">build CODE_SIGN_IDENTITY=<span class=\"string\">&quot;iPhone Distribution: Beijing PS Technology Co., Ltd.&quot;</span> \\</span><br><span class=\"line\">PROVISIONING_PROFILE=<span class=\"string\">&quot;&quot;</span> \\</span><br><span class=\"line\">-configuration Release clean archive \\</span><br><span class=\"line\">-archivePath <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcarchive</span><br><span class=\"line\"></span><br><span class=\"line\">xcodebuild -exportArchive -exportOptionsPlist <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/Enterprise.plist \\</span><br><span class=\"line\">-archivePath <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.xcarchive \\</span><br><span class=\"line\">-exportPath <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;----------------&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Build successfully!&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Begin Upload to itunes...&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#Use [shenzhen](https://github.com/nomad/shenzhen) to upload the ipa file to itunes connect.</span></span><br><span class=\"line\">/usr/local/bin/ipa distribute:itunesconnect -f <span class=\"variable\">$&#123;WORKSPACE&#125;</span>/build/<span class=\"variable\">$&#123;BUILD_VERSION&#125;</span>/<span class=\"variable\">$&#123;PROJECT_NAME&#125;</span>.ipa -a YourAppleID -p YourPassword -i <span class=\"variable\">$&#123;BUNDLE_ID&#125;</span> --upload</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Upload successfully!&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Tip8-重置-iOS-模拟器\"><a href=\"#Tip8-重置-iOS-模拟器\" class=\"headerlink\" title=\"Tip8: 重置 iOS 模拟器\"></a>Tip8: 重置 iOS 模拟器</h2><p>相信各位在做 iOS 开发的同学都会碰到模拟器上各种神奇的现象，通过重置 iOS 模拟器基本上可以解决大部分问题：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 退出当前的所有模拟器</span><br><span class=\"line\">$ osascript -e <span class=\"string\">&#x27;tell application &quot;iOS Simulator&quot; to quit&#x27;</span></span><br><span class=\"line\">$ osascript -e <span class=\"string\">&#x27;tell application &quot;Simulator&quot; to quit&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">// 清掉之前使用模拟器产生的所有内容</span><br><span class=\"line\">$ xcrun simctl erase all</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tip9-模拟器截图\"><a href=\"#Tip9-模拟器截图\" class=\"headerlink\" title=\"Tip9: 模拟器截图\"></a>Tip9: 模拟器截图</h2><p>下面的命令会默认截取第一个启动的模拟器：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcrun simctl io booted screenshot screenshot.png</span><br></pre></td></tr></table></figure>\n\n<p>当你同时启动了多个模拟器的情况下，需要先查看当前启动的模拟器 ID，然后指定 ID 截图：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcrun simctl list</span><br><span class=\"line\">xcrun simctl io B5EEDDC0-CDA3-46A9-A2B6-FA940D693DFC screenshot screenshot.png</span><br></pre></td></tr></table></figure>"},{"title":"Swift High-Performance Tip 2：final 和 private(fileprivate)","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n> Dynamic dispatch means that program has to determine at run time which method or property is being referred to and then perform an indirect call or indirect access.\n\n我们都知道 Swift 的 class 是可以被继承，function 和 property 是可以被重写的，而这就意味着 Swift 需要 dynamic dispatch 这种机制来完成这些功能。Swift 的 dynamic dispatch 首先会再 method table 查找方法，然后间接调用。很明显这种方式要比直接调用的效率慢，并且用间接调用的方式还会阻止编译器的一些优化无法实现。\n\n**那么应该怎么优化呢？**\n\n当我们明确的知道 class、function、property 是不需要 overridden，我们可以通过使用 final 和 private(fileprivate) 这些关键字减少动态派发的发生，从而有效的提高效率。\n\n在 Swift 中，如果被 final 或 private(fileprivate) 修饰的 class、function、property 是不能 overridden，并且调用这些 class、function、property 的时候不再通过 dynamic dispatch 去间接调用，而是直接调用。\n\n所以，通过在必要的代码中使用 final 或 private(fileprivate) 这些关键字进行优化的话，将可以有效提高的效率。\n\n**Whole Module Optimization**\n\nSwift 的 class、function、property 的默认权限都是 internal ，除非我们明确的加上 public 或 private(fileprivate) 关键字才能改变它们的默认权限。\n\n编译器在编译 Module 的时候都是对里面的源文件进行单独编译，这样的话编译器就无法确切的知道被 internal 修饰的 class、function、property 究竟有没有被 overridden。一旦我们开启 Whole Module Optimization 的优化选项，编译器就会同时对整个 Module 的所有源文件进行编译，这个时候编译器就可以知道哪些被 internal 修饰的 class、function、property 没有被 overridden，从而把它们的权限从 internal 修改为 final。这样的话，就可以减少 dynamic dispatch 的发生从而提高效率。\n\n开启编译优化选项的步骤如下：Xcode -> Build Settings -> Swift Compiler -> Optimization Level。\n\n![](http://i.imgur.com/0AxWEVA.jpg)\n\n---\n\n**参考文献**\n\n1. https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/\n\n2. https://developer.apple.com/swift/blog/?id=27\n\n3. https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations\n\n","source":"_posts/Swift-High-Performance-Tip 2：final和private(fileprivate).md","raw":"---\ntitle: Swift High-Performance Tip 2：final 和 private(fileprivate)\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: 技术\ntags: [iOS, Swift]\n---\n\n> Dynamic dispatch means that program has to determine at run time which method or property is being referred to and then perform an indirect call or indirect access.\n\n我们都知道 Swift 的 class 是可以被继承，function 和 property 是可以被重写的，而这就意味着 Swift 需要 dynamic dispatch 这种机制来完成这些功能。Swift 的 dynamic dispatch 首先会再 method table 查找方法，然后间接调用。很明显这种方式要比直接调用的效率慢，并且用间接调用的方式还会阻止编译器的一些优化无法实现。\n\n**那么应该怎么优化呢？**\n\n当我们明确的知道 class、function、property 是不需要 overridden，我们可以通过使用 final 和 private(fileprivate) 这些关键字减少动态派发的发生，从而有效的提高效率。\n\n在 Swift 中，如果被 final 或 private(fileprivate) 修饰的 class、function、property 是不能 overridden，并且调用这些 class、function、property 的时候不再通过 dynamic dispatch 去间接调用，而是直接调用。\n\n所以，通过在必要的代码中使用 final 或 private(fileprivate) 这些关键字进行优化的话，将可以有效提高的效率。\n\n**Whole Module Optimization**\n\nSwift 的 class、function、property 的默认权限都是 internal ，除非我们明确的加上 public 或 private(fileprivate) 关键字才能改变它们的默认权限。\n\n编译器在编译 Module 的时候都是对里面的源文件进行单独编译，这样的话编译器就无法确切的知道被 internal 修饰的 class、function、property 究竟有没有被 overridden。一旦我们开启 Whole Module Optimization 的优化选项，编译器就会同时对整个 Module 的所有源文件进行编译，这个时候编译器就可以知道哪些被 internal 修饰的 class、function、property 没有被 overridden，从而把它们的权限从 internal 修改为 final。这样的话，就可以减少 dynamic dispatch 的发生从而提高效率。\n\n开启编译优化选项的步骤如下：Xcode -> Build Settings -> Swift Compiler -> Optimization Level。\n\n![](http://i.imgur.com/0AxWEVA.jpg)\n\n---\n\n**参考文献**\n\n1. https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/\n\n2. https://developer.apple.com/swift/blog/?id=27\n\n3. https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations\n\n","slug":"Swift-High-Performance-Tip 2：final和private(fileprivate)","published":1,"updated":"2023-01-07T05:42:02.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldr5xjcj000jjbsec8gj5k4m","content":"<blockquote>\n<p>Dynamic dispatch means that program has to determine at run time which method or property is being referred to and then perform an indirect call or indirect access.</p>\n</blockquote>\n<p>我们都知道 Swift 的 class 是可以被继承，function 和 property 是可以被重写的，而这就意味着 Swift 需要 dynamic dispatch 这种机制来完成这些功能。Swift 的 dynamic dispatch 首先会再 method table 查找方法，然后间接调用。很明显这种方式要比直接调用的效率慢，并且用间接调用的方式还会阻止编译器的一些优化无法实现。</p>\n<p><strong>那么应该怎么优化呢？</strong></p>\n<p>当我们明确的知道 class、function、property 是不需要 overridden，我们可以通过使用 final 和 private(fileprivate) 这些关键字减少动态派发的发生，从而有效的提高效率。</p>\n<p>在 Swift 中，如果被 final 或 private(fileprivate) 修饰的 class、function、property 是不能 overridden，并且调用这些 class、function、property 的时候不再通过 dynamic dispatch 去间接调用，而是直接调用。</p>\n<p>所以，通过在必要的代码中使用 final 或 private(fileprivate) 这些关键字进行优化的话，将可以有效提高的效率。</p>\n<p><strong>Whole Module Optimization</strong></p>\n<p>Swift 的 class、function、property 的默认权限都是 internal ，除非我们明确的加上 public 或 private(fileprivate) 关键字才能改变它们的默认权限。</p>\n<p>编译器在编译 Module 的时候都是对里面的源文件进行单独编译，这样的话编译器就无法确切的知道被 internal 修饰的 class、function、property 究竟有没有被 overridden。一旦我们开启 Whole Module Optimization 的优化选项，编译器就会同时对整个 Module 的所有源文件进行编译，这个时候编译器就可以知道哪些被 internal 修饰的 class、function、property 没有被 overridden，从而把它们的权限从 internal 修改为 final。这样的话，就可以减少 dynamic dispatch 的发生从而提高效率。</p>\n<p>开启编译优化选项的步骤如下：Xcode -&gt; Build Settings -&gt; Swift Compiler -&gt; Optimization Level。</p>\n<p><img src=\"http://i.imgur.com/0AxWEVA.jpg\"></p>\n<hr>\n<p><strong>参考文献</strong></p>\n<ol>\n<li><p><a href=\"https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/\">https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/</a></p>\n</li>\n<li><p><a href=\"https://developer.apple.com/swift/blog/?id=27\">https://developer.apple.com/swift/blog/?id=27</a></p>\n</li>\n<li><p><a href=\"https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations\">https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Dynamic dispatch means that program has to determine at run time which method or property is being referred to and then perform an indirect call or indirect access.</p>\n</blockquote>\n<p>我们都知道 Swift 的 class 是可以被继承，function 和 property 是可以被重写的，而这就意味着 Swift 需要 dynamic dispatch 这种机制来完成这些功能。Swift 的 dynamic dispatch 首先会再 method table 查找方法，然后间接调用。很明显这种方式要比直接调用的效率慢，并且用间接调用的方式还会阻止编译器的一些优化无法实现。</p>\n<p><strong>那么应该怎么优化呢？</strong></p>\n<p>当我们明确的知道 class、function、property 是不需要 overridden，我们可以通过使用 final 和 private(fileprivate) 这些关键字减少动态派发的发生，从而有效的提高效率。</p>\n<p>在 Swift 中，如果被 final 或 private(fileprivate) 修饰的 class、function、property 是不能 overridden，并且调用这些 class、function、property 的时候不再通过 dynamic dispatch 去间接调用，而是直接调用。</p>\n<p>所以，通过在必要的代码中使用 final 或 private(fileprivate) 这些关键字进行优化的话，将可以有效提高的效率。</p>\n<p><strong>Whole Module Optimization</strong></p>\n<p>Swift 的 class、function、property 的默认权限都是 internal ，除非我们明确的加上 public 或 private(fileprivate) 关键字才能改变它们的默认权限。</p>\n<p>编译器在编译 Module 的时候都是对里面的源文件进行单独编译，这样的话编译器就无法确切的知道被 internal 修饰的 class、function、property 究竟有没有被 overridden。一旦我们开启 Whole Module Optimization 的优化选项，编译器就会同时对整个 Module 的所有源文件进行编译，这个时候编译器就可以知道哪些被 internal 修饰的 class、function、property 没有被 overridden，从而把它们的权限从 internal 修改为 final。这样的话，就可以减少 dynamic dispatch 的发生从而提高效率。</p>\n<p>开启编译优化选项的步骤如下：Xcode -&gt; Build Settings -&gt; Swift Compiler -&gt; Optimization Level。</p>\n<p><img src=\"http://i.imgur.com/0AxWEVA.jpg\"></p>\n<hr>\n<p><strong>参考文献</strong></p>\n<ol>\n<li><p><a href=\"https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/\">https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/</a></p>\n</li>\n<li><p><a href=\"https://developer.apple.com/swift/blog/?id=27\">https://developer.apple.com/swift/blog/?id=27</a></p>\n</li>\n<li><p><a href=\"https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations\">https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations</a></p>\n</li>\n</ol>\n"},{"title":"Swift High-Performance Tip 1：Array 和 ContiguousArray","author":"帕帕","date":"2017-09-05T15:30:56.000Z","thumbnail":"https://images.unsplash.com/photo-1485988412941-77a35537dae4?ixlib=rb-0.3.5&s=177fa5618e070b6d13cf5debd2034426&auto=format&fit=crop&w=160&q=100","_content":"\n> Array 是随机存储的（random-access）集合类型。\n\n> ContiguousArray 是连续存储（contiguously stored）的数组，并且不允许和 NSArray 进行桥接的。\n\n当我们的数组元素是 Class 或 @objc protocol 类型的话，并且我们不需要在 Objective-C 中使用该数组的话，那么我们最好使用 ContiguousArray。这是因为 Array 需要额外的资源来处理跟 NSArray 的桥接功能，但是 ContiguousArray 则不需要，所以 ContiguousArray 比 Array 的效率要高。\n\n```Swift\nclass A {\n\n}\n\n// 不要用Array: let array = Array<A>()\n\nlet contiguousArray = ContiguousArray<A>()\n```\n\n另外需要注意的是官方文档说如果数组元素不是 Class 和 @objc protocol 类型的话，Array 和 ContiguousArray 的效率是一样的。（我猜测是因为如果 Array 的元素都是 Struct 类型的话，它就不需要消耗资源来处理桥接的问题了。）\n\n> Efficiency is equivalent to that of Array, unless Element is a class or @objc protocol type, in which case using ContiguousArray may be more efficient.\n\n但是 [@Paul Hudson](https://twitter.com/twostraws) 在他的[《Pro Swift》](https://gumroad.com/l/proswift)中说他发现即使数组元素是 Struct 类型的话，ContiguousArray 也要比 Array 更快。我们来看看他给出的例子：\n\n```Swift\nlet array2 = Array<Int>(1...1000000)\nlet array3 = ContiguousArray<Int>(1...1000000)\n\nvar start = CFAbsoluteTimeGetCurrent()\narray2.reduce(0, combine: +)\nvar end = CFAbsoluteTimeGetCurrent() - start\nprint(\"Took \\(end) seconds\")\n\nstart = CFAbsoluteTimeGetCurrent()\narray3.reduce(0, combine: +)\nend = CFAbsoluteTimeGetCurrent() - start\nprint(\"Took \\(end) seconds\")\n```\n\n经过我的测试，上面的代码中 ContiguousArray 只用了0.19秒而 Array 用了0.38秒，所以 ContiguousArray 确实要比 Array 快。\n\n如果大家想在性能上有所提升的话，建议大家可以用 ContiguousArray 试一试。\n\n","source":"_posts/Swift-High-Performance-Tip 1：Array和ContiguousArray.md","raw":"---\ntitle: Swift High-Performance Tip 1：Array 和 ContiguousArray\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: 技术\ntags: [iOS, Swift]\nthumbnail: https://images.unsplash.com/photo-1485988412941-77a35537dae4?ixlib=rb-0.3.5&s=177fa5618e070b6d13cf5debd2034426&auto=format&fit=crop&w=160&q=100\n---\n\n> Array 是随机存储的（random-access）集合类型。\n\n> ContiguousArray 是连续存储（contiguously stored）的数组，并且不允许和 NSArray 进行桥接的。\n\n当我们的数组元素是 Class 或 @objc protocol 类型的话，并且我们不需要在 Objective-C 中使用该数组的话，那么我们最好使用 ContiguousArray。这是因为 Array 需要额外的资源来处理跟 NSArray 的桥接功能，但是 ContiguousArray 则不需要，所以 ContiguousArray 比 Array 的效率要高。\n\n```Swift\nclass A {\n\n}\n\n// 不要用Array: let array = Array<A>()\n\nlet contiguousArray = ContiguousArray<A>()\n```\n\n另外需要注意的是官方文档说如果数组元素不是 Class 和 @objc protocol 类型的话，Array 和 ContiguousArray 的效率是一样的。（我猜测是因为如果 Array 的元素都是 Struct 类型的话，它就不需要消耗资源来处理桥接的问题了。）\n\n> Efficiency is equivalent to that of Array, unless Element is a class or @objc protocol type, in which case using ContiguousArray may be more efficient.\n\n但是 [@Paul Hudson](https://twitter.com/twostraws) 在他的[《Pro Swift》](https://gumroad.com/l/proswift)中说他发现即使数组元素是 Struct 类型的话，ContiguousArray 也要比 Array 更快。我们来看看他给出的例子：\n\n```Swift\nlet array2 = Array<Int>(1...1000000)\nlet array3 = ContiguousArray<Int>(1...1000000)\n\nvar start = CFAbsoluteTimeGetCurrent()\narray2.reduce(0, combine: +)\nvar end = CFAbsoluteTimeGetCurrent() - start\nprint(\"Took \\(end) seconds\")\n\nstart = CFAbsoluteTimeGetCurrent()\narray3.reduce(0, combine: +)\nend = CFAbsoluteTimeGetCurrent() - start\nprint(\"Took \\(end) seconds\")\n```\n\n经过我的测试，上面的代码中 ContiguousArray 只用了0.19秒而 Array 用了0.38秒，所以 ContiguousArray 确实要比 Array 快。\n\n如果大家想在性能上有所提升的话，建议大家可以用 ContiguousArray 试一试。\n\n","slug":"Swift-High-Performance-Tip 1：Array和ContiguousArray","published":1,"updated":"2023-01-07T05:42:02.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldr5xjck000mjbsehmq36kz3","content":"<blockquote>\n<p>Array 是随机存储的（random-access）集合类型。</p>\n</blockquote>\n<blockquote>\n<p>ContiguousArray 是连续存储（contiguously stored）的数组，并且不允许和 NSArray 进行桥接的。</p>\n</blockquote>\n<p>当我们的数组元素是 Class 或 @objc protocol 类型的话，并且我们不需要在 Objective-C 中使用该数组的话，那么我们最好使用 ContiguousArray。这是因为 Array 需要额外的资源来处理跟 NSArray 的桥接功能，但是 ContiguousArray 则不需要，所以 ContiguousArray 比 Array 的效率要高。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不要用Array: let array = Array&lt;A&gt;()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> contiguousArray <span class=\"operator\">=</span> <span class=\"type\">ContiguousArray</span>&lt;<span class=\"type\">A</span>&gt;()</span><br></pre></td></tr></table></figure>\n\n<p>另外需要注意的是官方文档说如果数组元素不是 Class 和 @objc protocol 类型的话，Array 和 ContiguousArray 的效率是一样的。（我猜测是因为如果 Array 的元素都是 Struct 类型的话，它就不需要消耗资源来处理桥接的问题了。）</p>\n<blockquote>\n<p>Efficiency is equivalent to that of Array, unless Element is a class or @objc protocol type, in which case using ContiguousArray may be more efficient.</p>\n</blockquote>\n<p>但是 <a href=\"https://twitter.com/twostraws\">@Paul Hudson</a> 在他的<a href=\"https://gumroad.com/l/proswift\">《Pro Swift》</a>中说他发现即使数组元素是 Struct 类型的话，ContiguousArray 也要比 Array 更快。我们来看看他给出的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> array2 <span class=\"operator\">=</span> <span class=\"type\">Array</span>&lt;<span class=\"type\">Int</span>&gt;(<span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">1000000</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> array3 <span class=\"operator\">=</span> <span class=\"type\">ContiguousArray</span>&lt;<span class=\"type\">Int</span>&gt;(<span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">1000000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> start <span class=\"operator\">=</span> <span class=\"type\">CFAbsoluteTimeGetCurrent</span>()</span><br><span class=\"line\">array2.reduce(<span class=\"number\">0</span>, combine: <span class=\"operator\">+</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> end <span class=\"operator\">=</span> <span class=\"type\">CFAbsoluteTimeGetCurrent</span>() <span class=\"operator\">-</span> start</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Took <span class=\"subst\">\\(end)</span> seconds&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">start <span class=\"operator\">=</span> <span class=\"type\">CFAbsoluteTimeGetCurrent</span>()</span><br><span class=\"line\">array3.reduce(<span class=\"number\">0</span>, combine: <span class=\"operator\">+</span>)</span><br><span class=\"line\">end <span class=\"operator\">=</span> <span class=\"type\">CFAbsoluteTimeGetCurrent</span>() <span class=\"operator\">-</span> start</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Took <span class=\"subst\">\\(end)</span> seconds&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>经过我的测试，上面的代码中 ContiguousArray 只用了0.19秒而 Array 用了0.38秒，所以 ContiguousArray 确实要比 Array 快。</p>\n<p>如果大家想在性能上有所提升的话，建议大家可以用 ContiguousArray 试一试。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Array 是随机存储的（random-access）集合类型。</p>\n</blockquote>\n<blockquote>\n<p>ContiguousArray 是连续存储（contiguously stored）的数组，并且不允许和 NSArray 进行桥接的。</p>\n</blockquote>\n<p>当我们的数组元素是 Class 或 @objc protocol 类型的话，并且我们不需要在 Objective-C 中使用该数组的话，那么我们最好使用 ContiguousArray。这是因为 Array 需要额外的资源来处理跟 NSArray 的桥接功能，但是 ContiguousArray 则不需要，所以 ContiguousArray 比 Array 的效率要高。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不要用Array: let array = Array&lt;A&gt;()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> contiguousArray <span class=\"operator\">=</span> <span class=\"type\">ContiguousArray</span>&lt;<span class=\"type\">A</span>&gt;()</span><br></pre></td></tr></table></figure>\n\n<p>另外需要注意的是官方文档说如果数组元素不是 Class 和 @objc protocol 类型的话，Array 和 ContiguousArray 的效率是一样的。（我猜测是因为如果 Array 的元素都是 Struct 类型的话，它就不需要消耗资源来处理桥接的问题了。）</p>\n<blockquote>\n<p>Efficiency is equivalent to that of Array, unless Element is a class or @objc protocol type, in which case using ContiguousArray may be more efficient.</p>\n</blockquote>\n<p>但是 <a href=\"https://twitter.com/twostraws\">@Paul Hudson</a> 在他的<a href=\"https://gumroad.com/l/proswift\">《Pro Swift》</a>中说他发现即使数组元素是 Struct 类型的话，ContiguousArray 也要比 Array 更快。我们来看看他给出的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> array2 <span class=\"operator\">=</span> <span class=\"type\">Array</span>&lt;<span class=\"type\">Int</span>&gt;(<span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">1000000</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> array3 <span class=\"operator\">=</span> <span class=\"type\">ContiguousArray</span>&lt;<span class=\"type\">Int</span>&gt;(<span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">1000000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> start <span class=\"operator\">=</span> <span class=\"type\">CFAbsoluteTimeGetCurrent</span>()</span><br><span class=\"line\">array2.reduce(<span class=\"number\">0</span>, combine: <span class=\"operator\">+</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> end <span class=\"operator\">=</span> <span class=\"type\">CFAbsoluteTimeGetCurrent</span>() <span class=\"operator\">-</span> start</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Took <span class=\"subst\">\\(end)</span> seconds&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">start <span class=\"operator\">=</span> <span class=\"type\">CFAbsoluteTimeGetCurrent</span>()</span><br><span class=\"line\">array3.reduce(<span class=\"number\">0</span>, combine: <span class=\"operator\">+</span>)</span><br><span class=\"line\">end <span class=\"operator\">=</span> <span class=\"type\">CFAbsoluteTimeGetCurrent</span>() <span class=\"operator\">-</span> start</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Took <span class=\"subst\">\\(end)</span> seconds&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>经过我的测试，上面的代码中 ContiguousArray 只用了0.19秒而 Array 用了0.38秒，所以 ContiguousArray 确实要比 Array 快。</p>\n<p>如果大家想在性能上有所提升的话，建议大家可以用 ContiguousArray 试一试。</p>\n"},{"title":"Swift High-Performance Tip 3：@objc 和 dynamic","author":"帕帕","date":"2018-05-24T18:48:01.000Z","thumbnail":"https://images.unsplash.com/photo-1507358522600-9f71e620c44e?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=9606de2cffd6c619093871ef2d1c0e6f&auto=format&fit=crop&w=160&q=100","_content":"\n### @objc\n\n@objc 的作用是为了让 Objective-C 能够调用 Swift 的代码。其中的关键是 @objc 会生成一段 thunk 代码，Objective-C 通过这段 thunk 代码来间接调用 Swift 代码。如果是 Swift 来调用被 @objc 修饰的方法的时候，此时是不需要经过 thunk 代码就能直接调用的。\n\n所以我们可以想象，如果方法变得复杂或者被 @objc 修饰的方法数量变得越来越多会发生什么事？答案就是 thunk 代码变得越来越多，最后会导致我们的包大小也变得越来越大。并且动态链接器（dynamic linker）还需要整理这些 thunk 代码，最后导致加载时间也会变得越来越长。\n\n在 Swift3 的时候，编译器会推断出你的方法不是 Swift 专用的（比如有元组、结构体），就会默认给你的方法增加 @objc 的修饰。这种方式就导致了在 Swift3 的时候，会生成大量的 thunk 代码，并且这其中的大部分代码都不会被使用。所以 Swift4 默认是不做 @objc 的推断，只有我们手动添加了 @objc 之后，Objective-C 才能调用我们的 Swift 代码。 \n\n### dynamic\n\nSwift 的方法是通过 vtable 来调用的，使用 vtable 要比 Objective-C 的 runtime 更高效。\n\n而使用 dynamic 来修饰的方法，代表这个方法是可以被动态调用的。而由于目前 Swfit 还没有实现自己的 runtime 机制，所以动态调用只能够在 Objective-C 去调用。在  Swift4 使用 dynamic 修饰一个方法的时候，编译器会要求你还需要使用 @objc 去修饰。这是为了明确的告诉编译器这个方法是由 Objective-C 的 runtime 来调用的，同时也是为了兼容以后可能会出现的 Swift runtime 机制。\n\n由于目前使用 @objc dynamic 修饰的方法并不在 Swift 实例对象的 vtable 里面，所以 Swift 来调用该方法的时候依旧需要通过 thunk 代码来调用。\n\n### 总结\n\n![此图出自 https://swiftunboxed.com/interop/objc-dynamic/](https://swiftunboxed.com/images/native-objc-dynamic.png)\n\n通过上图我们知道：\n\n> 除非明确的知道会在 Objective-C 中调用这段代码，否则别使用 @objc；\n> 除非明确的知道该方法需要被 Objective-C 的 runtime 动态调用，否则别使用 @objc dynamic。\n\n\n---\n\n**参考文献**\n\n1. https://swiftunboxed.com/interop/objc-dynamic/\n\n2. https://github.com/apple/swift-evolution/blob/master/proposals/0160-objc-inference.md\n\n\n","source":"_posts/Swift-High-Performance-Tip 3：@objc-和-dynamic.md","raw":"---\ntitle: Swift High-Performance Tip 3：@objc 和 dynamic\nauthor: 帕帕\ndate: 2018-05-24 18:48:01 +0800\ncategories: 技术\ntags: [iOS, Swift]\nthumbnail: https://images.unsplash.com/photo-1507358522600-9f71e620c44e?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=9606de2cffd6c619093871ef2d1c0e6f&auto=format&fit=crop&w=160&q=100\n---\n\n### @objc\n\n@objc 的作用是为了让 Objective-C 能够调用 Swift 的代码。其中的关键是 @objc 会生成一段 thunk 代码，Objective-C 通过这段 thunk 代码来间接调用 Swift 代码。如果是 Swift 来调用被 @objc 修饰的方法的时候，此时是不需要经过 thunk 代码就能直接调用的。\n\n所以我们可以想象，如果方法变得复杂或者被 @objc 修饰的方法数量变得越来越多会发生什么事？答案就是 thunk 代码变得越来越多，最后会导致我们的包大小也变得越来越大。并且动态链接器（dynamic linker）还需要整理这些 thunk 代码，最后导致加载时间也会变得越来越长。\n\n在 Swift3 的时候，编译器会推断出你的方法不是 Swift 专用的（比如有元组、结构体），就会默认给你的方法增加 @objc 的修饰。这种方式就导致了在 Swift3 的时候，会生成大量的 thunk 代码，并且这其中的大部分代码都不会被使用。所以 Swift4 默认是不做 @objc 的推断，只有我们手动添加了 @objc 之后，Objective-C 才能调用我们的 Swift 代码。 \n\n### dynamic\n\nSwift 的方法是通过 vtable 来调用的，使用 vtable 要比 Objective-C 的 runtime 更高效。\n\n而使用 dynamic 来修饰的方法，代表这个方法是可以被动态调用的。而由于目前 Swfit 还没有实现自己的 runtime 机制，所以动态调用只能够在 Objective-C 去调用。在  Swift4 使用 dynamic 修饰一个方法的时候，编译器会要求你还需要使用 @objc 去修饰。这是为了明确的告诉编译器这个方法是由 Objective-C 的 runtime 来调用的，同时也是为了兼容以后可能会出现的 Swift runtime 机制。\n\n由于目前使用 @objc dynamic 修饰的方法并不在 Swift 实例对象的 vtable 里面，所以 Swift 来调用该方法的时候依旧需要通过 thunk 代码来调用。\n\n### 总结\n\n![此图出自 https://swiftunboxed.com/interop/objc-dynamic/](https://swiftunboxed.com/images/native-objc-dynamic.png)\n\n通过上图我们知道：\n\n> 除非明确的知道会在 Objective-C 中调用这段代码，否则别使用 @objc；\n> 除非明确的知道该方法需要被 Objective-C 的 runtime 动态调用，否则别使用 @objc dynamic。\n\n\n---\n\n**参考文献**\n\n1. https://swiftunboxed.com/interop/objc-dynamic/\n\n2. https://github.com/apple/swift-evolution/blob/master/proposals/0160-objc-inference.md\n\n\n","slug":"Swift-High-Performance-Tip 3：@objc-和-dynamic","published":1,"updated":"2023-01-07T05:42:02.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldr5xjck000qjbsecievhr1d","content":"<h3 id=\"objc\"><a href=\"#objc\" class=\"headerlink\" title=\"@objc\"></a>@objc</h3><p>@objc 的作用是为了让 Objective-C 能够调用 Swift 的代码。其中的关键是 @objc 会生成一段 thunk 代码，Objective-C 通过这段 thunk 代码来间接调用 Swift 代码。如果是 Swift 来调用被 @objc 修饰的方法的时候，此时是不需要经过 thunk 代码就能直接调用的。</p>\n<p>所以我们可以想象，如果方法变得复杂或者被 @objc 修饰的方法数量变得越来越多会发生什么事？答案就是 thunk 代码变得越来越多，最后会导致我们的包大小也变得越来越大。并且动态链接器（dynamic linker）还需要整理这些 thunk 代码，最后导致加载时间也会变得越来越长。</p>\n<p>在 Swift3 的时候，编译器会推断出你的方法不是 Swift 专用的（比如有元组、结构体），就会默认给你的方法增加 @objc 的修饰。这种方式就导致了在 Swift3 的时候，会生成大量的 thunk 代码，并且这其中的大部分代码都不会被使用。所以 Swift4 默认是不做 @objc 的推断，只有我们手动添加了 @objc 之后，Objective-C 才能调用我们的 Swift 代码。 </p>\n<h3 id=\"dynamic\"><a href=\"#dynamic\" class=\"headerlink\" title=\"dynamic\"></a>dynamic</h3><p>Swift 的方法是通过 vtable 来调用的，使用 vtable 要比 Objective-C 的 runtime 更高效。</p>\n<p>而使用 dynamic 来修饰的方法，代表这个方法是可以被动态调用的。而由于目前 Swfit 还没有实现自己的 runtime 机制，所以动态调用只能够在 Objective-C 去调用。在  Swift4 使用 dynamic 修饰一个方法的时候，编译器会要求你还需要使用 @objc 去修饰。这是为了明确的告诉编译器这个方法是由 Objective-C 的 runtime 来调用的，同时也是为了兼容以后可能会出现的 Swift runtime 机制。</p>\n<p>由于目前使用 @objc dynamic 修饰的方法并不在 Swift 实例对象的 vtable 里面，所以 Swift 来调用该方法的时候依旧需要通过 thunk 代码来调用。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><img src=\"https://swiftunboxed.com/images/native-objc-dynamic.png\" alt=\"此图出自 https://swiftunboxed.com/interop/objc-dynamic/\"></p>\n<p>通过上图我们知道：</p>\n<blockquote>\n<p>除非明确的知道会在 Objective-C 中调用这段代码，否则别使用 @objc；<br>除非明确的知道该方法需要被 Objective-C 的 runtime 动态调用，否则别使用 @objc dynamic。</p>\n</blockquote>\n<hr>\n<p><strong>参考文献</strong></p>\n<ol>\n<li><p><a href=\"https://swiftunboxed.com/interop/objc-dynamic/\">https://swiftunboxed.com/interop/objc-dynamic/</a></p>\n</li>\n<li><p><a href=\"https://github.com/apple/swift-evolution/blob/master/proposals/0160-objc-inference.md\">https://github.com/apple/swift-evolution/blob/master/proposals/0160-objc-inference.md</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"objc\"><a href=\"#objc\" class=\"headerlink\" title=\"@objc\"></a>@objc</h3><p>@objc 的作用是为了让 Objective-C 能够调用 Swift 的代码。其中的关键是 @objc 会生成一段 thunk 代码，Objective-C 通过这段 thunk 代码来间接调用 Swift 代码。如果是 Swift 来调用被 @objc 修饰的方法的时候，此时是不需要经过 thunk 代码就能直接调用的。</p>\n<p>所以我们可以想象，如果方法变得复杂或者被 @objc 修饰的方法数量变得越来越多会发生什么事？答案就是 thunk 代码变得越来越多，最后会导致我们的包大小也变得越来越大。并且动态链接器（dynamic linker）还需要整理这些 thunk 代码，最后导致加载时间也会变得越来越长。</p>\n<p>在 Swift3 的时候，编译器会推断出你的方法不是 Swift 专用的（比如有元组、结构体），就会默认给你的方法增加 @objc 的修饰。这种方式就导致了在 Swift3 的时候，会生成大量的 thunk 代码，并且这其中的大部分代码都不会被使用。所以 Swift4 默认是不做 @objc 的推断，只有我们手动添加了 @objc 之后，Objective-C 才能调用我们的 Swift 代码。 </p>\n<h3 id=\"dynamic\"><a href=\"#dynamic\" class=\"headerlink\" title=\"dynamic\"></a>dynamic</h3><p>Swift 的方法是通过 vtable 来调用的，使用 vtable 要比 Objective-C 的 runtime 更高效。</p>\n<p>而使用 dynamic 来修饰的方法，代表这个方法是可以被动态调用的。而由于目前 Swfit 还没有实现自己的 runtime 机制，所以动态调用只能够在 Objective-C 去调用。在  Swift4 使用 dynamic 修饰一个方法的时候，编译器会要求你还需要使用 @objc 去修饰。这是为了明确的告诉编译器这个方法是由 Objective-C 的 runtime 来调用的，同时也是为了兼容以后可能会出现的 Swift runtime 机制。</p>\n<p>由于目前使用 @objc dynamic 修饰的方法并不在 Swift 实例对象的 vtable 里面，所以 Swift 来调用该方法的时候依旧需要通过 thunk 代码来调用。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><img src=\"https://swiftunboxed.com/images/native-objc-dynamic.png\" alt=\"此图出自 https://swiftunboxed.com/interop/objc-dynamic/\"></p>\n<p>通过上图我们知道：</p>\n<blockquote>\n<p>除非明确的知道会在 Objective-C 中调用这段代码，否则别使用 @objc；<br>除非明确的知道该方法需要被 Objective-C 的 runtime 动态调用，否则别使用 @objc dynamic。</p>\n</blockquote>\n<hr>\n<p><strong>参考文献</strong></p>\n<ol>\n<li><p><a href=\"https://swiftunboxed.com/interop/objc-dynamic/\">https://swiftunboxed.com/interop/objc-dynamic/</a></p>\n</li>\n<li><p><a href=\"https://github.com/apple/swift-evolution/blob/master/proposals/0160-objc-inference.md\">https://github.com/apple/swift-evolution/blob/master/proposals/0160-objc-inference.md</a></p>\n</li>\n</ol>\n"},{"title":"UIScrollView 的偏移问题","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1514464750060-00e6e34c8b8c?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3749c47dd7beec20102c6b32fc19833a&auto=format&fit=crop&w=160&q=100","date":"2019-09-27T17:40:01.000Z","_content":"\n\n## 被控制的 UIScrollView\n\n在 UIViewController 中有个属性：`automaticallyAdjustsScrollViewInsets`，这个属性是用来控制 UIScrollView 的偏移行为的。\n\n> |                                                              |\n> | ------------------------------------------------------------ |\n> | The default value of this property is `true`, which lets container view controllers know that they should adjust the scroll view insets of this view controller’s view to account for screen areas consumed by a status bar, search bar, navigation bar, toolbar, or tab bar. Set this property to `false` if your view controller implementation manages its own scroll view inset adjustments. |\n> |                                                              |\n\n官方文档的意思当在 UIViewController 上添加  UIScrollView 的时候，会根据当前页面的 status bar、 search bar、navigation bar、toolbar 或 tab bar 来修改 UIScrollView 的内容区域。但是这个阶段的 UIViewController 比较蠢，不管任何情况下都会修改 UIScrollView 的偏移量。\n\n比如我们现在有个 UINavigationController，然后添加一个 UIScrollView，然后在 UIScrollView 上面添加一个红色的方块，代码如下：\n\n```Swift\nlet scrollView = UIScrollView()\nscrollView.backgroundColor = .blue\nscrollView.translatesAutoresizingMaskIntoConstraints = false\n// 这里强制设置 contentSize 只是为了让 scrollView 能滚动起来\nscrollView.contentSize = CGSize.init(width: view.frame.size.width, height: 1000)\nview.addSubview(scrollView)\n// ⚠️ 这里是直接跟 view 的 topAnchor 产生约束\nscrollView.topAnchor.constraint(equalTo: view.topAnchor).isActive = true\nscrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true\nscrollView.leftAnchor.constraint(equalTo: view.leftAnchor).isActive = true\nscrollView.rightAnchor.constraint(equalTo: view.rightAnchor).isActive = true\n\nlet redView = UIView()\nredView.backgroundColor = .red\nredView.translatesAutoresizingMaskIntoConstraints = false\nscrollView.addSubview(redView)\nredView.centerXAnchor.constraint(equalTo: scrollView.centerXAnchor).isActive = true\nredView.topAnchor.constraint(equalTo: scrollView.topAnchor).isActive = true\nredView.widthAnchor.constraint(equalToConstant: 100).isActive = true\nredView.heightAnchor.constraint(equalToConstant: 100).isActive = true\n```\n\n<img src=\"https://i.imgur.com/OnQDx7E.png\" alt=\"图一：iOS 10 模拟器效果\" style=\"zoom:50%;\" />\n\n\n\n当我们把 UIScrollView 的 topAnchor 修改为跟 UIViewController 的 topLayoutGuide 发生约束：\n\n```Swift\nscrollView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor).isActive = true\n```\n\n\n\n<img src=\"https://i.imgur.com/dwklB0X.png\" alt=\"图二：iOS 10 模拟器效果\" style=\"zoom:50%;\" />\n\n我们发现最终的效果是 UIScrollView 也发生了偏移，而且这个偏移是根据你顶部的 status bar 和 navigation bar 的高度来决定的。所以在 iOS 10 及以下的版本的时候，添加到 UIViewController 的 UIScrollView 总是会发生偏移。但是你可以通过把刚才说的那个属性 `automaticallyAdjustsScrollViewInsets`设置成 false，UIViewController 就不会让你的 UIScrollView 发生偏移。但是这个属性会影响到所有添加到 UIViewController 上的 UIScrollView，如果有些想要发生偏移，有些不想发生偏移的时候就需要把 `automaticallyAdjustsScrollViewInsets`设置成 false，然后通过代码单独去为每个 UIScrollView 设置不同的 contentInset。\n\n这种被控制的生活很不是滋味，于是随着 iOS 系统来到 11 之后，UIScrollView 终于夺回了自己的偏移控制权。UIViewController 的`automaticallyAdjustsScrollViewInsets`终于被废弃了，取而代之的是 UIScrollView 自己的`contentInsetAdjustmentBehavior`。\n\n## 自由的 UIScrollView\n\n>This property specifies how the safe area insets are used to modify the content area of the scroll view. The default value of this property is [UIScrollView.ContentInsetAdjustmentBehavior.automatic](apple-reference-documentation://hs7dxiWRRh).\n\nUIScrollView 的`contentInsetAdjustmentBehavior`的默认行为是`automatic`，这和 iOS 10 默认行为的最大区别就是它会判断 UIScrollView 是被添加到哪个位置，然后根据这个位置来判断是否需要修改 UIScrollView 的偏移量。\n\n还是拿上面图二的情况来讲，在 iOS 11 及 iOS 11 之后，我们还是照样只修改  UIScrollView 的 topAnchor：\n\n```swift\nscrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor).isActive = true\n```\n\n<img src=\"https://i.imgur.com/co1D7xr.png\" alt=\"图三：iOS 12 模拟器效果\" style=\"zoom:50%;\" />\n\n此时我们发现 UIScrollView 并没有发生偏移，这也是因为 iOS 11 之后引入来 safeArea 的概念之后带来的 UI 方面的优化。\n\n`contentInsetAdjustmentBehavior`还有两个值，其中`always`对应了`automaticallyAdjustsScrollViewInsets`的`true`,`never`对应了`automaticallyAdjustsScrollViewInsets`的`false`。\n\n至于`scrollableAxes`，它其实就是根据 UIScrollView 的滚动方向来决定在哪个轴上使用 sa feArea。\n\n通过`contentInsetAdjustmentBehavior`我们就可以为 UIViewController 上的每一个 UIScrollView 定制它们的偏移行为。","source":"_posts/UIScrollView-的偏移问题.md","raw":"---\ntitle: UIScrollView 的偏移问题\ntags:\n  - iOS\nauthor: 帕帕\ncategories: 技术\nthumbnail: >-\n  https://images.unsplash.com/photo-1514464750060-00e6e34c8b8c?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3749c47dd7beec20102c6b32fc19833a&auto=format&fit=crop&w=160&q=100\ndate: 2019-09-27 17:40:01\n---\n\n\n## 被控制的 UIScrollView\n\n在 UIViewController 中有个属性：`automaticallyAdjustsScrollViewInsets`，这个属性是用来控制 UIScrollView 的偏移行为的。\n\n> |                                                              |\n> | ------------------------------------------------------------ |\n> | The default value of this property is `true`, which lets container view controllers know that they should adjust the scroll view insets of this view controller’s view to account for screen areas consumed by a status bar, search bar, navigation bar, toolbar, or tab bar. Set this property to `false` if your view controller implementation manages its own scroll view inset adjustments. |\n> |                                                              |\n\n官方文档的意思当在 UIViewController 上添加  UIScrollView 的时候，会根据当前页面的 status bar、 search bar、navigation bar、toolbar 或 tab bar 来修改 UIScrollView 的内容区域。但是这个阶段的 UIViewController 比较蠢，不管任何情况下都会修改 UIScrollView 的偏移量。\n\n比如我们现在有个 UINavigationController，然后添加一个 UIScrollView，然后在 UIScrollView 上面添加一个红色的方块，代码如下：\n\n```Swift\nlet scrollView = UIScrollView()\nscrollView.backgroundColor = .blue\nscrollView.translatesAutoresizingMaskIntoConstraints = false\n// 这里强制设置 contentSize 只是为了让 scrollView 能滚动起来\nscrollView.contentSize = CGSize.init(width: view.frame.size.width, height: 1000)\nview.addSubview(scrollView)\n// ⚠️ 这里是直接跟 view 的 topAnchor 产生约束\nscrollView.topAnchor.constraint(equalTo: view.topAnchor).isActive = true\nscrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true\nscrollView.leftAnchor.constraint(equalTo: view.leftAnchor).isActive = true\nscrollView.rightAnchor.constraint(equalTo: view.rightAnchor).isActive = true\n\nlet redView = UIView()\nredView.backgroundColor = .red\nredView.translatesAutoresizingMaskIntoConstraints = false\nscrollView.addSubview(redView)\nredView.centerXAnchor.constraint(equalTo: scrollView.centerXAnchor).isActive = true\nredView.topAnchor.constraint(equalTo: scrollView.topAnchor).isActive = true\nredView.widthAnchor.constraint(equalToConstant: 100).isActive = true\nredView.heightAnchor.constraint(equalToConstant: 100).isActive = true\n```\n\n<img src=\"https://i.imgur.com/OnQDx7E.png\" alt=\"图一：iOS 10 模拟器效果\" style=\"zoom:50%;\" />\n\n\n\n当我们把 UIScrollView 的 topAnchor 修改为跟 UIViewController 的 topLayoutGuide 发生约束：\n\n```Swift\nscrollView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor).isActive = true\n```\n\n\n\n<img src=\"https://i.imgur.com/dwklB0X.png\" alt=\"图二：iOS 10 模拟器效果\" style=\"zoom:50%;\" />\n\n我们发现最终的效果是 UIScrollView 也发生了偏移，而且这个偏移是根据你顶部的 status bar 和 navigation bar 的高度来决定的。所以在 iOS 10 及以下的版本的时候，添加到 UIViewController 的 UIScrollView 总是会发生偏移。但是你可以通过把刚才说的那个属性 `automaticallyAdjustsScrollViewInsets`设置成 false，UIViewController 就不会让你的 UIScrollView 发生偏移。但是这个属性会影响到所有添加到 UIViewController 上的 UIScrollView，如果有些想要发生偏移，有些不想发生偏移的时候就需要把 `automaticallyAdjustsScrollViewInsets`设置成 false，然后通过代码单独去为每个 UIScrollView 设置不同的 contentInset。\n\n这种被控制的生活很不是滋味，于是随着 iOS 系统来到 11 之后，UIScrollView 终于夺回了自己的偏移控制权。UIViewController 的`automaticallyAdjustsScrollViewInsets`终于被废弃了，取而代之的是 UIScrollView 自己的`contentInsetAdjustmentBehavior`。\n\n## 自由的 UIScrollView\n\n>This property specifies how the safe area insets are used to modify the content area of the scroll view. The default value of this property is [UIScrollView.ContentInsetAdjustmentBehavior.automatic](apple-reference-documentation://hs7dxiWRRh).\n\nUIScrollView 的`contentInsetAdjustmentBehavior`的默认行为是`automatic`，这和 iOS 10 默认行为的最大区别就是它会判断 UIScrollView 是被添加到哪个位置，然后根据这个位置来判断是否需要修改 UIScrollView 的偏移量。\n\n还是拿上面图二的情况来讲，在 iOS 11 及 iOS 11 之后，我们还是照样只修改  UIScrollView 的 topAnchor：\n\n```swift\nscrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor).isActive = true\n```\n\n<img src=\"https://i.imgur.com/co1D7xr.png\" alt=\"图三：iOS 12 模拟器效果\" style=\"zoom:50%;\" />\n\n此时我们发现 UIScrollView 并没有发生偏移，这也是因为 iOS 11 之后引入来 safeArea 的概念之后带来的 UI 方面的优化。\n\n`contentInsetAdjustmentBehavior`还有两个值，其中`always`对应了`automaticallyAdjustsScrollViewInsets`的`true`,`never`对应了`automaticallyAdjustsScrollViewInsets`的`false`。\n\n至于`scrollableAxes`，它其实就是根据 UIScrollView 的滚动方向来决定在哪个轴上使用 sa feArea。\n\n通过`contentInsetAdjustmentBehavior`我们就可以为 UIViewController 上的每一个 UIScrollView 定制它们的偏移行为。","slug":"UIScrollView-的偏移问题","published":1,"updated":"2023-01-07T05:42:02.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldr5xjcl000tjbseb7hj7soz","content":"<h2 id=\"被控制的-UIScrollView\"><a href=\"#被控制的-UIScrollView\" class=\"headerlink\" title=\"被控制的 UIScrollView\"></a>被控制的 UIScrollView</h2><p>在 UIViewController 中有个属性：<code>automaticallyAdjustsScrollViewInsets</code>，这个属性是用来控制 UIScrollView 的偏移行为的。</p>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>The default value of this property is <code>true</code>, which lets container view controllers know that they should adjust the scroll view insets of this view controller’s view to account for screen areas consumed by a status bar, search bar, navigation bar, toolbar, or tab bar. Set this property to <code>false</code> if your view controller implementation manages its own scroll view inset adjustments.</td>\n</tr>\n<tr>\n<td></td>\n</tr>\n</tbody></table>\n</blockquote>\n<p>官方文档的意思当在 UIViewController 上添加  UIScrollView 的时候，会根据当前页面的 status bar、 search bar、navigation bar、toolbar 或 tab bar 来修改 UIScrollView 的内容区域。但是这个阶段的 UIViewController 比较蠢，不管任何情况下都会修改 UIScrollView 的偏移量。</p>\n<p>比如我们现在有个 UINavigationController，然后添加一个 UIScrollView，然后在 UIScrollView 上面添加一个红色的方块，代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> scrollView <span class=\"operator\">=</span> <span class=\"type\">UIScrollView</span>()</span><br><span class=\"line\">scrollView.backgroundColor <span class=\"operator\">=</span> .blue</span><br><span class=\"line\">scrollView.translatesAutoresizingMaskIntoConstraints <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\">// 这里强制设置 contentSize 只是为了让 scrollView 能滚动起来</span></span><br><span class=\"line\">scrollView.contentSize <span class=\"operator\">=</span> <span class=\"type\">CGSize</span>.<span class=\"keyword\">init</span>(width: view.frame.size.width, height: <span class=\"number\">1000</span>)</span><br><span class=\"line\">view.addSubview(scrollView)</span><br><span class=\"line\"><span class=\"comment\">// ⚠️ 这里是直接跟 view 的 topAnchor 产生约束</span></span><br><span class=\"line\">scrollView.topAnchor.constraint(equalTo: view.topAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">scrollView.leftAnchor.constraint(equalTo: view.leftAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">scrollView.rightAnchor.constraint(equalTo: view.rightAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> redView <span class=\"operator\">=</span> <span class=\"type\">UIView</span>()</span><br><span class=\"line\">redView.backgroundColor <span class=\"operator\">=</span> .red</span><br><span class=\"line\">redView.translatesAutoresizingMaskIntoConstraints <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\">scrollView.addSubview(redView)</span><br><span class=\"line\">redView.centerXAnchor.constraint(equalTo: scrollView.centerXAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">redView.topAnchor.constraint(equalTo: scrollView.topAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">redView.widthAnchor.constraint(equalToConstant: <span class=\"number\">100</span>).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">redView.heightAnchor.constraint(equalToConstant: <span class=\"number\">100</span>).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"https://i.imgur.com/OnQDx7E.png\" alt=\"图一：iOS 10 模拟器效果\" style=\"zoom:50%;\" />\n\n\n\n<p>当我们把 UIScrollView 的 topAnchor 修改为跟 UIViewController 的 topLayoutGuide 发生约束：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrollView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n\n\n<img src=\"https://i.imgur.com/dwklB0X.png\" alt=\"图二：iOS 10 模拟器效果\" style=\"zoom:50%;\" />\n\n<p>我们发现最终的效果是 UIScrollView 也发生了偏移，而且这个偏移是根据你顶部的 status bar 和 navigation bar 的高度来决定的。所以在 iOS 10 及以下的版本的时候，添加到 UIViewController 的 UIScrollView 总是会发生偏移。但是你可以通过把刚才说的那个属性 <code>automaticallyAdjustsScrollViewInsets</code>设置成 false，UIViewController 就不会让你的 UIScrollView 发生偏移。但是这个属性会影响到所有添加到 UIViewController 上的 UIScrollView，如果有些想要发生偏移，有些不想发生偏移的时候就需要把 <code>automaticallyAdjustsScrollViewInsets</code>设置成 false，然后通过代码单独去为每个 UIScrollView 设置不同的 contentInset。</p>\n<p>这种被控制的生活很不是滋味，于是随着 iOS 系统来到 11 之后，UIScrollView 终于夺回了自己的偏移控制权。UIViewController 的<code>automaticallyAdjustsScrollViewInsets</code>终于被废弃了，取而代之的是 UIScrollView 自己的<code>contentInsetAdjustmentBehavior</code>。</p>\n<h2 id=\"自由的-UIScrollView\"><a href=\"#自由的-UIScrollView\" class=\"headerlink\" title=\"自由的 UIScrollView\"></a>自由的 UIScrollView</h2><blockquote>\n<p>This property specifies how the safe area insets are used to modify the content area of the scroll view. The default value of this property is <a href=\"apple-reference-documentation://hs7dxiWRRh\">UIScrollView.ContentInsetAdjustmentBehavior.automatic</a>.</p>\n</blockquote>\n<p>UIScrollView 的<code>contentInsetAdjustmentBehavior</code>的默认行为是<code>automatic</code>，这和 iOS 10 默认行为的最大区别就是它会判断 UIScrollView 是被添加到哪个位置，然后根据这个位置来判断是否需要修改 UIScrollView 的偏移量。</p>\n<p>还是拿上面图二的情况来讲，在 iOS 11 及 iOS 11 之后，我们还是照样只修改  UIScrollView 的 topAnchor：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"https://i.imgur.com/co1D7xr.png\" alt=\"图三：iOS 12 模拟器效果\" style=\"zoom:50%;\" />\n\n<p>此时我们发现 UIScrollView 并没有发生偏移，这也是因为 iOS 11 之后引入来 safeArea 的概念之后带来的 UI 方面的优化。</p>\n<p><code>contentInsetAdjustmentBehavior</code>还有两个值，其中<code>always</code>对应了<code>automaticallyAdjustsScrollViewInsets</code>的<code>true</code>,<code>never</code>对应了<code>automaticallyAdjustsScrollViewInsets</code>的<code>false</code>。</p>\n<p>至于<code>scrollableAxes</code>，它其实就是根据 UIScrollView 的滚动方向来决定在哪个轴上使用 sa feArea。</p>\n<p>通过<code>contentInsetAdjustmentBehavior</code>我们就可以为 UIViewController 上的每一个 UIScrollView 定制它们的偏移行为。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"被控制的-UIScrollView\"><a href=\"#被控制的-UIScrollView\" class=\"headerlink\" title=\"被控制的 UIScrollView\"></a>被控制的 UIScrollView</h2><p>在 UIViewController 中有个属性：<code>automaticallyAdjustsScrollViewInsets</code>，这个属性是用来控制 UIScrollView 的偏移行为的。</p>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>The default value of this property is <code>true</code>, which lets container view controllers know that they should adjust the scroll view insets of this view controller’s view to account for screen areas consumed by a status bar, search bar, navigation bar, toolbar, or tab bar. Set this property to <code>false</code> if your view controller implementation manages its own scroll view inset adjustments.</td>\n</tr>\n<tr>\n<td></td>\n</tr>\n</tbody></table>\n</blockquote>\n<p>官方文档的意思当在 UIViewController 上添加  UIScrollView 的时候，会根据当前页面的 status bar、 search bar、navigation bar、toolbar 或 tab bar 来修改 UIScrollView 的内容区域。但是这个阶段的 UIViewController 比较蠢，不管任何情况下都会修改 UIScrollView 的偏移量。</p>\n<p>比如我们现在有个 UINavigationController，然后添加一个 UIScrollView，然后在 UIScrollView 上面添加一个红色的方块，代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> scrollView <span class=\"operator\">=</span> <span class=\"type\">UIScrollView</span>()</span><br><span class=\"line\">scrollView.backgroundColor <span class=\"operator\">=</span> .blue</span><br><span class=\"line\">scrollView.translatesAutoresizingMaskIntoConstraints <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\">// 这里强制设置 contentSize 只是为了让 scrollView 能滚动起来</span></span><br><span class=\"line\">scrollView.contentSize <span class=\"operator\">=</span> <span class=\"type\">CGSize</span>.<span class=\"keyword\">init</span>(width: view.frame.size.width, height: <span class=\"number\">1000</span>)</span><br><span class=\"line\">view.addSubview(scrollView)</span><br><span class=\"line\"><span class=\"comment\">// ⚠️ 这里是直接跟 view 的 topAnchor 产生约束</span></span><br><span class=\"line\">scrollView.topAnchor.constraint(equalTo: view.topAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">scrollView.leftAnchor.constraint(equalTo: view.leftAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">scrollView.rightAnchor.constraint(equalTo: view.rightAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> redView <span class=\"operator\">=</span> <span class=\"type\">UIView</span>()</span><br><span class=\"line\">redView.backgroundColor <span class=\"operator\">=</span> .red</span><br><span class=\"line\">redView.translatesAutoresizingMaskIntoConstraints <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\">scrollView.addSubview(redView)</span><br><span class=\"line\">redView.centerXAnchor.constraint(equalTo: scrollView.centerXAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">redView.topAnchor.constraint(equalTo: scrollView.topAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">redView.widthAnchor.constraint(equalToConstant: <span class=\"number\">100</span>).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">redView.heightAnchor.constraint(equalToConstant: <span class=\"number\">100</span>).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"https://i.imgur.com/OnQDx7E.png\" alt=\"图一：iOS 10 模拟器效果\" style=\"zoom:50%;\" />\n\n\n\n<p>当我们把 UIScrollView 的 topAnchor 修改为跟 UIViewController 的 topLayoutGuide 发生约束：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrollView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n\n\n<img src=\"https://i.imgur.com/dwklB0X.png\" alt=\"图二：iOS 10 模拟器效果\" style=\"zoom:50%;\" />\n\n<p>我们发现最终的效果是 UIScrollView 也发生了偏移，而且这个偏移是根据你顶部的 status bar 和 navigation bar 的高度来决定的。所以在 iOS 10 及以下的版本的时候，添加到 UIViewController 的 UIScrollView 总是会发生偏移。但是你可以通过把刚才说的那个属性 <code>automaticallyAdjustsScrollViewInsets</code>设置成 false，UIViewController 就不会让你的 UIScrollView 发生偏移。但是这个属性会影响到所有添加到 UIViewController 上的 UIScrollView，如果有些想要发生偏移，有些不想发生偏移的时候就需要把 <code>automaticallyAdjustsScrollViewInsets</code>设置成 false，然后通过代码单独去为每个 UIScrollView 设置不同的 contentInset。</p>\n<p>这种被控制的生活很不是滋味，于是随着 iOS 系统来到 11 之后，UIScrollView 终于夺回了自己的偏移控制权。UIViewController 的<code>automaticallyAdjustsScrollViewInsets</code>终于被废弃了，取而代之的是 UIScrollView 自己的<code>contentInsetAdjustmentBehavior</code>。</p>\n<h2 id=\"自由的-UIScrollView\"><a href=\"#自由的-UIScrollView\" class=\"headerlink\" title=\"自由的 UIScrollView\"></a>自由的 UIScrollView</h2><blockquote>\n<p>This property specifies how the safe area insets are used to modify the content area of the scroll view. The default value of this property is <a href=\"apple-reference-documentation://hs7dxiWRRh\">UIScrollView.ContentInsetAdjustmentBehavior.automatic</a>.</p>\n</blockquote>\n<p>UIScrollView 的<code>contentInsetAdjustmentBehavior</code>的默认行为是<code>automatic</code>，这和 iOS 10 默认行为的最大区别就是它会判断 UIScrollView 是被添加到哪个位置，然后根据这个位置来判断是否需要修改 UIScrollView 的偏移量。</p>\n<p>还是拿上面图二的情况来讲，在 iOS 11 及 iOS 11 之后，我们还是照样只修改  UIScrollView 的 topAnchor：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<img src=\"https://i.imgur.com/co1D7xr.png\" alt=\"图三：iOS 12 模拟器效果\" style=\"zoom:50%;\" />\n\n<p>此时我们发现 UIScrollView 并没有发生偏移，这也是因为 iOS 11 之后引入来 safeArea 的概念之后带来的 UI 方面的优化。</p>\n<p><code>contentInsetAdjustmentBehavior</code>还有两个值，其中<code>always</code>对应了<code>automaticallyAdjustsScrollViewInsets</code>的<code>true</code>,<code>never</code>对应了<code>automaticallyAdjustsScrollViewInsets</code>的<code>false</code>。</p>\n<p>至于<code>scrollableAxes</code>，它其实就是根据 UIScrollView 的滚动方向来决定在哪个轴上使用 sa feArea。</p>\n<p>通过<code>contentInsetAdjustmentBehavior</code>我们就可以为 UIViewController 上的每一个 UIScrollView 定制它们的偏移行为。</p>\n"},{"title":"Vim Tip","subtitle":"记录日常中使用的 Vim 命令，经常更新","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n## 1、替换第n1行到第n2行的内容\n\n```Vim\n:n1,n2/origin/replace/g\n```\n\n## 2、替换整个文件的内容\n\n```Vim\n:%s/origin/replace/g\n```\n\n## 3、移动n1-n2行(包括n1,n2)到n3行之下\n\n```Vim\nn1,n2 m n3     \n```\n\n## 4、复制n1-n2行(包括n1,n2)到n3行之下\n\n```Vim\n:n1,n2 co n3\n```\n\n## 5、删除文件的空行\n\n```Vim\n:g/^$/d\n```\n\n## 6、在文本中插入一个1到100的序列（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\n:r!seq 100\n```\n\n## 7、在当前的每一行文字前面增加“序号. ”（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\n:let i=1 | g /^/ s//\\=i.\". \"/ | let i+=1\n```\n\n## 8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\nvim\n:n **/*.java\n:argdo %s/apache/eclipse/ge | update \n```\n\n","source":"_posts/Vim-Tip.md","raw":"---\ntitle: Vim Tip\nsubtitle: 记录日常中使用的 Vim 命令，经常更新\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: 技术\ntags: [tip]\n---\n\n## 1、替换第n1行到第n2行的内容\n\n```Vim\n:n1,n2/origin/replace/g\n```\n\n## 2、替换整个文件的内容\n\n```Vim\n:%s/origin/replace/g\n```\n\n## 3、移动n1-n2行(包括n1,n2)到n3行之下\n\n```Vim\nn1,n2 m n3     \n```\n\n## 4、复制n1-n2行(包括n1,n2)到n3行之下\n\n```Vim\n:n1,n2 co n3\n```\n\n## 5、删除文件的空行\n\n```Vim\n:g/^$/d\n```\n\n## 6、在文本中插入一个1到100的序列（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\n:r!seq 100\n```\n\n## 7、在当前的每一行文字前面增加“序号. ”（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\n:let i=1 | g /^/ s//\\=i.\". \"/ | let i+=1\n```\n\n## 8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\nvim\n:n **/*.java\n:argdo %s/apache/eclipse/ge | update \n```\n\n","slug":"Vim-Tip","published":1,"updated":"2023-01-07T05:42:02.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldr5xjcl000xjbse6expd1an","content":"<h2 id=\"1、替换第n1行到第n2行的内容\"><a href=\"#1、替换第n1行到第n2行的内容\" class=\"headerlink\" title=\"1、替换第n1行到第n2行的内容\"></a>1、替换第n1行到第n2行的内容</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:n1,n2/origin/replace/g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、替换整个文件的内容\"><a href=\"#2、替换整个文件的内容\" class=\"headerlink\" title=\"2、替换整个文件的内容\"></a>2、替换整个文件的内容</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:%s/origin/replace/g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3、移动n1-n2行-包括n1-n2-到n3行之下\"><a href=\"#3、移动n1-n2行-包括n1-n2-到n3行之下\" class=\"headerlink\" title=\"3、移动n1-n2行(包括n1,n2)到n3行之下\"></a>3、移动n1-n2行(包括n1,n2)到n3行之下</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n1,n2 <span class=\"keyword\">m</span> n3     </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4、复制n1-n2行-包括n1-n2-到n3行之下\"><a href=\"#4、复制n1-n2行-包括n1-n2-到n3行之下\" class=\"headerlink\" title=\"4、复制n1-n2行(包括n1,n2)到n3行之下\"></a>4、复制n1-n2行(包括n1,n2)到n3行之下</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:n1,n2 <span class=\"keyword\">co</span> n3</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5、删除文件的空行\"><a href=\"#5、删除文件的空行\" class=\"headerlink\" title=\"5、删除文件的空行\"></a>5、删除文件的空行</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:g/^$/d</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\"></a>6、在文本中插入一个1到100的序列（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:r!seq <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7、在当前的每一行文字前面增加“序号-”（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#7、在当前的每一行文字前面增加“序号-”（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"7、在当前的每一行文字前面增加“序号. ”（来自池老师《说，谁才是最帅的编程工具？》）\"></a>7、在当前的每一行文字前面增加“序号. ”（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:<span class=\"keyword\">let</span> i=<span class=\"number\">1</span> | g /^/ s//\\=i.<span class=\"string\">&quot;. &quot;</span>/ | <span class=\"keyword\">let</span> i+=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8、当前目录下（包括子文件夹）所有后缀为-java-的文件中的-apache-替换成-eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#8、当前目录下（包括子文件夹）所有后缀为-java-的文件中的-apache-替换成-eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\"></a>8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">vim</span></span><br><span class=\"line\">:n **/*.java</span><br><span class=\"line\">:<span class=\"keyword\">argdo</span> %s/apache/eclipse/ge | <span class=\"keyword\">update</span> </span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1、替换第n1行到第n2行的内容\"><a href=\"#1、替换第n1行到第n2行的内容\" class=\"headerlink\" title=\"1、替换第n1行到第n2行的内容\"></a>1、替换第n1行到第n2行的内容</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:n1,n2/origin/replace/g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、替换整个文件的内容\"><a href=\"#2、替换整个文件的内容\" class=\"headerlink\" title=\"2、替换整个文件的内容\"></a>2、替换整个文件的内容</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:%s/origin/replace/g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3、移动n1-n2行-包括n1-n2-到n3行之下\"><a href=\"#3、移动n1-n2行-包括n1-n2-到n3行之下\" class=\"headerlink\" title=\"3、移动n1-n2行(包括n1,n2)到n3行之下\"></a>3、移动n1-n2行(包括n1,n2)到n3行之下</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n1,n2 <span class=\"keyword\">m</span> n3     </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4、复制n1-n2行-包括n1-n2-到n3行之下\"><a href=\"#4、复制n1-n2行-包括n1-n2-到n3行之下\" class=\"headerlink\" title=\"4、复制n1-n2行(包括n1,n2)到n3行之下\"></a>4、复制n1-n2行(包括n1,n2)到n3行之下</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:n1,n2 <span class=\"keyword\">co</span> n3</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5、删除文件的空行\"><a href=\"#5、删除文件的空行\" class=\"headerlink\" title=\"5、删除文件的空行\"></a>5、删除文件的空行</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:g/^$/d</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\"></a>6、在文本中插入一个1到100的序列（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:r!seq <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7、在当前的每一行文字前面增加“序号-”（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#7、在当前的每一行文字前面增加“序号-”（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"7、在当前的每一行文字前面增加“序号. ”（来自池老师《说，谁才是最帅的编程工具？》）\"></a>7、在当前的每一行文字前面增加“序号. ”（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:<span class=\"keyword\">let</span> i=<span class=\"number\">1</span> | g /^/ s//\\=i.<span class=\"string\">&quot;. &quot;</span>/ | <span class=\"keyword\">let</span> i+=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8、当前目录下（包括子文件夹）所有后缀为-java-的文件中的-apache-替换成-eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#8、当前目录下（包括子文件夹）所有后缀为-java-的文件中的-apache-替换成-eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\"></a>8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">vim</span></span><br><span class=\"line\">:n **/*.java</span><br><span class=\"line\">:<span class=\"keyword\">argdo</span> %s/apache/eclipse/ge | <span class=\"keyword\">update</span> </span><br></pre></td></tr></table></figure>\n\n"},{"title":"include 和 import 的区别","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n今天我们来了解下面这几种包含文件的方式有什么特点和区别：\n\n```Swift\n#include \"fiel\"\n#include <file>\n#import \"file\"\n#import <file>\n@import Module\n```\n\n---\n\n## 一、#include\n\n学过 C 语言的人都知道，#include 其实是一个预处理命令。它会在预处理的时候简单的把被 #include 包含的文件内容进行复制粘贴。我们来看看下面的代码：\n\n```C\n// A.h\nvoid sampleA() {\n  // A code\n}\n\n```\n\n```C\n// B.h\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们使用 gcc -E B.h 命令来看看经过预处理后的文件内容大概如下：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n我们可以看到经过预处理之后，A.h 文件中的内容被直接复制并粘贴到 B.h 文件中来。如果我们在 B.h 文件中多次包含了 A.h 文件，会出现什么情况？比如：\n\n```C\n// A.h\nvoid sampleA() {\n  // A code\n}\n```\n\n```C\n// B.h\n#include \"A.h\"\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n经过预处理之后的内容大概如下：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 3 \"B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\nA.h 文件中的 sampleA() 函数出现了两次，所以我们需要利用其他的一些预处理命令来规避这种情况，看看下面的代码：\n\n```C\n// A.h\n#ifndef FILE_A\n#define FILE_A\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```C\n// B.h\n#include \"A.h\"\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们再来看看增加了这些预处理命令之后的预处理文件内容：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n\n\n\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n\n\nvoid sampleB() {\n\n}\n```\n\nOK，这就正常了。如果我们在 A.h 中包含 B.h，然后又在 B.h 中包含 A.h，具体代码如下：\n\n```C\n// A.h\n#include \"B.h\"\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```\n// B.h\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们再来看看经过 gcc -E B.h 处理之后的文件内容：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\n...\n...\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\n...\n...\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\n./A.h:1:10: error: #include nested too deeply\n#include \"B.h\"\n         ^\n\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n...\n...\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n1 error generated.\n```\n\n我们发现 A.h 和 B.h 重复出现，这是因为这个时候 A.h 和 B.h 文件互相引用导致的。从理论上来讲，这个时候会无限循环下去，直至世界终结。在这里最后会出现一句 *1 error generated.*的提示是 gcc 强行中断了这个预处理的过程，所以我们才能看到这样的结果。那我们可以怎么做？当然是利用前面说的预处理命令来避免循环引用的问题。看下面的代码：\n\n```C\n// A.h\n#ifndef FILE_A\n#define FILE_A\n\n#include \"B.h\"\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```C\n// B.h\n#ifndef FILE_B\n#define FILE_B\n\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n#endif\n```\n\n这个时候使用 gcc -E B.h 就可以正常的进行预处理，最后的结果如下：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n\n\n\n# 1 \"./A.h\" 1\n\n\n\n# 1 \"./B.h\" 1\n# 5 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 5 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n所以C程序员总是需要通过各种手段（比如：[#pragma once](https://en.wikipedia.org/wiki/Pragma_once)）来防范此类事件的发生。\n\n\n## 二、#import\n\n我们在文件中通过#import来导入 iAd Framework：\n![](http://i.imgur.com/nLPSsNN.jpg)\n\n\n编译报错：\n![](http://i.imgur.com/XBXD8wu.jpg)\n\n需要重新导入和链接 Framework：\n![](http://i.imgur.com/rUnKJGb.jpg)\n![](http://i.imgur.com/XuxVI6b.jpg)\n\n编译成功：\n![](http://i.imgur.com/QvyQunr.jpg)\n\n从上面的过程中我们就知道在 Objective-C 项目中使用 #import 需要注意导入和链接 Framework，否则是会报错的。\n\n预处理器在碰到 #import 命令的时候，它会采用递归的方式把被所有头文件的内容复制并粘贴到当前文件中，如果文件依赖层次比较深就会造成预处理后的文件内容体积大幅度变大。\n\n比如导入 UIKit 的时候只需要一行代码：\n\n```Swift\n#import <UIKit/UIKit.h>\n```\n\n预处理之后会变成200多行（UIKit.h 文件有200多行代码）：\n\n```Swift\n#import <UIKit/UIKitDefines.h>\n\n#if __has_include(<UIKit/UIAccelerometer.h>)\n#import <UIKit/UIAccelerometer.h>\n.....\n#import <UIKit/UIRegion.h>\n#endif\n```\n\n接下来还需要递归的把每个头文件的内容展开，最后的结果就是一行代码变成超过11000行代码。如果有多个文件都包含来 UIKit 的头文件，这样就会让每个文件的体积都会变得很大，编译过程也会变得越来越慢。这种递归的方式会让项目的编译时间变成：*M source files + N headers => M x N compile time*。\n\n所以这个时候有一个优化方法就是把项目中频繁被引用的文件放到 PCH（Pre-Compile Header）文件中。PCH 会被编译一次并且会被缓存，这就可以缩短编译时间，我们也不需要在不同的文件里面添加import语法。\n\n当然，PCH 也有自己的缺点：\n\n* 维护负担：随着项目变得越来越复杂，我们就会不停的往PCH文件加入内容，内容一旦变多就会变得不好维护。（这也是我们平常在项目中要避免在 ViewController 做太多事情的，要研究 MVVM的缘故。）\n\n* 命名空间污染\n\n\n最后，给大家提供一个例子看看 #import 编译出来之后的文件内容：\n\n```C\n// A.h\n#import \"B.h\"\n \nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```C\n// B.h\n#import \"A.h\"\n#import \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n使用 gcc -E B.h 进行预处理之后的内容如下：\n\n```C\n\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n我们在B.h中有两个 #import \"A.h\"，但是这些内容跟我们之前在 A.h 和 B.h 文件中使用 #include 和其他预处理命令之后的处理结果很相似，所以我们就明白了 #import 大概做了什么事。\n\n## 三、@import\n\n在2012年的 LLVM 大会上，苹果的 Doug Gregor 首次提出了 Objective-C 中的 Module。使用 @import 方式导入有几个好处：\n\n* 不需要像 #import 一样得手动去链接 Framework，@import会自动去链接\n\n* @import 工作方式和 PCH 很像，但是 @import 要比 PCH 的效率高出许多\n\n* @import 导入 Modul 优化文件体积变大、编译速度变慢的问题\n\n* 可以部分导入（@import Framework.A）或全部导入（@import Framework）\n\n所以，建议大家尽量使用 @import 来导入文件。如果你以前的项目用的是 #import，那么你也不需要担心，我们只通过 Build Settings 开启 Modules 选项（看下图），#import 和 #include 会自动被映射成 @import，所以你不需要更改原来的代码也能享受 @import带来的好处。\n\n![](http://i.imgur.com/l7ZMUy6.jpg)\n\n详细内容可以看看苹果2013年的 [Advances in Objective-C](https://developer.apple.com/videos/play/wwdc2013/404/)，里面就详细介绍了 Module。\n\n## 四、文件路径\n\n接下来我们来了解一下 *#include <file>* 和 *#include \"file\"*：\n\n* \\#include \\<file>: 表示编译器会直接到系统设定的目录下寻找指定的文件。\n\n* \\#include \"file\": 表示编译器会到当前的目录下寻找指定的文件，如果找不到，则会去系统设定的目录下寻找指定的文件。\n\n---\n参考文献：\n\n1. https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html\n\n2. http://stackoverflow.com/questions/18947516/import-vs-import-ios-7\n\n3. https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7\n\n","source":"_posts/include和import的区别.md","raw":"---\ntitle: include 和 import 的区别\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: 技术 \ntags: [iOS]\n---\n\n今天我们来了解下面这几种包含文件的方式有什么特点和区别：\n\n```Swift\n#include \"fiel\"\n#include <file>\n#import \"file\"\n#import <file>\n@import Module\n```\n\n---\n\n## 一、#include\n\n学过 C 语言的人都知道，#include 其实是一个预处理命令。它会在预处理的时候简单的把被 #include 包含的文件内容进行复制粘贴。我们来看看下面的代码：\n\n```C\n// A.h\nvoid sampleA() {\n  // A code\n}\n\n```\n\n```C\n// B.h\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们使用 gcc -E B.h 命令来看看经过预处理后的文件内容大概如下：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n我们可以看到经过预处理之后，A.h 文件中的内容被直接复制并粘贴到 B.h 文件中来。如果我们在 B.h 文件中多次包含了 A.h 文件，会出现什么情况？比如：\n\n```C\n// A.h\nvoid sampleA() {\n  // A code\n}\n```\n\n```C\n// B.h\n#include \"A.h\"\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n经过预处理之后的内容大概如下：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 3 \"B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\nA.h 文件中的 sampleA() 函数出现了两次，所以我们需要利用其他的一些预处理命令来规避这种情况，看看下面的代码：\n\n```C\n// A.h\n#ifndef FILE_A\n#define FILE_A\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```C\n// B.h\n#include \"A.h\"\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们再来看看增加了这些预处理命令之后的预处理文件内容：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n\n\n\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n\n\nvoid sampleB() {\n\n}\n```\n\nOK，这就正常了。如果我们在 A.h 中包含 B.h，然后又在 B.h 中包含 A.h，具体代码如下：\n\n```C\n// A.h\n#include \"B.h\"\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```\n// B.h\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们再来看看经过 gcc -E B.h 处理之后的文件内容：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\n...\n...\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\n...\n...\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\n./A.h:1:10: error: #include nested too deeply\n#include \"B.h\"\n         ^\n\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n...\n...\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n1 error generated.\n```\n\n我们发现 A.h 和 B.h 重复出现，这是因为这个时候 A.h 和 B.h 文件互相引用导致的。从理论上来讲，这个时候会无限循环下去，直至世界终结。在这里最后会出现一句 *1 error generated.*的提示是 gcc 强行中断了这个预处理的过程，所以我们才能看到这样的结果。那我们可以怎么做？当然是利用前面说的预处理命令来避免循环引用的问题。看下面的代码：\n\n```C\n// A.h\n#ifndef FILE_A\n#define FILE_A\n\n#include \"B.h\"\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```C\n// B.h\n#ifndef FILE_B\n#define FILE_B\n\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n#endif\n```\n\n这个时候使用 gcc -E B.h 就可以正常的进行预处理，最后的结果如下：\n\n```C\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n\n\n\n# 1 \"./A.h\" 1\n\n\n\n# 1 \"./B.h\" 1\n# 5 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 5 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n所以C程序员总是需要通过各种手段（比如：[#pragma once](https://en.wikipedia.org/wiki/Pragma_once)）来防范此类事件的发生。\n\n\n## 二、#import\n\n我们在文件中通过#import来导入 iAd Framework：\n![](http://i.imgur.com/nLPSsNN.jpg)\n\n\n编译报错：\n![](http://i.imgur.com/XBXD8wu.jpg)\n\n需要重新导入和链接 Framework：\n![](http://i.imgur.com/rUnKJGb.jpg)\n![](http://i.imgur.com/XuxVI6b.jpg)\n\n编译成功：\n![](http://i.imgur.com/QvyQunr.jpg)\n\n从上面的过程中我们就知道在 Objective-C 项目中使用 #import 需要注意导入和链接 Framework，否则是会报错的。\n\n预处理器在碰到 #import 命令的时候，它会采用递归的方式把被所有头文件的内容复制并粘贴到当前文件中，如果文件依赖层次比较深就会造成预处理后的文件内容体积大幅度变大。\n\n比如导入 UIKit 的时候只需要一行代码：\n\n```Swift\n#import <UIKit/UIKit.h>\n```\n\n预处理之后会变成200多行（UIKit.h 文件有200多行代码）：\n\n```Swift\n#import <UIKit/UIKitDefines.h>\n\n#if __has_include(<UIKit/UIAccelerometer.h>)\n#import <UIKit/UIAccelerometer.h>\n.....\n#import <UIKit/UIRegion.h>\n#endif\n```\n\n接下来还需要递归的把每个头文件的内容展开，最后的结果就是一行代码变成超过11000行代码。如果有多个文件都包含来 UIKit 的头文件，这样就会让每个文件的体积都会变得很大，编译过程也会变得越来越慢。这种递归的方式会让项目的编译时间变成：*M source files + N headers => M x N compile time*。\n\n所以这个时候有一个优化方法就是把项目中频繁被引用的文件放到 PCH（Pre-Compile Header）文件中。PCH 会被编译一次并且会被缓存，这就可以缩短编译时间，我们也不需要在不同的文件里面添加import语法。\n\n当然，PCH 也有自己的缺点：\n\n* 维护负担：随着项目变得越来越复杂，我们就会不停的往PCH文件加入内容，内容一旦变多就会变得不好维护。（这也是我们平常在项目中要避免在 ViewController 做太多事情的，要研究 MVVM的缘故。）\n\n* 命名空间污染\n\n\n最后，给大家提供一个例子看看 #import 编译出来之后的文件内容：\n\n```C\n// A.h\n#import \"B.h\"\n \nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```C\n// B.h\n#import \"A.h\"\n#import \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n使用 gcc -E B.h 进行预处理之后的内容如下：\n\n```C\n\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n我们在B.h中有两个 #import \"A.h\"，但是这些内容跟我们之前在 A.h 和 B.h 文件中使用 #include 和其他预处理命令之后的处理结果很相似，所以我们就明白了 #import 大概做了什么事。\n\n## 三、@import\n\n在2012年的 LLVM 大会上，苹果的 Doug Gregor 首次提出了 Objective-C 中的 Module。使用 @import 方式导入有几个好处：\n\n* 不需要像 #import 一样得手动去链接 Framework，@import会自动去链接\n\n* @import 工作方式和 PCH 很像，但是 @import 要比 PCH 的效率高出许多\n\n* @import 导入 Modul 优化文件体积变大、编译速度变慢的问题\n\n* 可以部分导入（@import Framework.A）或全部导入（@import Framework）\n\n所以，建议大家尽量使用 @import 来导入文件。如果你以前的项目用的是 #import，那么你也不需要担心，我们只通过 Build Settings 开启 Modules 选项（看下图），#import 和 #include 会自动被映射成 @import，所以你不需要更改原来的代码也能享受 @import带来的好处。\n\n![](http://i.imgur.com/l7ZMUy6.jpg)\n\n详细内容可以看看苹果2013年的 [Advances in Objective-C](https://developer.apple.com/videos/play/wwdc2013/404/)，里面就详细介绍了 Module。\n\n## 四、文件路径\n\n接下来我们来了解一下 *#include <file>* 和 *#include \"file\"*：\n\n* \\#include \\<file>: 表示编译器会直接到系统设定的目录下寻找指定的文件。\n\n* \\#include \"file\": 表示编译器会到当前的目录下寻找指定的文件，如果找不到，则会去系统设定的目录下寻找指定的文件。\n\n---\n参考文献：\n\n1. https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html\n\n2. http://stackoverflow.com/questions/18947516/import-vs-import-ios-7\n\n3. https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7\n\n","slug":"include和import的区别","published":1,"updated":"2023-01-07T05:42:02.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldr5xjcl0010jbse5ffpc4od","content":"<p>今天我们来了解下面这几种包含文件的方式有什么特点和区别：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include <span class=\"string\">&quot;fiel&quot;</span></span><br><span class=\"line\">#include <span class=\"operator\">&lt;</span>file<span class=\"operator\">&gt;</span></span><br><span class=\"line\">#<span class=\"keyword\">import</span> &quot;file&quot;</span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;file&gt;</span><br><span class=\"line\"><span class=\"meta\">@import</span> <span class=\"type\">Module</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"一、-include\"><a href=\"#一、-include\" class=\"headerlink\" title=\"一、#include\"></a>一、#include</h2><p>学过 C 语言的人都知道，#include 其实是一个预处理命令。它会在预处理的时候简单的把被 #include 包含的文件内容进行复制粘贴。我们来看看下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们使用 gcc -E B.h 命令来看看经过预处理后的文件内容大概如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到经过预处理之后，A.h 文件中的内容被直接复制并粘贴到 B.h 文件中来。如果我们在 B.h 文件中多次包含了 A.h 文件，会出现什么情况？比如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经过预处理之后的内容大概如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">3</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>A.h 文件中的 sampleA() 函数出现了两次，所以我们需要利用其他的一些预处理命令来规避这种情况，看看下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> FILE_A</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FILE_A</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再来看看增加了这些预处理命令之后的预处理文件内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OK，这就正常了。如果我们在 A.h 中包含 B.h，然后又在 B.h 中包含 A.h，具体代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;B.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// B.h</span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\">  // B code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再来看看经过 gcc -E B.h 处理之后的文件内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\">In file included from ./B.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">In file included from ./A.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">In file included from ./B.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">In file included from ./A.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">In file included from ./B.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">In file included from ./A.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">./A.h:<span class=\"number\">1</span>:<span class=\"number\">10</span>: error: <span class=\"meta\">#<span class=\"keyword\">include</span> nested too deeply</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;B.h&quot;</span></span></span><br><span class=\"line\">         ^</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1</span> error generated.</span><br></pre></td></tr></table></figure>\n\n<p>我们发现 A.h 和 B.h 重复出现，这是因为这个时候 A.h 和 B.h 文件互相引用导致的。从理论上来讲，这个时候会无限循环下去，直至世界终结。在这里最后会出现一句 *1 error generated.*的提示是 gcc 强行中断了这个预处理的过程，所以我们才能看到这样的结果。那我们可以怎么做？当然是利用前面说的预处理命令来避免循环引用的问题。看下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> FILE_A</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FILE_A</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;B.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> FILE_B</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FILE_B</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这个时候使用 gcc -E B.h 就可以正常的进行预处理，最后的结果如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">5</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">5</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以C程序员总是需要通过各种手段（比如：<a href=\"https://en.wikipedia.org/wiki/Pragma_once\">#pragma once</a>）来防范此类事件的发生。</p>\n<h2 id=\"二、-import\"><a href=\"#二、-import\" class=\"headerlink\" title=\"二、#import\"></a>二、#import</h2><p>我们在文件中通过#import来导入 iAd Framework：<br><img src=\"http://i.imgur.com/nLPSsNN.jpg\"></p>\n<p>编译报错：<br><img src=\"http://i.imgur.com/XBXD8wu.jpg\"></p>\n<p>需要重新导入和链接 Framework：<br><img src=\"http://i.imgur.com/rUnKJGb.jpg\"><br><img src=\"http://i.imgur.com/XuxVI6b.jpg\"></p>\n<p>编译成功：<br><img src=\"http://i.imgur.com/QvyQunr.jpg\"></p>\n<p>从上面的过程中我们就知道在 Objective-C 项目中使用 #import 需要注意导入和链接 Framework，否则是会报错的。</p>\n<p>预处理器在碰到 #import 命令的时候，它会采用递归的方式把被所有头文件的内容复制并粘贴到当前文件中，如果文件依赖层次比较深就会造成预处理后的文件内容体积大幅度变大。</p>\n<p>比如导入 UIKit 的时候只需要一行代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">import</span> &lt;UIKit/UIKit.h&gt;</span><br></pre></td></tr></table></figure>\n\n<p>预处理之后会变成200多行（UIKit.h 文件有200多行代码）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">import</span> &lt;UIKit/UIKitDefines.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">#if</span> __has_include(<span class=\"operator\">&lt;</span><span class=\"type\">UIKit</span><span class=\"operator\">/</span><span class=\"type\">UIAccelerometer</span>.h<span class=\"operator\">&gt;</span>)</span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;UIKit/UIAccelerometer.h&gt;</span><br><span class=\"line\"><span class=\"operator\">.....</span></span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;UIKit/UIRegion.h&gt;</span><br><span class=\"line\"><span class=\"keyword\">#endif</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来还需要递归的把每个头文件的内容展开，最后的结果就是一行代码变成超过11000行代码。如果有多个文件都包含来 UIKit 的头文件，这样就会让每个文件的体积都会变得很大，编译过程也会变得越来越慢。这种递归的方式会让项目的编译时间变成：<em>M source files + N headers &#x3D;&gt; M x N compile time</em>。</p>\n<p>所以这个时候有一个优化方法就是把项目中频繁被引用的文件放到 PCH（Pre-Compile Header）文件中。PCH 会被编译一次并且会被缓存，这就可以缩短编译时间，我们也不需要在不同的文件里面添加import语法。</p>\n<p>当然，PCH 也有自己的缺点：</p>\n<ul>\n<li><p>维护负担：随着项目变得越来越复杂，我们就会不停的往PCH文件加入内容，内容一旦变多就会变得不好维护。（这也是我们平常在项目中要避免在 ViewController 做太多事情的，要研究 MVVM的缘故。）</p>\n</li>\n<li><p>命名空间污染</p>\n</li>\n</ul>\n<p>最后，给大家提供一个例子看看 #import 编译出来之后的文件内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;B.h&quot;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 gcc -E B.h 进行预处理之后的内容如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在B.h中有两个 #import “A.h”，但是这些内容跟我们之前在 A.h 和 B.h 文件中使用 #include 和其他预处理命令之后的处理结果很相似，所以我们就明白了 #import 大概做了什么事。</p>\n<h2 id=\"三、-import\"><a href=\"#三、-import\" class=\"headerlink\" title=\"三、@import\"></a>三、@import</h2><p>在2012年的 LLVM 大会上，苹果的 Doug Gregor 首次提出了 Objective-C 中的 Module。使用 @import 方式导入有几个好处：</p>\n<ul>\n<li><p>不需要像 #import 一样得手动去链接 Framework，@import会自动去链接</p>\n</li>\n<li><p>@import 工作方式和 PCH 很像，但是 @import 要比 PCH 的效率高出许多</p>\n</li>\n<li><p>@import 导入 Modul 优化文件体积变大、编译速度变慢的问题</p>\n</li>\n<li><p>可以部分导入（@import Framework.A）或全部导入（@import Framework）</p>\n</li>\n</ul>\n<p>所以，建议大家尽量使用 @import 来导入文件。如果你以前的项目用的是 #import，那么你也不需要担心，我们只通过 Build Settings 开启 Modules 选项（看下图），#import 和 #include 会自动被映射成 @import，所以你不需要更改原来的代码也能享受 @import带来的好处。</p>\n<p><img src=\"http://i.imgur.com/l7ZMUy6.jpg\"></p>\n<p>详细内容可以看看苹果2013年的 <a href=\"https://developer.apple.com/videos/play/wwdc2013/404/\">Advances in Objective-C</a>，里面就详细介绍了 Module。</p>\n<h2 id=\"四、文件路径\"><a href=\"#四、文件路径\" class=\"headerlink\" title=\"四、文件路径\"></a>四、文件路径</h2><p>接下来我们来了解一下 <em>#include <file></em> 和 *#include “file”*：</p>\n<ul>\n<li><p>#include &lt;file&gt;: 表示编译器会直接到系统设定的目录下寻找指定的文件。</p>\n</li>\n<li><p>#include “file”: 表示编译器会到当前的目录下寻找指定的文件，如果找不到，则会去系统设定的目录下寻找指定的文件。</p>\n</li>\n</ul>\n<hr>\n<p>参考文献：</p>\n<ol>\n<li><p><a href=\"https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html\">https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html</a></p>\n</li>\n<li><p><a href=\"http://stackoverflow.com/questions/18947516/import-vs-import-ios-7\">http://stackoverflow.com/questions/18947516/import-vs-import-ios-7</a></p>\n</li>\n<li><p><a href=\"https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7\">https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>今天我们来了解下面这几种包含文件的方式有什么特点和区别：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include <span class=\"string\">&quot;fiel&quot;</span></span><br><span class=\"line\">#include <span class=\"operator\">&lt;</span>file<span class=\"operator\">&gt;</span></span><br><span class=\"line\">#<span class=\"keyword\">import</span> &quot;file&quot;</span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;file&gt;</span><br><span class=\"line\"><span class=\"meta\">@import</span> <span class=\"type\">Module</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"一、-include\"><a href=\"#一、-include\" class=\"headerlink\" title=\"一、#include\"></a>一、#include</h2><p>学过 C 语言的人都知道，#include 其实是一个预处理命令。它会在预处理的时候简单的把被 #include 包含的文件内容进行复制粘贴。我们来看看下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们使用 gcc -E B.h 命令来看看经过预处理后的文件内容大概如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到经过预处理之后，A.h 文件中的内容被直接复制并粘贴到 B.h 文件中来。如果我们在 B.h 文件中多次包含了 A.h 文件，会出现什么情况？比如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经过预处理之后的内容大概如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">3</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>A.h 文件中的 sampleA() 函数出现了两次，所以我们需要利用其他的一些预处理命令来规避这种情况，看看下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> FILE_A</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FILE_A</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再来看看增加了这些预处理命令之后的预处理文件内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OK，这就正常了。如果我们在 A.h 中包含 B.h，然后又在 B.h 中包含 A.h，具体代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;B.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// B.h</span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\">  // B code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再来看看经过 gcc -E B.h 处理之后的文件内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\">In file included from ./B.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">In file included from ./A.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">In file included from ./B.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">In file included from ./A.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">In file included from ./B.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">In file included from ./A.h:<span class=\"number\">1</span>:</span><br><span class=\"line\">./A.h:<span class=\"number\">1</span>:<span class=\"number\">10</span>: error: <span class=\"meta\">#<span class=\"keyword\">include</span> nested too deeply</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;B.h&quot;</span></span></span><br><span class=\"line\">         ^</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1</span> error generated.</span><br></pre></td></tr></table></figure>\n\n<p>我们发现 A.h 和 B.h 重复出现，这是因为这个时候 A.h 和 B.h 文件互相引用导致的。从理论上来讲，这个时候会无限循环下去，直至世界终结。在这里最后会出现一句 *1 error generated.*的提示是 gcc 强行中断了这个预处理的过程，所以我们才能看到这样的结果。那我们可以怎么做？当然是利用前面说的预处理命令来避免循环引用的问题。看下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> FILE_A</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FILE_A</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;B.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> FILE_B</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FILE_B</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这个时候使用 gcc -E B.h 就可以正常的进行预处理，最后的结果如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">5</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">5</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以C程序员总是需要通过各种手段（比如：<a href=\"https://en.wikipedia.org/wiki/Pragma_once\">#pragma once</a>）来防范此类事件的发生。</p>\n<h2 id=\"二、-import\"><a href=\"#二、-import\" class=\"headerlink\" title=\"二、#import\"></a>二、#import</h2><p>我们在文件中通过#import来导入 iAd Framework：<br><img src=\"http://i.imgur.com/nLPSsNN.jpg\"></p>\n<p>编译报错：<br><img src=\"http://i.imgur.com/XBXD8wu.jpg\"></p>\n<p>需要重新导入和链接 Framework：<br><img src=\"http://i.imgur.com/rUnKJGb.jpg\"><br><img src=\"http://i.imgur.com/XuxVI6b.jpg\"></p>\n<p>编译成功：<br><img src=\"http://i.imgur.com/QvyQunr.jpg\"></p>\n<p>从上面的过程中我们就知道在 Objective-C 项目中使用 #import 需要注意导入和链接 Framework，否则是会报错的。</p>\n<p>预处理器在碰到 #import 命令的时候，它会采用递归的方式把被所有头文件的内容复制并粘贴到当前文件中，如果文件依赖层次比较深就会造成预处理后的文件内容体积大幅度变大。</p>\n<p>比如导入 UIKit 的时候只需要一行代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">import</span> &lt;UIKit/UIKit.h&gt;</span><br></pre></td></tr></table></figure>\n\n<p>预处理之后会变成200多行（UIKit.h 文件有200多行代码）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">import</span> &lt;UIKit/UIKitDefines.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">#if</span> __has_include(<span class=\"operator\">&lt;</span><span class=\"type\">UIKit</span><span class=\"operator\">/</span><span class=\"type\">UIAccelerometer</span>.h<span class=\"operator\">&gt;</span>)</span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;UIKit/UIAccelerometer.h&gt;</span><br><span class=\"line\"><span class=\"operator\">.....</span></span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;UIKit/UIRegion.h&gt;</span><br><span class=\"line\"><span class=\"keyword\">#endif</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来还需要递归的把每个头文件的内容展开，最后的结果就是一行代码变成超过11000行代码。如果有多个文件都包含来 UIKit 的头文件，这样就会让每个文件的体积都会变得很大，编译过程也会变得越来越慢。这种递归的方式会让项目的编译时间变成：<em>M source files + N headers &#x3D;&gt; M x N compile time</em>。</p>\n<p>所以这个时候有一个优化方法就是把项目中频繁被引用的文件放到 PCH（Pre-Compile Header）文件中。PCH 会被编译一次并且会被缓存，这就可以缩短编译时间，我们也不需要在不同的文件里面添加import语法。</p>\n<p>当然，PCH 也有自己的缺点：</p>\n<ul>\n<li><p>维护负担：随着项目变得越来越复杂，我们就会不停的往PCH文件加入内容，内容一旦变多就会变得不好维护。（这也是我们平常在项目中要避免在 ViewController 做太多事情的，要研究 MVVM的缘故。）</p>\n</li>\n<li><p>命名空间污染</p>\n</li>\n</ul>\n<p>最后，给大家提供一个例子看看 #import 编译出来之后的文件内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;B.h&quot;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// B.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;A.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// B code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 gcc -E B.h 进行预处理之后的内容如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">329</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">3</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;command line&gt;&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;&lt;built-in&gt;&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"># <span class=\"number\">1</span> <span class=\"string\">&quot;./A.h&quot;</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># <span class=\"number\">2</span> <span class=\"string\">&quot;./B.h&quot;</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sampleB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在B.h中有两个 #import “A.h”，但是这些内容跟我们之前在 A.h 和 B.h 文件中使用 #include 和其他预处理命令之后的处理结果很相似，所以我们就明白了 #import 大概做了什么事。</p>\n<h2 id=\"三、-import\"><a href=\"#三、-import\" class=\"headerlink\" title=\"三、@import\"></a>三、@import</h2><p>在2012年的 LLVM 大会上，苹果的 Doug Gregor 首次提出了 Objective-C 中的 Module。使用 @import 方式导入有几个好处：</p>\n<ul>\n<li><p>不需要像 #import 一样得手动去链接 Framework，@import会自动去链接</p>\n</li>\n<li><p>@import 工作方式和 PCH 很像，但是 @import 要比 PCH 的效率高出许多</p>\n</li>\n<li><p>@import 导入 Modul 优化文件体积变大、编译速度变慢的问题</p>\n</li>\n<li><p>可以部分导入（@import Framework.A）或全部导入（@import Framework）</p>\n</li>\n</ul>\n<p>所以，建议大家尽量使用 @import 来导入文件。如果你以前的项目用的是 #import，那么你也不需要担心，我们只通过 Build Settings 开启 Modules 选项（看下图），#import 和 #include 会自动被映射成 @import，所以你不需要更改原来的代码也能享受 @import带来的好处。</p>\n<p><img src=\"http://i.imgur.com/l7ZMUy6.jpg\"></p>\n<p>详细内容可以看看苹果2013年的 <a href=\"https://developer.apple.com/videos/play/wwdc2013/404/\">Advances in Objective-C</a>，里面就详细介绍了 Module。</p>\n<h2 id=\"四、文件路径\"><a href=\"#四、文件路径\" class=\"headerlink\" title=\"四、文件路径\"></a>四、文件路径</h2><p>接下来我们来了解一下 <em>#include <file></em> 和 *#include “file”*：</p>\n<ul>\n<li><p>#include &lt;file&gt;: 表示编译器会直接到系统设定的目录下寻找指定的文件。</p>\n</li>\n<li><p>#include “file”: 表示编译器会到当前的目录下寻找指定的文件，如果找不到，则会去系统设定的目录下寻找指定的文件。</p>\n</li>\n</ul>\n<hr>\n<p>参考文献：</p>\n<ol>\n<li><p><a href=\"https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html\">https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html</a></p>\n</li>\n<li><p><a href=\"http://stackoverflow.com/questions/18947516/import-vs-import-ios-7\">http://stackoverflow.com/questions/18947516/import-vs-import-ios-7</a></p>\n</li>\n<li><p><a href=\"https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7\">https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7</a></p>\n</li>\n</ol>\n"},{"title":"redux 之页面跳转","author":"帕帕","date":"2018-02-26T17:48:56.000Z","thumbnail":"https://images.unsplash.com/photo-1493235431945-90c060301e41?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=0279978342b1a6b4f3e0e00a0784c2e3&auto=format&fit=crop&w=160&q=100","_content":"\n最近正在用 React Native 重构整个项目，我们用了 **[react-native-navigation](https://github.com/krystofcelba/react-native-navigation#rn52)** 这个库来作为项目的导航控制器。\n所以，我们平常会把页面跳转逻辑的时候放在 Screen 里面的，比如:\n\n```Javascript\nclass FirstScreen extends React.Component {\n    \n    // 点击事件\n    _someAction = () => {\n        this.props.navigator.push({\n          screen: 'example.SecondScreen',\n        });\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n一般情况下，上面的写法没有问题。但是直到我们碰到这样一个需求的时候就抓瞎了：点击一个 PDF 文件，如果 PDF 文件没有下载就先去下载，下载完成之后自动跳转到 PDF 阅读器。由于用了 redux 之后，我们就增加一个 finished 的 state 来判断是否已经下载完成。示例代码如下：\n\n```Javascript\nclass ExampleScreen extends React.Component {\n\n    componentWillReceiveProps = (nextProps) => {\n        // 这里判断下载状态是否已完成，完成的话就去跳转\n        if (nextProps.finished === true) {\n            // 这里需要重置一下状态，不然其他 state 发生变化会多次触发页面的跳转\n            this.props.dispatch(resetFinished());\n            this.props.navigator.push({\n              screen: 'example.PDFScreen',\n            });\n        }\n    }\n    \n    // 点击事件\n    _someAction = () => {\n        // openPDF() 这个 action 会自动去下载 PDF 文件，然后修改 finished 的状态\n        this.props.dispatch(openPDF());\n    }\n    \n    render = () => {\n        ...\n    }\n}\n\nconst mapStateToProps = state => {\n  return {\n    finished: state.finished\n  }\n};\n\nexport default connect(mapStateToProps)(ExampleScreen);\n```\n\n上面的做法是可以实现我们的需求，但是这种写法很蛋疼。因为当你在调用用 openPDF() 的时候，你以为后面的事不需要你操心，然后这个时候有人告诉你还需要在其他地方增加一个中间状态去补充 openPDF() 的后续逻辑处理。\n\n经过讨论之后，我们决定改成用 callback 的方式来实现：\n\n```Javascript\nclass ExampleScreen extends React.Component {\n\n    // 点击事件\n    _someAction = () => {\n        // openPDF() 是一个异步 action\n        this.props.dispatch(openPDF(callback: () => {\n            this.props.navigator.push({\n              screen: 'example.PDFScreen',\n            });\n        }));\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n使用 callback 的好处就是去掉了一个烦人的中间状态，并且从阅读体验来说很容易让读者明白这个点击事件在干什么。但是在 redux 的 action 方法中增加一个 callback 的调用，看起来也有点不伦不类的。虽然我认为 callback 和其他参数具有相同的法律地位。\n\n其实最好的实现是，这个点击事件应该连页面的跳转逻辑也不需要处理：\n\n```Javascript\nclass ExampleScreen extends React.Component {\n\n    // 点击事件，这个事件只做一件事就是去 dispatch 一个 openPDF() 的 action\n    _someAction = () => {\n        this.props.dispatch(openPDF());\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n像上面这种实现，我们也就只能在 openPDF() 里动手脚了：\n\n```Javascript\n// action.js\nexport const openPDF = await () => {\n    return dispatch => {\n        // 异步下载 PDF\n        async downloadPDF();\n        // 完成之后通过 router 去实现页面跳转\n        dispatch(openRouter('PDFScreen'));\n    };\n}\n```\n\n> 这里就不再详细说 router 的实现细节了，因为网上有很多现成的资料。（PS: 主要是我也还没看到这一块）\n\n从页面（Screen）的角度来说，我认为这样的处理是最合适的。因为 Screen 只需要关注本页面的 state 和 action，至于跳转的逻辑交给后面的 action 来处理是最好的。\n\n\n\n\n","source":"_posts/redux-之页面跳转.md","raw":"---\ntitle: redux 之页面跳转\nauthor: 帕帕\ndate: 2018-02-26 17:48:56 +0800\ncategories: 技术\ntags: [RN, redux]\nthumbnail: https://images.unsplash.com/photo-1493235431945-90c060301e41?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=0279978342b1a6b4f3e0e00a0784c2e3&auto=format&fit=crop&w=160&q=100\n---\n\n最近正在用 React Native 重构整个项目，我们用了 **[react-native-navigation](https://github.com/krystofcelba/react-native-navigation#rn52)** 这个库来作为项目的导航控制器。\n所以，我们平常会把页面跳转逻辑的时候放在 Screen 里面的，比如:\n\n```Javascript\nclass FirstScreen extends React.Component {\n    \n    // 点击事件\n    _someAction = () => {\n        this.props.navigator.push({\n          screen: 'example.SecondScreen',\n        });\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n一般情况下，上面的写法没有问题。但是直到我们碰到这样一个需求的时候就抓瞎了：点击一个 PDF 文件，如果 PDF 文件没有下载就先去下载，下载完成之后自动跳转到 PDF 阅读器。由于用了 redux 之后，我们就增加一个 finished 的 state 来判断是否已经下载完成。示例代码如下：\n\n```Javascript\nclass ExampleScreen extends React.Component {\n\n    componentWillReceiveProps = (nextProps) => {\n        // 这里判断下载状态是否已完成，完成的话就去跳转\n        if (nextProps.finished === true) {\n            // 这里需要重置一下状态，不然其他 state 发生变化会多次触发页面的跳转\n            this.props.dispatch(resetFinished());\n            this.props.navigator.push({\n              screen: 'example.PDFScreen',\n            });\n        }\n    }\n    \n    // 点击事件\n    _someAction = () => {\n        // openPDF() 这个 action 会自动去下载 PDF 文件，然后修改 finished 的状态\n        this.props.dispatch(openPDF());\n    }\n    \n    render = () => {\n        ...\n    }\n}\n\nconst mapStateToProps = state => {\n  return {\n    finished: state.finished\n  }\n};\n\nexport default connect(mapStateToProps)(ExampleScreen);\n```\n\n上面的做法是可以实现我们的需求，但是这种写法很蛋疼。因为当你在调用用 openPDF() 的时候，你以为后面的事不需要你操心，然后这个时候有人告诉你还需要在其他地方增加一个中间状态去补充 openPDF() 的后续逻辑处理。\n\n经过讨论之后，我们决定改成用 callback 的方式来实现：\n\n```Javascript\nclass ExampleScreen extends React.Component {\n\n    // 点击事件\n    _someAction = () => {\n        // openPDF() 是一个异步 action\n        this.props.dispatch(openPDF(callback: () => {\n            this.props.navigator.push({\n              screen: 'example.PDFScreen',\n            });\n        }));\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n使用 callback 的好处就是去掉了一个烦人的中间状态，并且从阅读体验来说很容易让读者明白这个点击事件在干什么。但是在 redux 的 action 方法中增加一个 callback 的调用，看起来也有点不伦不类的。虽然我认为 callback 和其他参数具有相同的法律地位。\n\n其实最好的实现是，这个点击事件应该连页面的跳转逻辑也不需要处理：\n\n```Javascript\nclass ExampleScreen extends React.Component {\n\n    // 点击事件，这个事件只做一件事就是去 dispatch 一个 openPDF() 的 action\n    _someAction = () => {\n        this.props.dispatch(openPDF());\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n像上面这种实现，我们也就只能在 openPDF() 里动手脚了：\n\n```Javascript\n// action.js\nexport const openPDF = await () => {\n    return dispatch => {\n        // 异步下载 PDF\n        async downloadPDF();\n        // 完成之后通过 router 去实现页面跳转\n        dispatch(openRouter('PDFScreen'));\n    };\n}\n```\n\n> 这里就不再详细说 router 的实现细节了，因为网上有很多现成的资料。（PS: 主要是我也还没看到这一块）\n\n从页面（Screen）的角度来说，我认为这样的处理是最合适的。因为 Screen 只需要关注本页面的 state 和 action，至于跳转的逻辑交给后面的 action 来处理是最好的。\n\n\n\n\n","slug":"redux-之页面跳转","published":1,"updated":"2023-01-07T05:42:02.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldr5xjcm0013jbse3lm1fvj4","content":"<p>最近正在用 React Native 重构整个项目，我们用了 <strong><a href=\"https://github.com/krystofcelba/react-native-navigation#rn52\">react-native-navigation</a></strong> 这个库来作为项目的导航控制器。<br>所以，我们平常会把页面跳转逻辑的时候放在 Screen 里面的，比如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FirstScreen</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 点击事件</span></span><br><span class=\"line\">    _someAction = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">navigator</span>.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">          <span class=\"attr\">screen</span>: <span class=\"string\">&#x27;example.SecondScreen&#x27;</span>,</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一般情况下，上面的写法没有问题。但是直到我们碰到这样一个需求的时候就抓瞎了：点击一个 PDF 文件，如果 PDF 文件没有下载就先去下载，下载完成之后自动跳转到 PDF 阅读器。由于用了 redux 之后，我们就增加一个 finished 的 state 来判断是否已经下载完成。示例代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExampleScreen</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillReceiveProps = <span class=\"function\">(<span class=\"params\">nextProps</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里判断下载状态是否已完成，完成的话就去跳转</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextProps.<span class=\"property\">finished</span> === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里需要重置一下状态，不然其他 state 发生变化会多次触发页面的跳转</span></span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">dispatch</span>(<span class=\"title function_\">resetFinished</span>());</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">navigator</span>.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">              <span class=\"attr\">screen</span>: <span class=\"string\">&#x27;example.PDFScreen&#x27;</span>,</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 点击事件</span></span><br><span class=\"line\">    _someAction = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// openPDF() 这个 action 会自动去下载 PDF 文件，然后修改 finished 的状态</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">dispatch</span>(<span class=\"title function_\">openPDF</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">mapStateToProps</span> = state =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">finished</span>: state.<span class=\"property\">finished</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">connect</span>(mapStateToProps)(<span class=\"title class_\">ExampleScreen</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面的做法是可以实现我们的需求，但是这种写法很蛋疼。因为当你在调用用 openPDF() 的时候，你以为后面的事不需要你操心，然后这个时候有人告诉你还需要在其他地方增加一个中间状态去补充 openPDF() 的后续逻辑处理。</p>\n<p>经过讨论之后，我们决定改成用 callback 的方式来实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExampleScreen</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 点击事件</span></span><br><span class=\"line\">    _someAction = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// openPDF() 是一个异步 action</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">dispatch</span>(<span class=\"title function_\">openPDF</span>(<span class=\"attr\">callback</span>: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">navigator</span>.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">              <span class=\"attr\">screen</span>: <span class=\"string\">&#x27;example.PDFScreen&#x27;</span>,</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 callback 的好处就是去掉了一个烦人的中间状态，并且从阅读体验来说很容易让读者明白这个点击事件在干什么。但是在 redux 的 action 方法中增加一个 callback 的调用，看起来也有点不伦不类的。虽然我认为 callback 和其他参数具有相同的法律地位。</p>\n<p>其实最好的实现是，这个点击事件应该连页面的跳转逻辑也不需要处理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExampleScreen</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 点击事件，这个事件只做一件事就是去 dispatch 一个 openPDF() 的 action</span></span><br><span class=\"line\">    _someAction = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">dispatch</span>(<span class=\"title function_\">openPDF</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>像上面这种实现，我们也就只能在 openPDF() 里动手脚了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// action.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> openPDF = <span class=\"keyword\">await</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">dispatch</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 异步下载 PDF</span></span><br><span class=\"line\">        <span class=\"keyword\">async</span> <span class=\"title function_\">downloadPDF</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 完成之后通过 router 去实现页面跳转</span></span><br><span class=\"line\">        <span class=\"title function_\">dispatch</span>(<span class=\"title function_\">openRouter</span>(<span class=\"string\">&#x27;PDFScreen&#x27;</span>));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里就不再详细说 router 的实现细节了，因为网上有很多现成的资料。（PS: 主要是我也还没看到这一块）</p>\n</blockquote>\n<p>从页面（Screen）的角度来说，我认为这样的处理是最合适的。因为 Screen 只需要关注本页面的 state 和 action，至于跳转的逻辑交给后面的 action 来处理是最好的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近正在用 React Native 重构整个项目，我们用了 <strong><a href=\"https://github.com/krystofcelba/react-native-navigation#rn52\">react-native-navigation</a></strong> 这个库来作为项目的导航控制器。<br>所以，我们平常会把页面跳转逻辑的时候放在 Screen 里面的，比如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FirstScreen</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 点击事件</span></span><br><span class=\"line\">    _someAction = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">navigator</span>.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">          <span class=\"attr\">screen</span>: <span class=\"string\">&#x27;example.SecondScreen&#x27;</span>,</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一般情况下，上面的写法没有问题。但是直到我们碰到这样一个需求的时候就抓瞎了：点击一个 PDF 文件，如果 PDF 文件没有下载就先去下载，下载完成之后自动跳转到 PDF 阅读器。由于用了 redux 之后，我们就增加一个 finished 的 state 来判断是否已经下载完成。示例代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExampleScreen</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillReceiveProps = <span class=\"function\">(<span class=\"params\">nextProps</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里判断下载状态是否已完成，完成的话就去跳转</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextProps.<span class=\"property\">finished</span> === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里需要重置一下状态，不然其他 state 发生变化会多次触发页面的跳转</span></span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">dispatch</span>(<span class=\"title function_\">resetFinished</span>());</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">navigator</span>.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">              <span class=\"attr\">screen</span>: <span class=\"string\">&#x27;example.PDFScreen&#x27;</span>,</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 点击事件</span></span><br><span class=\"line\">    _someAction = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// openPDF() 这个 action 会自动去下载 PDF 文件，然后修改 finished 的状态</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">dispatch</span>(<span class=\"title function_\">openPDF</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">mapStateToProps</span> = state =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">finished</span>: state.<span class=\"property\">finished</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">connect</span>(mapStateToProps)(<span class=\"title class_\">ExampleScreen</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面的做法是可以实现我们的需求，但是这种写法很蛋疼。因为当你在调用用 openPDF() 的时候，你以为后面的事不需要你操心，然后这个时候有人告诉你还需要在其他地方增加一个中间状态去补充 openPDF() 的后续逻辑处理。</p>\n<p>经过讨论之后，我们决定改成用 callback 的方式来实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExampleScreen</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 点击事件</span></span><br><span class=\"line\">    _someAction = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// openPDF() 是一个异步 action</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">dispatch</span>(<span class=\"title function_\">openPDF</span>(<span class=\"attr\">callback</span>: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">navigator</span>.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">              <span class=\"attr\">screen</span>: <span class=\"string\">&#x27;example.PDFScreen&#x27;</span>,</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 callback 的好处就是去掉了一个烦人的中间状态，并且从阅读体验来说很容易让读者明白这个点击事件在干什么。但是在 redux 的 action 方法中增加一个 callback 的调用，看起来也有点不伦不类的。虽然我认为 callback 和其他参数具有相同的法律地位。</p>\n<p>其实最好的实现是，这个点击事件应该连页面的跳转逻辑也不需要处理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ExampleScreen</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 点击事件，这个事件只做一件事就是去 dispatch 一个 openPDF() 的 action</span></span><br><span class=\"line\">    _someAction = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">dispatch</span>(<span class=\"title function_\">openPDF</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>像上面这种实现，我们也就只能在 openPDF() 里动手脚了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// action.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> openPDF = <span class=\"keyword\">await</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">dispatch</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 异步下载 PDF</span></span><br><span class=\"line\">        <span class=\"keyword\">async</span> <span class=\"title function_\">downloadPDF</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 完成之后通过 router 去实现页面跳转</span></span><br><span class=\"line\">        <span class=\"title function_\">dispatch</span>(<span class=\"title function_\">openRouter</span>(<span class=\"string\">&#x27;PDFScreen&#x27;</span>));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里就不再详细说 router 的实现细节了，因为网上有很多现成的资料。（PS: 主要是我也还没看到这一块）</p>\n</blockquote>\n<p>从页面（Screen）的角度来说，我认为这样的处理是最合适的。因为 Screen 只需要关注本页面的 state 和 action，至于跳转的逻辑交给后面的 action 来处理是最好的。</p>\n"},{"title":"self 在 block 中的引用计数变化","author":"帕帕","date":"2018-04-19T11:34:51.000Z","thumbnail":"https://images.unsplash.com/photo-1462303966430-8a4708fd729e?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=c9dd0952e673c518403fb8d4c28f93b5&auto=format&fit=crop&w=160&q=60","_content":"\n\n相信大家在 Objective-C 中都会通过 `__waek` 的修饰符来保证 block 和 self 不会互相引用，代码如下:\n\n```Objective-C\n__weak typeof(self) weakSelf = self;\nself.block = ^{\n    __strong typeof(self) strongSelf = self;\n    ...\n}\n```\n\n但是你思考过 self 在这一段旅程中的引用计数变化么，接下来我会通过三个例子来展示这一段旅程是怎样的？\n\n\n```Objective-C\n// 🌰1\nNSLog(@\"Before block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\nself.block = ^{\n    self;\n    NSLog(@\"Within block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\n};\nself.block();\nNSLog(@\"After block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\n\n\n// 🌰2\n__weak typeof(self) weakSelf = self;\nNSLog(@\"Before block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\nself.block = ^{\n    weakSelf;\n    NSLog(@\"Within block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));\n};\nself.block();\nNSLog(@\"After block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\n\n\n// 🌰3\n__weak typeof(self) weakSelf = self;\nNSLog(@\"Before block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\nself.block = ^{\n    __strong typeof(self) strongSelf = weakSelf;\n    NSLog(@\"Within block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));\n};\nself.block();\nNSLog(@\"After block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\n```\n\n我们可以通过 Clang 对上面的三个例子做一下编译，通过编译后的 C 代码（接下来所展示代码都是经过简化），我们可以推导出 self 的引用计数变化。\n\n---\n\n🌰1 的 C 代码如下：\n\n```Objective-C\n// Block 结构体。这个大家可以通过其他的资料去看看，我们今天主要是来探寻一下 self 的旅程，这里就不对 Block 本身做更详细的介绍\nstruct __block_impl {\n  void *isa;\n  int Flags;\n  int Reserved;\n  void *FuncPtr;\n};\n\n// ^{} 的实现\nstruct __BlockTest__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __BlockTest__test_block_desc_0* Desc;\n    BlockTest *const __strong self;\n    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __strong _self, int flags=0) : self(_self) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n// Block 方法\nstatic void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) {\n    BlockTest *const __strong self = __cself->self; // bound by copy\n    self;\n}\n\n// Block 的 copy 操作\nstatic void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) {_Block_object_assign((void*)&dst->self, (void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n// Block 的 dispose 操作\nstatic void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) {_Block_object_dispose((void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n// 描述 Block 的 copy 和 dispose\nstatic struct __BlockTest__test_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);\n    void (*dispose)(struct __BlockTest__test_block_impl_0*);\n} __BlockTest__test_block_desc_0_DATA = { 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0};\n\n// 方法主体\nstatic void _I_BlockTest_test(BlockTest * self, SEL _cmd) {\n    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(\"setBlock:\"), ((void (*)())&__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &__BlockTest__test_block_desc_0_DATA, self, 570425344)));\n    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(\"block\"))();\n\n}\n```\n\n1. 在方法主体里面首先会构造一个 `__BlockTest__test_block_impl_0` 的结构体，该结构体捕获了 self；\n2. `__BlockTest__test_block_impl_0` 的构造函数中使用了 `__strong` 来捕获 self，所以我们知道在构造的时候默认是使用 `__strong` 来捕获外部的对象变量，此时 self 的引用计数应该要 +1；\n3. Block 被构造出来之后需要被赋值给 self，我们知道在 ARC 模式下此时的 Block 会执行 Copy 操作，从 `_NSConcreteStackBlock` 变成 `_NSMallocBlock`；\n4. Block 通过 `__BlockTest__test_block_desc_0_DATA` 找到 Copy 方法的具体实现 `__BlockTest__test_block_copy_0`，从上面的代码中我们知道该方法的实现是通过 `_Block_object_assign` 来实现的（对于这个方法的实现细节暂时还没有找到更相信的资料，有知道的可以麻烦告诉一下），通过名字我们可以猜测出该方法只是把捕获的变量地址直接拷贝一份到堆内存中，但是不会引起引用计数的变化；\n5. 当 Block 被真正执行的时候会通过 `__block_impl` 的 `FuncPtr` 找到真正的实现代码 `__BlockTest__test_block_func_0`，我们观察到在这个方法里面有这样一句代码 `BlockTest *const __strong self = __cself->self`，很明显此时 self 的引用计数会 +1，当该 `__BlockTest__test_block_func_0` 执行完毕之后还是会释放 self 的，此时引用计数会 -1；\n\n从上面的分析过程中，我们知道由于 Block 在构造的时候默认就对捕获的 self 进行了强引用，导致 self 的引用计数 +1；而又由于 self 持有了 Block，所以这里就造成了循环引用的问题。\n\n我们来看 🌰2 能不能解决这个问题？\n\n---\n\n🌰2 的 C 代码如下：\n\n```Objective-C\n// ^{} 结构体\nstruct __BlockTest__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __BlockTest__test_block_desc_0* Desc;\n    BlockTest *const __weak weakSelf;\n    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n// Block 方法\nstatic void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) {\n    BlockTest *const __weak weakSelf = __cself->weakSelf; // bound by copy\n    weakSelf;\n}\n\n// Block 的 copy 操作\nstatic void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) {_Block_object_assign((void*)&dst->weakSelf, (void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n// Block 的 dispose 操作\nstatic void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) {_Block_object_dispose((void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n// 描述 Block 的 copy 和 dispose\nstatic struct __BlockTest__test_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);\n    void (*dispose)(struct __BlockTest__test_block_impl_0*);\n} __BlockTest__test_block_desc_0_DATA = { 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0};\n\n// 方法主体\nstatic void _I_BlockTest_test(BlockTest * self, SEL _cmd) {\n    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;\n    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(\"setBlock:\"), ((void (*)())&__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));\n    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(\"block\"))();\n}\n```\n\n1. 方法主体会先用 `__weak` 初始化一个 weakSelf，此时 self 的引用计数是不会发生变化的；之后会构造一个`__BlockTest__test_block_impl_0` 的结构体，该结构体捕获了 weakSelf；\n2. `__BlockTest__test_block_impl_0` 的构造函数中使用了 `__weak` 来捕获 weakSelf，所以我们知道此时 self 的引用计数应该要也是不会发生变化的；\n3. 然后把该结构体赋值给 self.block，block 结构体被从栈复制到堆的时候使用了 `_Block_object_assign`，所以此时 self 的引用计数不会发生变化\n4. 然后 block 在被执行的时候做了一下 `__weak` 的操作 `BlockTest *const __weak weakSelf = __cself->weakSelf`，这时候 self 的引用计数也不会发生变化\n5. 由于 block 对 weakSelf 没有强引用，所以在 block 执行完成之后也不需要做释放 weakSelf 的工作\n\n所以，在该例子中 block 无法强引用 weakSelf，weakSelf 的引用计数没有发生任何变化。由于 self 没有被 block 强应用，所以当 self 要被释放的时候，block 也会被释放，这就解决了我们 🌰1 中的循环引用的问题。但是在 block 方法执行的过程中，self 对象有可能已经被释放了，此时如果你还去使用 weakSelf 就有可能造成奔溃的情况。\n\n---\n\n🌰3 的 C 代码如下：\n\n```Objective-C\nstruct __BlockTest__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __BlockTest__test_block_desc_0* Desc;\n    BlockTest *const __weak weakSelf;\n    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) {\n    BlockTest *const __weak weakSelf = __cself->weakSelf; // bound by copy\n    __attribute__((objc_ownership(strong))) typeof(self) strongSelf = weakSelf;    \n}\n\nstatic void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) {_Block_object_assign((void*)&dst->weakSelf, (void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) {_Block_object_dispose((void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic struct __BlockTest__test_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);\n    void (*dispose)(struct __BlockTest__test_block_impl_0*);\n} __BlockTest__test_block_desc_0_DATA = { 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0};\n\nstatic void _I_BlockTest_test(BlockTest * self, SEL _cmd) {\n    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;\n    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(\"setBlock:\"), ((void (*)())&__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));\n    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(\"block\"))();  \n}\n```\n\n\n前面的步骤都跟 🌰2 中的一样，关键是在 Block 的方法实现里面有点不一样。我们来看看 `__BlockTest__test_block_func_0`，它首先调用了 `BlockTest *const __weak weakSelf = __cself->weakSelf`， 所以它此时的引用计数不会发生变化；但是接下来又用 `objc_ownership(strong)` 来强引用 weakSelf，所以此时 self 的引用计数 +1。这就保证了在函数执行的过程中，Block 会一直持有 self，知道 Block 执行完毕之后会释放 weakSelf。\n\n所以 🌰3 完美的解决了循环应用和直接使用 `__weak` 可能导致奔溃的问题。\n\n---\n\n最后，说一下关于 _Block_object_assign 的猜想：\n\n```\n_Block_object_assign((void*)&dst->weakSelf, (void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);\n```\n\n通过上面的例子，我们知道 Block 在构造的时候就会对捕获的变量进行内存管理（强引用和弱引用），所以当 Block 在做 Copy 操作的时候其实没有必要对它捕获的变量再做一遍内存管理了。这也应该是 Block 的 Copy 操作使用了 `_Block_object_assign` 这种不会导致引用计数发生变化的方式来实现的原因。\n\n\n\n\n","source":"_posts/self-在-block-中的引用计数变化.md","raw":"---\ntitle: self 在 block 中的引用计数变化\nauthor: 帕帕\ndate: 2018-04-19 11:34:51 +0800\ncategories: 技术 \ntags: [iOS, Objective-C, Block]\nthumbnail: https://images.unsplash.com/photo-1462303966430-8a4708fd729e?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=c9dd0952e673c518403fb8d4c28f93b5&auto=format&fit=crop&w=160&q=60\n---\n\n\n相信大家在 Objective-C 中都会通过 `__waek` 的修饰符来保证 block 和 self 不会互相引用，代码如下:\n\n```Objective-C\n__weak typeof(self) weakSelf = self;\nself.block = ^{\n    __strong typeof(self) strongSelf = self;\n    ...\n}\n```\n\n但是你思考过 self 在这一段旅程中的引用计数变化么，接下来我会通过三个例子来展示这一段旅程是怎样的？\n\n\n```Objective-C\n// 🌰1\nNSLog(@\"Before block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\nself.block = ^{\n    self;\n    NSLog(@\"Within block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\n};\nself.block();\nNSLog(@\"After block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\n\n\n// 🌰2\n__weak typeof(self) weakSelf = self;\nNSLog(@\"Before block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\nself.block = ^{\n    weakSelf;\n    NSLog(@\"Within block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));\n};\nself.block();\nNSLog(@\"After block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\n\n\n// 🌰3\n__weak typeof(self) weakSelf = self;\nNSLog(@\"Before block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\nself.block = ^{\n    __strong typeof(self) strongSelf = weakSelf;\n    NSLog(@\"Within block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));\n};\nself.block();\nNSLog(@\"After block：%ld\", CFGetRetainCount((__bridge CFTypeRef)(self)));\n```\n\n我们可以通过 Clang 对上面的三个例子做一下编译，通过编译后的 C 代码（接下来所展示代码都是经过简化），我们可以推导出 self 的引用计数变化。\n\n---\n\n🌰1 的 C 代码如下：\n\n```Objective-C\n// Block 结构体。这个大家可以通过其他的资料去看看，我们今天主要是来探寻一下 self 的旅程，这里就不对 Block 本身做更详细的介绍\nstruct __block_impl {\n  void *isa;\n  int Flags;\n  int Reserved;\n  void *FuncPtr;\n};\n\n// ^{} 的实现\nstruct __BlockTest__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __BlockTest__test_block_desc_0* Desc;\n    BlockTest *const __strong self;\n    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __strong _self, int flags=0) : self(_self) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n// Block 方法\nstatic void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) {\n    BlockTest *const __strong self = __cself->self; // bound by copy\n    self;\n}\n\n// Block 的 copy 操作\nstatic void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) {_Block_object_assign((void*)&dst->self, (void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n// Block 的 dispose 操作\nstatic void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) {_Block_object_dispose((void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n// 描述 Block 的 copy 和 dispose\nstatic struct __BlockTest__test_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);\n    void (*dispose)(struct __BlockTest__test_block_impl_0*);\n} __BlockTest__test_block_desc_0_DATA = { 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0};\n\n// 方法主体\nstatic void _I_BlockTest_test(BlockTest * self, SEL _cmd) {\n    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(\"setBlock:\"), ((void (*)())&__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &__BlockTest__test_block_desc_0_DATA, self, 570425344)));\n    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(\"block\"))();\n\n}\n```\n\n1. 在方法主体里面首先会构造一个 `__BlockTest__test_block_impl_0` 的结构体，该结构体捕获了 self；\n2. `__BlockTest__test_block_impl_0` 的构造函数中使用了 `__strong` 来捕获 self，所以我们知道在构造的时候默认是使用 `__strong` 来捕获外部的对象变量，此时 self 的引用计数应该要 +1；\n3. Block 被构造出来之后需要被赋值给 self，我们知道在 ARC 模式下此时的 Block 会执行 Copy 操作，从 `_NSConcreteStackBlock` 变成 `_NSMallocBlock`；\n4. Block 通过 `__BlockTest__test_block_desc_0_DATA` 找到 Copy 方法的具体实现 `__BlockTest__test_block_copy_0`，从上面的代码中我们知道该方法的实现是通过 `_Block_object_assign` 来实现的（对于这个方法的实现细节暂时还没有找到更相信的资料，有知道的可以麻烦告诉一下），通过名字我们可以猜测出该方法只是把捕获的变量地址直接拷贝一份到堆内存中，但是不会引起引用计数的变化；\n5. 当 Block 被真正执行的时候会通过 `__block_impl` 的 `FuncPtr` 找到真正的实现代码 `__BlockTest__test_block_func_0`，我们观察到在这个方法里面有这样一句代码 `BlockTest *const __strong self = __cself->self`，很明显此时 self 的引用计数会 +1，当该 `__BlockTest__test_block_func_0` 执行完毕之后还是会释放 self 的，此时引用计数会 -1；\n\n从上面的分析过程中，我们知道由于 Block 在构造的时候默认就对捕获的 self 进行了强引用，导致 self 的引用计数 +1；而又由于 self 持有了 Block，所以这里就造成了循环引用的问题。\n\n我们来看 🌰2 能不能解决这个问题？\n\n---\n\n🌰2 的 C 代码如下：\n\n```Objective-C\n// ^{} 结构体\nstruct __BlockTest__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __BlockTest__test_block_desc_0* Desc;\n    BlockTest *const __weak weakSelf;\n    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\n// Block 方法\nstatic void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) {\n    BlockTest *const __weak weakSelf = __cself->weakSelf; // bound by copy\n    weakSelf;\n}\n\n// Block 的 copy 操作\nstatic void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) {_Block_object_assign((void*)&dst->weakSelf, (void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n// Block 的 dispose 操作\nstatic void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) {_Block_object_dispose((void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\n// 描述 Block 的 copy 和 dispose\nstatic struct __BlockTest__test_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);\n    void (*dispose)(struct __BlockTest__test_block_impl_0*);\n} __BlockTest__test_block_desc_0_DATA = { 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0};\n\n// 方法主体\nstatic void _I_BlockTest_test(BlockTest * self, SEL _cmd) {\n    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;\n    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(\"setBlock:\"), ((void (*)())&__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));\n    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(\"block\"))();\n}\n```\n\n1. 方法主体会先用 `__weak` 初始化一个 weakSelf，此时 self 的引用计数是不会发生变化的；之后会构造一个`__BlockTest__test_block_impl_0` 的结构体，该结构体捕获了 weakSelf；\n2. `__BlockTest__test_block_impl_0` 的构造函数中使用了 `__weak` 来捕获 weakSelf，所以我们知道此时 self 的引用计数应该要也是不会发生变化的；\n3. 然后把该结构体赋值给 self.block，block 结构体被从栈复制到堆的时候使用了 `_Block_object_assign`，所以此时 self 的引用计数不会发生变化\n4. 然后 block 在被执行的时候做了一下 `__weak` 的操作 `BlockTest *const __weak weakSelf = __cself->weakSelf`，这时候 self 的引用计数也不会发生变化\n5. 由于 block 对 weakSelf 没有强引用，所以在 block 执行完成之后也不需要做释放 weakSelf 的工作\n\n所以，在该例子中 block 无法强引用 weakSelf，weakSelf 的引用计数没有发生任何变化。由于 self 没有被 block 强应用，所以当 self 要被释放的时候，block 也会被释放，这就解决了我们 🌰1 中的循环引用的问题。但是在 block 方法执行的过程中，self 对象有可能已经被释放了，此时如果你还去使用 weakSelf 就有可能造成奔溃的情况。\n\n---\n\n🌰3 的 C 代码如下：\n\n```Objective-C\nstruct __BlockTest__test_block_impl_0 {\n    struct __block_impl impl;\n    struct __BlockTest__test_block_desc_0* Desc;\n    BlockTest *const __weak weakSelf;\n    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\nstatic void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) {\n    BlockTest *const __weak weakSelf = __cself->weakSelf; // bound by copy\n    __attribute__((objc_ownership(strong))) typeof(self) strongSelf = weakSelf;    \n}\n\nstatic void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) {_Block_object_assign((void*)&dst->weakSelf, (void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) {_Block_object_dispose((void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}\n\nstatic struct __BlockTest__test_block_desc_0 {\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);\n    void (*dispose)(struct __BlockTest__test_block_impl_0*);\n} __BlockTest__test_block_desc_0_DATA = { 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0};\n\nstatic void _I_BlockTest_test(BlockTest * self, SEL _cmd) {\n    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;\n    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(\"setBlock:\"), ((void (*)())&__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));\n    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(\"block\"))();  \n}\n```\n\n\n前面的步骤都跟 🌰2 中的一样，关键是在 Block 的方法实现里面有点不一样。我们来看看 `__BlockTest__test_block_func_0`，它首先调用了 `BlockTest *const __weak weakSelf = __cself->weakSelf`， 所以它此时的引用计数不会发生变化；但是接下来又用 `objc_ownership(strong)` 来强引用 weakSelf，所以此时 self 的引用计数 +1。这就保证了在函数执行的过程中，Block 会一直持有 self，知道 Block 执行完毕之后会释放 weakSelf。\n\n所以 🌰3 完美的解决了循环应用和直接使用 `__weak` 可能导致奔溃的问题。\n\n---\n\n最后，说一下关于 _Block_object_assign 的猜想：\n\n```\n_Block_object_assign((void*)&dst->weakSelf, (void*)src->weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);\n```\n\n通过上面的例子，我们知道 Block 在构造的时候就会对捕获的变量进行内存管理（强引用和弱引用），所以当 Block 在做 Copy 操作的时候其实没有必要对它捕获的变量再做一遍内存管理了。这也应该是 Block 的 Copy 操作使用了 `_Block_object_assign` 这种不会导致引用计数发生变化的方式来实现的原因。\n\n\n\n\n","slug":"self-在-block-中的引用计数变化","published":1,"updated":"2023-01-07T05:42:02.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldr5xjcm0017jbse4b7l950g","content":"<p>相信大家在 Objective-C 中都会通过 <code>__waek</code> 的修饰符来保证 block 和 self 不会互相引用，代码如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak typeof(self) weakSelf = self;</span><br><span class=\"line\">self.block = ^&#123;</span><br><span class=\"line\">    __strong typeof(self) strongSelf = self;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是你思考过 self 在这一段旅程中的引用计数变化么，接下来我会通过三个例子来展示这一段旅程是怎样的？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 🌰1</span><br><span class=\"line\">NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\">self.block = ^&#123;</span><br><span class=\"line\">    self;</span><br><span class=\"line\">    NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">self.block();</span><br><span class=\"line\">NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 🌰2</span><br><span class=\"line\">__weak typeof(self) weakSelf = self;</span><br><span class=\"line\">NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\">self.block = ^&#123;</span><br><span class=\"line\">    weakSelf;</span><br><span class=\"line\">    NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">self.block();</span><br><span class=\"line\">NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 🌰3</span><br><span class=\"line\">__weak typeof(self) weakSelf = self;</span><br><span class=\"line\">NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\">self.block = ^&#123;</span><br><span class=\"line\">    __strong typeof(self) strongSelf = weakSelf;</span><br><span class=\"line\">    NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">self.block();</span><br><span class=\"line\">NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过 Clang 对上面的三个例子做一下编译，通过编译后的 C 代码（接下来所展示代码都是经过简化），我们可以推导出 self 的引用计数变化。</p>\n<hr>\n<p>🌰1 的 C 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Block 结构体。这个大家可以通过其他的资料去看看，我们今天主要是来探寻一下 self 的旅程，这里就不对 Block 本身做更详细的介绍</span><br><span class=\"line\">struct __block_impl &#123;</span><br><span class=\"line\">  void *isa;</span><br><span class=\"line\">  int Flags;</span><br><span class=\"line\">  int Reserved;</span><br><span class=\"line\">  void *FuncPtr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// ^&#123;&#125; 的实现</span><br><span class=\"line\">struct __BlockTest__test_block_impl_0 &#123;</span><br><span class=\"line\">    struct __block_impl impl;</span><br><span class=\"line\">    struct __BlockTest__test_block_desc_0* Desc;</span><br><span class=\"line\">    BlockTest *const __strong self;</span><br><span class=\"line\">    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __strong _self, int flags=0) : self(_self) &#123;</span><br><span class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">        impl.Flags = flags;</span><br><span class=\"line\">        impl.FuncPtr = fp;</span><br><span class=\"line\">        Desc = desc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 方法</span><br><span class=\"line\">static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">    BlockTest *const __strong self = __cself-&gt;self; // bound by copy</span><br><span class=\"line\">    self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 的 copy 操作</span><br><span class=\"line\">static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 的 dispose 操作</span><br><span class=\"line\">static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 描述 Block 的 copy 和 dispose</span><br><span class=\"line\">static struct __BlockTest__test_block_desc_0 &#123;</span><br><span class=\"line\">    size_t reserved;</span><br><span class=\"line\">    size_t Block_size;</span><br><span class=\"line\">    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">    void (*dispose)(struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法主体</span><br><span class=\"line\">static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123;</span><br><span class=\"line\">    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, self, 570425344)));</span><br><span class=\"line\">    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>在方法主体里面首先会构造一个 <code>__BlockTest__test_block_impl_0</code> 的结构体，该结构体捕获了 self；</li>\n<li><code>__BlockTest__test_block_impl_0</code> 的构造函数中使用了 <code>__strong</code> 来捕获 self，所以我们知道在构造的时候默认是使用 <code>__strong</code> 来捕获外部的对象变量，此时 self 的引用计数应该要 +1；</li>\n<li>Block 被构造出来之后需要被赋值给 self，我们知道在 ARC 模式下此时的 Block 会执行 Copy 操作，从 <code>_NSConcreteStackBlock</code> 变成 <code>_NSMallocBlock</code>；</li>\n<li>Block 通过 <code>__BlockTest__test_block_desc_0_DATA</code> 找到 Copy 方法的具体实现 <code>__BlockTest__test_block_copy_0</code>，从上面的代码中我们知道该方法的实现是通过 <code>_Block_object_assign</code> 来实现的（对于这个方法的实现细节暂时还没有找到更相信的资料，有知道的可以麻烦告诉一下），通过名字我们可以猜测出该方法只是把捕获的变量地址直接拷贝一份到堆内存中，但是不会引起引用计数的变化；</li>\n<li>当 Block 被真正执行的时候会通过 <code>__block_impl</code> 的 <code>FuncPtr</code> 找到真正的实现代码 <code>__BlockTest__test_block_func_0</code>，我们观察到在这个方法里面有这样一句代码 <code>BlockTest *const __strong self = __cself-&gt;self</code>，很明显此时 self 的引用计数会 +1，当该 <code>__BlockTest__test_block_func_0</code> 执行完毕之后还是会释放 self 的，此时引用计数会 -1；</li>\n</ol>\n<p>从上面的分析过程中，我们知道由于 Block 在构造的时候默认就对捕获的 self 进行了强引用，导致 self 的引用计数 +1；而又由于 self 持有了 Block，所以这里就造成了循环引用的问题。</p>\n<p>我们来看 🌰2 能不能解决这个问题？</p>\n<hr>\n<p>🌰2 的 C 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ^&#123;&#125; 结构体</span><br><span class=\"line\">struct __BlockTest__test_block_impl_0 &#123;</span><br><span class=\"line\">    struct __block_impl impl;</span><br><span class=\"line\">    struct __BlockTest__test_block_desc_0* Desc;</span><br><span class=\"line\">    BlockTest *const __weak weakSelf;</span><br><span class=\"line\">    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123;</span><br><span class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">        impl.Flags = flags;</span><br><span class=\"line\">        impl.FuncPtr = fp;</span><br><span class=\"line\">        Desc = desc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 方法</span><br><span class=\"line\">static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">    BlockTest *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy</span><br><span class=\"line\">    weakSelf;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 的 copy 操作</span><br><span class=\"line\">static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 的 dispose 操作</span><br><span class=\"line\">static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 描述 Block 的 copy 和 dispose</span><br><span class=\"line\">static struct __BlockTest__test_block_desc_0 &#123;</span><br><span class=\"line\">    size_t reserved;</span><br><span class=\"line\">    size_t Block_size;</span><br><span class=\"line\">    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">    void (*dispose)(struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法主体</span><br><span class=\"line\">static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123;</span><br><span class=\"line\">    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;</span><br><span class=\"line\">    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));</span><br><span class=\"line\">    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>方法主体会先用 <code>__weak</code> 初始化一个 weakSelf，此时 self 的引用计数是不会发生变化的；之后会构造一个<code>__BlockTest__test_block_impl_0</code> 的结构体，该结构体捕获了 weakSelf；</li>\n<li><code>__BlockTest__test_block_impl_0</code> 的构造函数中使用了 <code>__weak</code> 来捕获 weakSelf，所以我们知道此时 self 的引用计数应该要也是不会发生变化的；</li>\n<li>然后把该结构体赋值给 self.block，block 结构体被从栈复制到堆的时候使用了 <code>_Block_object_assign</code>，所以此时 self 的引用计数不会发生变化</li>\n<li>然后 block 在被执行的时候做了一下 <code>__weak</code> 的操作 <code>BlockTest *const __weak weakSelf = __cself-&gt;weakSelf</code>，这时候 self 的引用计数也不会发生变化</li>\n<li>由于 block 对 weakSelf 没有强引用，所以在 block 执行完成之后也不需要做释放 weakSelf 的工作</li>\n</ol>\n<p>所以，在该例子中 block 无法强引用 weakSelf，weakSelf 的引用计数没有发生任何变化。由于 self 没有被 block 强应用，所以当 self 要被释放的时候，block 也会被释放，这就解决了我们 🌰1 中的循环引用的问题。但是在 block 方法执行的过程中，self 对象有可能已经被释放了，此时如果你还去使用 weakSelf 就有可能造成奔溃的情况。</p>\n<hr>\n<p>🌰3 的 C 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __BlockTest__test_block_impl_0 &#123;</span><br><span class=\"line\">    struct __block_impl impl;</span><br><span class=\"line\">    struct __BlockTest__test_block_desc_0* Desc;</span><br><span class=\"line\">    BlockTest *const __weak weakSelf;</span><br><span class=\"line\">    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123;</span><br><span class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">        impl.Flags = flags;</span><br><span class=\"line\">        impl.FuncPtr = fp;</span><br><span class=\"line\">        Desc = desc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">    BlockTest *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy</span><br><span class=\"line\">    __attribute__((objc_ownership(strong))) typeof(self) strongSelf = weakSelf;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static struct __BlockTest__test_block_desc_0 &#123;</span><br><span class=\"line\">    size_t reserved;</span><br><span class=\"line\">    size_t Block_size;</span><br><span class=\"line\">    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">    void (*dispose)(struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123;</span><br><span class=\"line\">    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;</span><br><span class=\"line\">    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));</span><br><span class=\"line\">    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>前面的步骤都跟 🌰2 中的一样，关键是在 Block 的方法实现里面有点不一样。我们来看看 <code>__BlockTest__test_block_func_0</code>，它首先调用了 <code>BlockTest *const __weak weakSelf = __cself-&gt;weakSelf</code>， 所以它此时的引用计数不会发生变化；但是接下来又用 <code>objc_ownership(strong)</code> 来强引用 weakSelf，所以此时 self 的引用计数 +1。这就保证了在函数执行的过程中，Block 会一直持有 self，知道 Block 执行完毕之后会释放 weakSelf。</p>\n<p>所以 🌰3 完美的解决了循环应用和直接使用 <code>__weak</code> 可能导致奔溃的问题。</p>\n<hr>\n<p>最后，说一下关于 _Block_object_assign 的猜想：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br></pre></td></tr></table></figure>\n\n<p>通过上面的例子，我们知道 Block 在构造的时候就会对捕获的变量进行内存管理（强引用和弱引用），所以当 Block 在做 Copy 操作的时候其实没有必要对它捕获的变量再做一遍内存管理了。这也应该是 Block 的 Copy 操作使用了 <code>_Block_object_assign</code> 这种不会导致引用计数发生变化的方式来实现的原因。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>相信大家在 Objective-C 中都会通过 <code>__waek</code> 的修饰符来保证 block 和 self 不会互相引用，代码如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak typeof(self) weakSelf = self;</span><br><span class=\"line\">self.block = ^&#123;</span><br><span class=\"line\">    __strong typeof(self) strongSelf = self;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是你思考过 self 在这一段旅程中的引用计数变化么，接下来我会通过三个例子来展示这一段旅程是怎样的？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 🌰1</span><br><span class=\"line\">NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\">self.block = ^&#123;</span><br><span class=\"line\">    self;</span><br><span class=\"line\">    NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">self.block();</span><br><span class=\"line\">NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 🌰2</span><br><span class=\"line\">__weak typeof(self) weakSelf = self;</span><br><span class=\"line\">NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\">self.block = ^&#123;</span><br><span class=\"line\">    weakSelf;</span><br><span class=\"line\">    NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">self.block();</span><br><span class=\"line\">NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 🌰3</span><br><span class=\"line\">__weak typeof(self) weakSelf = self;</span><br><span class=\"line\">NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class=\"line\">self.block = ^&#123;</span><br><span class=\"line\">    __strong typeof(self) strongSelf = weakSelf;</span><br><span class=\"line\">    NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">self.block();</span><br><span class=\"line\">NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过 Clang 对上面的三个例子做一下编译，通过编译后的 C 代码（接下来所展示代码都是经过简化），我们可以推导出 self 的引用计数变化。</p>\n<hr>\n<p>🌰1 的 C 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Block 结构体。这个大家可以通过其他的资料去看看，我们今天主要是来探寻一下 self 的旅程，这里就不对 Block 本身做更详细的介绍</span><br><span class=\"line\">struct __block_impl &#123;</span><br><span class=\"line\">  void *isa;</span><br><span class=\"line\">  int Flags;</span><br><span class=\"line\">  int Reserved;</span><br><span class=\"line\">  void *FuncPtr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// ^&#123;&#125; 的实现</span><br><span class=\"line\">struct __BlockTest__test_block_impl_0 &#123;</span><br><span class=\"line\">    struct __block_impl impl;</span><br><span class=\"line\">    struct __BlockTest__test_block_desc_0* Desc;</span><br><span class=\"line\">    BlockTest *const __strong self;</span><br><span class=\"line\">    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __strong _self, int flags=0) : self(_self) &#123;</span><br><span class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">        impl.Flags = flags;</span><br><span class=\"line\">        impl.FuncPtr = fp;</span><br><span class=\"line\">        Desc = desc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 方法</span><br><span class=\"line\">static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">    BlockTest *const __strong self = __cself-&gt;self; // bound by copy</span><br><span class=\"line\">    self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 的 copy 操作</span><br><span class=\"line\">static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 的 dispose 操作</span><br><span class=\"line\">static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 描述 Block 的 copy 和 dispose</span><br><span class=\"line\">static struct __BlockTest__test_block_desc_0 &#123;</span><br><span class=\"line\">    size_t reserved;</span><br><span class=\"line\">    size_t Block_size;</span><br><span class=\"line\">    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">    void (*dispose)(struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法主体</span><br><span class=\"line\">static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123;</span><br><span class=\"line\">    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, self, 570425344)));</span><br><span class=\"line\">    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>在方法主体里面首先会构造一个 <code>__BlockTest__test_block_impl_0</code> 的结构体，该结构体捕获了 self；</li>\n<li><code>__BlockTest__test_block_impl_0</code> 的构造函数中使用了 <code>__strong</code> 来捕获 self，所以我们知道在构造的时候默认是使用 <code>__strong</code> 来捕获外部的对象变量，此时 self 的引用计数应该要 +1；</li>\n<li>Block 被构造出来之后需要被赋值给 self，我们知道在 ARC 模式下此时的 Block 会执行 Copy 操作，从 <code>_NSConcreteStackBlock</code> 变成 <code>_NSMallocBlock</code>；</li>\n<li>Block 通过 <code>__BlockTest__test_block_desc_0_DATA</code> 找到 Copy 方法的具体实现 <code>__BlockTest__test_block_copy_0</code>，从上面的代码中我们知道该方法的实现是通过 <code>_Block_object_assign</code> 来实现的（对于这个方法的实现细节暂时还没有找到更相信的资料，有知道的可以麻烦告诉一下），通过名字我们可以猜测出该方法只是把捕获的变量地址直接拷贝一份到堆内存中，但是不会引起引用计数的变化；</li>\n<li>当 Block 被真正执行的时候会通过 <code>__block_impl</code> 的 <code>FuncPtr</code> 找到真正的实现代码 <code>__BlockTest__test_block_func_0</code>，我们观察到在这个方法里面有这样一句代码 <code>BlockTest *const __strong self = __cself-&gt;self</code>，很明显此时 self 的引用计数会 +1，当该 <code>__BlockTest__test_block_func_0</code> 执行完毕之后还是会释放 self 的，此时引用计数会 -1；</li>\n</ol>\n<p>从上面的分析过程中，我们知道由于 Block 在构造的时候默认就对捕获的 self 进行了强引用，导致 self 的引用计数 +1；而又由于 self 持有了 Block，所以这里就造成了循环引用的问题。</p>\n<p>我们来看 🌰2 能不能解决这个问题？</p>\n<hr>\n<p>🌰2 的 C 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ^&#123;&#125; 结构体</span><br><span class=\"line\">struct __BlockTest__test_block_impl_0 &#123;</span><br><span class=\"line\">    struct __block_impl impl;</span><br><span class=\"line\">    struct __BlockTest__test_block_desc_0* Desc;</span><br><span class=\"line\">    BlockTest *const __weak weakSelf;</span><br><span class=\"line\">    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123;</span><br><span class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">        impl.Flags = flags;</span><br><span class=\"line\">        impl.FuncPtr = fp;</span><br><span class=\"line\">        Desc = desc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 方法</span><br><span class=\"line\">static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">    BlockTest *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy</span><br><span class=\"line\">    weakSelf;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 的 copy 操作</span><br><span class=\"line\">static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Block 的 dispose 操作</span><br><span class=\"line\">static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 描述 Block 的 copy 和 dispose</span><br><span class=\"line\">static struct __BlockTest__test_block_desc_0 &#123;</span><br><span class=\"line\">    size_t reserved;</span><br><span class=\"line\">    size_t Block_size;</span><br><span class=\"line\">    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">    void (*dispose)(struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法主体</span><br><span class=\"line\">static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123;</span><br><span class=\"line\">    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;</span><br><span class=\"line\">    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));</span><br><span class=\"line\">    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>方法主体会先用 <code>__weak</code> 初始化一个 weakSelf，此时 self 的引用计数是不会发生变化的；之后会构造一个<code>__BlockTest__test_block_impl_0</code> 的结构体，该结构体捕获了 weakSelf；</li>\n<li><code>__BlockTest__test_block_impl_0</code> 的构造函数中使用了 <code>__weak</code> 来捕获 weakSelf，所以我们知道此时 self 的引用计数应该要也是不会发生变化的；</li>\n<li>然后把该结构体赋值给 self.block，block 结构体被从栈复制到堆的时候使用了 <code>_Block_object_assign</code>，所以此时 self 的引用计数不会发生变化</li>\n<li>然后 block 在被执行的时候做了一下 <code>__weak</code> 的操作 <code>BlockTest *const __weak weakSelf = __cself-&gt;weakSelf</code>，这时候 self 的引用计数也不会发生变化</li>\n<li>由于 block 对 weakSelf 没有强引用，所以在 block 执行完成之后也不需要做释放 weakSelf 的工作</li>\n</ol>\n<p>所以，在该例子中 block 无法强引用 weakSelf，weakSelf 的引用计数没有发生任何变化。由于 self 没有被 block 强应用，所以当 self 要被释放的时候，block 也会被释放，这就解决了我们 🌰1 中的循环引用的问题。但是在 block 方法执行的过程中，self 对象有可能已经被释放了，此时如果你还去使用 weakSelf 就有可能造成奔溃的情况。</p>\n<hr>\n<p>🌰3 的 C 代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __BlockTest__test_block_impl_0 &#123;</span><br><span class=\"line\">    struct __block_impl impl;</span><br><span class=\"line\">    struct __BlockTest__test_block_desc_0* Desc;</span><br><span class=\"line\">    BlockTest *const __weak weakSelf;</span><br><span class=\"line\">    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123;</span><br><span class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">        impl.Flags = flags;</span><br><span class=\"line\">        impl.FuncPtr = fp;</span><br><span class=\"line\">        Desc = desc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">    BlockTest *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy</span><br><span class=\"line\">    __attribute__((objc_ownership(strong))) typeof(self) strongSelf = weakSelf;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static struct __BlockTest__test_block_desc_0 &#123;</span><br><span class=\"line\">    size_t reserved;</span><br><span class=\"line\">    size_t Block_size;</span><br><span class=\"line\">    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">    void (*dispose)(struct __BlockTest__test_block_impl_0*);</span><br><span class=\"line\">&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123;</span><br><span class=\"line\">    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;</span><br><span class=\"line\">    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));</span><br><span class=\"line\">    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>前面的步骤都跟 🌰2 中的一样，关键是在 Block 的方法实现里面有点不一样。我们来看看 <code>__BlockTest__test_block_func_0</code>，它首先调用了 <code>BlockTest *const __weak weakSelf = __cself-&gt;weakSelf</code>， 所以它此时的引用计数不会发生变化；但是接下来又用 <code>objc_ownership(strong)</code> 来强引用 weakSelf，所以此时 self 的引用计数 +1。这就保证了在函数执行的过程中，Block 会一直持有 self，知道 Block 执行完毕之后会释放 weakSelf。</p>\n<p>所以 🌰3 完美的解决了循环应用和直接使用 <code>__weak</code> 可能导致奔溃的问题。</p>\n<hr>\n<p>最后，说一下关于 _Block_object_assign 的猜想：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br></pre></td></tr></table></figure>\n\n<p>通过上面的例子，我们知道 Block 在构造的时候就会对捕获的变量进行内存管理（强引用和弱引用），所以当 Block 在做 Copy 操作的时候其实没有必要对它捕获的变量再做一遍内存管理了。这也应该是 Block 的 Copy 操作使用了 <code>_Block_object_assign</code> 这种不会导致引用计数发生变化的方式来实现的原因。</p>\n"},{"title":"初步了解 GCD","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n## GCD 简介\n\nGCD(Grand Central Dispatch) 是苹果提供的一套多线程编程技术。想象一下，如果让你编写一个可以高效的跑在不同计算机、不同内核的应用程序，你会怎么做呢？你要看看硬件是什么，看看有有多少个内核，想想用什么算法，想想在什么时候去切换线程...总之，你要做的东西多了去了。而 GCD 帮我们屏蔽了这些技术细节，但是如果要用好 GCD 的话，还是要多了解一些知识点。\n\n## Dispatch 对象和内存管理\n\n在 Objective-C 里面，所有的 dispatch 对象都是 Objective-C 对象，所以他们同样适用引用技术的内存管理。如果你是使用 ARC 的话，dispatch 对象会向普通的 Objective-C 对象一样自动进行 retain 和 release 操作；如果你是使用 MRC，要记住使用 dispatch_retain 和 dispatch_release 来进行管理。\n\n## 常用 API\n\n### dispatch_queue_t（调度队列）\n\n```Swift\npublic func dispatch_queue_create(label: UnsafePointer<Int8>, _ attr: dispatch_queue_attr_t!) -> dispatch_queue_t!\n```\n\n在 GCD 中只能通过上面的 API 来创建调度队列，我们可以通过创建各种各样的 Block 形式的任务并由该调度队列来决定如何去执行这些 Block 任务。上面创建调度队列的函数需要两个参数：\n\n* label: 这个参数是用来给你创建的调度队列进行命名的，特别是在调试的时候你可以通过该参数来判断是哪个调度队列的任务在执行。\n* attr: 这个参数只有 DISPATCH_QUEUE_SERIAL 和 DISPATCH_QUEUE_CONCURRENT 两种值（在 Objective-C 中这个参数可以为 NULL，这个时候默认是 DISPATCH_QUEUE_SERIAL）。DISPATCH_QUEUE_SERIAL 是告诉调度队列以串行的方式去执行任务，DISPATCH_QUEUE_CONCURRENT 是告诉调度队列以并发的方式去执行任务。\n\n当然我们还可以通过下面的方法来获取系统已经创建好的调度队列：\n\n```Swift\n// 获取全局队列\npublic func dispatch_get_global_queue(identifier: Int, _ flags: UInt) -> dispatch_queue_t!\n```\n```Swift\n// 获取主线程的com.apple.main-thread (serial)队列\npublic func dispatch_get_main_queue() -> dispatch_queue_t!\n```\n\n注意，所有 pending 状态的 Block 任务都会持有该调度队列的引用，所以我们不需要显示的去持有调度队列，而调度队列会在所有的 Block 任务都从 pending 变为 finished 之后才会被释放。\n\n总之，现在大家要知道的是我们可以把不同的 Block任务提交到调度队列，具体的细节和实现看看后面内容。\n\n### dispatch_sync 和 dispatch_async（同步和异步）\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建调度队列\nprint(\"Begin Sync\")\n// 同步调用\ndispatch_sync(queue) {\n    // Block任务\n    print(\"Execute Block Task1\")   \n}\ndispatch_sync(queue) {\n    // Block任务\n    print(\"Execute Block Task2\")   \n}\nprint(\"After Sync\")\n```\n\n这段代码的输出结果如下：\n\n```Swift\nBegin Sync\nExecute Block Task1\nExecute Block Task2\nAfter Sync\n```\n\n上面的例子就是我们平常对 dispatch_sync 的用法，并且我们可以看到第一个 Block 任务执行之后才会执行第二个 Block 任务。dispatch_sync 需要等待 Block的任务执行完成之后，才能继续往后执行。但是使用 dispatch_sync 的时候，有几点是需要注意的：\n\n1. 当调用 dispatch_sync 方法的时候，系统默认情况下会在当前线程去执行调度队列里的任务，只有在一些特殊情况下才会把调度队列的任务分配到其他线程去执行。所以我们就知道，线程和调度队列并不是一对一的关系。至于为什么默认情况下会在当前线程去执行调度队列里的任务，我的猜测是为了性能。大家想一想，dispatch_sync 会同步执行 Block任务， Block任务没有结束的情况下，后面的代码是无法执行的。基于这样一个同步的机制，GCD 还有必要先把当前线程挂起，然后去创建新线程，然后切换到新的线程去执行调度队列里的任务，然后再把线程切换到当前线程，然后再让当前线程恢复么？结论是没有必要。\n\n2. 你不能够在当前的串行调度队列的任务里面去添加新的任务到当前的调度队列里面，否则会造成死锁。这句话怎么理解呢，我们来来看看下面的例子：\n    \n```Swift\n// 例1\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n// 同步调用\ndispatch_sync(queue) {\n    // Block1\n    print(\"Begin Execute Block Task1\")\n    dispatch_sync(queue) {\n        // Block2\n        print(\"Execute Block Task2\")   \n    }\n    print(\"End Execute Block Task1\")\n}\n\n// 例1的结果\nBegin Execute Block Task1\n    \n```\n\n为什么 Block1 后面的 print 和 Block2 的 print 都不执行了呢？首先我们要知道被 DISPATCH_QUEUE_SERIAL 声明的调度队列是串行调度队列，串行调度队列里的任务是同时只能有一个任务在执行，并且当前任务没有执行完成，下一个任务也无法执行。上面的例子中会先输出 Block1 中的 *Begin Execute Block Task1*，然后这个时候再把 Block2 添加到同一个串行调度队列中去。这个时候的 Block1 还没有执行完成，它需要等 dispatch_sync 的 Block2 执行完成之后才能继续执行，而 Block2 又必须等待 Block1 执行完成之后才能执行，所以这个时候就造成 Block1 等着 Block2，Block2 等着 Block1 的死锁。\n\n我们再把调度队列属性改为 DISPAT_QUEUE_CONCURRENT，然后再看看执行结果是什么：\n\n\n```Swift\n// 例2\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n// 同步调用\ndispatch_sync(queue) {\n    // Block1\n    print(\"Begin Execute Block Task1\")\n    dispatch_sync(queue) {\n        // Block2\n        print(\"Execute Block Task2\")   \n    }\n    print(\"End Execute Block Task1\")\n}\n```\n    \n```Swift\n// 例2的结果\nBegin Execute Block Task1\nExecute Block Task2\nEnd Execute Block Task1\n```\n\n被 DISPATCH_QUEUE_CONCURRENT 声明的并发调度队列就没有这种死锁的问题。并发调度队列里的任务是不会霸占资源不放的，每一个任务执行一个时间片段之后会把资源交出来给别的任务去执行。所以例2中的 Block1 虽然需要等待 Block2 执行完成之后才能继续执行，但是当 Block1 在等待的过程中，是可以把资源释放出来交给 Block2 去执行，Block2 执行完成之后 Block1 就可以继续执行了。所以，这个时候就不会造成死锁来。\n\n再来看看下面的例子会不会造成死锁：\n\n```Swift\noverride func viewDidLoad() {\n    dispatch_sync(dispatch_get_main_queue()) {\n        print(\"Excute Block Task\")\n    }\n}\n```\n    \n答案是会的。给大家一点提示，主线程的默认调度队列是串行（DISPATCH_QUEUE_SERIAL）的，viewDidLoad() 是在主线程的调度队列 com.apple.main-thread (serial) 执行的。\n\n上面的例子主要是希望大家理解串行和并发的概念，同时要明白造成死锁的原因。而要解决死锁一般可以用 DISPATCH_QUEUE_CONCURRENT 或接下来我们要讲的 dispatch_async 来解决。\n\n通过对 dispatch_sync 的了解，我们可以利用 dispatch_async 很快的写出异步代码：\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建调度队列\nprint(\"Begin Async\")\n// 异步调用\ndispatch_async(queue) {\n    // Block1\n    print(\"Execute Block Task1\")   \n}\ndispatch_async(queue) {\n    // Block2\n    print(\"Execute Block Task2\")   \n}\nprint(\"After Async\")\n```\n\n这个例子的结果有好几种：\n\n```Swift\n// 结果1\nBegin Async\nAfter Async\nExecute Block Task1\nExEcute Block Task2\n```\n```Swift\n// 结果2\nBegin Async\nExecute Block Task1\nExEcute Block Task2\nAfter Async\n```\n\n上面只是列出来两种可能，但实际上还有其他的可能。当我们调用 dispatch_async 的时候，它总是会在 Block 任务被提交之后马上返回，而不会傻傻的等待 Block 任务执行完成。由于上面创建的是串行调度队列，所以我们可以保证 Block1 要比 Block2 优先执行，但是 After Async 就无法确定是在 Block1 的前后还是 Block2 的前后。\n\n如果我们把上面的 DISPATCH_QUEUE_SERIAL 改成 DISPATCH_QUEUE_CONCURRENT，那我们就无法确定 After Async、Block1 和 Block2 这三者的执行顺序了。\n\n我们刚才说到用 dispatch_async 可以解决死锁的问题，那它是怎么解决的呢？\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n// 异步调用\ndispatch_async(queue) {\n    // Block1\n    print(\"Begin Execute Block Task1\")\n    dispatch_async(queue) {\n        // Block2\n        print(\"Execute Block Task2\")   \n    }\n    print(\"End Execute Block Task1\")\n}\n```\n\n上面的例子会优先输出 Block1 的 *Begin Execute Block Task1* 之后，通过 dispatch_async 把 Block2 提交到串行队列里面，然后又马上返回到 Block1 去输出 *End Execute Block Task1*，这个时候的 Block1 就结束了，接下来就开始执行 Block2。所以上面的代码是不会造成死锁的，虽然上面的例子也是创建了一个串行调度队列，但是该调度队列只是保证了 Block1 要比 Block2 优先执行。\n\n### dispatch_once\n\n写过 Objective-C 的人都知道，dispatch_once 一般会被用来创建单例对象：\n\n```Swift\n@implementation Single\n+ (Single *)sharedInstance {\n    static Single * _single = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        _single = [[Single alloc] init];\n    });\n    return _single; \n}\n@end\n```\n\n这是由于 dispatch_once 是线程安全且只会执行一次，所以才会被用来作为单例的实现。这里需要注意的是 dispatch_once_t 必须是静态的或全局的才能保证 dispatch_once 的 Block 只会被执行一次，所以上面的代码用了 static 来修饰 dispatch_once_t。\n\n### dispatch_apply\n\n```Swift\npublic func dispatch_apply(iterations: Int, _ queue: dispatch_queue_t!, _ block: (Int) -> Void)\n```\n\n其中的 interations 是表明要执行多少次 block，block 中的 Int 是该 Block 被执行的序号。调用这个方法的时候要注意该方法跟 dispatch_sync 一样会阻塞当前线程，所以我们需要注意在主线程中调用该方法。\n\n### dispatch_after\n\n```Swift\npublic func dispatch_after(when: dispatch_time_t, _ queue: dispatch_queue_t, _ block: dispatch_block_t)\n```\n\n调用这个方法的时候需要注意的是 when 这个参数，你需要通过 dispatch_time 或 dispatch_walltime 来创建。并且该方法是异步执行的，并不会阻塞当前线程。\n\n一般的写法如下：\n\n```Swift\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(5 * NSEC_PER_SEC)), queue) {\n    print(\"5s \\(NSThread.currentThread())\")\n}\n```\n\n### dispatch_group_t\n\ndispatch_group_t 是用来做聚合同步的，它可以用来跟踪你提交的所有任务（即使是在不同的调度队列也可以）的完成状态。\n\n接下来我们来看看 dispatch group 的一些常见用法：\n\n```Swift\n// 创建 dispatch_group_t 对象\nlet group = dispatch_group_create()\n\n// 创建串行队列\nlet serialQueue = dispatch_queue_create(\"Serial Queue\", DISPATCH_QUEUE_SERIAL)\n\n// 提交两个 Block 任务到 serialQueue，同时关联 serialQueue 和 group 的关系\ndispatch_group_async(group, serialQueue) {\n    print(\"Execute Block1 within Serial Queue\")\n}\ndispatch_group_async(group, serialQueue) {\n    print(\"Execute Block2 within Serial Queue\")\n}\n\n// 创建并发队列，并提交 Block 任务，同时关联该并发队列和 group 的关系\ndispatch_group_async(group, dispatch_queue_create(\"Concurrent Queue\", DISPATCH_QUEUE_CONCURRENT)) {\n    print(\"Execute Block within Concurrent Queue\")\n}\n\n// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发\ndispatch_group_notify(group, dispatch_queue_create(\"Finished\")) {\n    print(\"Finished\")\n}\n```\n\n注意，关联到 group 的方法只有 dispatch_group_async 而没有 dispatch_group_sync。\n\n但是还有另外一种方法可以让我们关联一个普通的任务：\n\n```Swift\n// 创建 dispatch_group_t 对象\nlet group = dispatch_group_create()\n\n// 使用 dispatch_group_enter 和 dispatch_group_leave 的话，我们不需要调用\n// dispatch_group_async 也能关联一个任务到 group 上\ndispatch_group_enter(group)\nself.executeTask {\n    // 执行代码\n    \n    dispatch_group_leave(group)\n}\n\n// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发\ndispatch_group_notify(group, dispatch_queue_create(\"Finished\")) {\n    print(\"Finished\")\n}\n```\n\n使用 dispatch_group_enter 和 dispatch_group_leave 的时候，它们必须成双成对出现，否则 dispatch_group_notify 是不会被调用的。\n\n接下来我们还要了解一下 dispatch_group_wait：\n\n```Swift\npublic func dispatch_group_wait(group: dispatch_group_t, _ timeout: dispatch_time_t) -> Int\n```\n\ndispatch_group_wait 可以指定一个 timeout 的参数，当 group 的任务没有在规定的时间内完成，它会返回一个非零的值，当 group 的任务能够在规定的时间内完成就返回0。同时，大家要注意这个方法会挂起当前线程，所以在主线程的时候要慎重使用该方法。\n\n### dispatch_barrier_t\n\n我们先来试想一个场景，假如现在有多个线程要去读取一份文件的内容，同时又有其他线程想要去更新该文件的内容，那么就有可能会发生你读错文件内容的现象。这个时候我们可以把所有读写操作都放到我们之前学习的串行队列去执行，但是我们都知道同时有多个线程去读取一份文件内容是没有问题的。\n\n使用 dispatch barrier 可以解决上面的问题：\n\n```Swift\n// 创建操作文件的并发队列\nlet queue = dispatch_queue_create(\"File\", DISPATCH_QUEUE_CONCURRENT)\ndispatch_async(queue) {\n    // Read1\n}\ndispatch_async(queue) {\n    // Read2\n}\ndispatch_barrier_async(queue) {\n    // Write\n}\ndispatch_async(queue) {\n    // Read3\n}\n```\n\n通过 dispatch_barrier_async 或 dispatch_barrier_sync 提交的任务会等待当前队列里正在执行的任务执行完毕才会执行，并且其他还没有执行的任务都必须等待提交到 dispatch barrier 的任务执行完毕之后才会开始执行。所以上面的代码中，当 Write 任务被提交的时候，如果当前队列中只有 Read1 在执行，那么 Write 会等待 Read1 执行完成之后才会执行，Read2  和 Read3 都必须等待 Write 执行完之后才会执行。另外，上面的代码中创建的是并发队列，因为如果是串行队列的话就没有必要用 dispatch barrier 了。\n\n### dispatch_semaphore_t\n\ndispatch semaphore 是一个效率非常高的传统计数信号量，所以我们一般可以用这个来控制最大的并发数量。\n\n```Swift\n// 创建初始值为2的信号量，最大并发数量为2\nlet semaphore = dispatch_semaphore_create(2)\n// 创建并发队列\nlet queue = dispatch_queue_create(\"Semaphore\", DISPATCH_QUEUE_CONCURRENT)\n// 创建100个并发任务\nfor index in 1...100 {\n    // 这个方法会进行信号量减1的操作，并且如果信号量减1之后的结果小于0的话，该方法会造成线程的挂起直\n    // 到该信号量进行加1操作才会恢复，所以在主线程要注意该方法的使用。\n    // 注意：这个方法要放在 dispatch_async 外面，否则系统依旧会创建超过2个线程同时来处理该调度队列\n    // 的任务\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)\n    dispatch_async(queue) {\n        \n        // 释放资源，信号量增加1\n        dispatch_semaphore_signal(semaphore)\n    }\n}\n```\n\n## 其他\n\nGCD 在 Swift3 的语法跟现在的语法不太一样了，有兴趣的可以自行去了解。在未来可能会考虑把本文章的代码都用 Swift3 的语法来重新写一下。\n\n\n\n\n","source":"_posts/初步了解GCD.md","raw":"---\ntitle: 初步了解 GCD\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: 技术 \ntags: [iOS, GCD]\n---\n\n## GCD 简介\n\nGCD(Grand Central Dispatch) 是苹果提供的一套多线程编程技术。想象一下，如果让你编写一个可以高效的跑在不同计算机、不同内核的应用程序，你会怎么做呢？你要看看硬件是什么，看看有有多少个内核，想想用什么算法，想想在什么时候去切换线程...总之，你要做的东西多了去了。而 GCD 帮我们屏蔽了这些技术细节，但是如果要用好 GCD 的话，还是要多了解一些知识点。\n\n## Dispatch 对象和内存管理\n\n在 Objective-C 里面，所有的 dispatch 对象都是 Objective-C 对象，所以他们同样适用引用技术的内存管理。如果你是使用 ARC 的话，dispatch 对象会向普通的 Objective-C 对象一样自动进行 retain 和 release 操作；如果你是使用 MRC，要记住使用 dispatch_retain 和 dispatch_release 来进行管理。\n\n## 常用 API\n\n### dispatch_queue_t（调度队列）\n\n```Swift\npublic func dispatch_queue_create(label: UnsafePointer<Int8>, _ attr: dispatch_queue_attr_t!) -> dispatch_queue_t!\n```\n\n在 GCD 中只能通过上面的 API 来创建调度队列，我们可以通过创建各种各样的 Block 形式的任务并由该调度队列来决定如何去执行这些 Block 任务。上面创建调度队列的函数需要两个参数：\n\n* label: 这个参数是用来给你创建的调度队列进行命名的，特别是在调试的时候你可以通过该参数来判断是哪个调度队列的任务在执行。\n* attr: 这个参数只有 DISPATCH_QUEUE_SERIAL 和 DISPATCH_QUEUE_CONCURRENT 两种值（在 Objective-C 中这个参数可以为 NULL，这个时候默认是 DISPATCH_QUEUE_SERIAL）。DISPATCH_QUEUE_SERIAL 是告诉调度队列以串行的方式去执行任务，DISPATCH_QUEUE_CONCURRENT 是告诉调度队列以并发的方式去执行任务。\n\n当然我们还可以通过下面的方法来获取系统已经创建好的调度队列：\n\n```Swift\n// 获取全局队列\npublic func dispatch_get_global_queue(identifier: Int, _ flags: UInt) -> dispatch_queue_t!\n```\n```Swift\n// 获取主线程的com.apple.main-thread (serial)队列\npublic func dispatch_get_main_queue() -> dispatch_queue_t!\n```\n\n注意，所有 pending 状态的 Block 任务都会持有该调度队列的引用，所以我们不需要显示的去持有调度队列，而调度队列会在所有的 Block 任务都从 pending 变为 finished 之后才会被释放。\n\n总之，现在大家要知道的是我们可以把不同的 Block任务提交到调度队列，具体的细节和实现看看后面内容。\n\n### dispatch_sync 和 dispatch_async（同步和异步）\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建调度队列\nprint(\"Begin Sync\")\n// 同步调用\ndispatch_sync(queue) {\n    // Block任务\n    print(\"Execute Block Task1\")   \n}\ndispatch_sync(queue) {\n    // Block任务\n    print(\"Execute Block Task2\")   \n}\nprint(\"After Sync\")\n```\n\n这段代码的输出结果如下：\n\n```Swift\nBegin Sync\nExecute Block Task1\nExecute Block Task2\nAfter Sync\n```\n\n上面的例子就是我们平常对 dispatch_sync 的用法，并且我们可以看到第一个 Block 任务执行之后才会执行第二个 Block 任务。dispatch_sync 需要等待 Block的任务执行完成之后，才能继续往后执行。但是使用 dispatch_sync 的时候，有几点是需要注意的：\n\n1. 当调用 dispatch_sync 方法的时候，系统默认情况下会在当前线程去执行调度队列里的任务，只有在一些特殊情况下才会把调度队列的任务分配到其他线程去执行。所以我们就知道，线程和调度队列并不是一对一的关系。至于为什么默认情况下会在当前线程去执行调度队列里的任务，我的猜测是为了性能。大家想一想，dispatch_sync 会同步执行 Block任务， Block任务没有结束的情况下，后面的代码是无法执行的。基于这样一个同步的机制，GCD 还有必要先把当前线程挂起，然后去创建新线程，然后切换到新的线程去执行调度队列里的任务，然后再把线程切换到当前线程，然后再让当前线程恢复么？结论是没有必要。\n\n2. 你不能够在当前的串行调度队列的任务里面去添加新的任务到当前的调度队列里面，否则会造成死锁。这句话怎么理解呢，我们来来看看下面的例子：\n    \n```Swift\n// 例1\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n// 同步调用\ndispatch_sync(queue) {\n    // Block1\n    print(\"Begin Execute Block Task1\")\n    dispatch_sync(queue) {\n        // Block2\n        print(\"Execute Block Task2\")   \n    }\n    print(\"End Execute Block Task1\")\n}\n\n// 例1的结果\nBegin Execute Block Task1\n    \n```\n\n为什么 Block1 后面的 print 和 Block2 的 print 都不执行了呢？首先我们要知道被 DISPATCH_QUEUE_SERIAL 声明的调度队列是串行调度队列，串行调度队列里的任务是同时只能有一个任务在执行，并且当前任务没有执行完成，下一个任务也无法执行。上面的例子中会先输出 Block1 中的 *Begin Execute Block Task1*，然后这个时候再把 Block2 添加到同一个串行调度队列中去。这个时候的 Block1 还没有执行完成，它需要等 dispatch_sync 的 Block2 执行完成之后才能继续执行，而 Block2 又必须等待 Block1 执行完成之后才能执行，所以这个时候就造成 Block1 等着 Block2，Block2 等着 Block1 的死锁。\n\n我们再把调度队列属性改为 DISPAT_QUEUE_CONCURRENT，然后再看看执行结果是什么：\n\n\n```Swift\n// 例2\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n// 同步调用\ndispatch_sync(queue) {\n    // Block1\n    print(\"Begin Execute Block Task1\")\n    dispatch_sync(queue) {\n        // Block2\n        print(\"Execute Block Task2\")   \n    }\n    print(\"End Execute Block Task1\")\n}\n```\n    \n```Swift\n// 例2的结果\nBegin Execute Block Task1\nExecute Block Task2\nEnd Execute Block Task1\n```\n\n被 DISPATCH_QUEUE_CONCURRENT 声明的并发调度队列就没有这种死锁的问题。并发调度队列里的任务是不会霸占资源不放的，每一个任务执行一个时间片段之后会把资源交出来给别的任务去执行。所以例2中的 Block1 虽然需要等待 Block2 执行完成之后才能继续执行，但是当 Block1 在等待的过程中，是可以把资源释放出来交给 Block2 去执行，Block2 执行完成之后 Block1 就可以继续执行了。所以，这个时候就不会造成死锁来。\n\n再来看看下面的例子会不会造成死锁：\n\n```Swift\noverride func viewDidLoad() {\n    dispatch_sync(dispatch_get_main_queue()) {\n        print(\"Excute Block Task\")\n    }\n}\n```\n    \n答案是会的。给大家一点提示，主线程的默认调度队列是串行（DISPATCH_QUEUE_SERIAL）的，viewDidLoad() 是在主线程的调度队列 com.apple.main-thread (serial) 执行的。\n\n上面的例子主要是希望大家理解串行和并发的概念，同时要明白造成死锁的原因。而要解决死锁一般可以用 DISPATCH_QUEUE_CONCURRENT 或接下来我们要讲的 dispatch_async 来解决。\n\n通过对 dispatch_sync 的了解，我们可以利用 dispatch_async 很快的写出异步代码：\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建调度队列\nprint(\"Begin Async\")\n// 异步调用\ndispatch_async(queue) {\n    // Block1\n    print(\"Execute Block Task1\")   \n}\ndispatch_async(queue) {\n    // Block2\n    print(\"Execute Block Task2\")   \n}\nprint(\"After Async\")\n```\n\n这个例子的结果有好几种：\n\n```Swift\n// 结果1\nBegin Async\nAfter Async\nExecute Block Task1\nExEcute Block Task2\n```\n```Swift\n// 结果2\nBegin Async\nExecute Block Task1\nExEcute Block Task2\nAfter Async\n```\n\n上面只是列出来两种可能，但实际上还有其他的可能。当我们调用 dispatch_async 的时候，它总是会在 Block 任务被提交之后马上返回，而不会傻傻的等待 Block 任务执行完成。由于上面创建的是串行调度队列，所以我们可以保证 Block1 要比 Block2 优先执行，但是 After Async 就无法确定是在 Block1 的前后还是 Block2 的前后。\n\n如果我们把上面的 DISPATCH_QUEUE_SERIAL 改成 DISPATCH_QUEUE_CONCURRENT，那我们就无法确定 After Async、Block1 和 Block2 这三者的执行顺序了。\n\n我们刚才说到用 dispatch_async 可以解决死锁的问题，那它是怎么解决的呢？\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n// 异步调用\ndispatch_async(queue) {\n    // Block1\n    print(\"Begin Execute Block Task1\")\n    dispatch_async(queue) {\n        // Block2\n        print(\"Execute Block Task2\")   \n    }\n    print(\"End Execute Block Task1\")\n}\n```\n\n上面的例子会优先输出 Block1 的 *Begin Execute Block Task1* 之后，通过 dispatch_async 把 Block2 提交到串行队列里面，然后又马上返回到 Block1 去输出 *End Execute Block Task1*，这个时候的 Block1 就结束了，接下来就开始执行 Block2。所以上面的代码是不会造成死锁的，虽然上面的例子也是创建了一个串行调度队列，但是该调度队列只是保证了 Block1 要比 Block2 优先执行。\n\n### dispatch_once\n\n写过 Objective-C 的人都知道，dispatch_once 一般会被用来创建单例对象：\n\n```Swift\n@implementation Single\n+ (Single *)sharedInstance {\n    static Single * _single = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        _single = [[Single alloc] init];\n    });\n    return _single; \n}\n@end\n```\n\n这是由于 dispatch_once 是线程安全且只会执行一次，所以才会被用来作为单例的实现。这里需要注意的是 dispatch_once_t 必须是静态的或全局的才能保证 dispatch_once 的 Block 只会被执行一次，所以上面的代码用了 static 来修饰 dispatch_once_t。\n\n### dispatch_apply\n\n```Swift\npublic func dispatch_apply(iterations: Int, _ queue: dispatch_queue_t!, _ block: (Int) -> Void)\n```\n\n其中的 interations 是表明要执行多少次 block，block 中的 Int 是该 Block 被执行的序号。调用这个方法的时候要注意该方法跟 dispatch_sync 一样会阻塞当前线程，所以我们需要注意在主线程中调用该方法。\n\n### dispatch_after\n\n```Swift\npublic func dispatch_after(when: dispatch_time_t, _ queue: dispatch_queue_t, _ block: dispatch_block_t)\n```\n\n调用这个方法的时候需要注意的是 when 这个参数，你需要通过 dispatch_time 或 dispatch_walltime 来创建。并且该方法是异步执行的，并不会阻塞当前线程。\n\n一般的写法如下：\n\n```Swift\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(5 * NSEC_PER_SEC)), queue) {\n    print(\"5s \\(NSThread.currentThread())\")\n}\n```\n\n### dispatch_group_t\n\ndispatch_group_t 是用来做聚合同步的，它可以用来跟踪你提交的所有任务（即使是在不同的调度队列也可以）的完成状态。\n\n接下来我们来看看 dispatch group 的一些常见用法：\n\n```Swift\n// 创建 dispatch_group_t 对象\nlet group = dispatch_group_create()\n\n// 创建串行队列\nlet serialQueue = dispatch_queue_create(\"Serial Queue\", DISPATCH_QUEUE_SERIAL)\n\n// 提交两个 Block 任务到 serialQueue，同时关联 serialQueue 和 group 的关系\ndispatch_group_async(group, serialQueue) {\n    print(\"Execute Block1 within Serial Queue\")\n}\ndispatch_group_async(group, serialQueue) {\n    print(\"Execute Block2 within Serial Queue\")\n}\n\n// 创建并发队列，并提交 Block 任务，同时关联该并发队列和 group 的关系\ndispatch_group_async(group, dispatch_queue_create(\"Concurrent Queue\", DISPATCH_QUEUE_CONCURRENT)) {\n    print(\"Execute Block within Concurrent Queue\")\n}\n\n// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发\ndispatch_group_notify(group, dispatch_queue_create(\"Finished\")) {\n    print(\"Finished\")\n}\n```\n\n注意，关联到 group 的方法只有 dispatch_group_async 而没有 dispatch_group_sync。\n\n但是还有另外一种方法可以让我们关联一个普通的任务：\n\n```Swift\n// 创建 dispatch_group_t 对象\nlet group = dispatch_group_create()\n\n// 使用 dispatch_group_enter 和 dispatch_group_leave 的话，我们不需要调用\n// dispatch_group_async 也能关联一个任务到 group 上\ndispatch_group_enter(group)\nself.executeTask {\n    // 执行代码\n    \n    dispatch_group_leave(group)\n}\n\n// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发\ndispatch_group_notify(group, dispatch_queue_create(\"Finished\")) {\n    print(\"Finished\")\n}\n```\n\n使用 dispatch_group_enter 和 dispatch_group_leave 的时候，它们必须成双成对出现，否则 dispatch_group_notify 是不会被调用的。\n\n接下来我们还要了解一下 dispatch_group_wait：\n\n```Swift\npublic func dispatch_group_wait(group: dispatch_group_t, _ timeout: dispatch_time_t) -> Int\n```\n\ndispatch_group_wait 可以指定一个 timeout 的参数，当 group 的任务没有在规定的时间内完成，它会返回一个非零的值，当 group 的任务能够在规定的时间内完成就返回0。同时，大家要注意这个方法会挂起当前线程，所以在主线程的时候要慎重使用该方法。\n\n### dispatch_barrier_t\n\n我们先来试想一个场景，假如现在有多个线程要去读取一份文件的内容，同时又有其他线程想要去更新该文件的内容，那么就有可能会发生你读错文件内容的现象。这个时候我们可以把所有读写操作都放到我们之前学习的串行队列去执行，但是我们都知道同时有多个线程去读取一份文件内容是没有问题的。\n\n使用 dispatch barrier 可以解决上面的问题：\n\n```Swift\n// 创建操作文件的并发队列\nlet queue = dispatch_queue_create(\"File\", DISPATCH_QUEUE_CONCURRENT)\ndispatch_async(queue) {\n    // Read1\n}\ndispatch_async(queue) {\n    // Read2\n}\ndispatch_barrier_async(queue) {\n    // Write\n}\ndispatch_async(queue) {\n    // Read3\n}\n```\n\n通过 dispatch_barrier_async 或 dispatch_barrier_sync 提交的任务会等待当前队列里正在执行的任务执行完毕才会执行，并且其他还没有执行的任务都必须等待提交到 dispatch barrier 的任务执行完毕之后才会开始执行。所以上面的代码中，当 Write 任务被提交的时候，如果当前队列中只有 Read1 在执行，那么 Write 会等待 Read1 执行完成之后才会执行，Read2  和 Read3 都必须等待 Write 执行完之后才会执行。另外，上面的代码中创建的是并发队列，因为如果是串行队列的话就没有必要用 dispatch barrier 了。\n\n### dispatch_semaphore_t\n\ndispatch semaphore 是一个效率非常高的传统计数信号量，所以我们一般可以用这个来控制最大的并发数量。\n\n```Swift\n// 创建初始值为2的信号量，最大并发数量为2\nlet semaphore = dispatch_semaphore_create(2)\n// 创建并发队列\nlet queue = dispatch_queue_create(\"Semaphore\", DISPATCH_QUEUE_CONCURRENT)\n// 创建100个并发任务\nfor index in 1...100 {\n    // 这个方法会进行信号量减1的操作，并且如果信号量减1之后的结果小于0的话，该方法会造成线程的挂起直\n    // 到该信号量进行加1操作才会恢复，所以在主线程要注意该方法的使用。\n    // 注意：这个方法要放在 dispatch_async 外面，否则系统依旧会创建超过2个线程同时来处理该调度队列\n    // 的任务\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)\n    dispatch_async(queue) {\n        \n        // 释放资源，信号量增加1\n        dispatch_semaphore_signal(semaphore)\n    }\n}\n```\n\n## 其他\n\nGCD 在 Swift3 的语法跟现在的语法不太一样了，有兴趣的可以自行去了解。在未来可能会考虑把本文章的代码都用 Swift3 的语法来重新写一下。\n\n\n\n\n","slug":"初步了解GCD","published":1,"updated":"2023-01-07T05:42:02.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldr5xjcm001ajbseeq1vae8c","content":"<h2 id=\"GCD-简介\"><a href=\"#GCD-简介\" class=\"headerlink\" title=\"GCD 简介\"></a>GCD 简介</h2><p>GCD(Grand Central Dispatch) 是苹果提供的一套多线程编程技术。想象一下，如果让你编写一个可以高效的跑在不同计算机、不同内核的应用程序，你会怎么做呢？你要看看硬件是什么，看看有有多少个内核，想想用什么算法，想想在什么时候去切换线程…总之，你要做的东西多了去了。而 GCD 帮我们屏蔽了这些技术细节，但是如果要用好 GCD 的话，还是要多了解一些知识点。</p>\n<h2 id=\"Dispatch-对象和内存管理\"><a href=\"#Dispatch-对象和内存管理\" class=\"headerlink\" title=\"Dispatch 对象和内存管理\"></a>Dispatch 对象和内存管理</h2><p>在 Objective-C 里面，所有的 dispatch 对象都是 Objective-C 对象，所以他们同样适用引用技术的内存管理。如果你是使用 ARC 的话，dispatch 对象会向普通的 Objective-C 对象一样自动进行 retain 和 release 操作；如果你是使用 MRC，要记住使用 dispatch_retain 和 dispatch_release 来进行管理。</p>\n<h2 id=\"常用-API\"><a href=\"#常用-API\" class=\"headerlink\" title=\"常用 API\"></a>常用 API</h2><h3 id=\"dispatch-queue-t（调度队列）\"><a href=\"#dispatch-queue-t（调度队列）\" class=\"headerlink\" title=\"dispatch_queue_t（调度队列）\"></a>dispatch_queue_t（调度队列）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_queue_create</span>(<span class=\"params\">label</span>: <span class=\"type\">UnsafePointer</span>&lt;<span class=\"type\">Int8</span>&gt;, <span class=\"keyword\">_</span> <span class=\"params\">attr</span>: dispatch_queue_attr_t<span class=\"operator\">!</span>) -&gt; dispatch_queue_t<span class=\"operator\">!</span></span><br></pre></td></tr></table></figure>\n\n<p>在 GCD 中只能通过上面的 API 来创建调度队列，我们可以通过创建各种各样的 Block 形式的任务并由该调度队列来决定如何去执行这些 Block 任务。上面创建调度队列的函数需要两个参数：</p>\n<ul>\n<li>label: 这个参数是用来给你创建的调度队列进行命名的，特别是在调试的时候你可以通过该参数来判断是哪个调度队列的任务在执行。</li>\n<li>attr: 这个参数只有 DISPATCH_QUEUE_SERIAL 和 DISPATCH_QUEUE_CONCURRENT 两种值（在 Objective-C 中这个参数可以为 NULL，这个时候默认是 DISPATCH_QUEUE_SERIAL）。DISPATCH_QUEUE_SERIAL 是告诉调度队列以串行的方式去执行任务，DISPATCH_QUEUE_CONCURRENT 是告诉调度队列以并发的方式去执行任务。</li>\n</ul>\n<p>当然我们还可以通过下面的方法来获取系统已经创建好的调度队列：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取全局队列</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_get_global_queue</span>(<span class=\"params\">identifier</span>: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> <span class=\"params\">flags</span>: <span class=\"type\">UInt</span>) -&gt; dispatch_queue_t<span class=\"operator\">!</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取主线程的com.apple.main-thread (serial)队列</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_get_main_queue</span>() -&gt; dispatch_queue_t<span class=\"operator\">!</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，所有 pending 状态的 Block 任务都会持有该调度队列的引用，所以我们不需要显示的去持有调度队列，而调度队列会在所有的 Block 任务都从 pending 变为 finished 之后才会被释放。</p>\n<p>总之，现在大家要知道的是我们可以把不同的 Block任务提交到调度队列，具体的细节和实现看看后面内容。</p>\n<h3 id=\"dispatch-sync-和-dispatch-async（同步和异步）\"><a href=\"#dispatch-sync-和-dispatch-async（同步和异步）\" class=\"headerlink\" title=\"dispatch_sync 和 dispatch_async（同步和异步）\"></a>dispatch_sync 和 dispatch_async（同步和异步）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建调度队列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Sync&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block任务</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task1&quot;</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block任务</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;After Sync&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的输出结果如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Sync</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Sync</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的例子就是我们平常对 dispatch_sync 的用法，并且我们可以看到第一个 Block 任务执行之后才会执行第二个 Block 任务。dispatch_sync 需要等待 Block的任务执行完成之后，才能继续往后执行。但是使用 dispatch_sync 的时候，有几点是需要注意的：</p>\n<ol>\n<li><p>当调用 dispatch_sync 方法的时候，系统默认情况下会在当前线程去执行调度队列里的任务，只有在一些特殊情况下才会把调度队列的任务分配到其他线程去执行。所以我们就知道，线程和调度队列并不是一对一的关系。至于为什么默认情况下会在当前线程去执行调度队列里的任务，我的猜测是为了性能。大家想一想，dispatch_sync 会同步执行 Block任务， Block任务没有结束的情况下，后面的代码是无法执行的。基于这样一个同步的机制，GCD 还有必要先把当前线程挂起，然后去创建新线程，然后切换到新的线程去执行调度队列里的任务，然后再把线程切换到当前线程，然后再让当前线程恢复么？结论是没有必要。</p>\n</li>\n<li><p>你不能够在当前的串行调度队列的任务里面去添加新的任务到当前的调度队列里面，否则会造成死锁。这句话怎么理解呢，我们来来看看下面的例子：</p>\n</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Execute Block Task1&quot;</span>)</span><br><span class=\"line\">    dispatch_sync(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Execute Block Task1&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例1的结果</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n<p>为什么 Block1 后面的 print 和 Block2 的 print 都不执行了呢？首先我们要知道被 DISPATCH_QUEUE_SERIAL 声明的调度队列是串行调度队列，串行调度队列里的任务是同时只能有一个任务在执行，并且当前任务没有执行完成，下一个任务也无法执行。上面的例子中会先输出 Block1 中的 <em>Begin Execute Block Task1</em>，然后这个时候再把 Block2 添加到同一个串行调度队列中去。这个时候的 Block1 还没有执行完成，它需要等 dispatch_sync 的 Block2 执行完成之后才能继续执行，而 Block2 又必须等待 Block1 执行完成之后才能执行，所以这个时候就造成 Block1 等着 Block2，Block2 等着 Block1 的死锁。</p>\n<p>我们再把调度队列属性改为 DISPAT_QUEUE_CONCURRENT，然后再看看执行结果是什么：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Execute Block Task1&quot;</span>)</span><br><span class=\"line\">    dispatch_sync(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Execute Block Task1&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2的结果</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">End</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br></pre></td></tr></table></figure>\n\n<p>被 DISPATCH_QUEUE_CONCURRENT 声明的并发调度队列就没有这种死锁的问题。并发调度队列里的任务是不会霸占资源不放的，每一个任务执行一个时间片段之后会把资源交出来给别的任务去执行。所以例2中的 Block1 虽然需要等待 Block2 执行完成之后才能继续执行，但是当 Block1 在等待的过程中，是可以把资源释放出来交给 Block2 去执行，Block2 执行完成之后 Block1 就可以继续执行了。所以，这个时候就不会造成死锁来。</p>\n<p>再来看看下面的例子会不会造成死锁：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">viewDidLoad</span>() &#123;</span><br><span class=\"line\">    dispatch_sync(dispatch_get_main_queue()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Excute Block Task&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案是会的。给大家一点提示，主线程的默认调度队列是串行（DISPATCH_QUEUE_SERIAL）的，viewDidLoad() 是在主线程的调度队列 com.apple.main-thread (serial) 执行的。</p>\n<p>上面的例子主要是希望大家理解串行和并发的概念，同时要明白造成死锁的原因。而要解决死锁一般可以用 DISPATCH_QUEUE_CONCURRENT 或接下来我们要讲的 dispatch_async 来解决。</p>\n<p>通过对 dispatch_sync 的了解，我们可以利用 dispatch_async 很快的写出异步代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建调度队列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Async&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 异步调用</span></span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task1&quot;</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block2</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;After Async&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这个例子的结果有好几种：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结果1</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">ExEcute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结果2</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">ExEcute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Async</span></span><br></pre></td></tr></table></figure>\n\n<p>上面只是列出来两种可能，但实际上还有其他的可能。当我们调用 dispatch_async 的时候，它总是会在 Block 任务被提交之后马上返回，而不会傻傻的等待 Block 任务执行完成。由于上面创建的是串行调度队列，所以我们可以保证 Block1 要比 Block2 优先执行，但是 After Async 就无法确定是在 Block1 的前后还是 Block2 的前后。</p>\n<p>如果我们把上面的 DISPATCH_QUEUE_SERIAL 改成 DISPATCH_QUEUE_CONCURRENT，那我们就无法确定 After Async、Block1 和 Block2 这三者的执行顺序了。</p>\n<p>我们刚才说到用 dispatch_async 可以解决死锁的问题，那它是怎么解决的呢？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 异步调用</span></span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Execute Block Task1&quot;</span>)</span><br><span class=\"line\">    dispatch_async(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Execute Block Task1&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子会优先输出 Block1 的 <em>Begin Execute Block Task1</em> 之后，通过 dispatch_async 把 Block2 提交到串行队列里面，然后又马上返回到 Block1 去输出 <em>End Execute Block Task1</em>，这个时候的 Block1 就结束了，接下来就开始执行 Block2。所以上面的代码是不会造成死锁的，虽然上面的例子也是创建了一个串行调度队列，但是该调度队列只是保证了 Block1 要比 Block2 优先执行。</p>\n<h3 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h3><p>写过 Objective-C 的人都知道，dispatch_once 一般会被用来创建单例对象：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@implementation</span> <span class=\"type\">Single</span></span><br><span class=\"line\"><span class=\"operator\">+</span> (<span class=\"type\">Single</span> <span class=\"operator\">*</span>)sharedInstance &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">Single</span> <span class=\"operator\">*</span> _single <span class=\"operator\">=</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(<span class=\"operator\">&amp;</span>onceToken, <span class=\"operator\">^</span>&#123;</span><br><span class=\"line\">        _single <span class=\"operator\">=</span> [[<span class=\"type\">Single</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _single; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>这是由于 dispatch_once 是线程安全且只会执行一次，所以才会被用来作为单例的实现。这里需要注意的是 dispatch_once_t 必须是静态的或全局的才能保证 dispatch_once 的 Block 只会被执行一次，所以上面的代码用了 static 来修饰 dispatch_once_t。</p>\n<h3 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_apply</span>(<span class=\"params\">iterations</span>: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> <span class=\"params\">queue</span>: dispatch_queue_t<span class=\"operator\">!</span>, <span class=\"keyword\">_</span> <span class=\"params\">block</span>: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Void</span>)</span><br></pre></td></tr></table></figure>\n\n<p>其中的 interations 是表明要执行多少次 block，block 中的 Int 是该 Block 被执行的序号。调用这个方法的时候要注意该方法跟 dispatch_sync 一样会阻塞当前线程，所以我们需要注意在主线程中调用该方法。</p>\n<h3 id=\"dispatch-after\"><a href=\"#dispatch-after\" class=\"headerlink\" title=\"dispatch_after\"></a>dispatch_after</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_after</span>(<span class=\"params\">when</span>: dispatch_time_t, <span class=\"keyword\">_</span> <span class=\"params\">queue</span>: dispatch_queue_t, <span class=\"keyword\">_</span> <span class=\"params\">block</span>: dispatch_block_t)</span><br></pre></td></tr></table></figure>\n\n<p>调用这个方法的时候需要注意的是 when 这个参数，你需要通过 dispatch_time 或 dispatch_walltime 来创建。并且该方法是异步执行的，并不会阻塞当前线程。</p>\n<p>一般的写法如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_after(dispatch_time(<span class=\"type\">DISPATCH_TIME_NOW</span>, <span class=\"type\">Int64</span>(<span class=\"number\">5</span> <span class=\"operator\">*</span> <span class=\"type\">NSEC_PER_SEC</span>)), queue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;5s <span class=\"subst\">\\(NSThread.currentThread())</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dispatch-group-t\"><a href=\"#dispatch-group-t\" class=\"headerlink\" title=\"dispatch_group_t\"></a>dispatch_group_t</h3><p>dispatch_group_t 是用来做聚合同步的，它可以用来跟踪你提交的所有任务（即使是在不同的调度队列也可以）的完成状态。</p>\n<p>接下来我们来看看 dispatch group 的一些常见用法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 dispatch_group_t 对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> group <span class=\"operator\">=</span> dispatch_group_create()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建串行队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> serialQueue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;Serial Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提交两个 Block 任务到 serialQueue，同时关联 serialQueue 和 group 的关系</span></span><br><span class=\"line\">dispatch_group_async(group, serialQueue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block1 within Serial Queue&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_group_async(group, serialQueue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block2 within Serial Queue&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并发队列，并提交 Block 任务，同时关联该并发队列和 group 的关系</span></span><br><span class=\"line\">dispatch_group_async(group, dispatch_queue_create(<span class=\"string\">&quot;Concurrent Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block within Concurrent Queue&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发</span></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_queue_create(<span class=\"string\">&quot;Finished&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Finished&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，关联到 group 的方法只有 dispatch_group_async 而没有 dispatch_group_sync。</p>\n<p>但是还有另外一种方法可以让我们关联一个普通的任务：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 dispatch_group_t 对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> group <span class=\"operator\">=</span> dispatch_group_create()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 dispatch_group_enter 和 dispatch_group_leave 的话，我们不需要调用</span></span><br><span class=\"line\"><span class=\"comment\">// dispatch_group_async 也能关联一个任务到 group 上</span></span><br><span class=\"line\">dispatch_group_enter(group)</span><br><span class=\"line\"><span class=\"keyword\">self</span>.executeTask &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行代码</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_group_leave(group)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发</span></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_queue_create(<span class=\"string\">&quot;Finished&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Finished&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 dispatch_group_enter 和 dispatch_group_leave 的时候，它们必须成双成对出现，否则 dispatch_group_notify 是不会被调用的。</p>\n<p>接下来我们还要了解一下 dispatch_group_wait：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_group_wait</span>(<span class=\"params\">group</span>: dispatch_group_t, <span class=\"keyword\">_</span> <span class=\"params\">timeout</span>: dispatch_time_t) -&gt; <span class=\"type\">Int</span></span><br></pre></td></tr></table></figure>\n\n<p>dispatch_group_wait 可以指定一个 timeout 的参数，当 group 的任务没有在规定的时间内完成，它会返回一个非零的值，当 group 的任务能够在规定的时间内完成就返回0。同时，大家要注意这个方法会挂起当前线程，所以在主线程的时候要慎重使用该方法。</p>\n<h3 id=\"dispatch-barrier-t\"><a href=\"#dispatch-barrier-t\" class=\"headerlink\" title=\"dispatch_barrier_t\"></a>dispatch_barrier_t</h3><p>我们先来试想一个场景，假如现在有多个线程要去读取一份文件的内容，同时又有其他线程想要去更新该文件的内容，那么就有可能会发生你读错文件内容的现象。这个时候我们可以把所有读写操作都放到我们之前学习的串行队列去执行，但是我们都知道同时有多个线程去读取一份文件内容是没有问题的。</p>\n<p>使用 dispatch barrier 可以解决上面的问题：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建操作文件的并发队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;File&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_barrier_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Write</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过 dispatch_barrier_async 或 dispatch_barrier_sync 提交的任务会等待当前队列里正在执行的任务执行完毕才会执行，并且其他还没有执行的任务都必须等待提交到 dispatch barrier 的任务执行完毕之后才会开始执行。所以上面的代码中，当 Write 任务被提交的时候，如果当前队列中只有 Read1 在执行，那么 Write 会等待 Read1 执行完成之后才会执行，Read2  和 Read3 都必须等待 Write 执行完之后才会执行。另外，上面的代码中创建的是并发队列，因为如果是串行队列的话就没有必要用 dispatch barrier 了。</p>\n<h3 id=\"dispatch-semaphore-t\"><a href=\"#dispatch-semaphore-t\" class=\"headerlink\" title=\"dispatch_semaphore_t\"></a>dispatch_semaphore_t</h3><p>dispatch semaphore 是一个效率非常高的传统计数信号量，所以我们一般可以用这个来控制最大的并发数量。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建初始值为2的信号量，最大并发数量为2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> semaphore <span class=\"operator\">=</span> dispatch_semaphore_create(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建并发队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;Semaphore&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建100个并发任务</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> <span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">100</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个方法会进行信号量减1的操作，并且如果信号量减1之后的结果小于0的话，该方法会造成线程的挂起直</span></span><br><span class=\"line\">    <span class=\"comment\">// 到该信号量进行加1操作才会恢复，所以在主线程要注意该方法的使用。</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意：这个方法要放在 dispatch_async 外面，否则系统依旧会创建超过2个线程同时来处理该调度队列</span></span><br><span class=\"line\">    <span class=\"comment\">// 的任务</span></span><br><span class=\"line\">    dispatch_semaphore_wait(semaphore, <span class=\"type\">DISPATCH_TIME_FOREVER</span>)</span><br><span class=\"line\">    dispatch_async(queue) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 释放资源，信号量增加1</span></span><br><span class=\"line\">        dispatch_semaphore_signal(semaphore)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>GCD 在 Swift3 的语法跟现在的语法不太一样了，有兴趣的可以自行去了解。在未来可能会考虑把本文章的代码都用 Swift3 的语法来重新写一下。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"GCD-简介\"><a href=\"#GCD-简介\" class=\"headerlink\" title=\"GCD 简介\"></a>GCD 简介</h2><p>GCD(Grand Central Dispatch) 是苹果提供的一套多线程编程技术。想象一下，如果让你编写一个可以高效的跑在不同计算机、不同内核的应用程序，你会怎么做呢？你要看看硬件是什么，看看有有多少个内核，想想用什么算法，想想在什么时候去切换线程…总之，你要做的东西多了去了。而 GCD 帮我们屏蔽了这些技术细节，但是如果要用好 GCD 的话，还是要多了解一些知识点。</p>\n<h2 id=\"Dispatch-对象和内存管理\"><a href=\"#Dispatch-对象和内存管理\" class=\"headerlink\" title=\"Dispatch 对象和内存管理\"></a>Dispatch 对象和内存管理</h2><p>在 Objective-C 里面，所有的 dispatch 对象都是 Objective-C 对象，所以他们同样适用引用技术的内存管理。如果你是使用 ARC 的话，dispatch 对象会向普通的 Objective-C 对象一样自动进行 retain 和 release 操作；如果你是使用 MRC，要记住使用 dispatch_retain 和 dispatch_release 来进行管理。</p>\n<h2 id=\"常用-API\"><a href=\"#常用-API\" class=\"headerlink\" title=\"常用 API\"></a>常用 API</h2><h3 id=\"dispatch-queue-t（调度队列）\"><a href=\"#dispatch-queue-t（调度队列）\" class=\"headerlink\" title=\"dispatch_queue_t（调度队列）\"></a>dispatch_queue_t（调度队列）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_queue_create</span>(<span class=\"params\">label</span>: <span class=\"type\">UnsafePointer</span>&lt;<span class=\"type\">Int8</span>&gt;, <span class=\"keyword\">_</span> <span class=\"params\">attr</span>: dispatch_queue_attr_t<span class=\"operator\">!</span>) -&gt; dispatch_queue_t<span class=\"operator\">!</span></span><br></pre></td></tr></table></figure>\n\n<p>在 GCD 中只能通过上面的 API 来创建调度队列，我们可以通过创建各种各样的 Block 形式的任务并由该调度队列来决定如何去执行这些 Block 任务。上面创建调度队列的函数需要两个参数：</p>\n<ul>\n<li>label: 这个参数是用来给你创建的调度队列进行命名的，特别是在调试的时候你可以通过该参数来判断是哪个调度队列的任务在执行。</li>\n<li>attr: 这个参数只有 DISPATCH_QUEUE_SERIAL 和 DISPATCH_QUEUE_CONCURRENT 两种值（在 Objective-C 中这个参数可以为 NULL，这个时候默认是 DISPATCH_QUEUE_SERIAL）。DISPATCH_QUEUE_SERIAL 是告诉调度队列以串行的方式去执行任务，DISPATCH_QUEUE_CONCURRENT 是告诉调度队列以并发的方式去执行任务。</li>\n</ul>\n<p>当然我们还可以通过下面的方法来获取系统已经创建好的调度队列：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取全局队列</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_get_global_queue</span>(<span class=\"params\">identifier</span>: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> <span class=\"params\">flags</span>: <span class=\"type\">UInt</span>) -&gt; dispatch_queue_t<span class=\"operator\">!</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取主线程的com.apple.main-thread (serial)队列</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_get_main_queue</span>() -&gt; dispatch_queue_t<span class=\"operator\">!</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，所有 pending 状态的 Block 任务都会持有该调度队列的引用，所以我们不需要显示的去持有调度队列，而调度队列会在所有的 Block 任务都从 pending 变为 finished 之后才会被释放。</p>\n<p>总之，现在大家要知道的是我们可以把不同的 Block任务提交到调度队列，具体的细节和实现看看后面内容。</p>\n<h3 id=\"dispatch-sync-和-dispatch-async（同步和异步）\"><a href=\"#dispatch-sync-和-dispatch-async（同步和异步）\" class=\"headerlink\" title=\"dispatch_sync 和 dispatch_async（同步和异步）\"></a>dispatch_sync 和 dispatch_async（同步和异步）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建调度队列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Sync&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block任务</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task1&quot;</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block任务</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;After Sync&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的输出结果如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Sync</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Sync</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的例子就是我们平常对 dispatch_sync 的用法，并且我们可以看到第一个 Block 任务执行之后才会执行第二个 Block 任务。dispatch_sync 需要等待 Block的任务执行完成之后，才能继续往后执行。但是使用 dispatch_sync 的时候，有几点是需要注意的：</p>\n<ol>\n<li><p>当调用 dispatch_sync 方法的时候，系统默认情况下会在当前线程去执行调度队列里的任务，只有在一些特殊情况下才会把调度队列的任务分配到其他线程去执行。所以我们就知道，线程和调度队列并不是一对一的关系。至于为什么默认情况下会在当前线程去执行调度队列里的任务，我的猜测是为了性能。大家想一想，dispatch_sync 会同步执行 Block任务， Block任务没有结束的情况下，后面的代码是无法执行的。基于这样一个同步的机制，GCD 还有必要先把当前线程挂起，然后去创建新线程，然后切换到新的线程去执行调度队列里的任务，然后再把线程切换到当前线程，然后再让当前线程恢复么？结论是没有必要。</p>\n</li>\n<li><p>你不能够在当前的串行调度队列的任务里面去添加新的任务到当前的调度队列里面，否则会造成死锁。这句话怎么理解呢，我们来来看看下面的例子：</p>\n</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Execute Block Task1&quot;</span>)</span><br><span class=\"line\">    dispatch_sync(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Execute Block Task1&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例1的结果</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n<p>为什么 Block1 后面的 print 和 Block2 的 print 都不执行了呢？首先我们要知道被 DISPATCH_QUEUE_SERIAL 声明的调度队列是串行调度队列，串行调度队列里的任务是同时只能有一个任务在执行，并且当前任务没有执行完成，下一个任务也无法执行。上面的例子中会先输出 Block1 中的 <em>Begin Execute Block Task1</em>，然后这个时候再把 Block2 添加到同一个串行调度队列中去。这个时候的 Block1 还没有执行完成，它需要等 dispatch_sync 的 Block2 执行完成之后才能继续执行，而 Block2 又必须等待 Block1 执行完成之后才能执行，所以这个时候就造成 Block1 等着 Block2，Block2 等着 Block1 的死锁。</p>\n<p>我们再把调度队列属性改为 DISPAT_QUEUE_CONCURRENT，然后再看看执行结果是什么：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Execute Block Task1&quot;</span>)</span><br><span class=\"line\">    dispatch_sync(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Execute Block Task1&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2的结果</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">End</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br></pre></td></tr></table></figure>\n\n<p>被 DISPATCH_QUEUE_CONCURRENT 声明的并发调度队列就没有这种死锁的问题。并发调度队列里的任务是不会霸占资源不放的，每一个任务执行一个时间片段之后会把资源交出来给别的任务去执行。所以例2中的 Block1 虽然需要等待 Block2 执行完成之后才能继续执行，但是当 Block1 在等待的过程中，是可以把资源释放出来交给 Block2 去执行，Block2 执行完成之后 Block1 就可以继续执行了。所以，这个时候就不会造成死锁来。</p>\n<p>再来看看下面的例子会不会造成死锁：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">viewDidLoad</span>() &#123;</span><br><span class=\"line\">    dispatch_sync(dispatch_get_main_queue()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Excute Block Task&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案是会的。给大家一点提示，主线程的默认调度队列是串行（DISPATCH_QUEUE_SERIAL）的，viewDidLoad() 是在主线程的调度队列 com.apple.main-thread (serial) 执行的。</p>\n<p>上面的例子主要是希望大家理解串行和并发的概念，同时要明白造成死锁的原因。而要解决死锁一般可以用 DISPATCH_QUEUE_CONCURRENT 或接下来我们要讲的 dispatch_async 来解决。</p>\n<p>通过对 dispatch_sync 的了解，我们可以利用 dispatch_async 很快的写出异步代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建调度队列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Async&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 异步调用</span></span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task1&quot;</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block2</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;After Async&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这个例子的结果有好几种：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结果1</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">ExEcute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结果2</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">ExEcute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Async</span></span><br></pre></td></tr></table></figure>\n\n<p>上面只是列出来两种可能，但实际上还有其他的可能。当我们调用 dispatch_async 的时候，它总是会在 Block 任务被提交之后马上返回，而不会傻傻的等待 Block 任务执行完成。由于上面创建的是串行调度队列，所以我们可以保证 Block1 要比 Block2 优先执行，但是 After Async 就无法确定是在 Block1 的前后还是 Block2 的前后。</p>\n<p>如果我们把上面的 DISPATCH_QUEUE_SERIAL 改成 DISPATCH_QUEUE_CONCURRENT，那我们就无法确定 After Async、Block1 和 Block2 这三者的执行顺序了。</p>\n<p>我们刚才说到用 dispatch_async 可以解决死锁的问题，那它是怎么解决的呢？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;com.PS.Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 异步调用</span></span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Begin Execute Block Task1&quot;</span>)</span><br><span class=\"line\">    dispatch_async(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block Task2&quot;</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;End Execute Block Task1&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子会优先输出 Block1 的 <em>Begin Execute Block Task1</em> 之后，通过 dispatch_async 把 Block2 提交到串行队列里面，然后又马上返回到 Block1 去输出 <em>End Execute Block Task1</em>，这个时候的 Block1 就结束了，接下来就开始执行 Block2。所以上面的代码是不会造成死锁的，虽然上面的例子也是创建了一个串行调度队列，但是该调度队列只是保证了 Block1 要比 Block2 优先执行。</p>\n<h3 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h3><p>写过 Objective-C 的人都知道，dispatch_once 一般会被用来创建单例对象：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@implementation</span> <span class=\"type\">Single</span></span><br><span class=\"line\"><span class=\"operator\">+</span> (<span class=\"type\">Single</span> <span class=\"operator\">*</span>)sharedInstance &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">Single</span> <span class=\"operator\">*</span> _single <span class=\"operator\">=</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(<span class=\"operator\">&amp;</span>onceToken, <span class=\"operator\">^</span>&#123;</span><br><span class=\"line\">        _single <span class=\"operator\">=</span> [[<span class=\"type\">Single</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _single; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>这是由于 dispatch_once 是线程安全且只会执行一次，所以才会被用来作为单例的实现。这里需要注意的是 dispatch_once_t 必须是静态的或全局的才能保证 dispatch_once 的 Block 只会被执行一次，所以上面的代码用了 static 来修饰 dispatch_once_t。</p>\n<h3 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_apply</span>(<span class=\"params\">iterations</span>: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> <span class=\"params\">queue</span>: dispatch_queue_t<span class=\"operator\">!</span>, <span class=\"keyword\">_</span> <span class=\"params\">block</span>: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Void</span>)</span><br></pre></td></tr></table></figure>\n\n<p>其中的 interations 是表明要执行多少次 block，block 中的 Int 是该 Block 被执行的序号。调用这个方法的时候要注意该方法跟 dispatch_sync 一样会阻塞当前线程，所以我们需要注意在主线程中调用该方法。</p>\n<h3 id=\"dispatch-after\"><a href=\"#dispatch-after\" class=\"headerlink\" title=\"dispatch_after\"></a>dispatch_after</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_after</span>(<span class=\"params\">when</span>: dispatch_time_t, <span class=\"keyword\">_</span> <span class=\"params\">queue</span>: dispatch_queue_t, <span class=\"keyword\">_</span> <span class=\"params\">block</span>: dispatch_block_t)</span><br></pre></td></tr></table></figure>\n\n<p>调用这个方法的时候需要注意的是 when 这个参数，你需要通过 dispatch_time 或 dispatch_walltime 来创建。并且该方法是异步执行的，并不会阻塞当前线程。</p>\n<p>一般的写法如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_after(dispatch_time(<span class=\"type\">DISPATCH_TIME_NOW</span>, <span class=\"type\">Int64</span>(<span class=\"number\">5</span> <span class=\"operator\">*</span> <span class=\"type\">NSEC_PER_SEC</span>)), queue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;5s <span class=\"subst\">\\(NSThread.currentThread())</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dispatch-group-t\"><a href=\"#dispatch-group-t\" class=\"headerlink\" title=\"dispatch_group_t\"></a>dispatch_group_t</h3><p>dispatch_group_t 是用来做聚合同步的，它可以用来跟踪你提交的所有任务（即使是在不同的调度队列也可以）的完成状态。</p>\n<p>接下来我们来看看 dispatch group 的一些常见用法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 dispatch_group_t 对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> group <span class=\"operator\">=</span> dispatch_group_create()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建串行队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> serialQueue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;Serial Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提交两个 Block 任务到 serialQueue，同时关联 serialQueue 和 group 的关系</span></span><br><span class=\"line\">dispatch_group_async(group, serialQueue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block1 within Serial Queue&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_group_async(group, serialQueue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block2 within Serial Queue&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并发队列，并提交 Block 任务，同时关联该并发队列和 group 的关系</span></span><br><span class=\"line\">dispatch_group_async(group, dispatch_queue_create(<span class=\"string\">&quot;Concurrent Queue&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Execute Block within Concurrent Queue&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发</span></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_queue_create(<span class=\"string\">&quot;Finished&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Finished&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，关联到 group 的方法只有 dispatch_group_async 而没有 dispatch_group_sync。</p>\n<p>但是还有另外一种方法可以让我们关联一个普通的任务：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 dispatch_group_t 对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> group <span class=\"operator\">=</span> dispatch_group_create()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 dispatch_group_enter 和 dispatch_group_leave 的话，我们不需要调用</span></span><br><span class=\"line\"><span class=\"comment\">// dispatch_group_async 也能关联一个任务到 group 上</span></span><br><span class=\"line\">dispatch_group_enter(group)</span><br><span class=\"line\"><span class=\"keyword\">self</span>.executeTask &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行代码</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_group_leave(group)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发</span></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_queue_create(<span class=\"string\">&quot;Finished&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Finished&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 dispatch_group_enter 和 dispatch_group_leave 的时候，它们必须成双成对出现，否则 dispatch_group_notify 是不会被调用的。</p>\n<p>接下来我们还要了解一下 dispatch_group_wait：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">dispatch_group_wait</span>(<span class=\"params\">group</span>: dispatch_group_t, <span class=\"keyword\">_</span> <span class=\"params\">timeout</span>: dispatch_time_t) -&gt; <span class=\"type\">Int</span></span><br></pre></td></tr></table></figure>\n\n<p>dispatch_group_wait 可以指定一个 timeout 的参数，当 group 的任务没有在规定的时间内完成，它会返回一个非零的值，当 group 的任务能够在规定的时间内完成就返回0。同时，大家要注意这个方法会挂起当前线程，所以在主线程的时候要慎重使用该方法。</p>\n<h3 id=\"dispatch-barrier-t\"><a href=\"#dispatch-barrier-t\" class=\"headerlink\" title=\"dispatch_barrier_t\"></a>dispatch_barrier_t</h3><p>我们先来试想一个场景，假如现在有多个线程要去读取一份文件的内容，同时又有其他线程想要去更新该文件的内容，那么就有可能会发生你读错文件内容的现象。这个时候我们可以把所有读写操作都放到我们之前学习的串行队列去执行，但是我们都知道同时有多个线程去读取一份文件内容是没有问题的。</p>\n<p>使用 dispatch barrier 可以解决上面的问题：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建操作文件的并发队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;File&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_barrier_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Write</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过 dispatch_barrier_async 或 dispatch_barrier_sync 提交的任务会等待当前队列里正在执行的任务执行完毕才会执行，并且其他还没有执行的任务都必须等待提交到 dispatch barrier 的任务执行完毕之后才会开始执行。所以上面的代码中，当 Write 任务被提交的时候，如果当前队列中只有 Read1 在执行，那么 Write 会等待 Read1 执行完成之后才会执行，Read2  和 Read3 都必须等待 Write 执行完之后才会执行。另外，上面的代码中创建的是并发队列，因为如果是串行队列的话就没有必要用 dispatch barrier 了。</p>\n<h3 id=\"dispatch-semaphore-t\"><a href=\"#dispatch-semaphore-t\" class=\"headerlink\" title=\"dispatch_semaphore_t\"></a>dispatch_semaphore_t</h3><p>dispatch semaphore 是一个效率非常高的传统计数信号量，所以我们一般可以用这个来控制最大的并发数量。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建初始值为2的信号量，最大并发数量为2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> semaphore <span class=\"operator\">=</span> dispatch_semaphore_create(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建并发队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue <span class=\"operator\">=</span> dispatch_queue_create(<span class=\"string\">&quot;Semaphore&quot;</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建100个并发任务</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> <span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">100</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个方法会进行信号量减1的操作，并且如果信号量减1之后的结果小于0的话，该方法会造成线程的挂起直</span></span><br><span class=\"line\">    <span class=\"comment\">// 到该信号量进行加1操作才会恢复，所以在主线程要注意该方法的使用。</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意：这个方法要放在 dispatch_async 外面，否则系统依旧会创建超过2个线程同时来处理该调度队列</span></span><br><span class=\"line\">    <span class=\"comment\">// 的任务</span></span><br><span class=\"line\">    dispatch_semaphore_wait(semaphore, <span class=\"type\">DISPATCH_TIME_FOREVER</span>)</span><br><span class=\"line\">    dispatch_async(queue) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 释放资源，信号量增加1</span></span><br><span class=\"line\">        dispatch_semaphore_signal(semaphore)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>GCD 在 Swift3 的语法跟现在的语法不太一样了，有兴趣的可以自行去了解。在未来可能会考虑把本文章的代码都用 Swift3 的语法来重新写一下。</p>\n"},{"title":"如何在 iOS 上自定义 React Native Component","author":"帕帕","date":"2018-03-19T17:22:09.000Z","thumbnail":"https://images.unsplash.com/photo-1508921234172-b68ed335b3e6?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=92e40b3819e4c173debf1500f27c9b60&auto=format&fit=crop&w=160&q=60","_content":"\n当我们要在 iOS 端实现一个 React Native 可用的 Component，比如：\n\n```ReactNative\n<MapView onRegionChange={(event) => {}} zoomLevel={2} />\n```\n\n那么我们基本上就是要解决下面这三个问题：\n\n* 如何把 iOS 上的 UI 暴露给 React Native 端？\n* 如何在 React Native 给 iOS 的 UI 传值？\n* 如何在 React Native 中响应 iOS 的事件？\n\n> 这三个问题可以在[官方文档](https://facebook.github.io/react-native/docs/native-components-ios.html)找到答案。\n    \n## 如何把 iOS 上的 UI 暴露给 React Native 端\n\n首先你需要创建一个继承自 `RCTViewManager` 的子类：\n\n```iOS\n// RNTMapManager.m\n#import <MapKit/MapKit.h>\n#import <React/RCTViewManager.h>\n\n// 继承 RCTViewManager\n@interface RNTMapManager : RCTViewManager\n@end\n\n\n@implementation RNTMapManager\n\n// 调用 RCT_EXPORT_MODULE 暴露该类的名字给 React Native 使用。如果你想自定义\n// 暴露给 React Native 的名字时，你需要 RCT_EXPORT_MODULE(YOUR_CUSTOM_NAME)。\nRCT_EXPORT_MODULE()\n\n// 由于 RCTViewManager 是 NSObject，所以这里必须需要实现该方法来告诉\n// React Native 去使用哪个 UIView\n- (UIView *)view\n{\n  return [MKMapView new];\n}\n\n@end\n```\n\n这样我们就可以在 React Native 使用 MapView 了：\n\n```ReactNative\n// MapView.js\n\nimport { requireNativeComponent } from 'react-native';\n\n// requireNativeComponent 会自动把 iOS 上的 RNTMapManager 解析成 RNTMap。\n// 如果去掉 iOS 上的 Manager 后缀会有什么影响？嗯，没有任何影响。\nmodule.exports = requireNativeComponent('RNTMap', null);\n\n\n// MyApp.js\nimport MapView from './MapView.js';\n\n...\n\nrender() {\n  return <MapView />;\n}\n```\n\n## 如何在 React Native 给 iOS 的 UI 传值\n\n如果需要传值给 iOS 上的 UI，那么需要使用另外一个宏：\n\n```iOS\nRCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)\n```\n\n这时候就可以在 React Native 上使用了：\n\n```ReactNative\n<MapView zoomEnable={true} />\n```\n\n这里需要注意的是，`RCT_EXPORT_VIEW_PROPERTY` 所暴露的属性必须是之前我们说的 UIView（即继承于 `RCTViewManager` 并通过 `- (UIView *)view;` 返回的 View）已经存在的属性。\n\n除了上面的宏 `RCT_EXPORT_VIEW_PROPERTY` 可以暴露属性给 React Native 使用之外还有下面 5 种（这里先挖个坑，回头研究一下再说说下面五种的作用和区别）：\n\n* RCT_REMAP_VIEW_PROPERTY\n* RCT_CUSTOM_VIEW_PROPERTY\n* RCT_EXPORT_SHADOW_PROPERTY\n* RCT_REMAP_SHADOW_PROPERTY\n* RCT_CUSTOM_SHADOW_PROPERTY\n\n## 如何在 React Native 中响应 iOS 的事件\n\n要想在 React Native 中响应 iOS 的事件，只需要暴露用 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 定义的属性即可，代码如下：\n\n```iOS\n// RNTMapView.h\n#import <MapKit/MapKit.h>\n#import <React/RCTComponent.h>\n\n// 由于 MKMapView 没有任何 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的\n// 属性，所以这里需要定义 MKMapView 的子类 RNTMapView\n@interface RNTMapView: MKMapView\n\n// 需要暴露给 React Native 的事件属性\n@property (nonatomic, copy) RCTBubblingEventBlock onRegionChange;\n\n@end\n\n\n// RNTMapView.m\n#import \"RNTMapView.h\"\n\n@implementation RNTMapView\n\n@end\n```\n\n然后我们需要在 `RCTViewManager` 中暴露 `onRegionChange` 给 React Native 使用：\n\n```iOS\n// RNTMapManager.m\n#import <MapKit/MapKit.h>\n#import <React/RCTViewManager.h>\n\n#import \"RNTMapView.h\"\n\n@interface RNTMapManager : RCTViewManager <MKMapViewDelegate>\n@end\n\n@implementation RNTMapManager\n\nRCT_EXPORT_MODULE()\n// 暴露 RNTMapView 中的 `onRegionChange` 属性\nRCT_EXPORT_VIEW_PROPERTY(onRegionChange, RCTBubblingEventBlock)\n\n- (UIView *)view {\n    // 这里需要返回 RNTMapView 而不是 MKMapView\n    return [RNTMapView new];\n}\n\n@end\n```\n\n> 重要的事说三遍：\n> 使用 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的事件都必须加上前缀 `on`，否则 React Native 无法接收到事件\n> 使用 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的事件都必须加上前缀 `on`，否则 React Native 无法接收到事件\n> 使用 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的事件都必须加上前缀 `on`，否则 React Native 无法接收到事件\n\n\n","source":"_posts/如何在-iOS-上自定义-React-Native-Component.md","raw":"---\ntitle: 如何在 iOS 上自定义 React Native Component\nauthor: 帕帕\ndate: 2018-03-19 17:22:09\ncategories: 技术\ntags: [iOS, RN]\nthumbnail: https://images.unsplash.com/photo-1508921234172-b68ed335b3e6?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=92e40b3819e4c173debf1500f27c9b60&auto=format&fit=crop&w=160&q=60\n---\n\n当我们要在 iOS 端实现一个 React Native 可用的 Component，比如：\n\n```ReactNative\n<MapView onRegionChange={(event) => {}} zoomLevel={2} />\n```\n\n那么我们基本上就是要解决下面这三个问题：\n\n* 如何把 iOS 上的 UI 暴露给 React Native 端？\n* 如何在 React Native 给 iOS 的 UI 传值？\n* 如何在 React Native 中响应 iOS 的事件？\n\n> 这三个问题可以在[官方文档](https://facebook.github.io/react-native/docs/native-components-ios.html)找到答案。\n    \n## 如何把 iOS 上的 UI 暴露给 React Native 端\n\n首先你需要创建一个继承自 `RCTViewManager` 的子类：\n\n```iOS\n// RNTMapManager.m\n#import <MapKit/MapKit.h>\n#import <React/RCTViewManager.h>\n\n// 继承 RCTViewManager\n@interface RNTMapManager : RCTViewManager\n@end\n\n\n@implementation RNTMapManager\n\n// 调用 RCT_EXPORT_MODULE 暴露该类的名字给 React Native 使用。如果你想自定义\n// 暴露给 React Native 的名字时，你需要 RCT_EXPORT_MODULE(YOUR_CUSTOM_NAME)。\nRCT_EXPORT_MODULE()\n\n// 由于 RCTViewManager 是 NSObject，所以这里必须需要实现该方法来告诉\n// React Native 去使用哪个 UIView\n- (UIView *)view\n{\n  return [MKMapView new];\n}\n\n@end\n```\n\n这样我们就可以在 React Native 使用 MapView 了：\n\n```ReactNative\n// MapView.js\n\nimport { requireNativeComponent } from 'react-native';\n\n// requireNativeComponent 会自动把 iOS 上的 RNTMapManager 解析成 RNTMap。\n// 如果去掉 iOS 上的 Manager 后缀会有什么影响？嗯，没有任何影响。\nmodule.exports = requireNativeComponent('RNTMap', null);\n\n\n// MyApp.js\nimport MapView from './MapView.js';\n\n...\n\nrender() {\n  return <MapView />;\n}\n```\n\n## 如何在 React Native 给 iOS 的 UI 传值\n\n如果需要传值给 iOS 上的 UI，那么需要使用另外一个宏：\n\n```iOS\nRCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)\n```\n\n这时候就可以在 React Native 上使用了：\n\n```ReactNative\n<MapView zoomEnable={true} />\n```\n\n这里需要注意的是，`RCT_EXPORT_VIEW_PROPERTY` 所暴露的属性必须是之前我们说的 UIView（即继承于 `RCTViewManager` 并通过 `- (UIView *)view;` 返回的 View）已经存在的属性。\n\n除了上面的宏 `RCT_EXPORT_VIEW_PROPERTY` 可以暴露属性给 React Native 使用之外还有下面 5 种（这里先挖个坑，回头研究一下再说说下面五种的作用和区别）：\n\n* RCT_REMAP_VIEW_PROPERTY\n* RCT_CUSTOM_VIEW_PROPERTY\n* RCT_EXPORT_SHADOW_PROPERTY\n* RCT_REMAP_SHADOW_PROPERTY\n* RCT_CUSTOM_SHADOW_PROPERTY\n\n## 如何在 React Native 中响应 iOS 的事件\n\n要想在 React Native 中响应 iOS 的事件，只需要暴露用 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 定义的属性即可，代码如下：\n\n```iOS\n// RNTMapView.h\n#import <MapKit/MapKit.h>\n#import <React/RCTComponent.h>\n\n// 由于 MKMapView 没有任何 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的\n// 属性，所以这里需要定义 MKMapView 的子类 RNTMapView\n@interface RNTMapView: MKMapView\n\n// 需要暴露给 React Native 的事件属性\n@property (nonatomic, copy) RCTBubblingEventBlock onRegionChange;\n\n@end\n\n\n// RNTMapView.m\n#import \"RNTMapView.h\"\n\n@implementation RNTMapView\n\n@end\n```\n\n然后我们需要在 `RCTViewManager` 中暴露 `onRegionChange` 给 React Native 使用：\n\n```iOS\n// RNTMapManager.m\n#import <MapKit/MapKit.h>\n#import <React/RCTViewManager.h>\n\n#import \"RNTMapView.h\"\n\n@interface RNTMapManager : RCTViewManager <MKMapViewDelegate>\n@end\n\n@implementation RNTMapManager\n\nRCT_EXPORT_MODULE()\n// 暴露 RNTMapView 中的 `onRegionChange` 属性\nRCT_EXPORT_VIEW_PROPERTY(onRegionChange, RCTBubblingEventBlock)\n\n- (UIView *)view {\n    // 这里需要返回 RNTMapView 而不是 MKMapView\n    return [RNTMapView new];\n}\n\n@end\n```\n\n> 重要的事说三遍：\n> 使用 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的事件都必须加上前缀 `on`，否则 React Native 无法接收到事件\n> 使用 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的事件都必须加上前缀 `on`，否则 React Native 无法接收到事件\n> 使用 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的事件都必须加上前缀 `on`，否则 React Native 无法接收到事件\n\n\n","slug":"如何在-iOS-上自定义-React-Native-Component","published":1,"updated":"2023-01-07T05:42:02.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldr5xjcn001ejbsehb4gg1w0","content":"<p>当我们要在 iOS 端实现一个 React Native 可用的 Component，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;MapView onRegionChange=&#123;(event) =&gt; &#123;&#125;&#125; zoomLevel=&#123;2&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>那么我们基本上就是要解决下面这三个问题：</p>\n<ul>\n<li>如何把 iOS 上的 UI 暴露给 React Native 端？</li>\n<li>如何在 React Native 给 iOS 的 UI 传值？</li>\n<li>如何在 React Native 中响应 iOS 的事件？</li>\n</ul>\n<blockquote>\n<p>这三个问题可以在<a href=\"https://facebook.github.io/react-native/docs/native-components-ios.html\">官方文档</a>找到答案。</p>\n</blockquote>\n<h2 id=\"如何把-iOS-上的-UI-暴露给-React-Native-端\"><a href=\"#如何把-iOS-上的-UI-暴露给-React-Native-端\" class=\"headerlink\" title=\"如何把 iOS 上的 UI 暴露给 React Native 端\"></a>如何把 iOS 上的 UI 暴露给 React Native 端</h2><p>首先你需要创建一个继承自 <code>RCTViewManager</code> 的子类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RNTMapManager.m</span><br><span class=\"line\">#import &lt;MapKit/MapKit.h&gt;</span><br><span class=\"line\">#import &lt;React/RCTViewManager.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 继承 RCTViewManager</span><br><span class=\"line\">@interface RNTMapManager : RCTViewManager</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@implementation RNTMapManager</span><br><span class=\"line\"></span><br><span class=\"line\">// 调用 RCT_EXPORT_MODULE 暴露该类的名字给 React Native 使用。如果你想自定义</span><br><span class=\"line\">// 暴露给 React Native 的名字时，你需要 RCT_EXPORT_MODULE(YOUR_CUSTOM_NAME)。</span><br><span class=\"line\">RCT_EXPORT_MODULE()</span><br><span class=\"line\"></span><br><span class=\"line\">// 由于 RCTViewManager 是 NSObject，所以这里必须需要实现该方法来告诉</span><br><span class=\"line\">// React Native 去使用哪个 UIView</span><br><span class=\"line\">- (UIView *)view</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return [MKMapView new];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就可以在 React Native 使用 MapView 了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// MapView.js</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; requireNativeComponent &#125; from &#x27;react-native&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">// requireNativeComponent 会自动把 iOS 上的 RNTMapManager 解析成 RNTMap。</span><br><span class=\"line\">// 如果去掉 iOS 上的 Manager 后缀会有什么影响？嗯，没有任何影响。</span><br><span class=\"line\">module.exports = requireNativeComponent(&#x27;RNTMap&#x27;, null);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// MyApp.js</span><br><span class=\"line\">import MapView from &#x27;./MapView.js&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">render() &#123;</span><br><span class=\"line\">  return &lt;MapView /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何在-React-Native-给-iOS-的-UI-传值\"><a href=\"#如何在-React-Native-给-iOS-的-UI-传值\" class=\"headerlink\" title=\"如何在 React Native 给 iOS 的 UI 传值\"></a>如何在 React Native 给 iOS 的 UI 传值</h2><p>如果需要传值给 iOS 上的 UI，那么需要使用另外一个宏：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)</span><br></pre></td></tr></table></figure>\n\n<p>这时候就可以在 React Native 上使用了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;MapView zoomEnable=&#123;true&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意的是，<code>RCT_EXPORT_VIEW_PROPERTY</code> 所暴露的属性必须是之前我们说的 UIView（即继承于 <code>RCTViewManager</code> 并通过 <code>- (UIView *)view;</code> 返回的 View）已经存在的属性。</p>\n<p>除了上面的宏 <code>RCT_EXPORT_VIEW_PROPERTY</code> 可以暴露属性给 React Native 使用之外还有下面 5 种（这里先挖个坑，回头研究一下再说说下面五种的作用和区别）：</p>\n<ul>\n<li>RCT_REMAP_VIEW_PROPERTY</li>\n<li>RCT_CUSTOM_VIEW_PROPERTY</li>\n<li>RCT_EXPORT_SHADOW_PROPERTY</li>\n<li>RCT_REMAP_SHADOW_PROPERTY</li>\n<li>RCT_CUSTOM_SHADOW_PROPERTY</li>\n</ul>\n<h2 id=\"如何在-React-Native-中响应-iOS-的事件\"><a href=\"#如何在-React-Native-中响应-iOS-的事件\" class=\"headerlink\" title=\"如何在 React Native 中响应 iOS 的事件\"></a>如何在 React Native 中响应 iOS 的事件</h2><p>要想在 React Native 中响应 iOS 的事件，只需要暴露用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 定义的属性即可，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RNTMapView.h</span><br><span class=\"line\">#import &lt;MapKit/MapKit.h&gt;</span><br><span class=\"line\">#import &lt;React/RCTComponent.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 由于 MKMapView 没有任何 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的</span><br><span class=\"line\">// 属性，所以这里需要定义 MKMapView 的子类 RNTMapView</span><br><span class=\"line\">@interface RNTMapView: MKMapView</span><br><span class=\"line\"></span><br><span class=\"line\">// 需要暴露给 React Native 的事件属性</span><br><span class=\"line\">@property (nonatomic, copy) RCTBubblingEventBlock onRegionChange;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// RNTMapView.m</span><br><span class=\"line\">#import &quot;RNTMapView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation RNTMapView</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>然后我们需要在 <code>RCTViewManager</code> 中暴露 <code>onRegionChange</code> 给 React Native 使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RNTMapManager.m</span><br><span class=\"line\">#import &lt;MapKit/MapKit.h&gt;</span><br><span class=\"line\">#import &lt;React/RCTViewManager.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;RNTMapView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface RNTMapManager : RCTViewManager &lt;MKMapViewDelegate&gt;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation RNTMapManager</span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_MODULE()</span><br><span class=\"line\">// 暴露 RNTMapView 中的 `onRegionChange` 属性</span><br><span class=\"line\">RCT_EXPORT_VIEW_PROPERTY(onRegionChange, RCTBubblingEventBlock)</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIView *)view &#123;</span><br><span class=\"line\">    // 这里需要返回 RNTMapView 而不是 MKMapView</span><br><span class=\"line\">    return [RNTMapView new];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>重要的事说三遍：<br>使用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 所定义的事件都必须加上前缀 <code>on</code>，否则 React Native 无法接收到事件<br>使用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 所定义的事件都必须加上前缀 <code>on</code>，否则 React Native 无法接收到事件<br>使用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 所定义的事件都必须加上前缀 <code>on</code>，否则 React Native 无法接收到事件</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>当我们要在 iOS 端实现一个 React Native 可用的 Component，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;MapView onRegionChange=&#123;(event) =&gt; &#123;&#125;&#125; zoomLevel=&#123;2&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>那么我们基本上就是要解决下面这三个问题：</p>\n<ul>\n<li>如何把 iOS 上的 UI 暴露给 React Native 端？</li>\n<li>如何在 React Native 给 iOS 的 UI 传值？</li>\n<li>如何在 React Native 中响应 iOS 的事件？</li>\n</ul>\n<blockquote>\n<p>这三个问题可以在<a href=\"https://facebook.github.io/react-native/docs/native-components-ios.html\">官方文档</a>找到答案。</p>\n</blockquote>\n<h2 id=\"如何把-iOS-上的-UI-暴露给-React-Native-端\"><a href=\"#如何把-iOS-上的-UI-暴露给-React-Native-端\" class=\"headerlink\" title=\"如何把 iOS 上的 UI 暴露给 React Native 端\"></a>如何把 iOS 上的 UI 暴露给 React Native 端</h2><p>首先你需要创建一个继承自 <code>RCTViewManager</code> 的子类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RNTMapManager.m</span><br><span class=\"line\">#import &lt;MapKit/MapKit.h&gt;</span><br><span class=\"line\">#import &lt;React/RCTViewManager.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 继承 RCTViewManager</span><br><span class=\"line\">@interface RNTMapManager : RCTViewManager</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@implementation RNTMapManager</span><br><span class=\"line\"></span><br><span class=\"line\">// 调用 RCT_EXPORT_MODULE 暴露该类的名字给 React Native 使用。如果你想自定义</span><br><span class=\"line\">// 暴露给 React Native 的名字时，你需要 RCT_EXPORT_MODULE(YOUR_CUSTOM_NAME)。</span><br><span class=\"line\">RCT_EXPORT_MODULE()</span><br><span class=\"line\"></span><br><span class=\"line\">// 由于 RCTViewManager 是 NSObject，所以这里必须需要实现该方法来告诉</span><br><span class=\"line\">// React Native 去使用哪个 UIView</span><br><span class=\"line\">- (UIView *)view</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return [MKMapView new];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就可以在 React Native 使用 MapView 了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// MapView.js</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; requireNativeComponent &#125; from &#x27;react-native&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">// requireNativeComponent 会自动把 iOS 上的 RNTMapManager 解析成 RNTMap。</span><br><span class=\"line\">// 如果去掉 iOS 上的 Manager 后缀会有什么影响？嗯，没有任何影响。</span><br><span class=\"line\">module.exports = requireNativeComponent(&#x27;RNTMap&#x27;, null);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// MyApp.js</span><br><span class=\"line\">import MapView from &#x27;./MapView.js&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">render() &#123;</span><br><span class=\"line\">  return &lt;MapView /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何在-React-Native-给-iOS-的-UI-传值\"><a href=\"#如何在-React-Native-给-iOS-的-UI-传值\" class=\"headerlink\" title=\"如何在 React Native 给 iOS 的 UI 传值\"></a>如何在 React Native 给 iOS 的 UI 传值</h2><p>如果需要传值给 iOS 上的 UI，那么需要使用另外一个宏：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)</span><br></pre></td></tr></table></figure>\n\n<p>这时候就可以在 React Native 上使用了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;MapView zoomEnable=&#123;true&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意的是，<code>RCT_EXPORT_VIEW_PROPERTY</code> 所暴露的属性必须是之前我们说的 UIView（即继承于 <code>RCTViewManager</code> 并通过 <code>- (UIView *)view;</code> 返回的 View）已经存在的属性。</p>\n<p>除了上面的宏 <code>RCT_EXPORT_VIEW_PROPERTY</code> 可以暴露属性给 React Native 使用之外还有下面 5 种（这里先挖个坑，回头研究一下再说说下面五种的作用和区别）：</p>\n<ul>\n<li>RCT_REMAP_VIEW_PROPERTY</li>\n<li>RCT_CUSTOM_VIEW_PROPERTY</li>\n<li>RCT_EXPORT_SHADOW_PROPERTY</li>\n<li>RCT_REMAP_SHADOW_PROPERTY</li>\n<li>RCT_CUSTOM_SHADOW_PROPERTY</li>\n</ul>\n<h2 id=\"如何在-React-Native-中响应-iOS-的事件\"><a href=\"#如何在-React-Native-中响应-iOS-的事件\" class=\"headerlink\" title=\"如何在 React Native 中响应 iOS 的事件\"></a>如何在 React Native 中响应 iOS 的事件</h2><p>要想在 React Native 中响应 iOS 的事件，只需要暴露用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 定义的属性即可，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RNTMapView.h</span><br><span class=\"line\">#import &lt;MapKit/MapKit.h&gt;</span><br><span class=\"line\">#import &lt;React/RCTComponent.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 由于 MKMapView 没有任何 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的</span><br><span class=\"line\">// 属性，所以这里需要定义 MKMapView 的子类 RNTMapView</span><br><span class=\"line\">@interface RNTMapView: MKMapView</span><br><span class=\"line\"></span><br><span class=\"line\">// 需要暴露给 React Native 的事件属性</span><br><span class=\"line\">@property (nonatomic, copy) RCTBubblingEventBlock onRegionChange;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// RNTMapView.m</span><br><span class=\"line\">#import &quot;RNTMapView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation RNTMapView</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>然后我们需要在 <code>RCTViewManager</code> 中暴露 <code>onRegionChange</code> 给 React Native 使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RNTMapManager.m</span><br><span class=\"line\">#import &lt;MapKit/MapKit.h&gt;</span><br><span class=\"line\">#import &lt;React/RCTViewManager.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;RNTMapView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface RNTMapManager : RCTViewManager &lt;MKMapViewDelegate&gt;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation RNTMapManager</span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_MODULE()</span><br><span class=\"line\">// 暴露 RNTMapView 中的 `onRegionChange` 属性</span><br><span class=\"line\">RCT_EXPORT_VIEW_PROPERTY(onRegionChange, RCTBubblingEventBlock)</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIView *)view &#123;</span><br><span class=\"line\">    // 这里需要返回 RNTMapView 而不是 MKMapView</span><br><span class=\"line\">    return [RNTMapView new];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>重要的事说三遍：<br>使用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 所定义的事件都必须加上前缀 <code>on</code>，否则 React Native 无法接收到事件<br>使用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 所定义的事件都必须加上前缀 <code>on</code>，否则 React Native 无法接收到事件<br>使用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 所定义的事件都必须加上前缀 <code>on</code>，否则 React Native 无法接收到事件</p>\n</blockquote>\n"},{"title":"如何用 Objective-C 实现一个死锁","date":"2018-04-01T20:29:42.000Z","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1509655172625-03265ba919a1?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=24b01fba0d86b9fa95814c692429379f&auto=format&fit=crop&w=160&q=100","_content":"\n> 当系统存在两个线程及以上的时候，双方都在等待对方停止执行，以获得系统资源，但是没有一方提前退出的时候就叫做死锁。\n\n\n那在 Objective-C 里面如何实现死锁呢：\n\n```Objective-C \nself.lock1 = [NSLock new];\nself.lock2 = [NSLock new];\n    \ndispatch_async(dispatch_queue_create(\"com.papa.task1\", DISPATCH_QUEUE_SERIAL), ^{\n    [self.lock1 lock];\n    NSLog(@\"task1 获得 lock1\");\n    sleep(2);\n    [self.lock2 lock];\n    NSLog(@\"task1 获得 lock2\");\n    [self.lock2 unlock];\n    [self.lock1 unlock];\n});\n\ndispatch_async(dispatch_queue_create(\"com.papa.task2\", DISPATCH_QUEUE_SERIAL), ^{\n    [self.lock2 lock];\n    NSLog(@\"task2 获得 lock2\");\n    sleep(2);\n    [self.lock1 lock];\n    NSLog(@\"task2 获得 lock1\");\n    [self.lock1 unlock];\n    [self.lock2 unlock];\n});\n```\n我们可以看到最后控制台输出的结果是：\n\n```\ntask2 获得 lock2\ntask1 获得 lock1\n```\n\n或\n\n```\ntask2 获得 lock2\ntask1 获得 lock1\n```\n\n为什么是两种结果呢，可以参考我的[「初步了解 GCD」](https://hparis.github.io/blog/2017/09/05/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3GCD/)。\n\n但是不管如何，这两种结果都没有输出 `task1 获得 lock2` 或 `task2 获得 lock1`。我们来分析一下：\n\n* task1 获得 lock1，然后沉睡 2s\n* task2 获得 lock2，然后沉睡 2s\n* task1 经过 2s 的沉睡之后想要去获取 lock2，此时发现 lock2 已经被使用，那就继续等待\n* task2 经过 2s 的沉睡之后想要去获取 lock1，此时发现 lock1 已经被使用，那就继续等待\n* task1 又被唤醒想要去获取 lock2，此时 lock2 依旧没有被 task2 释放，只能继续等待\n* task2 又被唤醒想要去获取 lock1，此时 lock1 依旧没有被 task1 释放，只能继续等待\n* ...\n* ...\n    \n于是 task1 和 task2 都在等待对方释放资源，但是自己也不退出也不释放资源，最终导致死锁的产生。\n\n\n接下来，我们来讨论另外一个例子是不是死锁：\n\n```Objective-C\n// 某个按钮的点击事件\n- (void)onClick:(UIEvent *)event {\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        ...    \n    });\n}\n```\n\n相信大家都知道上面这个例子会导致主线程发生阻塞的现象，但是这是因为死锁造成的么？\n\n> Submits a block to a dispatch queue for synchronous execution. Unlike dispatch_async, this function does not return until the block has finished. Calling this function and targeting the current queue results in deadlock.\n\n在官方文档里面明确的说了，这就是死锁。我们可以把上面的例子“翻译”一下：\n\n```Objective-C\n// 首先进入 onClick 的时候，我们可以认为此时是需要加锁的\n// 某个按钮的点击事件\n- (void)onClick:(UIEvent *)event {\n    [self.lock1 lock];\n    \n    // 此时我们可以认为 dispatch_sync 是在获取 block 里面的 lock2 \n    {\n        [self.lock2 lock];\n        \n        // 放在主线程执行，那么它也需要获得 lock1 \n        [self.lock1 lock];\n        [self.lock1 unlock];\n        \n        [self.lock2 unlock];\n    }\n    \n    [self.lock1 unlock];\n}\n```\n\n我们可以看到其实上面的情况就是两个任务都在同时竞争主线程的资源，并且谁都没有退出最终导致死锁的产生。但是这两个任务并不是普通的两个线程在竞争资源，而是都在主线程上，一个嵌套另外一个。而且这种特殊的情况，在运行的时候会直接导致奔溃，而不像我们一开始的例子一样只是在互相等待。但是既然苹果把这种情况也称为死锁，那我们就当做死锁来看待，毕竟他们都是在竞争系统资源。\n\n","source":"_posts/如何用-Objective-C-实现一个死锁.md","raw":"---\ntitle: 如何用 Objective-C 实现一个死锁\ndate: 2018-04-01 20:29:42 +0800\nauthor: 帕帕\ncategories: 技术\ntags: [iOS, Objective-C, GCD]\nthumbnail: https://images.unsplash.com/photo-1509655172625-03265ba919a1?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=24b01fba0d86b9fa95814c692429379f&auto=format&fit=crop&w=160&q=100\n---\n\n> 当系统存在两个线程及以上的时候，双方都在等待对方停止执行，以获得系统资源，但是没有一方提前退出的时候就叫做死锁。\n\n\n那在 Objective-C 里面如何实现死锁呢：\n\n```Objective-C \nself.lock1 = [NSLock new];\nself.lock2 = [NSLock new];\n    \ndispatch_async(dispatch_queue_create(\"com.papa.task1\", DISPATCH_QUEUE_SERIAL), ^{\n    [self.lock1 lock];\n    NSLog(@\"task1 获得 lock1\");\n    sleep(2);\n    [self.lock2 lock];\n    NSLog(@\"task1 获得 lock2\");\n    [self.lock2 unlock];\n    [self.lock1 unlock];\n});\n\ndispatch_async(dispatch_queue_create(\"com.papa.task2\", DISPATCH_QUEUE_SERIAL), ^{\n    [self.lock2 lock];\n    NSLog(@\"task2 获得 lock2\");\n    sleep(2);\n    [self.lock1 lock];\n    NSLog(@\"task2 获得 lock1\");\n    [self.lock1 unlock];\n    [self.lock2 unlock];\n});\n```\n我们可以看到最后控制台输出的结果是：\n\n```\ntask2 获得 lock2\ntask1 获得 lock1\n```\n\n或\n\n```\ntask2 获得 lock2\ntask1 获得 lock1\n```\n\n为什么是两种结果呢，可以参考我的[「初步了解 GCD」](https://hparis.github.io/blog/2017/09/05/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3GCD/)。\n\n但是不管如何，这两种结果都没有输出 `task1 获得 lock2` 或 `task2 获得 lock1`。我们来分析一下：\n\n* task1 获得 lock1，然后沉睡 2s\n* task2 获得 lock2，然后沉睡 2s\n* task1 经过 2s 的沉睡之后想要去获取 lock2，此时发现 lock2 已经被使用，那就继续等待\n* task2 经过 2s 的沉睡之后想要去获取 lock1，此时发现 lock1 已经被使用，那就继续等待\n* task1 又被唤醒想要去获取 lock2，此时 lock2 依旧没有被 task2 释放，只能继续等待\n* task2 又被唤醒想要去获取 lock1，此时 lock1 依旧没有被 task1 释放，只能继续等待\n* ...\n* ...\n    \n于是 task1 和 task2 都在等待对方释放资源，但是自己也不退出也不释放资源，最终导致死锁的产生。\n\n\n接下来，我们来讨论另外一个例子是不是死锁：\n\n```Objective-C\n// 某个按钮的点击事件\n- (void)onClick:(UIEvent *)event {\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        ...    \n    });\n}\n```\n\n相信大家都知道上面这个例子会导致主线程发生阻塞的现象，但是这是因为死锁造成的么？\n\n> Submits a block to a dispatch queue for synchronous execution. Unlike dispatch_async, this function does not return until the block has finished. Calling this function and targeting the current queue results in deadlock.\n\n在官方文档里面明确的说了，这就是死锁。我们可以把上面的例子“翻译”一下：\n\n```Objective-C\n// 首先进入 onClick 的时候，我们可以认为此时是需要加锁的\n// 某个按钮的点击事件\n- (void)onClick:(UIEvent *)event {\n    [self.lock1 lock];\n    \n    // 此时我们可以认为 dispatch_sync 是在获取 block 里面的 lock2 \n    {\n        [self.lock2 lock];\n        \n        // 放在主线程执行，那么它也需要获得 lock1 \n        [self.lock1 lock];\n        [self.lock1 unlock];\n        \n        [self.lock2 unlock];\n    }\n    \n    [self.lock1 unlock];\n}\n```\n\n我们可以看到其实上面的情况就是两个任务都在同时竞争主线程的资源，并且谁都没有退出最终导致死锁的产生。但是这两个任务并不是普通的两个线程在竞争资源，而是都在主线程上，一个嵌套另外一个。而且这种特殊的情况，在运行的时候会直接导致奔溃，而不像我们一开始的例子一样只是在互相等待。但是既然苹果把这种情况也称为死锁，那我们就当做死锁来看待，毕竟他们都是在竞争系统资源。\n\n","slug":"如何用-Objective-C-实现一个死锁","published":1,"updated":"2023-01-07T05:42:02.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldr5xjcn001hjbse9z066sex","content":"<blockquote>\n<p>当系统存在两个线程及以上的时候，双方都在等待对方停止执行，以获得系统资源，但是没有一方提前退出的时候就叫做死锁。</p>\n</blockquote>\n<p>那在 Objective-C 里面如何实现死锁呢：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.lock1 = [NSLock new];</span><br><span class=\"line\">self.lock2 = [NSLock new];</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_async(dispatch_queue_create(&quot;com.papa.task1&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class=\"line\">    [self.lock1 lock];</span><br><span class=\"line\">    NSLog(@&quot;task1 获得 lock1&quot;);</span><br><span class=\"line\">    sleep(2);</span><br><span class=\"line\">    [self.lock2 lock];</span><br><span class=\"line\">    NSLog(@&quot;task1 获得 lock2&quot;);</span><br><span class=\"line\">    [self.lock2 unlock];</span><br><span class=\"line\">    [self.lock1 unlock];</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(dispatch_queue_create(&quot;com.papa.task2&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class=\"line\">    [self.lock2 lock];</span><br><span class=\"line\">    NSLog(@&quot;task2 获得 lock2&quot;);</span><br><span class=\"line\">    sleep(2);</span><br><span class=\"line\">    [self.lock1 lock];</span><br><span class=\"line\">    NSLog(@&quot;task2 获得 lock1&quot;);</span><br><span class=\"line\">    [self.lock1 unlock];</span><br><span class=\"line\">    [self.lock2 unlock];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我们可以看到最后控制台输出的结果是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task2 获得 lock2</span><br><span class=\"line\">task1 获得 lock1</span><br></pre></td></tr></table></figure>\n\n<p>或</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task2 获得 lock2</span><br><span class=\"line\">task1 获得 lock1</span><br></pre></td></tr></table></figure>\n\n<p>为什么是两种结果呢，可以参考我的<a href=\"https://hparis.github.io/blog/2017/09/05/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3GCD/\">「初步了解 GCD」</a>。</p>\n<p>但是不管如何，这两种结果都没有输出 <code>task1 获得 lock2</code> 或 <code>task2 获得 lock1</code>。我们来分析一下：</p>\n<ul>\n<li>task1 获得 lock1，然后沉睡 2s</li>\n<li>task2 获得 lock2，然后沉睡 2s</li>\n<li>task1 经过 2s 的沉睡之后想要去获取 lock2，此时发现 lock2 已经被使用，那就继续等待</li>\n<li>task2 经过 2s 的沉睡之后想要去获取 lock1，此时发现 lock1 已经被使用，那就继续等待</li>\n<li>task1 又被唤醒想要去获取 lock2，此时 lock2 依旧没有被 task2 释放，只能继续等待</li>\n<li>task2 又被唤醒想要去获取 lock1，此时 lock1 依旧没有被 task1 释放，只能继续等待</li>\n<li>…</li>\n<li>…</li>\n</ul>\n<p>于是 task1 和 task2 都在等待对方释放资源，但是自己也不退出也不释放资源，最终导致死锁的产生。</p>\n<p>接下来，我们来讨论另外一个例子是不是死锁：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 某个按钮的点击事件</span><br><span class=\"line\">- (void)onClick:(UIEvent *)event &#123;</span><br><span class=\"line\">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        ...    </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相信大家都知道上面这个例子会导致主线程发生阻塞的现象，但是这是因为死锁造成的么？</p>\n<blockquote>\n<p>Submits a block to a dispatch queue for synchronous execution. Unlike dispatch_async, this function does not return until the block has finished. Calling this function and targeting the current queue results in deadlock.</p>\n</blockquote>\n<p>在官方文档里面明确的说了，这就是死锁。我们可以把上面的例子“翻译”一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 首先进入 onClick 的时候，我们可以认为此时是需要加锁的</span><br><span class=\"line\">// 某个按钮的点击事件</span><br><span class=\"line\">- (void)onClick:(UIEvent *)event &#123;</span><br><span class=\"line\">    [self.lock1 lock];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 此时我们可以认为 dispatch_sync 是在获取 block 里面的 lock2 </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [self.lock2 lock];</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 放在主线程执行，那么它也需要获得 lock1 </span><br><span class=\"line\">        [self.lock1 lock];</span><br><span class=\"line\">        [self.lock1 unlock];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [self.lock2 unlock];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [self.lock1 unlock];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到其实上面的情况就是两个任务都在同时竞争主线程的资源，并且谁都没有退出最终导致死锁的产生。但是这两个任务并不是普通的两个线程在竞争资源，而是都在主线程上，一个嵌套另外一个。而且这种特殊的情况，在运行的时候会直接导致奔溃，而不像我们一开始的例子一样只是在互相等待。但是既然苹果把这种情况也称为死锁，那我们就当做死锁来看待，毕竟他们都是在竞争系统资源。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>当系统存在两个线程及以上的时候，双方都在等待对方停止执行，以获得系统资源，但是没有一方提前退出的时候就叫做死锁。</p>\n</blockquote>\n<p>那在 Objective-C 里面如何实现死锁呢：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.lock1 = [NSLock new];</span><br><span class=\"line\">self.lock2 = [NSLock new];</span><br><span class=\"line\">    </span><br><span class=\"line\">dispatch_async(dispatch_queue_create(&quot;com.papa.task1&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class=\"line\">    [self.lock1 lock];</span><br><span class=\"line\">    NSLog(@&quot;task1 获得 lock1&quot;);</span><br><span class=\"line\">    sleep(2);</span><br><span class=\"line\">    [self.lock2 lock];</span><br><span class=\"line\">    NSLog(@&quot;task1 获得 lock2&quot;);</span><br><span class=\"line\">    [self.lock2 unlock];</span><br><span class=\"line\">    [self.lock1 unlock];</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(dispatch_queue_create(&quot;com.papa.task2&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class=\"line\">    [self.lock2 lock];</span><br><span class=\"line\">    NSLog(@&quot;task2 获得 lock2&quot;);</span><br><span class=\"line\">    sleep(2);</span><br><span class=\"line\">    [self.lock1 lock];</span><br><span class=\"line\">    NSLog(@&quot;task2 获得 lock1&quot;);</span><br><span class=\"line\">    [self.lock1 unlock];</span><br><span class=\"line\">    [self.lock2 unlock];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我们可以看到最后控制台输出的结果是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task2 获得 lock2</span><br><span class=\"line\">task1 获得 lock1</span><br></pre></td></tr></table></figure>\n\n<p>或</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task2 获得 lock2</span><br><span class=\"line\">task1 获得 lock1</span><br></pre></td></tr></table></figure>\n\n<p>为什么是两种结果呢，可以参考我的<a href=\"https://hparis.github.io/blog/2017/09/05/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3GCD/\">「初步了解 GCD」</a>。</p>\n<p>但是不管如何，这两种结果都没有输出 <code>task1 获得 lock2</code> 或 <code>task2 获得 lock1</code>。我们来分析一下：</p>\n<ul>\n<li>task1 获得 lock1，然后沉睡 2s</li>\n<li>task2 获得 lock2，然后沉睡 2s</li>\n<li>task1 经过 2s 的沉睡之后想要去获取 lock2，此时发现 lock2 已经被使用，那就继续等待</li>\n<li>task2 经过 2s 的沉睡之后想要去获取 lock1，此时发现 lock1 已经被使用，那就继续等待</li>\n<li>task1 又被唤醒想要去获取 lock2，此时 lock2 依旧没有被 task2 释放，只能继续等待</li>\n<li>task2 又被唤醒想要去获取 lock1，此时 lock1 依旧没有被 task1 释放，只能继续等待</li>\n<li>…</li>\n<li>…</li>\n</ul>\n<p>于是 task1 和 task2 都在等待对方释放资源，但是自己也不退出也不释放资源，最终导致死锁的产生。</p>\n<p>接下来，我们来讨论另外一个例子是不是死锁：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 某个按钮的点击事件</span><br><span class=\"line\">- (void)onClick:(UIEvent *)event &#123;</span><br><span class=\"line\">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        ...    </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相信大家都知道上面这个例子会导致主线程发生阻塞的现象，但是这是因为死锁造成的么？</p>\n<blockquote>\n<p>Submits a block to a dispatch queue for synchronous execution. Unlike dispatch_async, this function does not return until the block has finished. Calling this function and targeting the current queue results in deadlock.</p>\n</blockquote>\n<p>在官方文档里面明确的说了，这就是死锁。我们可以把上面的例子“翻译”一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 首先进入 onClick 的时候，我们可以认为此时是需要加锁的</span><br><span class=\"line\">// 某个按钮的点击事件</span><br><span class=\"line\">- (void)onClick:(UIEvent *)event &#123;</span><br><span class=\"line\">    [self.lock1 lock];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 此时我们可以认为 dispatch_sync 是在获取 block 里面的 lock2 </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [self.lock2 lock];</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 放在主线程执行，那么它也需要获得 lock1 </span><br><span class=\"line\">        [self.lock1 lock];</span><br><span class=\"line\">        [self.lock1 unlock];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [self.lock2 unlock];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [self.lock1 unlock];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到其实上面的情况就是两个任务都在同时竞争主线程的资源，并且谁都没有退出最终导致死锁的产生。但是这两个任务并不是普通的两个线程在竞争资源，而是都在主线程上，一个嵌套另外一个。而且这种特殊的情况，在运行的时候会直接导致奔溃，而不像我们一开始的例子一样只是在互相等待。但是既然苹果把这种情况也称为死锁，那我们就当做死锁来看待，毕竟他们都是在竞争系统资源。</p>\n"},{"title":"线程优先级反转和自旋锁","date":"2023-01-07T14:17:56.000Z","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1507289872412-523fc6b2db5f?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=20ca9d0eba2016344894aec7bb453a2d&auto=format&fit=crop&w=160&q=100","_content":"\n最近在面试的过程中让我突然线程优先级反转和自旋锁的关系有了一个新的认识。\n\n## 优先级反转\n\n线程优先级反转问题（Priority Inversion）即当一个高优先级任务通过信号量机制访问共享资源时，该信号量已被一低优先级任务占有，而这个低优先级任务在访问共享资源时可能又被其它一些中等优先级任务抢先，因此造成高优先级任务被许多具有较低优先级任务阻塞，实时性难以得到保证。\n\n关于线程优先级反转可以参考【[优先级反转那点事儿](https://zhuanlan.zhihu.com/p/146132061)】。\n\n优先级反转的问题一般可以通过调整线程的优先级得到解决：\n\n- 优先级天花板（Priority Ceiling）\n- 优先级继承（Priority Inheritance）\n\n## 自旋锁\n\n自旋锁是一种线程同步机制，在等待锁的过程中，线程会不断地轮询锁的状态（`忙等待`），直到获得锁为止。\n\n自旋锁的优点是可以避免线程的阻塞和唤醒，从而减少了线程上下文切换的开销。但是自旋锁不能很好地应对长时间占用锁的情况，可能会导致其他线程无法及时获得 CPU 时间片，影响系统的并发性，并且在高竞争的情况下可能会导致 CPU 占用率过高，影响系统的性能。\n\n自旋锁一般都是针对比较轻量的任务使用的，在 iOS 中一般就是对属性的 atomic 修饰，weak 的实现等这些轻量的任务使用自旋锁。\n\n自旋锁不安全的原因是由于 iOS 的线程调度器和 QOS 的原因可能会导致低优先级的线程最终不会被执行。线程调度器总是优先考虑给 QOS 中较高等级中可运行的线程，而不是低等级的线程。由于在自旋锁上旋转的线程总是可运行的，这意味着如果有足够多的高 QOS 线程在等待一个由低 QOS 线程持有的锁，拥有该锁的线程将永远不会执行。\n\n## 优先级反转和自旋锁的关系\n\n其实我们可以发现优先级反转其实跟自旋锁没有关系，但是为什么在 iOS 面试中总是会把自旋锁和优先级反转放在一起来说呢？这是因为一旦出现优先级反转问题，自旋锁会让优先级反转问题不容易解决，甚至造成更严重的线程等待问题\n\n参考资料：\n\n1. https://zhuanlan.zhihu.com/p/146132061\n2. https://forums.swift.org/t/thread-safety-of-weak-properties/422/12\n","source":"_posts/线程优先级反转和自旋锁.md","raw":"---\ntitle: 线程优先级反转和自旋锁\ndate: 2023-01-07 14:17:56 +0800\nauthor: 帕帕\ncategories: 技术\ntags: [iOS]\nthumbnail: https://images.unsplash.com/photo-1507289872412-523fc6b2db5f?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=20ca9d0eba2016344894aec7bb453a2d&auto=format&fit=crop&w=160&q=100\n---\n\n最近在面试的过程中让我突然线程优先级反转和自旋锁的关系有了一个新的认识。\n\n## 优先级反转\n\n线程优先级反转问题（Priority Inversion）即当一个高优先级任务通过信号量机制访问共享资源时，该信号量已被一低优先级任务占有，而这个低优先级任务在访问共享资源时可能又被其它一些中等优先级任务抢先，因此造成高优先级任务被许多具有较低优先级任务阻塞，实时性难以得到保证。\n\n关于线程优先级反转可以参考【[优先级反转那点事儿](https://zhuanlan.zhihu.com/p/146132061)】。\n\n优先级反转的问题一般可以通过调整线程的优先级得到解决：\n\n- 优先级天花板（Priority Ceiling）\n- 优先级继承（Priority Inheritance）\n\n## 自旋锁\n\n自旋锁是一种线程同步机制，在等待锁的过程中，线程会不断地轮询锁的状态（`忙等待`），直到获得锁为止。\n\n自旋锁的优点是可以避免线程的阻塞和唤醒，从而减少了线程上下文切换的开销。但是自旋锁不能很好地应对长时间占用锁的情况，可能会导致其他线程无法及时获得 CPU 时间片，影响系统的并发性，并且在高竞争的情况下可能会导致 CPU 占用率过高，影响系统的性能。\n\n自旋锁一般都是针对比较轻量的任务使用的，在 iOS 中一般就是对属性的 atomic 修饰，weak 的实现等这些轻量的任务使用自旋锁。\n\n自旋锁不安全的原因是由于 iOS 的线程调度器和 QOS 的原因可能会导致低优先级的线程最终不会被执行。线程调度器总是优先考虑给 QOS 中较高等级中可运行的线程，而不是低等级的线程。由于在自旋锁上旋转的线程总是可运行的，这意味着如果有足够多的高 QOS 线程在等待一个由低 QOS 线程持有的锁，拥有该锁的线程将永远不会执行。\n\n## 优先级反转和自旋锁的关系\n\n其实我们可以发现优先级反转其实跟自旋锁没有关系，但是为什么在 iOS 面试中总是会把自旋锁和优先级反转放在一起来说呢？这是因为一旦出现优先级反转问题，自旋锁会让优先级反转问题不容易解决，甚至造成更严重的线程等待问题\n\n参考资料：\n\n1. https://zhuanlan.zhihu.com/p/146132061\n2. https://forums.swift.org/t/thread-safety-of-weak-properties/422/12\n","slug":"线程优先级反转和自旋锁","published":1,"updated":"2023-02-05T03:22:41.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldr5xjcn001ljbsegq3d2xpq","content":"<p>最近在面试的过程中让我突然线程优先级反转和自旋锁的关系有了一个新的认识。</p>\n<h2 id=\"优先级反转\"><a href=\"#优先级反转\" class=\"headerlink\" title=\"优先级反转\"></a>优先级反转</h2><p>线程优先级反转问题（Priority Inversion）即当一个高优先级任务通过信号量机制访问共享资源时，该信号量已被一低优先级任务占有，而这个低优先级任务在访问共享资源时可能又被其它一些中等优先级任务抢先，因此造成高优先级任务被许多具有较低优先级任务阻塞，实时性难以得到保证。</p>\n<p>关于线程优先级反转可以参考【<a href=\"https://zhuanlan.zhihu.com/p/146132061\">优先级反转那点事儿</a>】。</p>\n<p>优先级反转的问题一般可以通过调整线程的优先级得到解决：</p>\n<ul>\n<li>优先级天花板（Priority Ceiling）</li>\n<li>优先级继承（Priority Inheritance）</li>\n</ul>\n<h2 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h2><p>自旋锁是一种线程同步机制，在等待锁的过程中，线程会不断地轮询锁的状态（<code>忙等待</code>），直到获得锁为止。</p>\n<p>自旋锁的优点是可以避免线程的阻塞和唤醒，从而减少了线程上下文切换的开销。但是自旋锁不能很好地应对长时间占用锁的情况，可能会导致其他线程无法及时获得 CPU 时间片，影响系统的并发性，并且在高竞争的情况下可能会导致 CPU 占用率过高，影响系统的性能。</p>\n<p>自旋锁一般都是针对比较轻量的任务使用的，在 iOS 中一般就是对属性的 atomic 修饰，weak 的实现等这些轻量的任务使用自旋锁。</p>\n<p>自旋锁不安全的原因是由于 iOS 的线程调度器和 QOS 的原因可能会导致低优先级的线程最终不会被执行。线程调度器总是优先考虑给 QOS 中较高等级中可运行的线程，而不是低等级的线程。由于在自旋锁上旋转的线程总是可运行的，这意味着如果有足够多的高 QOS 线程在等待一个由低 QOS 线程持有的锁，拥有该锁的线程将永远不会执行。</p>\n<h2 id=\"优先级反转和自旋锁的关系\"><a href=\"#优先级反转和自旋锁的关系\" class=\"headerlink\" title=\"优先级反转和自旋锁的关系\"></a>优先级反转和自旋锁的关系</h2><p>其实我们可以发现优先级反转其实跟自旋锁没有关系，但是为什么在 iOS 面试中总是会把自旋锁和优先级反转放在一起来说呢？这是因为一旦出现优先级反转问题，自旋锁会让优先级反转问题不容易解决，甚至造成更严重的线程等待问题</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/146132061\">https://zhuanlan.zhihu.com/p/146132061</a></li>\n<li><a href=\"https://forums.swift.org/t/thread-safety-of-weak-properties/422/12\">https://forums.swift.org/t/thread-safety-of-weak-properties/422/12</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在面试的过程中让我突然线程优先级反转和自旋锁的关系有了一个新的认识。</p>\n<h2 id=\"优先级反转\"><a href=\"#优先级反转\" class=\"headerlink\" title=\"优先级反转\"></a>优先级反转</h2><p>线程优先级反转问题（Priority Inversion）即当一个高优先级任务通过信号量机制访问共享资源时，该信号量已被一低优先级任务占有，而这个低优先级任务在访问共享资源时可能又被其它一些中等优先级任务抢先，因此造成高优先级任务被许多具有较低优先级任务阻塞，实时性难以得到保证。</p>\n<p>关于线程优先级反转可以参考【<a href=\"https://zhuanlan.zhihu.com/p/146132061\">优先级反转那点事儿</a>】。</p>\n<p>优先级反转的问题一般可以通过调整线程的优先级得到解决：</p>\n<ul>\n<li>优先级天花板（Priority Ceiling）</li>\n<li>优先级继承（Priority Inheritance）</li>\n</ul>\n<h2 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h2><p>自旋锁是一种线程同步机制，在等待锁的过程中，线程会不断地轮询锁的状态（<code>忙等待</code>），直到获得锁为止。</p>\n<p>自旋锁的优点是可以避免线程的阻塞和唤醒，从而减少了线程上下文切换的开销。但是自旋锁不能很好地应对长时间占用锁的情况，可能会导致其他线程无法及时获得 CPU 时间片，影响系统的并发性，并且在高竞争的情况下可能会导致 CPU 占用率过高，影响系统的性能。</p>\n<p>自旋锁一般都是针对比较轻量的任务使用的，在 iOS 中一般就是对属性的 atomic 修饰，weak 的实现等这些轻量的任务使用自旋锁。</p>\n<p>自旋锁不安全的原因是由于 iOS 的线程调度器和 QOS 的原因可能会导致低优先级的线程最终不会被执行。线程调度器总是优先考虑给 QOS 中较高等级中可运行的线程，而不是低等级的线程。由于在自旋锁上旋转的线程总是可运行的，这意味着如果有足够多的高 QOS 线程在等待一个由低 QOS 线程持有的锁，拥有该锁的线程将永远不会执行。</p>\n<h2 id=\"优先级反转和自旋锁的关系\"><a href=\"#优先级反转和自旋锁的关系\" class=\"headerlink\" title=\"优先级反转和自旋锁的关系\"></a>优先级反转和自旋锁的关系</h2><p>其实我们可以发现优先级反转其实跟自旋锁没有关系，但是为什么在 iOS 面试中总是会把自旋锁和优先级反转放在一起来说呢？这是因为一旦出现优先级反转问题，自旋锁会让优先级反转问题不容易解决，甚至造成更严重的线程等待问题</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/146132061\">https://zhuanlan.zhihu.com/p/146132061</a></li>\n<li><a href=\"https://forums.swift.org/t/thread-safety-of-weak-properties/422/12\">https://forums.swift.org/t/thread-safety-of-weak-properties/422/12</a></li>\n</ol>\n"},{"title":"如何避免 App 被重签名（奇怪的用法）","date":"2023-02-05T16:01:06.000Z","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1507289872412-523fc6b2db5f?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=20ca9d0eba2016344894aec7bb453a2d&auto=format&fit=crop&w=160&q=100","_content":"\n由于业务线的调整，之前负责的产品不打算上架 AppStore 了，需要调整为只提供给公司内部的员工使用。当时考虑的解决方案有两种：\n\n1. 使用新的 BundleID 和企业证书打包，采用此种方案需要重新申请部分第三方 SDK 的权限\n2. 直接在现在 AppStore 的包的基础之上使用企业证书**重签名**，这种方式会导致推送功能无法使用，还有一些依赖于证书的特性（Capabilities）无法使用\n\n后来经过团队的考虑决定采用第二种方案，但是在采用第二种方案的之后出现了一个崩溃问题，而这个问题就是可以被我们利用来防止 App 被重签名的关键了。\n\n写过 Swift 的同学都知道，在 Swift 中有一种 optional 类型的数据，它可以通过 **!** 进行强制解包，而当它强制解包不成功的时候就会导致程序出现崩溃问题。\n\n（说到这里可能会有同学认为在代码中就不应该使用强制解包的语法，那请问 Swift 为什么要推出这种语法呢？其实当我们能够百分比确认某一个变量或业务的状态，那我们就应该使用强制解包，这个时候强制解包的好处就是能够帮助我们在开发阶段提前把问题暴露出来，并且在代码的使用上也更方便。）\n\n我们的应用由于需要在 Extension 和 Host App 之间进行数据共享，所以我们开启了 **App Groups** 这个特性。而在 Swift 代码中我们是这样去使用：\n\n```Swift\nlet store = UserDefaults(suiteName: \"group.com.yourcompany.product\")!\n// or\nlet url = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: \"group.com.yourcompany.product\")!\n```\n\n由于使用重签名的企业证书并没有包含这个的 **App Group** 的特性，所以最后会导致当我们手机安装重签名的包之后并且在启动后运行到这段代码的时候因为强制解包失败导致应用直接崩溃。\n所以一般的应用即使在业务上没有相关的需求，我依旧建议大家也应该增加这样的特性功能，并且利用这个特性来让其他人没有那么容易就能对你的应用进行重签名之后拿去使用。\n","source":"_posts/如何避免-App-被重签名.md","raw":"---\ntitle: 如何避免 App 被重签名（奇怪的用法）\ndate: 2023-02-05 16:01:06\nauthor: 帕帕\ncategories: 技术\ntags: [iOS, Swift]\nthumbnail: https://images.unsplash.com/photo-1507289872412-523fc6b2db5f?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=20ca9d0eba2016344894aec7bb453a2d&auto=format&fit=crop&w=160&q=100\n---\n\n由于业务线的调整，之前负责的产品不打算上架 AppStore 了，需要调整为只提供给公司内部的员工使用。当时考虑的解决方案有两种：\n\n1. 使用新的 BundleID 和企业证书打包，采用此种方案需要重新申请部分第三方 SDK 的权限\n2. 直接在现在 AppStore 的包的基础之上使用企业证书**重签名**，这种方式会导致推送功能无法使用，还有一些依赖于证书的特性（Capabilities）无法使用\n\n后来经过团队的考虑决定采用第二种方案，但是在采用第二种方案的之后出现了一个崩溃问题，而这个问题就是可以被我们利用来防止 App 被重签名的关键了。\n\n写过 Swift 的同学都知道，在 Swift 中有一种 optional 类型的数据，它可以通过 **!** 进行强制解包，而当它强制解包不成功的时候就会导致程序出现崩溃问题。\n\n（说到这里可能会有同学认为在代码中就不应该使用强制解包的语法，那请问 Swift 为什么要推出这种语法呢？其实当我们能够百分比确认某一个变量或业务的状态，那我们就应该使用强制解包，这个时候强制解包的好处就是能够帮助我们在开发阶段提前把问题暴露出来，并且在代码的使用上也更方便。）\n\n我们的应用由于需要在 Extension 和 Host App 之间进行数据共享，所以我们开启了 **App Groups** 这个特性。而在 Swift 代码中我们是这样去使用：\n\n```Swift\nlet store = UserDefaults(suiteName: \"group.com.yourcompany.product\")!\n// or\nlet url = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: \"group.com.yourcompany.product\")!\n```\n\n由于使用重签名的企业证书并没有包含这个的 **App Group** 的特性，所以最后会导致当我们手机安装重签名的包之后并且在启动后运行到这段代码的时候因为强制解包失败导致应用直接崩溃。\n所以一般的应用即使在业务上没有相关的需求，我依旧建议大家也应该增加这样的特性功能，并且利用这个特性来让其他人没有那么容易就能对你的应用进行重签名之后拿去使用。\n","slug":"如何避免-App-被重签名","published":1,"updated":"2023-02-06T08:39:56.060Z","_id":"cldr5xjco001ojbse7ej2hae7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>由于业务线的调整，之前负责的产品不打算上架 AppStore 了，需要调整为只提供给公司内部的员工使用。当时考虑的解决方案有两种：</p>\n<ol>\n<li>使用新的 BundleID 和企业证书打包，采用此种方案需要重新申请部分第三方 SDK 的权限</li>\n<li>直接在现在 AppStore 的包的基础之上使用企业证书<strong>重签名</strong>，这种方式会导致推送功能无法使用，还有一些依赖于证书的特性（Capabilities）无法使用</li>\n</ol>\n<p>后来经过团队的考虑决定采用第二种方案，但是在采用第二种方案的之后出现了一个崩溃问题，而这个问题就是可以被我们利用来防止 App 被重签名的关键了。</p>\n<p>写过 Swift 的同学都知道，在 Swift 中有一种 optional 类型的数据，它可以通过 <strong>!</strong> 进行强制解包，而当它强制解包不成功的时候就会导致程序出现崩溃问题。</p>\n<p>（说到这里可能会有同学认为在代码中就不应该使用强制解包的语法，那请问 Swift 为什么要推出这种语法呢？其实当我们能够百分比确认某一个变量或业务的状态，那我们就应该使用强制解包，这个时候强制解包的好处就是能够帮助我们在开发阶段提前把问题暴露出来，并且在代码的使用上也更方便。）</p>\n<p>我们的应用由于需要在 Extension 和 Host App 之间进行数据共享，所以我们开启了 <strong>App Groups</strong> 这个特性。而在 Swift 代码中我们是这样去使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> store <span class=\"operator\">=</span> <span class=\"type\">UserDefaults</span>(suiteName: <span class=\"string\">&quot;group.com.yourcompany.product&quot;</span>)<span class=\"operator\">!</span></span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> url <span class=\"operator\">=</span> <span class=\"type\">FileManager</span>.default.containerURL(forSecurityApplicationGroupIdentifier: <span class=\"string\">&quot;group.com.yourcompany.product&quot;</span>)<span class=\"operator\">!</span></span><br></pre></td></tr></table></figure>\n\n<p>由于使用重签名的企业证书并没有包含这个的 <strong>App Group</strong> 的特性，所以最后会导致当我们手机安装重签名的包之后并且在启动后运行到这段代码的时候因为强制解包失败导致应用直接崩溃。<br>所以一般的应用即使在业务上没有相关的需求，我依旧建议大家也应该增加这样的特性功能，并且利用这个特性来让其他人没有那么容易就能对你的应用进行重签名之后拿去使用。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>由于业务线的调整，之前负责的产品不打算上架 AppStore 了，需要调整为只提供给公司内部的员工使用。当时考虑的解决方案有两种：</p>\n<ol>\n<li>使用新的 BundleID 和企业证书打包，采用此种方案需要重新申请部分第三方 SDK 的权限</li>\n<li>直接在现在 AppStore 的包的基础之上使用企业证书<strong>重签名</strong>，这种方式会导致推送功能无法使用，还有一些依赖于证书的特性（Capabilities）无法使用</li>\n</ol>\n<p>后来经过团队的考虑决定采用第二种方案，但是在采用第二种方案的之后出现了一个崩溃问题，而这个问题就是可以被我们利用来防止 App 被重签名的关键了。</p>\n<p>写过 Swift 的同学都知道，在 Swift 中有一种 optional 类型的数据，它可以通过 <strong>!</strong> 进行强制解包，而当它强制解包不成功的时候就会导致程序出现崩溃问题。</p>\n<p>（说到这里可能会有同学认为在代码中就不应该使用强制解包的语法，那请问 Swift 为什么要推出这种语法呢？其实当我们能够百分比确认某一个变量或业务的状态，那我们就应该使用强制解包，这个时候强制解包的好处就是能够帮助我们在开发阶段提前把问题暴露出来，并且在代码的使用上也更方便。）</p>\n<p>我们的应用由于需要在 Extension 和 Host App 之间进行数据共享，所以我们开启了 <strong>App Groups</strong> 这个特性。而在 Swift 代码中我们是这样去使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> store <span class=\"operator\">=</span> <span class=\"type\">UserDefaults</span>(suiteName: <span class=\"string\">&quot;group.com.yourcompany.product&quot;</span>)<span class=\"operator\">!</span></span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> url <span class=\"operator\">=</span> <span class=\"type\">FileManager</span>.default.containerURL(forSecurityApplicationGroupIdentifier: <span class=\"string\">&quot;group.com.yourcompany.product&quot;</span>)<span class=\"operator\">!</span></span><br></pre></td></tr></table></figure>\n\n<p>由于使用重签名的企业证书并没有包含这个的 <strong>App Group</strong> 的特性，所以最后会导致当我们手机安装重签名的包之后并且在启动后运行到这段代码的时候因为强制解包失败导致应用直接崩溃。<br>所以一般的应用即使在业务上没有相关的需求，我依旧建议大家也应该增加这样的特性功能，并且利用这个特性来让其他人没有那么容易就能对你的应用进行重签名之后拿去使用。</p>\n"},{"title":"说说 Objective-C 中的 Copy 操作","date":"2018-03-23T16:35:55.000Z","author":"帕帕","thumbnail":"https://i.imgur.com/svn3AbQs.png","_content":"\n## 浅拷贝（Shallow copies）和深拷贝（Deep copies）\n\n我们都知道 Objective-C 中把 Copy 操作分成两种：`浅拷贝（Shallow copies）`和`深拷贝（Deep copies）`。学过 C 语言的同学应该知道区分这两种操作的区别其实很简单：\n\n> 浅拷贝（Shallow copies）: 指针拷贝，指向的还是同一块内容的地址\n> 深拷贝（Deep copies）: 内容拷贝\n\n\n但是在 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别。我们先来看看 Apple 的官方文档给出的一张图：\n\n![Collections Programming Topics](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png)\n\n通过上图可以看出`浅拷贝`过后，Array 1 和 Array 2 的元素都是相同的指针地址，指向相同的内容；`深拷贝`过后，内容被拷贝一份新的出来，Array 2 的元素的指针地址都和 Array 1 不一样，因为 Array2 的元素的指针地址都指向新的内容。\n\n## immutable 和 mutable 对象的拷贝\n\n在 Objective-C 中一般会用 copy 或 mutableCopy 进行拷贝操作，我们可以通过观察指针变化来确定这两种拷贝操作是`浅复制`还是`深复制`。\n    \n* immutable 对象的复制操作\n\n    ```Objective-C\n    NSString * aName = @\"帕帕\";\n    NSString * bName = [aName copy];\n    NSMutableString * cName = [aName mutableCopy];\n    \n    NSLog(@\"aName 的指针：%p\", aName);\n    NSLog(@\"bName 的指针：%p\", bName);\n    NSLog(@\"cName 的指针：%p\", cName);\n    \n    ```\n\n    输出的结果：\n    \n    ```\n    aName 的指针：0x103d34070\n    bName 的指针：0x103d34070\n    cName 的指针：0x600000250dd0\n    ```\n\n* mutable 对象的复制操作\n\n    ```Objective-C\n    NSMutableString * aName = [NSMutableString stringWithString:@\"帕帕\"];\n    NSString * bName = [aName copy];\n    NSMutableString * cName = [aName mutableCopy];\n    \n    NSLog(@\"aName 的指针：%p\", aName);\n    NSLog(@\"bName 的指针：%p\", bName);\n    NSLog(@\"cName 的指针：%p\", cName);\n    \n    ```\n\n    输出的结果：\n    \n    ```\n    aName 的指针：0x60000025e150\n    bName 的指针：0x600000222900\n    cName 的指针：0x60000025e450\n    ```\n\n通过上面两个例子以及它们的输出结果，我们可以得出下面这个表格：\n\n|  | imutable 对象 | mutable 对象 |\n| :---: | :---: | :---: |\n| copy | 浅复制 | 深复制 |\n| mutableCopy | 深复制| 深复制 |\n\n上面的规则对集合对象也是一样的：NSArray 和 NSMutableArray，NSDictionary 和 NSMutableDictionary，NSSet 和 NSMutableSet\n\n\n## 单层深复制（one-level-deep）\n\n```Objective-C\nNSMutableString * aString = [NSMutableString stringWithString:@\"\bHello\"]\n\nNSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];\nNSArray * bArray = [aArray copy];\n\nNSMutableString * bString = bArray[0];\n[bString appendString:@\" \b帕帕\"];\n    \nNSLog(@\"aArray 的指针：%p\", aName);\nNSLog(@\"bArray 的指针：%p\", bName);\nNSLog(@\"aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@\", aArray[0], aArray[0]);\nNSLog(@\"bArray 第一个元素的指针: %p，\b\b内容：%@\", bArray[0], bArray[0]);\n```\n\n输出结果：\n\n```\naArray 的指针：0x60000025d9a0\nbArray 的指针：0x60000002cf60\naArray \b\u001d\b第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕\nbArray 第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕\n```\n\n从 aArray 到 bArray 的 copy 操作之后，它们的指针地址发生了变化，按照我们之前的理解这是`深拷贝`。`深拷贝`会把 aArray 的元素都拷贝一份，那为什么改变 bArray 的元素的值会导致 aArray 的元素的值也发生了变化呢？\n\n![集合对象的深拷贝](https://i.imgur.com/svn3AbQ.png)\n\n## 完全深复制\n\n那我们要如何做到真正的深复制呢？我们可以简单的把上面的代码改一下：\n\n```Objective-C\nNSMutableString * aString = [NSMutableString stringWithString:@\"\bHello\"]\n\nNSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];\n\n// 只需要改动这一行代码\nNSArray *bArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:aArray]];\n\nNSMutableString * bString = bArray[0];\n[bString appendString:@\" \b帕帕\"];\n    \nNSLog(@\"aArray 的指针：%p\", aName);\nNSLog(@\"bArray 的指针：%p\", bName);\nNSLog(@\"aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@\", aArray[0], aArray[0]);\nNSLog(@\"bArray 第一个元素的指针: %p，\b\b内容：%@\", bArray[0], bArray[0]);\n```\n\n输出结果：\n\n```\naArray 的指针：0x600000259cb0\nbArray 的指针：0x600000030ac0\naArray \b\u001d\b第一个元素的指针: 0x604000452120，\b\b内容：\bHello\nbArray 第一个元素的指针: 0x604000452780，\b\b内容：\bHello \b帕帕\n```\n\n只要先对集合对象分别用 NSKeyedArchiver 和 NSKeyedUnarchiver 就可以真正完成对一个集合对象的深复制。\n\n## Copy 和 内存管理\n\n之前我们说过 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别，那差别在什么地方呢？\n内存中做复制操作是很耗费资源的，而我们都知道 Objective-C 高效的一个原因在于它的内存管理机制是`引用计数`。我们前面分析的`深拷贝`是对内容的拷贝，这一点跟 C 语言的一样。C 语言的`浅拷贝`是指针的拷贝，它依旧做了一次复制操作。而在 Objective-C 中，`浅拷贝`其实只是引用计数的增加，不信的话，我们可以看看下面的例子：\n\n```Objective-C\nNSArray * aArray = [NSArray arrayWithObjects:@\"帕帕\", nil];\nNSLog(@\"aArray 的指针：%p，\b\b引用计数：%ld\", aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));\nNSArray * bArray = [aArray copy];\nNSLog(@\"aArray 的指针：%p，\b\b引用计数：%ld\", aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));\nNSMutableArray * cArray = [aArray mutableCopy];\nNSLog(@\"aArray 的指针：%p，\b\b引用计数：%ld\", aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));\n```\n\n输出结果：\n\n```\naArray 的指针：0x604000443ba0，\b\b引用计数：2\naArray 的指针：0x604000443ba0，\b\b引用计数：3\naArray 的指针：0x604000443ba0，\b\b引用计数：3\n```\n\n为什么 aArray 刚出来的时候的引用计数是 2？因为 `[NSArray arrayWithObjects:@\"帕帕\", nil]` 本身就是一个对象，它的引用计数就是 1；然后我们又定义了 aArray 来引用这个对象，此时它的引用计数就增加了 1，变成了 2；之后我们对 aArray 进行了 copy 操作，发现它的引用计数变成了 3，所以这里的 copy 操作其实相当于 retaion；最后我们对 aArray 进行了 mutableCopy 操作，此时它的引用计数还是 3，没有发生变化，因为这个时候进行了内容复制。\n\n所以在 Objective-C 中对一个 imutable 对象进行的 copy（浅复制）操作，其实都只会引起引用计数的变化，而不会在内存中做出任何拷贝操作，包括指针拷贝。\n\n## NSCopying 和 NSMutableCopying\n\n如果我们有一个自定义的对象，并且对其进行 copy 操作的话，会发生什么：\n\n```Objective-C\n// Person\n@interface Person: NSObject\n@property (nonatomic, copy) NSString * name;\n@end\n@implementation Person\n@end\n\nPerson * aPerson = [Person new];\nPerson * bPerson = [aPerson copy];\n```\n\nXcode 直接奔溃了：\n\n```\n// 崩溃\n*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[Person copyWithZone:]: unrecognized selector sent to instance 0x60000000d5f0'\n```\n\n为什么我们对一个 Person 对象使用了 copy，Xcode 确报的是找不到 `copyWithZone:` 这个 selector 的错误。\n\n这是因为 Objective-C 中规定，一个对象如果想要使用 copy 或 mutableCopy 的操作，必须要实现 `NSCopying` 或 `NSMutableCopying` 这两个协议。这两个协议规定了对象需要实现 `copyWithZone:` 或 `mutableCopyWithZone:` 这两个方法，因为对一个对象做 copy 或 mutableCopy 最后都会去调用这两个方法来做最终的实现。\n上面例子中的集合对象能够使用 copy 和 mutableCopy 操作是也因为它们都实现了 NSCopying 和 NSMutableCopying 协议。\n\n我们来看看如何对一个普通的对象实现 NSCopying 协议：\n\n```Objective-C\n@interface Person: NSObject <NSCopying>\n@property (nonatomic, copy) NSString * name;\n@property (nonatomic, strong) NSMutableArray * mArray;\n@end\n\n@implementation Person\n- (instancetype)copyWithZone:(NSZone *)zone {\n    Person * person = [[self class] new];\n    person.name = [self.name copy];\n    person.mArray = [self.mArray mutableCopy];\n    return person;\n}\n@end\n```\n\n这样，我们就可以愉快的使用 `[Person copy]` 了。当然，这里 Person 的 mArray 也只是`单层深复制`，如果想要实现`完全深复制`的话，我们可以用 NSKeyedArchiver 和 NSKeyedUnarchiver 来完成对 mArray 的`完全深复制`。\n\n## Block 和 Copy\n\n简单说一下，在 Objective-C 中，Block 的 copy 是一种特殊的操作。因为 Block 是一种结构体，它无法实现 NSCopying 或 NSMutableCopying 协议，但是它却可以调用 copy 方法。这是由 Block 的结构体决定的：\n\n![](http://www.devtalking.com/postImages/block-struct.jpg)\n\nBlock 里面的 descriptor 有 copy 的函数指针，当对 Block 执行 copy 操作最后都会通过该函数指针进行真正的操作。这也是 Bloc看不需要实现 NSCopying 和 NSMutableCopying 就能调用 copy 方法的原因。\n\n\n\n参考资料：\n1. https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html\n2. https://www.zybuluo.com/MicroCai/note/50592\n\n","source":"_posts/说说-Objective-C-中的-Copy-操作.md","raw":"---\ntitle: 说说 Objective-C 中的 Copy 操作\ndate: 2018-03-23 16:35:55 +0800\nauthor: 帕帕\ncategories: 技术 \ntags: [iOS, Objective-C]\nthumbnail: https://i.imgur.com/svn3AbQs.png\n---\n\n## 浅拷贝（Shallow copies）和深拷贝（Deep copies）\n\n我们都知道 Objective-C 中把 Copy 操作分成两种：`浅拷贝（Shallow copies）`和`深拷贝（Deep copies）`。学过 C 语言的同学应该知道区分这两种操作的区别其实很简单：\n\n> 浅拷贝（Shallow copies）: 指针拷贝，指向的还是同一块内容的地址\n> 深拷贝（Deep copies）: 内容拷贝\n\n\n但是在 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别。我们先来看看 Apple 的官方文档给出的一张图：\n\n![Collections Programming Topics](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png)\n\n通过上图可以看出`浅拷贝`过后，Array 1 和 Array 2 的元素都是相同的指针地址，指向相同的内容；`深拷贝`过后，内容被拷贝一份新的出来，Array 2 的元素的指针地址都和 Array 1 不一样，因为 Array2 的元素的指针地址都指向新的内容。\n\n## immutable 和 mutable 对象的拷贝\n\n在 Objective-C 中一般会用 copy 或 mutableCopy 进行拷贝操作，我们可以通过观察指针变化来确定这两种拷贝操作是`浅复制`还是`深复制`。\n    \n* immutable 对象的复制操作\n\n    ```Objective-C\n    NSString * aName = @\"帕帕\";\n    NSString * bName = [aName copy];\n    NSMutableString * cName = [aName mutableCopy];\n    \n    NSLog(@\"aName 的指针：%p\", aName);\n    NSLog(@\"bName 的指针：%p\", bName);\n    NSLog(@\"cName 的指针：%p\", cName);\n    \n    ```\n\n    输出的结果：\n    \n    ```\n    aName 的指针：0x103d34070\n    bName 的指针：0x103d34070\n    cName 的指针：0x600000250dd0\n    ```\n\n* mutable 对象的复制操作\n\n    ```Objective-C\n    NSMutableString * aName = [NSMutableString stringWithString:@\"帕帕\"];\n    NSString * bName = [aName copy];\n    NSMutableString * cName = [aName mutableCopy];\n    \n    NSLog(@\"aName 的指针：%p\", aName);\n    NSLog(@\"bName 的指针：%p\", bName);\n    NSLog(@\"cName 的指针：%p\", cName);\n    \n    ```\n\n    输出的结果：\n    \n    ```\n    aName 的指针：0x60000025e150\n    bName 的指针：0x600000222900\n    cName 的指针：0x60000025e450\n    ```\n\n通过上面两个例子以及它们的输出结果，我们可以得出下面这个表格：\n\n|  | imutable 对象 | mutable 对象 |\n| :---: | :---: | :---: |\n| copy | 浅复制 | 深复制 |\n| mutableCopy | 深复制| 深复制 |\n\n上面的规则对集合对象也是一样的：NSArray 和 NSMutableArray，NSDictionary 和 NSMutableDictionary，NSSet 和 NSMutableSet\n\n\n## 单层深复制（one-level-deep）\n\n```Objective-C\nNSMutableString * aString = [NSMutableString stringWithString:@\"\bHello\"]\n\nNSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];\nNSArray * bArray = [aArray copy];\n\nNSMutableString * bString = bArray[0];\n[bString appendString:@\" \b帕帕\"];\n    \nNSLog(@\"aArray 的指针：%p\", aName);\nNSLog(@\"bArray 的指针：%p\", bName);\nNSLog(@\"aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@\", aArray[0], aArray[0]);\nNSLog(@\"bArray 第一个元素的指针: %p，\b\b内容：%@\", bArray[0], bArray[0]);\n```\n\n输出结果：\n\n```\naArray 的指针：0x60000025d9a0\nbArray 的指针：0x60000002cf60\naArray \b\u001d\b第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕\nbArray 第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕\n```\n\n从 aArray 到 bArray 的 copy 操作之后，它们的指针地址发生了变化，按照我们之前的理解这是`深拷贝`。`深拷贝`会把 aArray 的元素都拷贝一份，那为什么改变 bArray 的元素的值会导致 aArray 的元素的值也发生了变化呢？\n\n![集合对象的深拷贝](https://i.imgur.com/svn3AbQ.png)\n\n## 完全深复制\n\n那我们要如何做到真正的深复制呢？我们可以简单的把上面的代码改一下：\n\n```Objective-C\nNSMutableString * aString = [NSMutableString stringWithString:@\"\bHello\"]\n\nNSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];\n\n// 只需要改动这一行代码\nNSArray *bArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:aArray]];\n\nNSMutableString * bString = bArray[0];\n[bString appendString:@\" \b帕帕\"];\n    \nNSLog(@\"aArray 的指针：%p\", aName);\nNSLog(@\"bArray 的指针：%p\", bName);\nNSLog(@\"aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@\", aArray[0], aArray[0]);\nNSLog(@\"bArray 第一个元素的指针: %p，\b\b内容：%@\", bArray[0], bArray[0]);\n```\n\n输出结果：\n\n```\naArray 的指针：0x600000259cb0\nbArray 的指针：0x600000030ac0\naArray \b\u001d\b第一个元素的指针: 0x604000452120，\b\b内容：\bHello\nbArray 第一个元素的指针: 0x604000452780，\b\b内容：\bHello \b帕帕\n```\n\n只要先对集合对象分别用 NSKeyedArchiver 和 NSKeyedUnarchiver 就可以真正完成对一个集合对象的深复制。\n\n## Copy 和 内存管理\n\n之前我们说过 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别，那差别在什么地方呢？\n内存中做复制操作是很耗费资源的，而我们都知道 Objective-C 高效的一个原因在于它的内存管理机制是`引用计数`。我们前面分析的`深拷贝`是对内容的拷贝，这一点跟 C 语言的一样。C 语言的`浅拷贝`是指针的拷贝，它依旧做了一次复制操作。而在 Objective-C 中，`浅拷贝`其实只是引用计数的增加，不信的话，我们可以看看下面的例子：\n\n```Objective-C\nNSArray * aArray = [NSArray arrayWithObjects:@\"帕帕\", nil];\nNSLog(@\"aArray 的指针：%p，\b\b引用计数：%ld\", aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));\nNSArray * bArray = [aArray copy];\nNSLog(@\"aArray 的指针：%p，\b\b引用计数：%ld\", aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));\nNSMutableArray * cArray = [aArray mutableCopy];\nNSLog(@\"aArray 的指针：%p，\b\b引用计数：%ld\", aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));\n```\n\n输出结果：\n\n```\naArray 的指针：0x604000443ba0，\b\b引用计数：2\naArray 的指针：0x604000443ba0，\b\b引用计数：3\naArray 的指针：0x604000443ba0，\b\b引用计数：3\n```\n\n为什么 aArray 刚出来的时候的引用计数是 2？因为 `[NSArray arrayWithObjects:@\"帕帕\", nil]` 本身就是一个对象，它的引用计数就是 1；然后我们又定义了 aArray 来引用这个对象，此时它的引用计数就增加了 1，变成了 2；之后我们对 aArray 进行了 copy 操作，发现它的引用计数变成了 3，所以这里的 copy 操作其实相当于 retaion；最后我们对 aArray 进行了 mutableCopy 操作，此时它的引用计数还是 3，没有发生变化，因为这个时候进行了内容复制。\n\n所以在 Objective-C 中对一个 imutable 对象进行的 copy（浅复制）操作，其实都只会引起引用计数的变化，而不会在内存中做出任何拷贝操作，包括指针拷贝。\n\n## NSCopying 和 NSMutableCopying\n\n如果我们有一个自定义的对象，并且对其进行 copy 操作的话，会发生什么：\n\n```Objective-C\n// Person\n@interface Person: NSObject\n@property (nonatomic, copy) NSString * name;\n@end\n@implementation Person\n@end\n\nPerson * aPerson = [Person new];\nPerson * bPerson = [aPerson copy];\n```\n\nXcode 直接奔溃了：\n\n```\n// 崩溃\n*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[Person copyWithZone:]: unrecognized selector sent to instance 0x60000000d5f0'\n```\n\n为什么我们对一个 Person 对象使用了 copy，Xcode 确报的是找不到 `copyWithZone:` 这个 selector 的错误。\n\n这是因为 Objective-C 中规定，一个对象如果想要使用 copy 或 mutableCopy 的操作，必须要实现 `NSCopying` 或 `NSMutableCopying` 这两个协议。这两个协议规定了对象需要实现 `copyWithZone:` 或 `mutableCopyWithZone:` 这两个方法，因为对一个对象做 copy 或 mutableCopy 最后都会去调用这两个方法来做最终的实现。\n上面例子中的集合对象能够使用 copy 和 mutableCopy 操作是也因为它们都实现了 NSCopying 和 NSMutableCopying 协议。\n\n我们来看看如何对一个普通的对象实现 NSCopying 协议：\n\n```Objective-C\n@interface Person: NSObject <NSCopying>\n@property (nonatomic, copy) NSString * name;\n@property (nonatomic, strong) NSMutableArray * mArray;\n@end\n\n@implementation Person\n- (instancetype)copyWithZone:(NSZone *)zone {\n    Person * person = [[self class] new];\n    person.name = [self.name copy];\n    person.mArray = [self.mArray mutableCopy];\n    return person;\n}\n@end\n```\n\n这样，我们就可以愉快的使用 `[Person copy]` 了。当然，这里 Person 的 mArray 也只是`单层深复制`，如果想要实现`完全深复制`的话，我们可以用 NSKeyedArchiver 和 NSKeyedUnarchiver 来完成对 mArray 的`完全深复制`。\n\n## Block 和 Copy\n\n简单说一下，在 Objective-C 中，Block 的 copy 是一种特殊的操作。因为 Block 是一种结构体，它无法实现 NSCopying 或 NSMutableCopying 协议，但是它却可以调用 copy 方法。这是由 Block 的结构体决定的：\n\n![](http://www.devtalking.com/postImages/block-struct.jpg)\n\nBlock 里面的 descriptor 有 copy 的函数指针，当对 Block 执行 copy 操作最后都会通过该函数指针进行真正的操作。这也是 Bloc看不需要实现 NSCopying 和 NSMutableCopying 就能调用 copy 方法的原因。\n\n\n\n参考资料：\n1. https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html\n2. https://www.zybuluo.com/MicroCai/note/50592\n\n","slug":"说说-Objective-C-中的-Copy-操作","published":1,"updated":"2023-01-07T05:42:02.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldr5xjcq002mjbseda8qbjuv","content":"<h2 id=\"浅拷贝（Shallow-copies）和深拷贝（Deep-copies）\"><a href=\"#浅拷贝（Shallow-copies）和深拷贝（Deep-copies）\" class=\"headerlink\" title=\"浅拷贝（Shallow copies）和深拷贝（Deep copies）\"></a>浅拷贝（Shallow copies）和深拷贝（Deep copies）</h2><p>我们都知道 Objective-C 中把 Copy 操作分成两种：<code>浅拷贝（Shallow copies）</code>和<code>深拷贝（Deep copies）</code>。学过 C 语言的同学应该知道区分这两种操作的区别其实很简单：</p>\n<blockquote>\n<p>浅拷贝（Shallow copies）: 指针拷贝，指向的还是同一块内容的地址<br>深拷贝（Deep copies）: 内容拷贝</p>\n</blockquote>\n<p>但是在 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别。我们先来看看 Apple 的官方文档给出的一张图：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png\" alt=\"Collections Programming Topics\"></p>\n<p>通过上图可以看出<code>浅拷贝</code>过后，Array 1 和 Array 2 的元素都是相同的指针地址，指向相同的内容；<code>深拷贝</code>过后，内容被拷贝一份新的出来，Array 2 的元素的指针地址都和 Array 1 不一样，因为 Array2 的元素的指针地址都指向新的内容。</p>\n<h2 id=\"immutable-和-mutable-对象的拷贝\"><a href=\"#immutable-和-mutable-对象的拷贝\" class=\"headerlink\" title=\"immutable 和 mutable 对象的拷贝\"></a>immutable 和 mutable 对象的拷贝</h2><p>在 Objective-C 中一般会用 copy 或 mutableCopy 进行拷贝操作，我们可以通过观察指针变化来确定这两种拷贝操作是<code>浅复制</code>还是<code>深复制</code>。</p>\n<ul>\n<li><p>immutable 对象的复制操作</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSString * aName = @&quot;帕帕&quot;;</span><br><span class=\"line\">NSString * bName = [aName copy];</span><br><span class=\"line\">NSMutableString * cName = [aName mutableCopy];</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;aName 的指针：%p&quot;, aName);</span><br><span class=\"line\">NSLog(@&quot;bName 的指针：%p&quot;, bName);</span><br><span class=\"line\">NSLog(@&quot;cName 的指针：%p&quot;, cName);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>  输出的结果：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aName 的指针：0x103d34070</span><br><span class=\"line\">bName 的指针：0x103d34070</span><br><span class=\"line\">cName 的指针：0x600000250dd0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>mutable 对象的复制操作</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableString * aName = [NSMutableString stringWithString:@&quot;帕帕&quot;];</span><br><span class=\"line\">NSString * bName = [aName copy];</span><br><span class=\"line\">NSMutableString * cName = [aName mutableCopy];</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;aName 的指针：%p&quot;, aName);</span><br><span class=\"line\">NSLog(@&quot;bName 的指针：%p&quot;, bName);</span><br><span class=\"line\">NSLog(@&quot;cName 的指针：%p&quot;, cName);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>  输出的结果：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aName 的指针：0x60000025e150</span><br><span class=\"line\">bName 的指针：0x600000222900</span><br><span class=\"line\">cName 的指针：0x60000025e450</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>通过上面两个例子以及它们的输出结果，我们可以得出下面这个表格：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">imutable 对象</th>\n<th align=\"center\">mutable 对象</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">copy</td>\n<td align=\"center\">浅复制</td>\n<td align=\"center\">深复制</td>\n</tr>\n<tr>\n<td align=\"center\">mutableCopy</td>\n<td align=\"center\">深复制</td>\n<td align=\"center\">深复制</td>\n</tr>\n</tbody></table>\n<p>上面的规则对集合对象也是一样的：NSArray 和 NSMutableArray，NSDictionary 和 NSMutableDictionary，NSSet 和 NSMutableSet</p>\n<h2 id=\"单层深复制（one-level-deep）\"><a href=\"#单层深复制（one-level-deep）\" class=\"headerlink\" title=\"单层深复制（one-level-deep）\"></a>单层深复制（one-level-deep）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableString * aString = [NSMutableString stringWithString:@&quot;\bHello&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];</span><br><span class=\"line\">NSArray * bArray = [aArray copy];</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableString * bString = bArray[0];</span><br><span class=\"line\">[bString appendString:@&quot; \b帕帕&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p&quot;, aName);</span><br><span class=\"line\">NSLog(@&quot;bArray 的指针：%p&quot;, bName);</span><br><span class=\"line\">NSLog(@&quot;aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@&quot;, aArray[0], aArray[0]);</span><br><span class=\"line\">NSLog(@&quot;bArray 第一个元素的指针: %p，\b\b内容：%@&quot;, bArray[0], bArray[0]);</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aArray 的指针：0x60000025d9a0</span><br><span class=\"line\">bArray 的指针：0x60000002cf60</span><br><span class=\"line\">aArray \b\u001d\b第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕</span><br><span class=\"line\">bArray 第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕</span><br></pre></td></tr></table></figure>\n\n<p>从 aArray 到 bArray 的 copy 操作之后，它们的指针地址发生了变化，按照我们之前的理解这是<code>深拷贝</code>。<code>深拷贝</code>会把 aArray 的元素都拷贝一份，那为什么改变 bArray 的元素的值会导致 aArray 的元素的值也发生了变化呢？</p>\n<p><img src=\"https://i.imgur.com/svn3AbQ.png\" alt=\"集合对象的深拷贝\"></p>\n<h2 id=\"完全深复制\"><a href=\"#完全深复制\" class=\"headerlink\" title=\"完全深复制\"></a>完全深复制</h2><p>那我们要如何做到真正的深复制呢？我们可以简单的把上面的代码改一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableString * aString = [NSMutableString stringWithString:@&quot;\bHello&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];</span><br><span class=\"line\"></span><br><span class=\"line\">// 只需要改动这一行代码</span><br><span class=\"line\">NSArray *bArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:aArray]];</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableString * bString = bArray[0];</span><br><span class=\"line\">[bString appendString:@&quot; \b帕帕&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p&quot;, aName);</span><br><span class=\"line\">NSLog(@&quot;bArray 的指针：%p&quot;, bName);</span><br><span class=\"line\">NSLog(@&quot;aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@&quot;, aArray[0], aArray[0]);</span><br><span class=\"line\">NSLog(@&quot;bArray 第一个元素的指针: %p，\b\b内容：%@&quot;, bArray[0], bArray[0]);</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aArray 的指针：0x600000259cb0</span><br><span class=\"line\">bArray 的指针：0x600000030ac0</span><br><span class=\"line\">aArray \b\u001d\b第一个元素的指针: 0x604000452120，\b\b内容：\bHello</span><br><span class=\"line\">bArray 第一个元素的指针: 0x604000452780，\b\b内容：\bHello \b帕帕</span><br></pre></td></tr></table></figure>\n\n<p>只要先对集合对象分别用 NSKeyedArchiver 和 NSKeyedUnarchiver 就可以真正完成对一个集合对象的深复制。</p>\n<h2 id=\"Copy-和-内存管理\"><a href=\"#Copy-和-内存管理\" class=\"headerlink\" title=\"Copy 和 内存管理\"></a>Copy 和 内存管理</h2><p>之前我们说过 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别，那差别在什么地方呢？<br>内存中做复制操作是很耗费资源的，而我们都知道 Objective-C 高效的一个原因在于它的内存管理机制是<code>引用计数</code>。我们前面分析的<code>深拷贝</code>是对内容的拷贝，这一点跟 C 语言的一样。C 语言的<code>浅拷贝</code>是指针的拷贝，它依旧做了一次复制操作。而在 Objective-C 中，<code>浅拷贝</code>其实只是引用计数的增加，不信的话，我们可以看看下面的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSArray * aArray = [NSArray arrayWithObjects:@&quot;帕帕&quot;, nil];</span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p，\b\b引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));</span><br><span class=\"line\">NSArray * bArray = [aArray copy];</span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p，\b\b引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));</span><br><span class=\"line\">NSMutableArray * cArray = [aArray mutableCopy];</span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p，\b\b引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aArray 的指针：0x604000443ba0，\b\b引用计数：2</span><br><span class=\"line\">aArray 的指针：0x604000443ba0，\b\b引用计数：3</span><br><span class=\"line\">aArray 的指针：0x604000443ba0，\b\b引用计数：3</span><br></pre></td></tr></table></figure>\n\n<p>为什么 aArray 刚出来的时候的引用计数是 2？因为 <code>[NSArray arrayWithObjects:@&quot;帕帕&quot;, nil]</code> 本身就是一个对象，它的引用计数就是 1；然后我们又定义了 aArray 来引用这个对象，此时它的引用计数就增加了 1，变成了 2；之后我们对 aArray 进行了 copy 操作，发现它的引用计数变成了 3，所以这里的 copy 操作其实相当于 retaion；最后我们对 aArray 进行了 mutableCopy 操作，此时它的引用计数还是 3，没有发生变化，因为这个时候进行了内容复制。</p>\n<p>所以在 Objective-C 中对一个 imutable 对象进行的 copy（浅复制）操作，其实都只会引起引用计数的变化，而不会在内存中做出任何拷贝操作，包括指针拷贝。</p>\n<h2 id=\"NSCopying-和-NSMutableCopying\"><a href=\"#NSCopying-和-NSMutableCopying\" class=\"headerlink\" title=\"NSCopying 和 NSMutableCopying\"></a>NSCopying 和 NSMutableCopying</h2><p>如果我们有一个自定义的对象，并且对其进行 copy 操作的话，会发生什么：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Person</span><br><span class=\"line\">@interface Person: NSObject</span><br><span class=\"line\">@property (nonatomic, copy) NSString * name;</span><br><span class=\"line\">@end</span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">Person * aPerson = [Person new];</span><br><span class=\"line\">Person * bPerson = [aPerson copy];</span><br></pre></td></tr></table></figure>\n\n<p>Xcode 直接奔溃了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 崩溃</span><br><span class=\"line\">*** Terminating app due to uncaught exception &#x27;NSInvalidArgumentException&#x27;, reason: &#x27;-[Person copyWithZone:]: unrecognized selector sent to instance 0x60000000d5f0&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>为什么我们对一个 Person 对象使用了 copy，Xcode 确报的是找不到 <code>copyWithZone:</code> 这个 selector 的错误。</p>\n<p>这是因为 Objective-C 中规定，一个对象如果想要使用 copy 或 mutableCopy 的操作，必须要实现 <code>NSCopying</code> 或 <code>NSMutableCopying</code> 这两个协议。这两个协议规定了对象需要实现 <code>copyWithZone:</code> 或 <code>mutableCopyWithZone:</code> 这两个方法，因为对一个对象做 copy 或 mutableCopy 最后都会去调用这两个方法来做最终的实现。<br>上面例子中的集合对象能够使用 copy 和 mutableCopy 操作是也因为它们都实现了 NSCopying 和 NSMutableCopying 协议。</p>\n<p>我们来看看如何对一个普通的对象实现 NSCopying 协议：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Person: NSObject &lt;NSCopying&gt;</span><br><span class=\"line\">@property (nonatomic, copy) NSString * name;</span><br><span class=\"line\">@property (nonatomic, strong) NSMutableArray * mArray;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\">- (instancetype)copyWithZone:(NSZone *)zone &#123;</span><br><span class=\"line\">    Person * person = [[self class] new];</span><br><span class=\"line\">    person.name = [self.name copy];</span><br><span class=\"line\">    person.mArray = [self.mArray mutableCopy];</span><br><span class=\"line\">    return person;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们就可以愉快的使用 <code>[Person copy]</code> 了。当然，这里 Person 的 mArray 也只是<code>单层深复制</code>，如果想要实现<code>完全深复制</code>的话，我们可以用 NSKeyedArchiver 和 NSKeyedUnarchiver 来完成对 mArray 的<code>完全深复制</code>。</p>\n<h2 id=\"Block-和-Copy\"><a href=\"#Block-和-Copy\" class=\"headerlink\" title=\"Block 和 Copy\"></a>Block 和 Copy</h2><p>简单说一下，在 Objective-C 中，Block 的 copy 是一种特殊的操作。因为 Block 是一种结构体，它无法实现 NSCopying 或 NSMutableCopying 协议，但是它却可以调用 copy 方法。这是由 Block 的结构体决定的：</p>\n<p><img src=\"http://www.devtalking.com/postImages/block-struct.jpg\"></p>\n<p>Block 里面的 descriptor 有 copy 的函数指针，当对 Block 执行 copy 操作最后都会通过该函数指针进行真正的操作。这也是 Bloc看不需要实现 NSCopying 和 NSMutableCopying 就能调用 copy 方法的原因。</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html\">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html</a></li>\n<li><a href=\"https://www.zybuluo.com/MicroCai/note/50592\">https://www.zybuluo.com/MicroCai/note/50592</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"浅拷贝（Shallow-copies）和深拷贝（Deep-copies）\"><a href=\"#浅拷贝（Shallow-copies）和深拷贝（Deep-copies）\" class=\"headerlink\" title=\"浅拷贝（Shallow copies）和深拷贝（Deep copies）\"></a>浅拷贝（Shallow copies）和深拷贝（Deep copies）</h2><p>我们都知道 Objective-C 中把 Copy 操作分成两种：<code>浅拷贝（Shallow copies）</code>和<code>深拷贝（Deep copies）</code>。学过 C 语言的同学应该知道区分这两种操作的区别其实很简单：</p>\n<blockquote>\n<p>浅拷贝（Shallow copies）: 指针拷贝，指向的还是同一块内容的地址<br>深拷贝（Deep copies）: 内容拷贝</p>\n</blockquote>\n<p>但是在 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别。我们先来看看 Apple 的官方文档给出的一张图：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png\" alt=\"Collections Programming Topics\"></p>\n<p>通过上图可以看出<code>浅拷贝</code>过后，Array 1 和 Array 2 的元素都是相同的指针地址，指向相同的内容；<code>深拷贝</code>过后，内容被拷贝一份新的出来，Array 2 的元素的指针地址都和 Array 1 不一样，因为 Array2 的元素的指针地址都指向新的内容。</p>\n<h2 id=\"immutable-和-mutable-对象的拷贝\"><a href=\"#immutable-和-mutable-对象的拷贝\" class=\"headerlink\" title=\"immutable 和 mutable 对象的拷贝\"></a>immutable 和 mutable 对象的拷贝</h2><p>在 Objective-C 中一般会用 copy 或 mutableCopy 进行拷贝操作，我们可以通过观察指针变化来确定这两种拷贝操作是<code>浅复制</code>还是<code>深复制</code>。</p>\n<ul>\n<li><p>immutable 对象的复制操作</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSString * aName = @&quot;帕帕&quot;;</span><br><span class=\"line\">NSString * bName = [aName copy];</span><br><span class=\"line\">NSMutableString * cName = [aName mutableCopy];</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;aName 的指针：%p&quot;, aName);</span><br><span class=\"line\">NSLog(@&quot;bName 的指针：%p&quot;, bName);</span><br><span class=\"line\">NSLog(@&quot;cName 的指针：%p&quot;, cName);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>  输出的结果：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aName 的指针：0x103d34070</span><br><span class=\"line\">bName 的指针：0x103d34070</span><br><span class=\"line\">cName 的指针：0x600000250dd0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>mutable 对象的复制操作</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableString * aName = [NSMutableString stringWithString:@&quot;帕帕&quot;];</span><br><span class=\"line\">NSString * bName = [aName copy];</span><br><span class=\"line\">NSMutableString * cName = [aName mutableCopy];</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;aName 的指针：%p&quot;, aName);</span><br><span class=\"line\">NSLog(@&quot;bName 的指针：%p&quot;, bName);</span><br><span class=\"line\">NSLog(@&quot;cName 的指针：%p&quot;, cName);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>  输出的结果：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aName 的指针：0x60000025e150</span><br><span class=\"line\">bName 的指针：0x600000222900</span><br><span class=\"line\">cName 的指针：0x60000025e450</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>通过上面两个例子以及它们的输出结果，我们可以得出下面这个表格：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">imutable 对象</th>\n<th align=\"center\">mutable 对象</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">copy</td>\n<td align=\"center\">浅复制</td>\n<td align=\"center\">深复制</td>\n</tr>\n<tr>\n<td align=\"center\">mutableCopy</td>\n<td align=\"center\">深复制</td>\n<td align=\"center\">深复制</td>\n</tr>\n</tbody></table>\n<p>上面的规则对集合对象也是一样的：NSArray 和 NSMutableArray，NSDictionary 和 NSMutableDictionary，NSSet 和 NSMutableSet</p>\n<h2 id=\"单层深复制（one-level-deep）\"><a href=\"#单层深复制（one-level-deep）\" class=\"headerlink\" title=\"单层深复制（one-level-deep）\"></a>单层深复制（one-level-deep）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableString * aString = [NSMutableString stringWithString:@&quot;\bHello&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];</span><br><span class=\"line\">NSArray * bArray = [aArray copy];</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableString * bString = bArray[0];</span><br><span class=\"line\">[bString appendString:@&quot; \b帕帕&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p&quot;, aName);</span><br><span class=\"line\">NSLog(@&quot;bArray 的指针：%p&quot;, bName);</span><br><span class=\"line\">NSLog(@&quot;aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@&quot;, aArray[0], aArray[0]);</span><br><span class=\"line\">NSLog(@&quot;bArray 第一个元素的指针: %p，\b\b内容：%@&quot;, bArray[0], bArray[0]);</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aArray 的指针：0x60000025d9a0</span><br><span class=\"line\">bArray 的指针：0x60000002cf60</span><br><span class=\"line\">aArray \b\u001d\b第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕</span><br><span class=\"line\">bArray 第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕</span><br></pre></td></tr></table></figure>\n\n<p>从 aArray 到 bArray 的 copy 操作之后，它们的指针地址发生了变化，按照我们之前的理解这是<code>深拷贝</code>。<code>深拷贝</code>会把 aArray 的元素都拷贝一份，那为什么改变 bArray 的元素的值会导致 aArray 的元素的值也发生了变化呢？</p>\n<p><img src=\"https://i.imgur.com/svn3AbQ.png\" alt=\"集合对象的深拷贝\"></p>\n<h2 id=\"完全深复制\"><a href=\"#完全深复制\" class=\"headerlink\" title=\"完全深复制\"></a>完全深复制</h2><p>那我们要如何做到真正的深复制呢？我们可以简单的把上面的代码改一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableString * aString = [NSMutableString stringWithString:@&quot;\bHello&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];</span><br><span class=\"line\"></span><br><span class=\"line\">// 只需要改动这一行代码</span><br><span class=\"line\">NSArray *bArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:aArray]];</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableString * bString = bArray[0];</span><br><span class=\"line\">[bString appendString:@&quot; \b帕帕&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p&quot;, aName);</span><br><span class=\"line\">NSLog(@&quot;bArray 的指针：%p&quot;, bName);</span><br><span class=\"line\">NSLog(@&quot;aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@&quot;, aArray[0], aArray[0]);</span><br><span class=\"line\">NSLog(@&quot;bArray 第一个元素的指针: %p，\b\b内容：%@&quot;, bArray[0], bArray[0]);</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aArray 的指针：0x600000259cb0</span><br><span class=\"line\">bArray 的指针：0x600000030ac0</span><br><span class=\"line\">aArray \b\u001d\b第一个元素的指针: 0x604000452120，\b\b内容：\bHello</span><br><span class=\"line\">bArray 第一个元素的指针: 0x604000452780，\b\b内容：\bHello \b帕帕</span><br></pre></td></tr></table></figure>\n\n<p>只要先对集合对象分别用 NSKeyedArchiver 和 NSKeyedUnarchiver 就可以真正完成对一个集合对象的深复制。</p>\n<h2 id=\"Copy-和-内存管理\"><a href=\"#Copy-和-内存管理\" class=\"headerlink\" title=\"Copy 和 内存管理\"></a>Copy 和 内存管理</h2><p>之前我们说过 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别，那差别在什么地方呢？<br>内存中做复制操作是很耗费资源的，而我们都知道 Objective-C 高效的一个原因在于它的内存管理机制是<code>引用计数</code>。我们前面分析的<code>深拷贝</code>是对内容的拷贝，这一点跟 C 语言的一样。C 语言的<code>浅拷贝</code>是指针的拷贝，它依旧做了一次复制操作。而在 Objective-C 中，<code>浅拷贝</code>其实只是引用计数的增加，不信的话，我们可以看看下面的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSArray * aArray = [NSArray arrayWithObjects:@&quot;帕帕&quot;, nil];</span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p，\b\b引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));</span><br><span class=\"line\">NSArray * bArray = [aArray copy];</span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p，\b\b引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));</span><br><span class=\"line\">NSMutableArray * cArray = [aArray mutableCopy];</span><br><span class=\"line\">NSLog(@&quot;aArray 的指针：%p，\b\b引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aArray 的指针：0x604000443ba0，\b\b引用计数：2</span><br><span class=\"line\">aArray 的指针：0x604000443ba0，\b\b引用计数：3</span><br><span class=\"line\">aArray 的指针：0x604000443ba0，\b\b引用计数：3</span><br></pre></td></tr></table></figure>\n\n<p>为什么 aArray 刚出来的时候的引用计数是 2？因为 <code>[NSArray arrayWithObjects:@&quot;帕帕&quot;, nil]</code> 本身就是一个对象，它的引用计数就是 1；然后我们又定义了 aArray 来引用这个对象，此时它的引用计数就增加了 1，变成了 2；之后我们对 aArray 进行了 copy 操作，发现它的引用计数变成了 3，所以这里的 copy 操作其实相当于 retaion；最后我们对 aArray 进行了 mutableCopy 操作，此时它的引用计数还是 3，没有发生变化，因为这个时候进行了内容复制。</p>\n<p>所以在 Objective-C 中对一个 imutable 对象进行的 copy（浅复制）操作，其实都只会引起引用计数的变化，而不会在内存中做出任何拷贝操作，包括指针拷贝。</p>\n<h2 id=\"NSCopying-和-NSMutableCopying\"><a href=\"#NSCopying-和-NSMutableCopying\" class=\"headerlink\" title=\"NSCopying 和 NSMutableCopying\"></a>NSCopying 和 NSMutableCopying</h2><p>如果我们有一个自定义的对象，并且对其进行 copy 操作的话，会发生什么：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Person</span><br><span class=\"line\">@interface Person: NSObject</span><br><span class=\"line\">@property (nonatomic, copy) NSString * name;</span><br><span class=\"line\">@end</span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">Person * aPerson = [Person new];</span><br><span class=\"line\">Person * bPerson = [aPerson copy];</span><br></pre></td></tr></table></figure>\n\n<p>Xcode 直接奔溃了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 崩溃</span><br><span class=\"line\">*** Terminating app due to uncaught exception &#x27;NSInvalidArgumentException&#x27;, reason: &#x27;-[Person copyWithZone:]: unrecognized selector sent to instance 0x60000000d5f0&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>为什么我们对一个 Person 对象使用了 copy，Xcode 确报的是找不到 <code>copyWithZone:</code> 这个 selector 的错误。</p>\n<p>这是因为 Objective-C 中规定，一个对象如果想要使用 copy 或 mutableCopy 的操作，必须要实现 <code>NSCopying</code> 或 <code>NSMutableCopying</code> 这两个协议。这两个协议规定了对象需要实现 <code>copyWithZone:</code> 或 <code>mutableCopyWithZone:</code> 这两个方法，因为对一个对象做 copy 或 mutableCopy 最后都会去调用这两个方法来做最终的实现。<br>上面例子中的集合对象能够使用 copy 和 mutableCopy 操作是也因为它们都实现了 NSCopying 和 NSMutableCopying 协议。</p>\n<p>我们来看看如何对一个普通的对象实现 NSCopying 协议：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Person: NSObject &lt;NSCopying&gt;</span><br><span class=\"line\">@property (nonatomic, copy) NSString * name;</span><br><span class=\"line\">@property (nonatomic, strong) NSMutableArray * mArray;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Person</span><br><span class=\"line\">- (instancetype)copyWithZone:(NSZone *)zone &#123;</span><br><span class=\"line\">    Person * person = [[self class] new];</span><br><span class=\"line\">    person.name = [self.name copy];</span><br><span class=\"line\">    person.mArray = [self.mArray mutableCopy];</span><br><span class=\"line\">    return person;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们就可以愉快的使用 <code>[Person copy]</code> 了。当然，这里 Person 的 mArray 也只是<code>单层深复制</code>，如果想要实现<code>完全深复制</code>的话，我们可以用 NSKeyedArchiver 和 NSKeyedUnarchiver 来完成对 mArray 的<code>完全深复制</code>。</p>\n<h2 id=\"Block-和-Copy\"><a href=\"#Block-和-Copy\" class=\"headerlink\" title=\"Block 和 Copy\"></a>Block 和 Copy</h2><p>简单说一下，在 Objective-C 中，Block 的 copy 是一种特殊的操作。因为 Block 是一种结构体，它无法实现 NSCopying 或 NSMutableCopying 协议，但是它却可以调用 copy 方法。这是由 Block 的结构体决定的：</p>\n<p><img src=\"http://www.devtalking.com/postImages/block-struct.jpg\"></p>\n<p>Block 里面的 descriptor 有 copy 的函数指针，当对 Block 执行 copy 操作最后都会通过该函数指针进行真正的操作。这也是 Bloc看不需要实现 NSCopying 和 NSMutableCopying 就能调用 copy 方法的原因。</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html\">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html</a></li>\n<li><a href=\"https://www.zybuluo.com/MicroCai/note/50592\">https://www.zybuluo.com/MicroCai/note/50592</a></li>\n</ol>\n"},{"title":"关于 iOS 中 View 和 Cell 的思考","date":"2023-02-23T14:35:06.000Z","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1507289872412-523fc6b2db5f?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=20ca9d0eba2016344894aec7bb453a2d&auto=format&fit=crop&w=160&q=100","_content":"\n## Cell 组件\n\n在 iOS 开发中，当我们需要实现列表需求时，通常会写出 Cell 组件来实现每个列表项的布局和样式。但是这种方式的缺点是，当列表的实现方式从 UITableView 切换到 UICollectionView 时，我们的 Cell 组件就需要做出一些修改，这不够灵活。甚至当我们需要在其他地方使用 Cell 组件时，还需要重新实现一遍，这对于复用和维护来说都不是最佳的解决方案。\n\n当使用 Cell 的方式实现下面的课程组件：\n\n![列表组件](https://i.imgur.com/Z96M8LW.jpg)\n\n```Swift\n// 定义课程的 Cell 组件\nfinal class CourseCell: UITableCell {\n    // ...\n\n    let coverView = CourseCoverView()\n    let infoView = CourseInfoView()\n}\n\n// 定义课程的封面组件\nfinal class CourseCoverView: UIView {\n    // ...\n}\n\n// 定义课程的详细信息组件\nfinal class CourseInfoView: UIView {\n    // ...\n}\n\n```\n\n如果现在又来一个新的需求，需要在列表的最上面放一排可以横向滚动的封面图，下面依旧还是课程列表。这里使用 UICollectionView 来实现我们的这个需求，那么需要修改的代码如下：\n\n```Swift\n// 定义课程的 Cell 组件\nfinal class CourseCell: UICollectionViewCell {\n    // ...\n\n    let coverView = CourseCoverView()\n    let infoView = CourseInfoView()\n}\n\n// 定义课程封面的 Cell 组件\nfinal class CourseCoverCell: UICollectionViewCell {\n    // ...\n\n    let coverView = CourseCoverView()\n}\n\n// 定义课程的封面组件\nfinal class CourseCoverView: UIView {\n    // ...\n}\n\n// 定义课程的详细信息组件\nfinal class CourseInfoView: UIView {\n    // ...\n}\n\n```\n\n## View 组件\n\n因此，使用 View 组件实现列表项会更加灵活。在这种情况下，Cell 的作用只是一个容器，只是把 View 放到 Cell 上去，并且负责做一些注册和重用的机制。但这种方式的问题是，每当我们把这个 View 用在 UITableView 或 UICollectionView 上时，我们就必须编写对应的 Cell 容器代码，这部分代码的工作基本相同（添加 View，添加约束）。\n\n```Swift\n// MARK: - Cell 组件\n// 定义课程的 UICollectionViewCell 组件\nfinal class CourseCollectionCell: UICollectionViewCell {\n    // ...\n\n    let courseView = CourseView()\n}\n\n// 定义课程的 UITableViewCell 组件\nfinal class CourseTableCell: UITableViewCell {\n    // ...\n\n    let courseView = CourseView()\n}\n\n// MARK: -  View 组件\n// 定义课程组件\nfinal class CourseView: UIView {\n    // ...\n\n    let coverView = CourseCoverView()\n    let infoView = CourseInfoView()\n}\n\n// 定义课程的封面组件\nfinal class CourseCoverView: UIView {\n    // ...\n}\n\n// 定义课程的详细信息组件\nfinal class CourseInfoView: UIView {\n    // ...\n}\n\n```\n\n我们可以从上面的示例代码中看出，这种方式在实际的工程中依旧会出现大量的模板代码，所这就需要我们思考有没有什么方式可以来避免编写大量、重复的模板代码了？\n\n## [CheapCell](https://github.com/HParis/CheapCell)\n\nCheapCell 是之前的项目重构成 Swift 之后实现的一套能够让你不用写 Cell 容器的库，这个库当时帮助我们减少了上千行的 Cell 容器代码。它的核心代码很简单，最重要的是利用了 Swift 的面相协议编程的方式来实现的，能够极大地减少代码量和提高代码的复用性和可维护性。具体的实现代码可以看我的 Github 仓库 https://github.com/HParis/CheapCell。\n\n下面是集成了 CheapCell 之后的使用方式：\n\n第一步：让我们的 View 组件遵循我们定义的 CheapCell 协议\n\n```Swift\n// MARK: - CheapCell 协议\nextension CourseView: CheapCell {}\nextension CourseCoverView: CheapCell {}\n```\n\n第二步：在 UICollectionView 中的使用方式（UITableView 的使用方式也是类似的）\n\n```Swift\n// Register cheap cell\ncollectionView.registerCheapCell(CourseView.self)\ncollectionView.registerCheapCell(CourseCoverView.self)\n\n// Reuse cheep cell\nlet cell = collectionView.dequeueReusableCheapCell(for: indexPath) as CollectionCell<CourseView>\nlet cell = collectionView.dequeueReusableCheapCell(for: indexPath) as CollectionCell<CourseCoverView>\n```\n\n### 配合第三方库使用\n\n如果你使用了一些第三方的 Cell 的话，比如 [SwipeCellKit](https://github.com/SwipeCellKit/SwipeCellKit)，那么你可以按照下面的方式来实现你的 CheapCell：\n\n```Swift\nimport SwipeCellKit\n\npublic extension UICollectionView {\n    func registerCheapSwipeCell<T: CheapCell>(_ : T.Type) {\n        register(CollectionSwipeCell<T>.self, forCellWithReuseIdentifier: CollectionSwipeCell<T>.identifier)\n    }\n\n    func dequeueReusableCheapSwaipeCell<T: CheapCell>(for indexPath: IndexPath) -> CollectionSwipeCell<T> {\n        dequeueReusableCell(withReuseIdentifier: CollectionSwipeCell<T>.identifier, for: indexPath) as! CollectionSwipeCell<T>\n    }\n}\n\n\npublic final class CollectionSwipeCell<T: CheapCell>: SwipeCollectionViewCell {\n    public static var identifier: String {\n        return T.identifier\n    }\n\n    public let itemView = T()\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    }\n\n    required init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n        setupView()\n    }\n\n    private func setupView() {\n        contentView.addSubview(itemView)\n\n        itemView.translatesAutoresizingMaskIntoConstraints = false\n        itemView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor).isActive = true\n        itemView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor).isActive = true\n        itemView.topAnchor.constraint(equalTo: contentView.topAnchor).isActive = true\n        itemView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor).isActive = true\n    }\n}\n```\n\n现在你就可以直接通过 CheapCell 的方式来使用了：\n\n```Swift\n// Register cheap swipe cell\ncollectionView.registerCheapSwipeCell(CourseView.self)\n\n// Reuse cheep swipe cell\nlet cell = collectionView.dequeueReusableCheapCell(for: indexPath) as CollectionSwipeCell<CourseView>\ncell.delegate = self\n```\n","source":"_posts/关于 iOS 中 View 和 Cell 的思考.md","raw":"---\ntitle: 关于 iOS 中 View 和 Cell 的思考\ndate: 2023-02-23 14:35:06\nauthor: 帕帕\ncategories: 技术\ntags: [iOS]\nthumbnail: https://images.unsplash.com/photo-1507289872412-523fc6b2db5f?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=20ca9d0eba2016344894aec7bb453a2d&auto=format&fit=crop&w=160&q=100\n---\n\n## Cell 组件\n\n在 iOS 开发中，当我们需要实现列表需求时，通常会写出 Cell 组件来实现每个列表项的布局和样式。但是这种方式的缺点是，当列表的实现方式从 UITableView 切换到 UICollectionView 时，我们的 Cell 组件就需要做出一些修改，这不够灵活。甚至当我们需要在其他地方使用 Cell 组件时，还需要重新实现一遍，这对于复用和维护来说都不是最佳的解决方案。\n\n当使用 Cell 的方式实现下面的课程组件：\n\n![列表组件](https://i.imgur.com/Z96M8LW.jpg)\n\n```Swift\n// 定义课程的 Cell 组件\nfinal class CourseCell: UITableCell {\n    // ...\n\n    let coverView = CourseCoverView()\n    let infoView = CourseInfoView()\n}\n\n// 定义课程的封面组件\nfinal class CourseCoverView: UIView {\n    // ...\n}\n\n// 定义课程的详细信息组件\nfinal class CourseInfoView: UIView {\n    // ...\n}\n\n```\n\n如果现在又来一个新的需求，需要在列表的最上面放一排可以横向滚动的封面图，下面依旧还是课程列表。这里使用 UICollectionView 来实现我们的这个需求，那么需要修改的代码如下：\n\n```Swift\n// 定义课程的 Cell 组件\nfinal class CourseCell: UICollectionViewCell {\n    // ...\n\n    let coverView = CourseCoverView()\n    let infoView = CourseInfoView()\n}\n\n// 定义课程封面的 Cell 组件\nfinal class CourseCoverCell: UICollectionViewCell {\n    // ...\n\n    let coverView = CourseCoverView()\n}\n\n// 定义课程的封面组件\nfinal class CourseCoverView: UIView {\n    // ...\n}\n\n// 定义课程的详细信息组件\nfinal class CourseInfoView: UIView {\n    // ...\n}\n\n```\n\n## View 组件\n\n因此，使用 View 组件实现列表项会更加灵活。在这种情况下，Cell 的作用只是一个容器，只是把 View 放到 Cell 上去，并且负责做一些注册和重用的机制。但这种方式的问题是，每当我们把这个 View 用在 UITableView 或 UICollectionView 上时，我们就必须编写对应的 Cell 容器代码，这部分代码的工作基本相同（添加 View，添加约束）。\n\n```Swift\n// MARK: - Cell 组件\n// 定义课程的 UICollectionViewCell 组件\nfinal class CourseCollectionCell: UICollectionViewCell {\n    // ...\n\n    let courseView = CourseView()\n}\n\n// 定义课程的 UITableViewCell 组件\nfinal class CourseTableCell: UITableViewCell {\n    // ...\n\n    let courseView = CourseView()\n}\n\n// MARK: -  View 组件\n// 定义课程组件\nfinal class CourseView: UIView {\n    // ...\n\n    let coverView = CourseCoverView()\n    let infoView = CourseInfoView()\n}\n\n// 定义课程的封面组件\nfinal class CourseCoverView: UIView {\n    // ...\n}\n\n// 定义课程的详细信息组件\nfinal class CourseInfoView: UIView {\n    // ...\n}\n\n```\n\n我们可以从上面的示例代码中看出，这种方式在实际的工程中依旧会出现大量的模板代码，所这就需要我们思考有没有什么方式可以来避免编写大量、重复的模板代码了？\n\n## [CheapCell](https://github.com/HParis/CheapCell)\n\nCheapCell 是之前的项目重构成 Swift 之后实现的一套能够让你不用写 Cell 容器的库，这个库当时帮助我们减少了上千行的 Cell 容器代码。它的核心代码很简单，最重要的是利用了 Swift 的面相协议编程的方式来实现的，能够极大地减少代码量和提高代码的复用性和可维护性。具体的实现代码可以看我的 Github 仓库 https://github.com/HParis/CheapCell。\n\n下面是集成了 CheapCell 之后的使用方式：\n\n第一步：让我们的 View 组件遵循我们定义的 CheapCell 协议\n\n```Swift\n// MARK: - CheapCell 协议\nextension CourseView: CheapCell {}\nextension CourseCoverView: CheapCell {}\n```\n\n第二步：在 UICollectionView 中的使用方式（UITableView 的使用方式也是类似的）\n\n```Swift\n// Register cheap cell\ncollectionView.registerCheapCell(CourseView.self)\ncollectionView.registerCheapCell(CourseCoverView.self)\n\n// Reuse cheep cell\nlet cell = collectionView.dequeueReusableCheapCell(for: indexPath) as CollectionCell<CourseView>\nlet cell = collectionView.dequeueReusableCheapCell(for: indexPath) as CollectionCell<CourseCoverView>\n```\n\n### 配合第三方库使用\n\n如果你使用了一些第三方的 Cell 的话，比如 [SwipeCellKit](https://github.com/SwipeCellKit/SwipeCellKit)，那么你可以按照下面的方式来实现你的 CheapCell：\n\n```Swift\nimport SwipeCellKit\n\npublic extension UICollectionView {\n    func registerCheapSwipeCell<T: CheapCell>(_ : T.Type) {\n        register(CollectionSwipeCell<T>.self, forCellWithReuseIdentifier: CollectionSwipeCell<T>.identifier)\n    }\n\n    func dequeueReusableCheapSwaipeCell<T: CheapCell>(for indexPath: IndexPath) -> CollectionSwipeCell<T> {\n        dequeueReusableCell(withReuseIdentifier: CollectionSwipeCell<T>.identifier, for: indexPath) as! CollectionSwipeCell<T>\n    }\n}\n\n\npublic final class CollectionSwipeCell<T: CheapCell>: SwipeCollectionViewCell {\n    public static var identifier: String {\n        return T.identifier\n    }\n\n    public let itemView = T()\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    }\n\n    required init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n        setupView()\n    }\n\n    private func setupView() {\n        contentView.addSubview(itemView)\n\n        itemView.translatesAutoresizingMaskIntoConstraints = false\n        itemView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor).isActive = true\n        itemView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor).isActive = true\n        itemView.topAnchor.constraint(equalTo: contentView.topAnchor).isActive = true\n        itemView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor).isActive = true\n    }\n}\n```\n\n现在你就可以直接通过 CheapCell 的方式来使用了：\n\n```Swift\n// Register cheap swipe cell\ncollectionView.registerCheapSwipeCell(CourseView.self)\n\n// Reuse cheep swipe cell\nlet cell = collectionView.dequeueReusableCheapCell(for: indexPath) as CollectionSwipeCell<CourseView>\ncell.delegate = self\n```\n","slug":"关于 iOS 中 View 和 Cell 的思考","published":1,"updated":"2023-02-26T00:37:17.395Z","_id":"clegtszv300002esehbhv6zpd","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Cell-组件\"><a href=\"#Cell-组件\" class=\"headerlink\" title=\"Cell 组件\"></a>Cell 组件</h2><p>在 iOS 开发中，当我们需要实现列表需求时，通常会写出 Cell 组件来实现每个列表项的布局和样式。但是这种方式的缺点是，当列表的实现方式从 UITableView 切换到 UICollectionView 时，我们的 Cell 组件就需要做出一些修改，这不够灵活。甚至当我们需要在其他地方使用 Cell 组件时，还需要重新实现一遍，这对于复用和维护来说都不是最佳的解决方案。</p>\n<p>当使用 Cell 的方式实现下面的课程组件：</p>\n<p><img src=\"https://i.imgur.com/Z96M8LW.jpg\" alt=\"列表组件\"></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义课程的 Cell 组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseCell</span>: <span class=\"title class_\">UITableCell</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> coverView <span class=\"operator\">=</span> <span class=\"type\">CourseCoverView</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> infoView <span class=\"operator\">=</span> <span class=\"type\">CourseInfoView</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义课程的封面组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseCoverView</span>: <span class=\"title class_\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义课程的详细信息组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseInfoView</span>: <span class=\"title class_\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>如果现在又来一个新的需求，需要在列表的最上面放一排可以横向滚动的封面图，下面依旧还是课程列表。这里使用 UICollectionView 来实现我们的这个需求，那么需要修改的代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义课程的 Cell 组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseCell</span>: <span class=\"title class_\">UICollectionViewCell</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> coverView <span class=\"operator\">=</span> <span class=\"type\">CourseCoverView</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> infoView <span class=\"operator\">=</span> <span class=\"type\">CourseInfoView</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义课程封面的 Cell 组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseCoverCell</span>: <span class=\"title class_\">UICollectionViewCell</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> coverView <span class=\"operator\">=</span> <span class=\"type\">CourseCoverView</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义课程的封面组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseCoverView</span>: <span class=\"title class_\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义课程的详细信息组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseInfoView</span>: <span class=\"title class_\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"View-组件\"><a href=\"#View-组件\" class=\"headerlink\" title=\"View 组件\"></a>View 组件</h2><p>因此，使用 View 组件实现列表项会更加灵活。在这种情况下，Cell 的作用只是一个容器，只是把 View 放到 Cell 上去，并且负责做一些注册和重用的机制。但这种方式的问题是，每当我们把这个 View 用在 UITableView 或 UICollectionView 上时，我们就必须编写对应的 Cell 容器代码，这部分代码的工作基本相同（添加 View，添加约束）。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MARK: - Cell 组件</span></span><br><span class=\"line\"><span class=\"comment\">// 定义课程的 UICollectionViewCell 组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseCollectionCell</span>: <span class=\"title class_\">UICollectionViewCell</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> courseView <span class=\"operator\">=</span> <span class=\"type\">CourseView</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义课程的 UITableViewCell 组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseTableCell</span>: <span class=\"title class_\">UITableViewCell</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> courseView <span class=\"operator\">=</span> <span class=\"type\">CourseView</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MARK: -  View 组件</span></span><br><span class=\"line\"><span class=\"comment\">// 定义课程组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseView</span>: <span class=\"title class_\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> coverView <span class=\"operator\">=</span> <span class=\"type\">CourseCoverView</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> infoView <span class=\"operator\">=</span> <span class=\"type\">CourseInfoView</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义课程的封面组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseCoverView</span>: <span class=\"title class_\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义课程的详细信息组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseInfoView</span>: <span class=\"title class_\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们可以从上面的示例代码中看出，这种方式在实际的工程中依旧会出现大量的模板代码，所这就需要我们思考有没有什么方式可以来避免编写大量、重复的模板代码了？</p>\n<h2 id=\"CheapCell\"><a href=\"#CheapCell\" class=\"headerlink\" title=\"CheapCell\"></a><a href=\"https://github.com/HParis/CheapCell\">CheapCell</a></h2><p>CheapCell 是之前的项目重构成 Swift 之后实现的一套能够让你不用写 Cell 容器的库，这个库当时帮助我们减少了上千行的 Cell 容器代码。它的核心代码很简单，最重要的是利用了 Swift 的面相协议编程的方式来实现的，能够极大地减少代码量和提高代码的复用性和可维护性。具体的实现代码可以看我的 Github 仓库 <a href=\"https://github.com/HParis/CheapCell%E3%80%82\">https://github.com/HParis/CheapCell。</a></p>\n<p>下面是集成了 CheapCell 之后的使用方式：</p>\n<p>第一步：让我们的 View 组件遵循我们定义的 CheapCell 协议</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MARK: - CheapCell 协议</span></span><br><span class=\"line\"><span class=\"keyword\">extension</span> <span class=\"title class_\">CourseView</span>: <span class=\"title class_\">CheapCell</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">extension</span> <span class=\"title class_\">CourseCoverView</span>: <span class=\"title class_\">CheapCell</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二步：在 UICollectionView 中的使用方式（UITableView 的使用方式也是类似的）</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Register cheap cell</span></span><br><span class=\"line\">collectionView.registerCheapCell(<span class=\"type\">CourseView</span>.<span class=\"keyword\">self</span>)</span><br><span class=\"line\">collectionView.registerCheapCell(<span class=\"type\">CourseCoverView</span>.<span class=\"keyword\">self</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reuse cheep cell</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cell <span class=\"operator\">=</span> collectionView.dequeueReusableCheapCell(for: indexPath) <span class=\"keyword\">as</span> <span class=\"type\">CollectionCell</span>&lt;<span class=\"type\">CourseView</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cell <span class=\"operator\">=</span> collectionView.dequeueReusableCheapCell(for: indexPath) <span class=\"keyword\">as</span> <span class=\"type\">CollectionCell</span>&lt;<span class=\"type\">CourseCoverView</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配合第三方库使用\"><a href=\"#配合第三方库使用\" class=\"headerlink\" title=\"配合第三方库使用\"></a>配合第三方库使用</h3><p>如果你使用了一些第三方的 Cell 的话，比如 <a href=\"https://github.com/SwipeCellKit/SwipeCellKit\">SwipeCellKit</a>，那么你可以按照下面的方式来实现你的 CheapCell：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> SwipeCellKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">extension</span> <span class=\"title class_\">UICollectionView</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">registerCheapSwipeCell</span>&lt;<span class=\"type\">T</span>: <span class=\"type\">CheapCell</span>&gt;(<span class=\"keyword\">_</span> : <span class=\"type\">T</span>.<span class=\"keyword\">Type</span>) &#123;</span><br><span class=\"line\">        register(<span class=\"type\">CollectionSwipeCell</span>&lt;<span class=\"type\">T</span>&gt;.<span class=\"keyword\">self</span>, forCellWithReuseIdentifier: <span class=\"type\">CollectionSwipeCell</span>&lt;<span class=\"type\">T</span>&gt;.identifier)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">dequeueReusableCheapSwaipeCell</span>&lt;<span class=\"type\">T</span>: <span class=\"type\">CheapCell</span>&gt;(<span class=\"params\">for</span> <span class=\"params\">indexPath</span>: <span class=\"type\">IndexPath</span>) -&gt; <span class=\"type\">CollectionSwipeCell</span>&lt;<span class=\"type\">T</span>&gt; &#123;</span><br><span class=\"line\">        dequeueReusableCell(withReuseIdentifier: <span class=\"type\">CollectionSwipeCell</span>&lt;<span class=\"type\">T</span>&gt;.identifier, for: indexPath) <span class=\"keyword\">as!</span> <span class=\"type\">CollectionSwipeCell</span>&lt;<span class=\"type\">T</span>&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CollectionSwipeCell</span>&lt;<span class=\"title class_\">T</span>: <span class=\"title class_\">CheapCell</span>&gt;: <span class=\"title class_\">SwipeCollectionViewCell</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> identifier: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">T</span>.identifier</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">let</span> itemView <span class=\"operator\">=</span> <span class=\"type\">T</span>()</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">init</span>(<span class=\"params\">frame</span>: <span class=\"type\">CGRect</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(frame: frame)</span><br><span class=\"line\">        setupView()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init?</span>(<span class=\"params\">coder</span> <span class=\"params\">aDecoder</span>: <span class=\"type\">NSCoder</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(coder: aDecoder)</span><br><span class=\"line\">        setupView()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">setupView</span>() &#123;</span><br><span class=\"line\">        contentView.addSubview(itemView)</span><br><span class=\"line\"></span><br><span class=\"line\">        itemView.translatesAutoresizingMaskIntoConstraints <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        itemView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        itemView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        itemView.topAnchor.constraint(equalTo: contentView.topAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        itemView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在你就可以直接通过 CheapCell 的方式来使用了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Register cheap swipe cell</span></span><br><span class=\"line\">collectionView.registerCheapSwipeCell(<span class=\"type\">CourseView</span>.<span class=\"keyword\">self</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reuse cheep swipe cell</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cell <span class=\"operator\">=</span> collectionView.dequeueReusableCheapCell(for: indexPath) <span class=\"keyword\">as</span> <span class=\"type\">CollectionSwipeCell</span>&lt;<span class=\"type\">CourseView</span>&gt;</span><br><span class=\"line\">cell.delegate <span class=\"operator\">=</span> <span class=\"keyword\">self</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Cell-组件\"><a href=\"#Cell-组件\" class=\"headerlink\" title=\"Cell 组件\"></a>Cell 组件</h2><p>在 iOS 开发中，当我们需要实现列表需求时，通常会写出 Cell 组件来实现每个列表项的布局和样式。但是这种方式的缺点是，当列表的实现方式从 UITableView 切换到 UICollectionView 时，我们的 Cell 组件就需要做出一些修改，这不够灵活。甚至当我们需要在其他地方使用 Cell 组件时，还需要重新实现一遍，这对于复用和维护来说都不是最佳的解决方案。</p>\n<p>当使用 Cell 的方式实现下面的课程组件：</p>\n<p><img src=\"https://i.imgur.com/Z96M8LW.jpg\" alt=\"列表组件\"></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义课程的 Cell 组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseCell</span>: <span class=\"title class_\">UITableCell</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> coverView <span class=\"operator\">=</span> <span class=\"type\">CourseCoverView</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> infoView <span class=\"operator\">=</span> <span class=\"type\">CourseInfoView</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义课程的封面组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseCoverView</span>: <span class=\"title class_\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义课程的详细信息组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseInfoView</span>: <span class=\"title class_\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>如果现在又来一个新的需求，需要在列表的最上面放一排可以横向滚动的封面图，下面依旧还是课程列表。这里使用 UICollectionView 来实现我们的这个需求，那么需要修改的代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义课程的 Cell 组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseCell</span>: <span class=\"title class_\">UICollectionViewCell</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> coverView <span class=\"operator\">=</span> <span class=\"type\">CourseCoverView</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> infoView <span class=\"operator\">=</span> <span class=\"type\">CourseInfoView</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义课程封面的 Cell 组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseCoverCell</span>: <span class=\"title class_\">UICollectionViewCell</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> coverView <span class=\"operator\">=</span> <span class=\"type\">CourseCoverView</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义课程的封面组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseCoverView</span>: <span class=\"title class_\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义课程的详细信息组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseInfoView</span>: <span class=\"title class_\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"View-组件\"><a href=\"#View-组件\" class=\"headerlink\" title=\"View 组件\"></a>View 组件</h2><p>因此，使用 View 组件实现列表项会更加灵活。在这种情况下，Cell 的作用只是一个容器，只是把 View 放到 Cell 上去，并且负责做一些注册和重用的机制。但这种方式的问题是，每当我们把这个 View 用在 UITableView 或 UICollectionView 上时，我们就必须编写对应的 Cell 容器代码，这部分代码的工作基本相同（添加 View，添加约束）。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MARK: - Cell 组件</span></span><br><span class=\"line\"><span class=\"comment\">// 定义课程的 UICollectionViewCell 组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseCollectionCell</span>: <span class=\"title class_\">UICollectionViewCell</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> courseView <span class=\"operator\">=</span> <span class=\"type\">CourseView</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义课程的 UITableViewCell 组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseTableCell</span>: <span class=\"title class_\">UITableViewCell</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> courseView <span class=\"operator\">=</span> <span class=\"type\">CourseView</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MARK: -  View 组件</span></span><br><span class=\"line\"><span class=\"comment\">// 定义课程组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseView</span>: <span class=\"title class_\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> coverView <span class=\"operator\">=</span> <span class=\"type\">CourseCoverView</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> infoView <span class=\"operator\">=</span> <span class=\"type\">CourseInfoView</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义课程的封面组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseCoverView</span>: <span class=\"title class_\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义课程的详细信息组件</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CourseInfoView</span>: <span class=\"title class_\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们可以从上面的示例代码中看出，这种方式在实际的工程中依旧会出现大量的模板代码，所这就需要我们思考有没有什么方式可以来避免编写大量、重复的模板代码了？</p>\n<h2 id=\"CheapCell\"><a href=\"#CheapCell\" class=\"headerlink\" title=\"CheapCell\"></a><a href=\"https://github.com/HParis/CheapCell\">CheapCell</a></h2><p>CheapCell 是之前的项目重构成 Swift 之后实现的一套能够让你不用写 Cell 容器的库，这个库当时帮助我们减少了上千行的 Cell 容器代码。它的核心代码很简单，最重要的是利用了 Swift 的面相协议编程的方式来实现的，能够极大地减少代码量和提高代码的复用性和可维护性。具体的实现代码可以看我的 Github 仓库 <a href=\"https://github.com/HParis/CheapCell%E3%80%82\">https://github.com/HParis/CheapCell。</a></p>\n<p>下面是集成了 CheapCell 之后的使用方式：</p>\n<p>第一步：让我们的 View 组件遵循我们定义的 CheapCell 协议</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MARK: - CheapCell 协议</span></span><br><span class=\"line\"><span class=\"keyword\">extension</span> <span class=\"title class_\">CourseView</span>: <span class=\"title class_\">CheapCell</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">extension</span> <span class=\"title class_\">CourseCoverView</span>: <span class=\"title class_\">CheapCell</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二步：在 UICollectionView 中的使用方式（UITableView 的使用方式也是类似的）</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Register cheap cell</span></span><br><span class=\"line\">collectionView.registerCheapCell(<span class=\"type\">CourseView</span>.<span class=\"keyword\">self</span>)</span><br><span class=\"line\">collectionView.registerCheapCell(<span class=\"type\">CourseCoverView</span>.<span class=\"keyword\">self</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reuse cheep cell</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cell <span class=\"operator\">=</span> collectionView.dequeueReusableCheapCell(for: indexPath) <span class=\"keyword\">as</span> <span class=\"type\">CollectionCell</span>&lt;<span class=\"type\">CourseView</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cell <span class=\"operator\">=</span> collectionView.dequeueReusableCheapCell(for: indexPath) <span class=\"keyword\">as</span> <span class=\"type\">CollectionCell</span>&lt;<span class=\"type\">CourseCoverView</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配合第三方库使用\"><a href=\"#配合第三方库使用\" class=\"headerlink\" title=\"配合第三方库使用\"></a>配合第三方库使用</h3><p>如果你使用了一些第三方的 Cell 的话，比如 <a href=\"https://github.com/SwipeCellKit/SwipeCellKit\">SwipeCellKit</a>，那么你可以按照下面的方式来实现你的 CheapCell：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> SwipeCellKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">extension</span> <span class=\"title class_\">UICollectionView</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">registerCheapSwipeCell</span>&lt;<span class=\"type\">T</span>: <span class=\"type\">CheapCell</span>&gt;(<span class=\"keyword\">_</span> : <span class=\"type\">T</span>.<span class=\"keyword\">Type</span>) &#123;</span><br><span class=\"line\">        register(<span class=\"type\">CollectionSwipeCell</span>&lt;<span class=\"type\">T</span>&gt;.<span class=\"keyword\">self</span>, forCellWithReuseIdentifier: <span class=\"type\">CollectionSwipeCell</span>&lt;<span class=\"type\">T</span>&gt;.identifier)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">dequeueReusableCheapSwaipeCell</span>&lt;<span class=\"type\">T</span>: <span class=\"type\">CheapCell</span>&gt;(<span class=\"params\">for</span> <span class=\"params\">indexPath</span>: <span class=\"type\">IndexPath</span>) -&gt; <span class=\"type\">CollectionSwipeCell</span>&lt;<span class=\"type\">T</span>&gt; &#123;</span><br><span class=\"line\">        dequeueReusableCell(withReuseIdentifier: <span class=\"type\">CollectionSwipeCell</span>&lt;<span class=\"type\">T</span>&gt;.identifier, for: indexPath) <span class=\"keyword\">as!</span> <span class=\"type\">CollectionSwipeCell</span>&lt;<span class=\"type\">T</span>&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CollectionSwipeCell</span>&lt;<span class=\"title class_\">T</span>: <span class=\"title class_\">CheapCell</span>&gt;: <span class=\"title class_\">SwipeCollectionViewCell</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> identifier: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">T</span>.identifier</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">let</span> itemView <span class=\"operator\">=</span> <span class=\"type\">T</span>()</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">init</span>(<span class=\"params\">frame</span>: <span class=\"type\">CGRect</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(frame: frame)</span><br><span class=\"line\">        setupView()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init?</span>(<span class=\"params\">coder</span> <span class=\"params\">aDecoder</span>: <span class=\"type\">NSCoder</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(coder: aDecoder)</span><br><span class=\"line\">        setupView()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">setupView</span>() &#123;</span><br><span class=\"line\">        contentView.addSubview(itemView)</span><br><span class=\"line\"></span><br><span class=\"line\">        itemView.translatesAutoresizingMaskIntoConstraints <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        itemView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        itemView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        itemView.topAnchor.constraint(equalTo: contentView.topAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        itemView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor).isActive <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在你就可以直接通过 CheapCell 的方式来使用了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Register cheap swipe cell</span></span><br><span class=\"line\">collectionView.registerCheapSwipeCell(<span class=\"type\">CourseView</span>.<span class=\"keyword\">self</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reuse cheep swipe cell</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cell <span class=\"operator\">=</span> collectionView.dequeueReusableCheapCell(for: indexPath) <span class=\"keyword\">as</span> <span class=\"type\">CollectionSwipeCell</span>&lt;<span class=\"type\">CourseView</span>&gt;</span><br><span class=\"line\">cell.delegate <span class=\"operator\">=</span> <span class=\"keyword\">self</span></span><br></pre></td></tr></table></figure>\n"},{"title":"常用工具","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1514443031610-8c063c7a9822?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=73d9a7ce5ba0ed22cb91bdc0506ac9d0&auto=format&fit=crop&w=160&q=10","_content":"\n> 此文章暂未完成....\n\n# Ruby\n\n## 版本管理工具 - rvm\n\n* `$ rvm list` 列出已安装的 ruby 版本\n* `$ rvm list kn=own` 显示 local + remote 的 ruby 版本\n* `$ rvm use [ruby-version]` 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本\n* `$ rvm remove [ruby-version]` 删除 ruby 版本\n\n## 包管理工具 - gem\n\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem update` 更新 gem 包\n* `$ gem update --system` 更新 gem 本身\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem list` 列出所有安装的 gem 包\n* `$ gem remove [gem-package]` 删除安装过的 gem 包\n\n\n## 常用工具\n\n### cocoapods\n\n* `$ gem instal cocoapods` 安装 cocoapods\n* `$ pod setup` 初始化 Pod 库\n* `$ pod repo update` 更新 Pod 库\n* `$ pod install` 根据当前目录的 Podfile 文件安装 Pod 库\n* `$ pod update` 更新 Podfile 文件中的 Pod 库\n\n# Python\n\n## 版本管理工具 - pyenv\n\n\n# JavaScript\n\n\n## 包管理工具 - npm\n\n\n# 包管理工具 - brew\n\n* `brew update` 更新 pythpackage\n* `brew cleanup` 移除旧版本\n* `brew cleanup -n` 查看可以清理的旧版本\n* `brew list` 列出已安装的 package\n\n\n","source":"_drafts/iOS 架构中的 Model 层.md","raw":"---\ntitle: 常用工具\nauthor: 帕帕\ncategories: 技术\ntags: [其他]\nthumbnail: https://images.unsplash.com/photo-1514443031610-8c063c7a9822?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=73d9a7ce5ba0ed22cb91bdc0506ac9d0&auto=format&fit=crop&w=160&q=10\n---\n\n> 此文章暂未完成....\n\n# Ruby\n\n## 版本管理工具 - rvm\n\n* `$ rvm list` 列出已安装的 ruby 版本\n* `$ rvm list kn=own` 显示 local + remote 的 ruby 版本\n* `$ rvm use [ruby-version]` 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本\n* `$ rvm remove [ruby-version]` 删除 ruby 版本\n\n## 包管理工具 - gem\n\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem update` 更新 gem 包\n* `$ gem update --system` 更新 gem 本身\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem list` 列出所有安装的 gem 包\n* `$ gem remove [gem-package]` 删除安装过的 gem 包\n\n\n## 常用工具\n\n### cocoapods\n\n* `$ gem instal cocoapods` 安装 cocoapods\n* `$ pod setup` 初始化 Pod 库\n* `$ pod repo update` 更新 Pod 库\n* `$ pod install` 根据当前目录的 Podfile 文件安装 Pod 库\n* `$ pod update` 更新 Podfile 文件中的 Pod 库\n\n# Python\n\n## 版本管理工具 - pyenv\n\n\n# JavaScript\n\n\n## 包管理工具 - npm\n\n\n# 包管理工具 - brew\n\n* `brew update` 更新 pythpackage\n* `brew cleanup` 移除旧版本\n* `brew cleanup -n` 查看可以清理的旧版本\n* `brew list` 列出已安装的 package\n\n\n","slug":"iOS 架构中的 Model 层","published":0,"date":"2023-02-23T08:59:12.310Z","updated":"2023-02-23T08:59:12.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cleknwjsm0000o5sefn4dhsfx","content":"<blockquote>\n<p>此文章暂未完成….</p>\n</blockquote>\n<h1 id=\"Ruby\"><a href=\"#Ruby\" class=\"headerlink\" title=\"Ruby\"></a>Ruby</h1><h2 id=\"版本管理工具-rvm\"><a href=\"#版本管理工具-rvm\" class=\"headerlink\" title=\"版本管理工具 - rvm\"></a>版本管理工具 - rvm</h2><ul>\n<li><code>$ rvm list</code> 列出已安装的 ruby 版本</li>\n<li><code>$ rvm list kn=own</code> 显示 local + remote 的 ruby 版本</li>\n<li><code>$ rvm use [ruby-version]</code> 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本</li>\n<li><code>$ rvm remove [ruby-version]</code> 删除 ruby 版本</li>\n</ul>\n<h2 id=\"包管理工具-gem\"><a href=\"#包管理工具-gem\" class=\"headerlink\" title=\"包管理工具 - gem\"></a>包管理工具 - gem</h2><ul>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem update</code> 更新 gem 包</li>\n<li><code>$ gem update --system</code> 更新 gem 本身</li>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem list</code> 列出所有安装的 gem 包</li>\n<li><code>$ gem remove [gem-package]</code> 删除安装过的 gem 包</li>\n</ul>\n<h2 id=\"常用工具\"><a href=\"#常用工具\" class=\"headerlink\" title=\"常用工具\"></a>常用工具</h2><h3 id=\"cocoapods\"><a href=\"#cocoapods\" class=\"headerlink\" title=\"cocoapods\"></a>cocoapods</h3><ul>\n<li><code>$ gem instal cocoapods</code> 安装 cocoapods</li>\n<li><code>$ pod setup</code> 初始化 Pod 库</li>\n<li><code>$ pod repo update</code> 更新 Pod 库</li>\n<li><code>$ pod install</code> 根据当前目录的 Podfile 文件安装 Pod 库</li>\n<li><code>$ pod update</code> 更新 Podfile 文件中的 Pod 库</li>\n</ul>\n<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h2 id=\"版本管理工具-pyenv\"><a href=\"#版本管理工具-pyenv\" class=\"headerlink\" title=\"版本管理工具 - pyenv\"></a>版本管理工具 - pyenv</h2><h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><h2 id=\"包管理工具-npm\"><a href=\"#包管理工具-npm\" class=\"headerlink\" title=\"包管理工具 - npm\"></a>包管理工具 - npm</h2><h1 id=\"包管理工具-brew\"><a href=\"#包管理工具-brew\" class=\"headerlink\" title=\"包管理工具 - brew\"></a>包管理工具 - brew</h1><ul>\n<li><code>brew update</code> 更新 pythpackage</li>\n<li><code>brew cleanup</code> 移除旧版本</li>\n<li><code>brew cleanup -n</code> 查看可以清理的旧版本</li>\n<li><code>brew list</code> 列出已安装的 package</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>此文章暂未完成….</p>\n</blockquote>\n<h1 id=\"Ruby\"><a href=\"#Ruby\" class=\"headerlink\" title=\"Ruby\"></a>Ruby</h1><h2 id=\"版本管理工具-rvm\"><a href=\"#版本管理工具-rvm\" class=\"headerlink\" title=\"版本管理工具 - rvm\"></a>版本管理工具 - rvm</h2><ul>\n<li><code>$ rvm list</code> 列出已安装的 ruby 版本</li>\n<li><code>$ rvm list kn=own</code> 显示 local + remote 的 ruby 版本</li>\n<li><code>$ rvm use [ruby-version]</code> 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本</li>\n<li><code>$ rvm remove [ruby-version]</code> 删除 ruby 版本</li>\n</ul>\n<h2 id=\"包管理工具-gem\"><a href=\"#包管理工具-gem\" class=\"headerlink\" title=\"包管理工具 - gem\"></a>包管理工具 - gem</h2><ul>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem update</code> 更新 gem 包</li>\n<li><code>$ gem update --system</code> 更新 gem 本身</li>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem list</code> 列出所有安装的 gem 包</li>\n<li><code>$ gem remove [gem-package]</code> 删除安装过的 gem 包</li>\n</ul>\n<h2 id=\"常用工具\"><a href=\"#常用工具\" class=\"headerlink\" title=\"常用工具\"></a>常用工具</h2><h3 id=\"cocoapods\"><a href=\"#cocoapods\" class=\"headerlink\" title=\"cocoapods\"></a>cocoapods</h3><ul>\n<li><code>$ gem instal cocoapods</code> 安装 cocoapods</li>\n<li><code>$ pod setup</code> 初始化 Pod 库</li>\n<li><code>$ pod repo update</code> 更新 Pod 库</li>\n<li><code>$ pod install</code> 根据当前目录的 Podfile 文件安装 Pod 库</li>\n<li><code>$ pod update</code> 更新 Podfile 文件中的 Pod 库</li>\n</ul>\n<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h2 id=\"版本管理工具-pyenv\"><a href=\"#版本管理工具-pyenv\" class=\"headerlink\" title=\"版本管理工具 - pyenv\"></a>版本管理工具 - pyenv</h2><h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><h2 id=\"包管理工具-npm\"><a href=\"#包管理工具-npm\" class=\"headerlink\" title=\"包管理工具 - npm\"></a>包管理工具 - npm</h2><h1 id=\"包管理工具-brew\"><a href=\"#包管理工具-brew\" class=\"headerlink\" title=\"包管理工具 - brew\"></a>包管理工具 - brew</h1><ul>\n<li><code>brew update</code> 更新 pythpackage</li>\n<li><code>brew cleanup</code> 移除旧版本</li>\n<li><code>brew cleanup -n</code> 查看可以清理的旧版本</li>\n<li><code>brew list</code> 列出已安装的 package</li>\n</ul>\n"},{"title":"常用工具","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1514443031610-8c063c7a9822?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=73d9a7ce5ba0ed22cb91bdc0506ac9d0&auto=format&fit=crop&w=160&q=10","_content":"\n> 此文章暂未完成....\n\n# Ruby\n\n## 版本管理工具 - rvm\n\n* `$ rvm list` 列出已安装的 ruby 版本\n* `$ rvm list kn=own` 显示 local + remote 的 ruby 版本\n* `$ rvm use [ruby-version]` 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本\n* `$ rvm remove [ruby-version]` 删除 ruby 版本\n\n## 包管理工具 - gem\n\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem update` 更新 gem 包\n* `$ gem update --system` 更新 gem 本身\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem list` 列出所有安装的 gem 包\n* `$ gem remove [gem-package]` 删除安装过的 gem 包\n\n\n## 常用工具\n\n### cocoapods\n\n* `$ gem instal cocoapods` 安装 cocoapods\n* `$ pod setup` 初始化 Pod 库\n* `$ pod repo update` 更新 Pod 库\n* `$ pod install` 根据当前目录的 Podfile 文件安装 Pod 库\n* `$ pod update` 更新 Podfile 文件中的 Pod 库\n\n# Python\n\n## 版本管理工具 - pyenv\n\n\n# JavaScript\n\n\n## 包管理工具 - npm\n\n\n# 包管理工具 - brew\n\n* `brew update` 更新 pythpackage\n* `brew cleanup` 移除旧版本\n* `brew cleanup -n` 查看可以清理的旧版本\n* `brew list` 列出已安装的 package\n\n\n","source":"_drafts/不要使用 UserDefaults.stand.md","raw":"---\ntitle: 常用工具\nauthor: 帕帕\ncategories: 技术\ntags: [其他]\nthumbnail: https://images.unsplash.com/photo-1514443031610-8c063c7a9822?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=73d9a7ce5ba0ed22cb91bdc0506ac9d0&auto=format&fit=crop&w=160&q=10\n---\n\n> 此文章暂未完成....\n\n# Ruby\n\n## 版本管理工具 - rvm\n\n* `$ rvm list` 列出已安装的 ruby 版本\n* `$ rvm list kn=own` 显示 local + remote 的 ruby 版本\n* `$ rvm use [ruby-version]` 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本\n* `$ rvm remove [ruby-version]` 删除 ruby 版本\n\n## 包管理工具 - gem\n\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem update` 更新 gem 包\n* `$ gem update --system` 更新 gem 本身\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem list` 列出所有安装的 gem 包\n* `$ gem remove [gem-package]` 删除安装过的 gem 包\n\n\n## 常用工具\n\n### cocoapods\n\n* `$ gem instal cocoapods` 安装 cocoapods\n* `$ pod setup` 初始化 Pod 库\n* `$ pod repo update` 更新 Pod 库\n* `$ pod install` 根据当前目录的 Podfile 文件安装 Pod 库\n* `$ pod update` 更新 Podfile 文件中的 Pod 库\n\n# Python\n\n## 版本管理工具 - pyenv\n\n\n# JavaScript\n\n\n## 包管理工具 - npm\n\n\n# 包管理工具 - brew\n\n* `brew update` 更新 pythpackage\n* `brew cleanup` 移除旧版本\n* `brew cleanup -n` 查看可以清理的旧版本\n* `brew list` 列出已安装的 package\n\n\n","slug":"不要使用 UserDefaults.stand","published":0,"date":"2023-02-23T09:04:28.693Z","updated":"2023-02-23T09:04:28.694Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cleknwjst0001o5se8s4q6aa5","content":"<blockquote>\n<p>此文章暂未完成….</p>\n</blockquote>\n<h1 id=\"Ruby\"><a href=\"#Ruby\" class=\"headerlink\" title=\"Ruby\"></a>Ruby</h1><h2 id=\"版本管理工具-rvm\"><a href=\"#版本管理工具-rvm\" class=\"headerlink\" title=\"版本管理工具 - rvm\"></a>版本管理工具 - rvm</h2><ul>\n<li><code>$ rvm list</code> 列出已安装的 ruby 版本</li>\n<li><code>$ rvm list kn=own</code> 显示 local + remote 的 ruby 版本</li>\n<li><code>$ rvm use [ruby-version]</code> 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本</li>\n<li><code>$ rvm remove [ruby-version]</code> 删除 ruby 版本</li>\n</ul>\n<h2 id=\"包管理工具-gem\"><a href=\"#包管理工具-gem\" class=\"headerlink\" title=\"包管理工具 - gem\"></a>包管理工具 - gem</h2><ul>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem update</code> 更新 gem 包</li>\n<li><code>$ gem update --system</code> 更新 gem 本身</li>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem list</code> 列出所有安装的 gem 包</li>\n<li><code>$ gem remove [gem-package]</code> 删除安装过的 gem 包</li>\n</ul>\n<h2 id=\"常用工具\"><a href=\"#常用工具\" class=\"headerlink\" title=\"常用工具\"></a>常用工具</h2><h3 id=\"cocoapods\"><a href=\"#cocoapods\" class=\"headerlink\" title=\"cocoapods\"></a>cocoapods</h3><ul>\n<li><code>$ gem instal cocoapods</code> 安装 cocoapods</li>\n<li><code>$ pod setup</code> 初始化 Pod 库</li>\n<li><code>$ pod repo update</code> 更新 Pod 库</li>\n<li><code>$ pod install</code> 根据当前目录的 Podfile 文件安装 Pod 库</li>\n<li><code>$ pod update</code> 更新 Podfile 文件中的 Pod 库</li>\n</ul>\n<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h2 id=\"版本管理工具-pyenv\"><a href=\"#版本管理工具-pyenv\" class=\"headerlink\" title=\"版本管理工具 - pyenv\"></a>版本管理工具 - pyenv</h2><h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><h2 id=\"包管理工具-npm\"><a href=\"#包管理工具-npm\" class=\"headerlink\" title=\"包管理工具 - npm\"></a>包管理工具 - npm</h2><h1 id=\"包管理工具-brew\"><a href=\"#包管理工具-brew\" class=\"headerlink\" title=\"包管理工具 - brew\"></a>包管理工具 - brew</h1><ul>\n<li><code>brew update</code> 更新 pythpackage</li>\n<li><code>brew cleanup</code> 移除旧版本</li>\n<li><code>brew cleanup -n</code> 查看可以清理的旧版本</li>\n<li><code>brew list</code> 列出已安装的 package</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>此文章暂未完成….</p>\n</blockquote>\n<h1 id=\"Ruby\"><a href=\"#Ruby\" class=\"headerlink\" title=\"Ruby\"></a>Ruby</h1><h2 id=\"版本管理工具-rvm\"><a href=\"#版本管理工具-rvm\" class=\"headerlink\" title=\"版本管理工具 - rvm\"></a>版本管理工具 - rvm</h2><ul>\n<li><code>$ rvm list</code> 列出已安装的 ruby 版本</li>\n<li><code>$ rvm list kn=own</code> 显示 local + remote 的 ruby 版本</li>\n<li><code>$ rvm use [ruby-version]</code> 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本</li>\n<li><code>$ rvm remove [ruby-version]</code> 删除 ruby 版本</li>\n</ul>\n<h2 id=\"包管理工具-gem\"><a href=\"#包管理工具-gem\" class=\"headerlink\" title=\"包管理工具 - gem\"></a>包管理工具 - gem</h2><ul>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem update</code> 更新 gem 包</li>\n<li><code>$ gem update --system</code> 更新 gem 本身</li>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem list</code> 列出所有安装的 gem 包</li>\n<li><code>$ gem remove [gem-package]</code> 删除安装过的 gem 包</li>\n</ul>\n<h2 id=\"常用工具\"><a href=\"#常用工具\" class=\"headerlink\" title=\"常用工具\"></a>常用工具</h2><h3 id=\"cocoapods\"><a href=\"#cocoapods\" class=\"headerlink\" title=\"cocoapods\"></a>cocoapods</h3><ul>\n<li><code>$ gem instal cocoapods</code> 安装 cocoapods</li>\n<li><code>$ pod setup</code> 初始化 Pod 库</li>\n<li><code>$ pod repo update</code> 更新 Pod 库</li>\n<li><code>$ pod install</code> 根据当前目录的 Podfile 文件安装 Pod 库</li>\n<li><code>$ pod update</code> 更新 Podfile 文件中的 Pod 库</li>\n</ul>\n<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h2 id=\"版本管理工具-pyenv\"><a href=\"#版本管理工具-pyenv\" class=\"headerlink\" title=\"版本管理工具 - pyenv\"></a>版本管理工具 - pyenv</h2><h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><h2 id=\"包管理工具-npm\"><a href=\"#包管理工具-npm\" class=\"headerlink\" title=\"包管理工具 - npm\"></a>包管理工具 - npm</h2><h1 id=\"包管理工具-brew\"><a href=\"#包管理工具-brew\" class=\"headerlink\" title=\"包管理工具 - brew\"></a>包管理工具 - brew</h1><ul>\n<li><code>brew update</code> 更新 pythpackage</li>\n<li><code>brew cleanup</code> 移除旧版本</li>\n<li><code>brew cleanup -n</code> 查看可以清理的旧版本</li>\n<li><code>brew list</code> 列出已安装的 package</li>\n</ul>\n"},{"title":"常用工具","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1514443031610-8c063c7a9822?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=73d9a7ce5ba0ed22cb91bdc0506ac9d0&auto=format&fit=crop&w=160&q=10","_content":"\n> 此文章暂未完成....\n\n# Ruby\n\n## 版本管理工具 - rvm\n\n* `$ rvm list` 列出已安装的 ruby 版本\n* `$ rvm list kn=own` 显示 local + remote 的 ruby 版本\n* `$ rvm use [ruby-version]` 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本\n* `$ rvm remove [ruby-version]` 删除 ruby 版本\n\n## 包管理工具 - gem\n\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem update` 更新 gem 包\n* `$ gem update --system` 更新 gem 本身\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem list` 列出所有安装的 gem 包\n* `$ gem remove [gem-package]` 删除安装过的 gem 包\n\n\n## 常用工具\n\n### cocoapods\n\n* `$ gem instal cocoapods` 安装 cocoapods\n* `$ pod setup` 初始化 Pod 库\n* `$ pod repo update` 更新 Pod 库\n* `$ pod install` 根据当前目录的 Podfile 文件安装 Pod 库\n* `$ pod update` 更新 Podfile 文件中的 Pod 库\n\n# Python\n\n## 版本管理工具 - pyenv\n\n\n# JavaScript\n\n\n## 包管理工具 - npm\n\n\n# 包管理工具 - brew\n\n* `brew update` 更新 pythpackage\n* `brew cleanup` 移除旧版本\n* `brew cleanup -n` 查看可以清理的旧版本\n* `brew list` 列出已安装的 package\n\n\n","source":"_drafts/如何处理 Model 层.md","raw":"---\ntitle: 常用工具\nauthor: 帕帕\ncategories: 技术\ntags: [其他]\nthumbnail: https://images.unsplash.com/photo-1514443031610-8c063c7a9822?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=73d9a7ce5ba0ed22cb91bdc0506ac9d0&auto=format&fit=crop&w=160&q=10\n---\n\n> 此文章暂未完成....\n\n# Ruby\n\n## 版本管理工具 - rvm\n\n* `$ rvm list` 列出已安装的 ruby 版本\n* `$ rvm list kn=own` 显示 local + remote 的 ruby 版本\n* `$ rvm use [ruby-version]` 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本\n* `$ rvm remove [ruby-version]` 删除 ruby 版本\n\n## 包管理工具 - gem\n\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem update` 更新 gem 包\n* `$ gem update --system` 更新 gem 本身\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem list` 列出所有安装的 gem 包\n* `$ gem remove [gem-package]` 删除安装过的 gem 包\n\n\n## 常用工具\n\n### cocoapods\n\n* `$ gem instal cocoapods` 安装 cocoapods\n* `$ pod setup` 初始化 Pod 库\n* `$ pod repo update` 更新 Pod 库\n* `$ pod install` 根据当前目录的 Podfile 文件安装 Pod 库\n* `$ pod update` 更新 Podfile 文件中的 Pod 库\n\n# Python\n\n## 版本管理工具 - pyenv\n\n\n# JavaScript\n\n\n## 包管理工具 - npm\n\n\n# 包管理工具 - brew\n\n* `brew update` 更新 pythpackage\n* `brew cleanup` 移除旧版本\n* `brew cleanup -n` 查看可以清理的旧版本\n* `brew list` 列出已安装的 package\n\n\n","slug":"如何处理 Model 层","published":0,"date":"2023-02-23T08:58:48.195Z","updated":"2023-02-23T08:58:48.197Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cleknwjsv0003o5sebp0ubuit","content":"<blockquote>\n<p>此文章暂未完成….</p>\n</blockquote>\n<h1 id=\"Ruby\"><a href=\"#Ruby\" class=\"headerlink\" title=\"Ruby\"></a>Ruby</h1><h2 id=\"版本管理工具-rvm\"><a href=\"#版本管理工具-rvm\" class=\"headerlink\" title=\"版本管理工具 - rvm\"></a>版本管理工具 - rvm</h2><ul>\n<li><code>$ rvm list</code> 列出已安装的 ruby 版本</li>\n<li><code>$ rvm list kn=own</code> 显示 local + remote 的 ruby 版本</li>\n<li><code>$ rvm use [ruby-version]</code> 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本</li>\n<li><code>$ rvm remove [ruby-version]</code> 删除 ruby 版本</li>\n</ul>\n<h2 id=\"包管理工具-gem\"><a href=\"#包管理工具-gem\" class=\"headerlink\" title=\"包管理工具 - gem\"></a>包管理工具 - gem</h2><ul>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem update</code> 更新 gem 包</li>\n<li><code>$ gem update --system</code> 更新 gem 本身</li>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem list</code> 列出所有安装的 gem 包</li>\n<li><code>$ gem remove [gem-package]</code> 删除安装过的 gem 包</li>\n</ul>\n<h2 id=\"常用工具\"><a href=\"#常用工具\" class=\"headerlink\" title=\"常用工具\"></a>常用工具</h2><h3 id=\"cocoapods\"><a href=\"#cocoapods\" class=\"headerlink\" title=\"cocoapods\"></a>cocoapods</h3><ul>\n<li><code>$ gem instal cocoapods</code> 安装 cocoapods</li>\n<li><code>$ pod setup</code> 初始化 Pod 库</li>\n<li><code>$ pod repo update</code> 更新 Pod 库</li>\n<li><code>$ pod install</code> 根据当前目录的 Podfile 文件安装 Pod 库</li>\n<li><code>$ pod update</code> 更新 Podfile 文件中的 Pod 库</li>\n</ul>\n<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h2 id=\"版本管理工具-pyenv\"><a href=\"#版本管理工具-pyenv\" class=\"headerlink\" title=\"版本管理工具 - pyenv\"></a>版本管理工具 - pyenv</h2><h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><h2 id=\"包管理工具-npm\"><a href=\"#包管理工具-npm\" class=\"headerlink\" title=\"包管理工具 - npm\"></a>包管理工具 - npm</h2><h1 id=\"包管理工具-brew\"><a href=\"#包管理工具-brew\" class=\"headerlink\" title=\"包管理工具 - brew\"></a>包管理工具 - brew</h1><ul>\n<li><code>brew update</code> 更新 pythpackage</li>\n<li><code>brew cleanup</code> 移除旧版本</li>\n<li><code>brew cleanup -n</code> 查看可以清理的旧版本</li>\n<li><code>brew list</code> 列出已安装的 package</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>此文章暂未完成….</p>\n</blockquote>\n<h1 id=\"Ruby\"><a href=\"#Ruby\" class=\"headerlink\" title=\"Ruby\"></a>Ruby</h1><h2 id=\"版本管理工具-rvm\"><a href=\"#版本管理工具-rvm\" class=\"headerlink\" title=\"版本管理工具 - rvm\"></a>版本管理工具 - rvm</h2><ul>\n<li><code>$ rvm list</code> 列出已安装的 ruby 版本</li>\n<li><code>$ rvm list kn=own</code> 显示 local + remote 的 ruby 版本</li>\n<li><code>$ rvm use [ruby-version]</code> 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本</li>\n<li><code>$ rvm remove [ruby-version]</code> 删除 ruby 版本</li>\n</ul>\n<h2 id=\"包管理工具-gem\"><a href=\"#包管理工具-gem\" class=\"headerlink\" title=\"包管理工具 - gem\"></a>包管理工具 - gem</h2><ul>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem update</code> 更新 gem 包</li>\n<li><code>$ gem update --system</code> 更新 gem 本身</li>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem list</code> 列出所有安装的 gem 包</li>\n<li><code>$ gem remove [gem-package]</code> 删除安装过的 gem 包</li>\n</ul>\n<h2 id=\"常用工具\"><a href=\"#常用工具\" class=\"headerlink\" title=\"常用工具\"></a>常用工具</h2><h3 id=\"cocoapods\"><a href=\"#cocoapods\" class=\"headerlink\" title=\"cocoapods\"></a>cocoapods</h3><ul>\n<li><code>$ gem instal cocoapods</code> 安装 cocoapods</li>\n<li><code>$ pod setup</code> 初始化 Pod 库</li>\n<li><code>$ pod repo update</code> 更新 Pod 库</li>\n<li><code>$ pod install</code> 根据当前目录的 Podfile 文件安装 Pod 库</li>\n<li><code>$ pod update</code> 更新 Podfile 文件中的 Pod 库</li>\n</ul>\n<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h2 id=\"版本管理工具-pyenv\"><a href=\"#版本管理工具-pyenv\" class=\"headerlink\" title=\"版本管理工具 - pyenv\"></a>版本管理工具 - pyenv</h2><h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><h2 id=\"包管理工具-npm\"><a href=\"#包管理工具-npm\" class=\"headerlink\" title=\"包管理工具 - npm\"></a>包管理工具 - npm</h2><h1 id=\"包管理工具-brew\"><a href=\"#包管理工具-brew\" class=\"headerlink\" title=\"包管理工具 - brew\"></a>包管理工具 - brew</h1><ul>\n<li><code>brew update</code> 更新 pythpackage</li>\n<li><code>brew cleanup</code> 移除旧版本</li>\n<li><code>brew cleanup -n</code> 查看可以清理的旧版本</li>\n<li><code>brew list</code> 列出已安装的 package</li>\n</ul>\n"},{"title":"常用工具","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1514443031610-8c063c7a9822?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=73d9a7ce5ba0ed22cb91bdc0506ac9d0&auto=format&fit=crop&w=160&q=10","_content":"\n> 此文章暂未完成....\n\n# Ruby\n\n## 版本管理工具 - rvm\n\n* `$ rvm list` 列出已安装的 ruby 版本\n* `$ rvm list kn=own` 显示 local + remote 的 ruby 版本\n* `$ rvm use [ruby-version]` 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本\n* `$ rvm remove [ruby-version]` 删除 ruby 版本\n\n## 包管理工具 - gem\n\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem update` 更新 gem 包\n* `$ gem update --system` 更新 gem 本身\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem list` 列出所有安装的 gem 包\n* `$ gem remove [gem-package]` 删除安装过的 gem 包\n\n\n## 常用工具\n\n### cocoapods\n\n* `$ gem instal cocoapods` 安装 cocoapods\n* `$ pod setup` 初始化 Pod 库\n* `$ pod repo update` 更新 Pod 库\n* `$ pod install` 根据当前目录的 Podfile 文件安装 Pod 库\n* `$ pod update` 更新 Podfile 文件中的 Pod 库\n\n# Python\n\n## 版本管理工具 - pyenv\n\n\n# JavaScript\n\n\n## 包管理工具 - npm\n\n\n# 包管理工具 - brew\n\n* `brew update` 更新 pythpackage\n* `brew cleanup` 移除旧版本\n* `brew cleanup -n` 查看可以清理的旧版本\n* `brew list` 列出已安装的 package\n\n\n","source":"_drafts/为什么有了 ARC 之后还要 autoreleasepool.md","raw":"---\ntitle: 常用工具\nauthor: 帕帕\ncategories: 技术\ntags: [其他]\nthumbnail: https://images.unsplash.com/photo-1514443031610-8c063c7a9822?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=73d9a7ce5ba0ed22cb91bdc0506ac9d0&auto=format&fit=crop&w=160&q=10\n---\n\n> 此文章暂未完成....\n\n# Ruby\n\n## 版本管理工具 - rvm\n\n* `$ rvm list` 列出已安装的 ruby 版本\n* `$ rvm list kn=own` 显示 local + remote 的 ruby 版本\n* `$ rvm use [ruby-version]` 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本\n* `$ rvm remove [ruby-version]` 删除 ruby 版本\n\n## 包管理工具 - gem\n\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem update` 更新 gem 包\n* `$ gem update --system` 更新 gem 本身\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem list` 列出所有安装的 gem 包\n* `$ gem remove [gem-package]` 删除安装过的 gem 包\n\n\n## 常用工具\n\n### cocoapods\n\n* `$ gem instal cocoapods` 安装 cocoapods\n* `$ pod setup` 初始化 Pod 库\n* `$ pod repo update` 更新 Pod 库\n* `$ pod install` 根据当前目录的 Podfile 文件安装 Pod 库\n* `$ pod update` 更新 Podfile 文件中的 Pod 库\n\n# Python\n\n## 版本管理工具 - pyenv\n\n\n# JavaScript\n\n\n## 包管理工具 - npm\n\n\n# 包管理工具 - brew\n\n* `brew update` 更新 pythpackage\n* `brew cleanup` 移除旧版本\n* `brew cleanup -n` 查看可以清理的旧版本\n* `brew list` 列出已安装的 package\n\n\n","slug":"为什么有了 ARC 之后还要 autoreleasepool","published":0,"date":"2023-02-23T08:53:31.015Z","updated":"2023-02-23T08:53:31.016Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cleknwjsv0005o5se81cxf2sd","content":"<blockquote>\n<p>此文章暂未完成….</p>\n</blockquote>\n<h1 id=\"Ruby\"><a href=\"#Ruby\" class=\"headerlink\" title=\"Ruby\"></a>Ruby</h1><h2 id=\"版本管理工具-rvm\"><a href=\"#版本管理工具-rvm\" class=\"headerlink\" title=\"版本管理工具 - rvm\"></a>版本管理工具 - rvm</h2><ul>\n<li><code>$ rvm list</code> 列出已安装的 ruby 版本</li>\n<li><code>$ rvm list kn=own</code> 显示 local + remote 的 ruby 版本</li>\n<li><code>$ rvm use [ruby-version]</code> 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本</li>\n<li><code>$ rvm remove [ruby-version]</code> 删除 ruby 版本</li>\n</ul>\n<h2 id=\"包管理工具-gem\"><a href=\"#包管理工具-gem\" class=\"headerlink\" title=\"包管理工具 - gem\"></a>包管理工具 - gem</h2><ul>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem update</code> 更新 gem 包</li>\n<li><code>$ gem update --system</code> 更新 gem 本身</li>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem list</code> 列出所有安装的 gem 包</li>\n<li><code>$ gem remove [gem-package]</code> 删除安装过的 gem 包</li>\n</ul>\n<h2 id=\"常用工具\"><a href=\"#常用工具\" class=\"headerlink\" title=\"常用工具\"></a>常用工具</h2><h3 id=\"cocoapods\"><a href=\"#cocoapods\" class=\"headerlink\" title=\"cocoapods\"></a>cocoapods</h3><ul>\n<li><code>$ gem instal cocoapods</code> 安装 cocoapods</li>\n<li><code>$ pod setup</code> 初始化 Pod 库</li>\n<li><code>$ pod repo update</code> 更新 Pod 库</li>\n<li><code>$ pod install</code> 根据当前目录的 Podfile 文件安装 Pod 库</li>\n<li><code>$ pod update</code> 更新 Podfile 文件中的 Pod 库</li>\n</ul>\n<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h2 id=\"版本管理工具-pyenv\"><a href=\"#版本管理工具-pyenv\" class=\"headerlink\" title=\"版本管理工具 - pyenv\"></a>版本管理工具 - pyenv</h2><h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><h2 id=\"包管理工具-npm\"><a href=\"#包管理工具-npm\" class=\"headerlink\" title=\"包管理工具 - npm\"></a>包管理工具 - npm</h2><h1 id=\"包管理工具-brew\"><a href=\"#包管理工具-brew\" class=\"headerlink\" title=\"包管理工具 - brew\"></a>包管理工具 - brew</h1><ul>\n<li><code>brew update</code> 更新 pythpackage</li>\n<li><code>brew cleanup</code> 移除旧版本</li>\n<li><code>brew cleanup -n</code> 查看可以清理的旧版本</li>\n<li><code>brew list</code> 列出已安装的 package</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>此文章暂未完成….</p>\n</blockquote>\n<h1 id=\"Ruby\"><a href=\"#Ruby\" class=\"headerlink\" title=\"Ruby\"></a>Ruby</h1><h2 id=\"版本管理工具-rvm\"><a href=\"#版本管理工具-rvm\" class=\"headerlink\" title=\"版本管理工具 - rvm\"></a>版本管理工具 - rvm</h2><ul>\n<li><code>$ rvm list</code> 列出已安装的 ruby 版本</li>\n<li><code>$ rvm list kn=own</code> 显示 local + remote 的 ruby 版本</li>\n<li><code>$ rvm use [ruby-version]</code> 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本</li>\n<li><code>$ rvm remove [ruby-version]</code> 删除 ruby 版本</li>\n</ul>\n<h2 id=\"包管理工具-gem\"><a href=\"#包管理工具-gem\" class=\"headerlink\" title=\"包管理工具 - gem\"></a>包管理工具 - gem</h2><ul>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem update</code> 更新 gem 包</li>\n<li><code>$ gem update --system</code> 更新 gem 本身</li>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem list</code> 列出所有安装的 gem 包</li>\n<li><code>$ gem remove [gem-package]</code> 删除安装过的 gem 包</li>\n</ul>\n<h2 id=\"常用工具\"><a href=\"#常用工具\" class=\"headerlink\" title=\"常用工具\"></a>常用工具</h2><h3 id=\"cocoapods\"><a href=\"#cocoapods\" class=\"headerlink\" title=\"cocoapods\"></a>cocoapods</h3><ul>\n<li><code>$ gem instal cocoapods</code> 安装 cocoapods</li>\n<li><code>$ pod setup</code> 初始化 Pod 库</li>\n<li><code>$ pod repo update</code> 更新 Pod 库</li>\n<li><code>$ pod install</code> 根据当前目录的 Podfile 文件安装 Pod 库</li>\n<li><code>$ pod update</code> 更新 Podfile 文件中的 Pod 库</li>\n</ul>\n<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h2 id=\"版本管理工具-pyenv\"><a href=\"#版本管理工具-pyenv\" class=\"headerlink\" title=\"版本管理工具 - pyenv\"></a>版本管理工具 - pyenv</h2><h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><h2 id=\"包管理工具-npm\"><a href=\"#包管理工具-npm\" class=\"headerlink\" title=\"包管理工具 - npm\"></a>包管理工具 - npm</h2><h1 id=\"包管理工具-brew\"><a href=\"#包管理工具-brew\" class=\"headerlink\" title=\"包管理工具 - brew\"></a>包管理工具 - brew</h1><ul>\n<li><code>brew update</code> 更新 pythpackage</li>\n<li><code>brew cleanup</code> 移除旧版本</li>\n<li><code>brew cleanup -n</code> 查看可以清理的旧版本</li>\n<li><code>brew list</code> 列出已安装的 package</li>\n</ul>\n"},{"title":"常用工具","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1514443031610-8c063c7a9822?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=73d9a7ce5ba0ed22cb91bdc0506ac9d0&auto=format&fit=crop&w=160&q=10","_content":"\n> 此文章暂未完成....\n\n# Ruby\n\n## 版本管理工具 - rvm\n\n* `$ rvm list` 列出已安装的 ruby 版本\n* `$ rvm list kn=own` 显示 local + remote 的 ruby 版本\n* `$ rvm use [ruby-version]` 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本\n* `$ rvm remove [ruby-version]` 删除 ruby 版本\n\n## 包管理工具 - gem\n\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem update` 更新 gem 包\n* `$ gem update --system` 更新 gem 本身\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem list` 列出所有安装的 gem 包\n* `$ gem remove [gem-package]` 删除安装过的 gem 包\n\n\n## 常用工具\n\n### cocoapods\n\n* `$ gem instal cocoapods` 安装 cocoapods\n* `$ pod setup` 初始化 Pod 库\n* `$ pod repo update` 更新 Pod 库\n* `$ pod install` 根据当前目录的 Podfile 文件安装 Pod 库\n* `$ pod update` 更新 Podfile 文件中的 Pod 库\n\n# Python\n\n## 版本管理工具 - pyenv\n\n\n# JavaScript\n\n\n## 包管理工具 - npm\n\n\n# 包管理工具 - brew\n\n* `brew update` 更新 pythpackage\n* `brew cleanup` 移除旧版本\n* `brew cleanup -n` 查看可以清理的旧版本\n* `brew list` 列出已安装的 package\n\n\n","source":"_drafts/理解 Swift 中 Struct 是线程安全的.md","raw":"---\ntitle: 常用工具\nauthor: 帕帕\ncategories: 技术\ntags: [其他]\nthumbnail: https://images.unsplash.com/photo-1514443031610-8c063c7a9822?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=73d9a7ce5ba0ed22cb91bdc0506ac9d0&auto=format&fit=crop&w=160&q=10\n---\n\n> 此文章暂未完成....\n\n# Ruby\n\n## 版本管理工具 - rvm\n\n* `$ rvm list` 列出已安装的 ruby 版本\n* `$ rvm list kn=own` 显示 local + remote 的 ruby 版本\n* `$ rvm use [ruby-version]` 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本\n* `$ rvm remove [ruby-version]` 删除 ruby 版本\n\n## 包管理工具 - gem\n\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem update` 更新 gem 包\n* `$ gem update --system` 更新 gem 本身\n* `$ gem install [gem-package]` 安装 gem 包\n* `$ gem list` 列出所有安装的 gem 包\n* `$ gem remove [gem-package]` 删除安装过的 gem 包\n\n\n## 常用工具\n\n### cocoapods\n\n* `$ gem instal cocoapods` 安装 cocoapods\n* `$ pod setup` 初始化 Pod 库\n* `$ pod repo update` 更新 Pod 库\n* `$ pod install` 根据当前目录的 Podfile 文件安装 Pod 库\n* `$ pod update` 更新 Podfile 文件中的 Pod 库\n\n# Python\n\n## 版本管理工具 - pyenv\n\n\n# JavaScript\n\n\n## 包管理工具 - npm\n\n\n# 包管理工具 - brew\n\n* `brew update` 更新 pythpackage\n* `brew cleanup` 移除旧版本\n* `brew cleanup -n` 查看可以清理的旧版本\n* `brew list` 列出已安装的 package\n\n\n","slug":"理解 Swift 中 Struct 是线程安全的","published":0,"date":"2023-02-23T09:13:43.573Z","updated":"2023-02-23T09:13:43.574Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cleknwjsy000co5sebaekbx3f","content":"<blockquote>\n<p>此文章暂未完成….</p>\n</blockquote>\n<h1 id=\"Ruby\"><a href=\"#Ruby\" class=\"headerlink\" title=\"Ruby\"></a>Ruby</h1><h2 id=\"版本管理工具-rvm\"><a href=\"#版本管理工具-rvm\" class=\"headerlink\" title=\"版本管理工具 - rvm\"></a>版本管理工具 - rvm</h2><ul>\n<li><code>$ rvm list</code> 列出已安装的 ruby 版本</li>\n<li><code>$ rvm list kn=own</code> 显示 local + remote 的 ruby 版本</li>\n<li><code>$ rvm use [ruby-version]</code> 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本</li>\n<li><code>$ rvm remove [ruby-version]</code> 删除 ruby 版本</li>\n</ul>\n<h2 id=\"包管理工具-gem\"><a href=\"#包管理工具-gem\" class=\"headerlink\" title=\"包管理工具 - gem\"></a>包管理工具 - gem</h2><ul>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem update</code> 更新 gem 包</li>\n<li><code>$ gem update --system</code> 更新 gem 本身</li>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem list</code> 列出所有安装的 gem 包</li>\n<li><code>$ gem remove [gem-package]</code> 删除安装过的 gem 包</li>\n</ul>\n<h2 id=\"常用工具\"><a href=\"#常用工具\" class=\"headerlink\" title=\"常用工具\"></a>常用工具</h2><h3 id=\"cocoapods\"><a href=\"#cocoapods\" class=\"headerlink\" title=\"cocoapods\"></a>cocoapods</h3><ul>\n<li><code>$ gem instal cocoapods</code> 安装 cocoapods</li>\n<li><code>$ pod setup</code> 初始化 Pod 库</li>\n<li><code>$ pod repo update</code> 更新 Pod 库</li>\n<li><code>$ pod install</code> 根据当前目录的 Podfile 文件安装 Pod 库</li>\n<li><code>$ pod update</code> 更新 Podfile 文件中的 Pod 库</li>\n</ul>\n<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h2 id=\"版本管理工具-pyenv\"><a href=\"#版本管理工具-pyenv\" class=\"headerlink\" title=\"版本管理工具 - pyenv\"></a>版本管理工具 - pyenv</h2><h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><h2 id=\"包管理工具-npm\"><a href=\"#包管理工具-npm\" class=\"headerlink\" title=\"包管理工具 - npm\"></a>包管理工具 - npm</h2><h1 id=\"包管理工具-brew\"><a href=\"#包管理工具-brew\" class=\"headerlink\" title=\"包管理工具 - brew\"></a>包管理工具 - brew</h1><ul>\n<li><code>brew update</code> 更新 pythpackage</li>\n<li><code>brew cleanup</code> 移除旧版本</li>\n<li><code>brew cleanup -n</code> 查看可以清理的旧版本</li>\n<li><code>brew list</code> 列出已安装的 package</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>此文章暂未完成….</p>\n</blockquote>\n<h1 id=\"Ruby\"><a href=\"#Ruby\" class=\"headerlink\" title=\"Ruby\"></a>Ruby</h1><h2 id=\"版本管理工具-rvm\"><a href=\"#版本管理工具-rvm\" class=\"headerlink\" title=\"版本管理工具 - rvm\"></a>版本管理工具 - rvm</h2><ul>\n<li><code>$ rvm list</code> 列出已安装的 ruby 版本</li>\n<li><code>$ rvm list kn=own</code> 显示 local + remote 的 ruby 版本</li>\n<li><code>$ rvm use [ruby-version]</code> 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本</li>\n<li><code>$ rvm remove [ruby-version]</code> 删除 ruby 版本</li>\n</ul>\n<h2 id=\"包管理工具-gem\"><a href=\"#包管理工具-gem\" class=\"headerlink\" title=\"包管理工具 - gem\"></a>包管理工具 - gem</h2><ul>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem update</code> 更新 gem 包</li>\n<li><code>$ gem update --system</code> 更新 gem 本身</li>\n<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>\n<li><code>$ gem list</code> 列出所有安装的 gem 包</li>\n<li><code>$ gem remove [gem-package]</code> 删除安装过的 gem 包</li>\n</ul>\n<h2 id=\"常用工具\"><a href=\"#常用工具\" class=\"headerlink\" title=\"常用工具\"></a>常用工具</h2><h3 id=\"cocoapods\"><a href=\"#cocoapods\" class=\"headerlink\" title=\"cocoapods\"></a>cocoapods</h3><ul>\n<li><code>$ gem instal cocoapods</code> 安装 cocoapods</li>\n<li><code>$ pod setup</code> 初始化 Pod 库</li>\n<li><code>$ pod repo update</code> 更新 Pod 库</li>\n<li><code>$ pod install</code> 根据当前目录的 Podfile 文件安装 Pod 库</li>\n<li><code>$ pod update</code> 更新 Podfile 文件中的 Pod 库</li>\n</ul>\n<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h2 id=\"版本管理工具-pyenv\"><a href=\"#版本管理工具-pyenv\" class=\"headerlink\" title=\"版本管理工具 - pyenv\"></a>版本管理工具 - pyenv</h2><h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><h2 id=\"包管理工具-npm\"><a href=\"#包管理工具-npm\" class=\"headerlink\" title=\"包管理工具 - npm\"></a>包管理工具 - npm</h2><h1 id=\"包管理工具-brew\"><a href=\"#包管理工具-brew\" class=\"headerlink\" title=\"包管理工具 - brew\"></a>包管理工具 - brew</h1><ul>\n<li><code>brew update</code> 更新 pythpackage</li>\n<li><code>brew cleanup</code> 移除旧版本</li>\n<li><code>brew cleanup -n</code> 查看可以清理的旧版本</li>\n<li><code>brew list</code> 列出已安装的 package</li>\n</ul>\n"},{"title":"iOS MVVM 架构的一点思考","date":"2023-04-02T16:58:32.000Z","author":"帕帕","thumbnail":"https://images.unsplash.com/photo-1514464750060-00e6e34c8b8c?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3749c47dd7beec20102c6b32fc19833a&auto=format&fit=crop&w=160&q=100","_content":"\n## MVVM 的基本介绍\n\nMVVM（Model-View-ViewModel）是一种基于 MVC（Model-View-Controller）模式的衍生设计模式，它将应用程序分为三个部分：模型（Model）、视图（View）和视图模型（ViewModel）。\n\n1. 模型（Model）\n   模型是应用程序中的数据和业务逻辑层，它是一个独立的组件，负责数据的存储和处理。模型通常是被动的，也就是说它不知道视图和视图模型的存在，只负责提供数据和业务逻辑的处理。 **模型可以包含数据模型、网络模型、数据库模型等等，它们都负责对数据的获取、处理和存储**。\n2. 视图（View）\n   视图是应用程序的用户界面，它负责将模型中的数据展示给用户，并接收用户的操作反馈。视图负责应用程序的外观和交互，并且需要与用户进行直接的交互。视图通常由图形用户界面（GUI）组成，它包含了各种控件和布局信息，例如按钮、文本框、列表等等。\n3. 视图模型（ViewModel）\n   视图模型是 MVVM 模式的核心部分，它充当了视图和模型之间的中间层，将模型中的数据转换成视图可以使用的数据，并将视图反馈转换成模型可以处理的操作。视图模型还负责处理用户交互逻辑，例如校验输入、调用模型方法等。 **视图模型通过绑定机制将数据和视图绑定起来，当数据发生变化时，视图会自动更新**。\n\n总之，MVVM 模式通过将应用程序分为三个部分来分离用户界面和业务逻辑，使得应用程序更加容易维护和扩展。模型和视图模型之间使用双向数据绑定机制，使得视图模型和视图之间的通信变得更加轻松和高效。在实际开发中，MVVM 模式已经被广泛应用于 iOS、Android 和 Web 等平台的应用程序中。\n\n## MVVM 的正常架构\n\n![图一](https://i.imgur.com/nAFi2ds.png)\n\n这是一个很经典的 MVVM 架构图，但是当我们细化到 iOS 开发的时候这个架构图就有简单了。我们可以思考下面的几个问题：\n\n1. Controller 在这里被当成一个特殊的 View 对待的，合理么？\n2. View 层持有 ViewModel，方便测试么？\n3. Model 究竟是 Fat (胖) 还是 Thin (瘦) ？\n\n## MVVM 的 iOS 架构\n\n![图二](https://i.imgur.com/d9IeLxf.png)\n\n### Controller（控制器）\n\n在 iOS 中，Controller（控制器）通常被放在 View 层中处理，但是这种做法可能会导致代码的混乱和耦合度的增加。\n\n在传统的 iOS 开发中，Controller 负责将数据从模型传递给视图，并响应视图的事件和用户交互。然而，随着应用程序变得越来越复杂，Controller 所承担的责任也变得越来越多，它可能包含大量的业务逻辑和用户交互代码，导致代码难以维护和测试。此外，Controller 与特定的视图耦合度较高，使得重用和测试变得更加困难。\n\n因此，为了避免这些问题，我们可以将 Controller 的职责进行分离，将视图控制和业务逻辑分别放置在不同的层中。在这种情况下，Controller 可以变得更加轻量级，并将其主要职责放在视图控制上，而将业务逻辑和用户交互放在其他层中。\n\n一种常见的做法是采用 MVVM 模式，将视图控制和视图模型分离开来。视图模型负责管理视图所需的数据和逻辑，并提供双向绑定机制，将视图与模型解耦。Controller 则只需要负责处理视图的生命周期和响应路由，将视图和视图模型连接起来。\n\n因此，虽然 Controller 在 iOS 中通常被放在 View 层中处理，但是为了避免代码的混乱和耦合度的增加，我们应该将其职责进行分离，并采用合适的模式来进行架构设计。\n\n```Swift\nfinal class ViewController: UIViewController {\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view.\n        setupView()\n        setupViewModel()\n        setupBuriedPoint()\n    }\n    // MARK: View & ViewModel\n    func setupView() {\n        view.addSubview(aView)\n    }\n\n    func setupViewModel() {\n        aView.bind(viewModel: aViewModel)\n    }\n\n    // MARK: 埋点 & 日志\n    func setupBuriedPoint() {\n        aViewModel.searchEvent.subscribe {\n        }\n        aViewModel.likeEvent.subscribe {\n        }\n    }\n\n    // MARK: Life Cycle\n    override func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n    }\n\n    override func viewDidDisappear(_ animated: Bool) {\n        super.viewDidDisappear(animated)\n    }\n\n    // MARK: - View\n    private let aView = AView()\n\n    // MARK: - ViewModel\n    private let aViewModel = AViewModel()\n\n    // MARK: - Business Logic / Network Request / Event Handle 统统都不见了\n}\n```\n\n### View 和 ViewModel 数据绑定\n\n双向绑定：双向数据绑定是指在数据模型和视图控件之间建立双向的关联，当数据模型发生变化时，自动更新关联的视图控件；当视图控件发生变化时，自动更新关联的数据模型。实现双向数据绑定可以提高应用程序的开发效率和用户体验，降低代码的复杂度和维护成本。\n\n单向绑定：单向数据绑定是指在数据模型和视图控件之间建立单向的关联，当数据模型发生变化时，自动更新关联的视图控件，但是当视图控件发生变化时，不会自动更新关联的数据模型。\n\n![图三](https://i.imgur.com/mPKsPUN.png)\n\n### Model 应该是 Fat 还是 Thin\n\nFat Model 是指将所有的业务逻辑和数据操作都放在 Model 层中实现。在这种设计模式下，Model 层会变得比较庞大，甚至会包含一些与业务逻辑无关的代码，因此被称为“Fat Model”。\n\nThin Model 是指将 Model 层中的业务逻辑和数据操作进行拆分，只保留最基本的数据存储和数据操作功能。在这种设计模式下，业务逻辑和数据操作通常被放在其他层中实现，比如 Controller 层或者 Service 层，因此 Model 层相对来说比较“瘦”，被称为“Thin Model”。\n\n在过去的项目中，我通常会将 Model 层定义为介于 Fat 和 Thin 之间，因为我会将跟 Model 相关的网络请求和弱业务逻辑的代码放在这一层。\n\n我们来看看一般情况下在 ViewModel 层如何处理数据和网络相关的代码：\n\n```Swift\n// ViewModel 层处理网络和数据的伪代码\ndo {\n    let response = try await Network.request(method, path, parameter)\n    if response.code == 200 {\n        do {\n            let model = try AModel.decode(from: response.data)\n            AModel.saveToCache()\n        } catch {\n            // 处理 decode 的异常情况\n            if let model = AModel.getFromCache() {\n\n            } else {\n                // 没有缓存返回 error\n            }\n        }\n    } else {\n        // 处理非 200 的业务代码\n    }\n} catch {\n    // 处理网络请求的 error\n}\n```\n\n实际上，上述的网络请求、业务代码处理以及数据解析在每个 Model 中都大致相同（缓存处理属于弱业务逻辑的一部分，因为每个 Model 的数据缓存策略可能会有一些不同的业务需求）。因此，我们希望将这部分代码封装起来以便复用。有些项目可能会新建工具类来处理这部分代码，但我通常会将这些代码放在 Model 的 Extension/Category 中处理。\n\n```Swift\n// AModel.Extension.Swift\nextesion AModel {\n    static fetch() async throws -> AModel {\n        do {\n            let response = try await Network.request(method, path, parameter)\n            if response.code == 200 {\n                do {\n                    let model = try AModel.decode(from: response.data)\n                    AModel.saveToCache()\n                } catch {\n                    // 处理 decode 的异常情况\n                    if let model = AModel.getFromCache() {\n\n                    } else {\n                        // 没有缓存返回 error\n                        throw Error.cache\n                    }\n                }\n            } else {\n                // 处理非 200 的业务代码\n                throw Error.data\n            }\n        } catch {\n            // 处理网络请求的 error\n            throw Error.network\n        }\n    }\n}\n\n\n// AViewModel.Swift\nfinal class AViewModel {\n    func fetch() {\n        do {\n        \tlet model = try await AModel.fetch()\n        } catch {\n            // 处理不同类型的 error\n        }\n    }\n}\n```\n\n> 弱业务逻辑（Weak Business Logic）是指应用程序中的业务逻辑缺乏严谨性或者可扩展性，并且散落在项目中的各个地方，导致应用程序难以维护和扩展。现在我们通过上面的优化相当把很多弱业务逻辑的代码放到统一的层级来进行管理，有利于我们的代码维护。\n\n对于图形界面来说，最重要的是拿到数据进行页面渲染，并响应用户的输入并交给数据去处理。它们并不需要关心数据的来源和如何处理数据。通过我们之前的优化，ViewModel 基本上不需要知道网络和缓存的存在。Model 层的数据可能是从网络系统、文件系统、本地缓存等方式获取的，但是这些细节 ViewModel 不需要关心。\n\n**Model 可以包含数据模型、网络模型、数据库模型等等，它们都负责对数据的获取、处理和存储。**\n\n---\n\n参考文献：\n\n1. [iOS Architecture Patterns Demystifying MVC, MVP, MVVM and VIPER](https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.tliwdfd60)\n2. [iOS 应用架构谈 view 层的组织和调用方案](https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html)\n","source":"_posts/iOS-中-MVVM-架构的一点思考.md","raw":"---\ntitle: iOS MVVM 架构的一点思考\ndate: 2023-4-2 16:58:32 +0800\nauthor: 帕帕\ncategories: 技术\ntags: [iOS]\nthumbnail: https://images.unsplash.com/photo-1514464750060-00e6e34c8b8c?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=3749c47dd7beec20102c6b32fc19833a&auto=format&fit=crop&w=160&q=100\n---\n\n## MVVM 的基本介绍\n\nMVVM（Model-View-ViewModel）是一种基于 MVC（Model-View-Controller）模式的衍生设计模式，它将应用程序分为三个部分：模型（Model）、视图（View）和视图模型（ViewModel）。\n\n1. 模型（Model）\n   模型是应用程序中的数据和业务逻辑层，它是一个独立的组件，负责数据的存储和处理。模型通常是被动的，也就是说它不知道视图和视图模型的存在，只负责提供数据和业务逻辑的处理。 **模型可以包含数据模型、网络模型、数据库模型等等，它们都负责对数据的获取、处理和存储**。\n2. 视图（View）\n   视图是应用程序的用户界面，它负责将模型中的数据展示给用户，并接收用户的操作反馈。视图负责应用程序的外观和交互，并且需要与用户进行直接的交互。视图通常由图形用户界面（GUI）组成，它包含了各种控件和布局信息，例如按钮、文本框、列表等等。\n3. 视图模型（ViewModel）\n   视图模型是 MVVM 模式的核心部分，它充当了视图和模型之间的中间层，将模型中的数据转换成视图可以使用的数据，并将视图反馈转换成模型可以处理的操作。视图模型还负责处理用户交互逻辑，例如校验输入、调用模型方法等。 **视图模型通过绑定机制将数据和视图绑定起来，当数据发生变化时，视图会自动更新**。\n\n总之，MVVM 模式通过将应用程序分为三个部分来分离用户界面和业务逻辑，使得应用程序更加容易维护和扩展。模型和视图模型之间使用双向数据绑定机制，使得视图模型和视图之间的通信变得更加轻松和高效。在实际开发中，MVVM 模式已经被广泛应用于 iOS、Android 和 Web 等平台的应用程序中。\n\n## MVVM 的正常架构\n\n![图一](https://i.imgur.com/nAFi2ds.png)\n\n这是一个很经典的 MVVM 架构图，但是当我们细化到 iOS 开发的时候这个架构图就有简单了。我们可以思考下面的几个问题：\n\n1. Controller 在这里被当成一个特殊的 View 对待的，合理么？\n2. View 层持有 ViewModel，方便测试么？\n3. Model 究竟是 Fat (胖) 还是 Thin (瘦) ？\n\n## MVVM 的 iOS 架构\n\n![图二](https://i.imgur.com/d9IeLxf.png)\n\n### Controller（控制器）\n\n在 iOS 中，Controller（控制器）通常被放在 View 层中处理，但是这种做法可能会导致代码的混乱和耦合度的增加。\n\n在传统的 iOS 开发中，Controller 负责将数据从模型传递给视图，并响应视图的事件和用户交互。然而，随着应用程序变得越来越复杂，Controller 所承担的责任也变得越来越多，它可能包含大量的业务逻辑和用户交互代码，导致代码难以维护和测试。此外，Controller 与特定的视图耦合度较高，使得重用和测试变得更加困难。\n\n因此，为了避免这些问题，我们可以将 Controller 的职责进行分离，将视图控制和业务逻辑分别放置在不同的层中。在这种情况下，Controller 可以变得更加轻量级，并将其主要职责放在视图控制上，而将业务逻辑和用户交互放在其他层中。\n\n一种常见的做法是采用 MVVM 模式，将视图控制和视图模型分离开来。视图模型负责管理视图所需的数据和逻辑，并提供双向绑定机制，将视图与模型解耦。Controller 则只需要负责处理视图的生命周期和响应路由，将视图和视图模型连接起来。\n\n因此，虽然 Controller 在 iOS 中通常被放在 View 层中处理，但是为了避免代码的混乱和耦合度的增加，我们应该将其职责进行分离，并采用合适的模式来进行架构设计。\n\n```Swift\nfinal class ViewController: UIViewController {\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view.\n        setupView()\n        setupViewModel()\n        setupBuriedPoint()\n    }\n    // MARK: View & ViewModel\n    func setupView() {\n        view.addSubview(aView)\n    }\n\n    func setupViewModel() {\n        aView.bind(viewModel: aViewModel)\n    }\n\n    // MARK: 埋点 & 日志\n    func setupBuriedPoint() {\n        aViewModel.searchEvent.subscribe {\n        }\n        aViewModel.likeEvent.subscribe {\n        }\n    }\n\n    // MARK: Life Cycle\n    override func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n    }\n\n    override func viewDidDisappear(_ animated: Bool) {\n        super.viewDidDisappear(animated)\n    }\n\n    // MARK: - View\n    private let aView = AView()\n\n    // MARK: - ViewModel\n    private let aViewModel = AViewModel()\n\n    // MARK: - Business Logic / Network Request / Event Handle 统统都不见了\n}\n```\n\n### View 和 ViewModel 数据绑定\n\n双向绑定：双向数据绑定是指在数据模型和视图控件之间建立双向的关联，当数据模型发生变化时，自动更新关联的视图控件；当视图控件发生变化时，自动更新关联的数据模型。实现双向数据绑定可以提高应用程序的开发效率和用户体验，降低代码的复杂度和维护成本。\n\n单向绑定：单向数据绑定是指在数据模型和视图控件之间建立单向的关联，当数据模型发生变化时，自动更新关联的视图控件，但是当视图控件发生变化时，不会自动更新关联的数据模型。\n\n![图三](https://i.imgur.com/mPKsPUN.png)\n\n### Model 应该是 Fat 还是 Thin\n\nFat Model 是指将所有的业务逻辑和数据操作都放在 Model 层中实现。在这种设计模式下，Model 层会变得比较庞大，甚至会包含一些与业务逻辑无关的代码，因此被称为“Fat Model”。\n\nThin Model 是指将 Model 层中的业务逻辑和数据操作进行拆分，只保留最基本的数据存储和数据操作功能。在这种设计模式下，业务逻辑和数据操作通常被放在其他层中实现，比如 Controller 层或者 Service 层，因此 Model 层相对来说比较“瘦”，被称为“Thin Model”。\n\n在过去的项目中，我通常会将 Model 层定义为介于 Fat 和 Thin 之间，因为我会将跟 Model 相关的网络请求和弱业务逻辑的代码放在这一层。\n\n我们来看看一般情况下在 ViewModel 层如何处理数据和网络相关的代码：\n\n```Swift\n// ViewModel 层处理网络和数据的伪代码\ndo {\n    let response = try await Network.request(method, path, parameter)\n    if response.code == 200 {\n        do {\n            let model = try AModel.decode(from: response.data)\n            AModel.saveToCache()\n        } catch {\n            // 处理 decode 的异常情况\n            if let model = AModel.getFromCache() {\n\n            } else {\n                // 没有缓存返回 error\n            }\n        }\n    } else {\n        // 处理非 200 的业务代码\n    }\n} catch {\n    // 处理网络请求的 error\n}\n```\n\n实际上，上述的网络请求、业务代码处理以及数据解析在每个 Model 中都大致相同（缓存处理属于弱业务逻辑的一部分，因为每个 Model 的数据缓存策略可能会有一些不同的业务需求）。因此，我们希望将这部分代码封装起来以便复用。有些项目可能会新建工具类来处理这部分代码，但我通常会将这些代码放在 Model 的 Extension/Category 中处理。\n\n```Swift\n// AModel.Extension.Swift\nextesion AModel {\n    static fetch() async throws -> AModel {\n        do {\n            let response = try await Network.request(method, path, parameter)\n            if response.code == 200 {\n                do {\n                    let model = try AModel.decode(from: response.data)\n                    AModel.saveToCache()\n                } catch {\n                    // 处理 decode 的异常情况\n                    if let model = AModel.getFromCache() {\n\n                    } else {\n                        // 没有缓存返回 error\n                        throw Error.cache\n                    }\n                }\n            } else {\n                // 处理非 200 的业务代码\n                throw Error.data\n            }\n        } catch {\n            // 处理网络请求的 error\n            throw Error.network\n        }\n    }\n}\n\n\n// AViewModel.Swift\nfinal class AViewModel {\n    func fetch() {\n        do {\n        \tlet model = try await AModel.fetch()\n        } catch {\n            // 处理不同类型的 error\n        }\n    }\n}\n```\n\n> 弱业务逻辑（Weak Business Logic）是指应用程序中的业务逻辑缺乏严谨性或者可扩展性，并且散落在项目中的各个地方，导致应用程序难以维护和扩展。现在我们通过上面的优化相当把很多弱业务逻辑的代码放到统一的层级来进行管理，有利于我们的代码维护。\n\n对于图形界面来说，最重要的是拿到数据进行页面渲染，并响应用户的输入并交给数据去处理。它们并不需要关心数据的来源和如何处理数据。通过我们之前的优化，ViewModel 基本上不需要知道网络和缓存的存在。Model 层的数据可能是从网络系统、文件系统、本地缓存等方式获取的，但是这些细节 ViewModel 不需要关心。\n\n**Model 可以包含数据模型、网络模型、数据库模型等等，它们都负责对数据的获取、处理和存储。**\n\n---\n\n参考文献：\n\n1. [iOS Architecture Patterns Demystifying MVC, MVP, MVVM and VIPER](https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.tliwdfd60)\n2. [iOS 应用架构谈 view 层的组织和调用方案](https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html)\n","slug":"iOS-中-MVVM-架构的一点思考","published":1,"updated":"2023-04-02T13:01:08.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfzevzx800004hse6p4zbkyr","content":"<h2 id=\"MVVM-的基本介绍\"><a href=\"#MVVM-的基本介绍\" class=\"headerlink\" title=\"MVVM 的基本介绍\"></a>MVVM 的基本介绍</h2><p>MVVM（Model-View-ViewModel）是一种基于 MVC（Model-View-Controller）模式的衍生设计模式，它将应用程序分为三个部分：模型（Model）、视图（View）和视图模型（ViewModel）。</p>\n<ol>\n<li>模型（Model）<br>模型是应用程序中的数据和业务逻辑层，它是一个独立的组件，负责数据的存储和处理。模型通常是被动的，也就是说它不知道视图和视图模型的存在，只负责提供数据和业务逻辑的处理。 <strong>模型可以包含数据模型、网络模型、数据库模型等等，它们都负责对数据的获取、处理和存储</strong>。</li>\n<li>视图（View）<br>视图是应用程序的用户界面，它负责将模型中的数据展示给用户，并接收用户的操作反馈。视图负责应用程序的外观和交互，并且需要与用户进行直接的交互。视图通常由图形用户界面（GUI）组成，它包含了各种控件和布局信息，例如按钮、文本框、列表等等。</li>\n<li>视图模型（ViewModel）<br>视图模型是 MVVM 模式的核心部分，它充当了视图和模型之间的中间层，将模型中的数据转换成视图可以使用的数据，并将视图反馈转换成模型可以处理的操作。视图模型还负责处理用户交互逻辑，例如校验输入、调用模型方法等。 <strong>视图模型通过绑定机制将数据和视图绑定起来，当数据发生变化时，视图会自动更新</strong>。</li>\n</ol>\n<p>总之，MVVM 模式通过将应用程序分为三个部分来分离用户界面和业务逻辑，使得应用程序更加容易维护和扩展。模型和视图模型之间使用双向数据绑定机制，使得视图模型和视图之间的通信变得更加轻松和高效。在实际开发中，MVVM 模式已经被广泛应用于 iOS、Android 和 Web 等平台的应用程序中。</p>\n<h2 id=\"MVVM-的正常架构\"><a href=\"#MVVM-的正常架构\" class=\"headerlink\" title=\"MVVM 的正常架构\"></a>MVVM 的正常架构</h2><p><img src=\"https://i.imgur.com/nAFi2ds.png\" alt=\"图一\"></p>\n<p>这是一个很经典的 MVVM 架构图，但是当我们细化到 iOS 开发的时候这个架构图就有简单了。我们可以思考下面的几个问题：</p>\n<ol>\n<li>Controller 在这里被当成一个特殊的 View 对待的，合理么？</li>\n<li>View 层持有 ViewModel，方便测试么？</li>\n<li>Model 究竟是 Fat (胖) 还是 Thin (瘦) ？</li>\n</ol>\n<h2 id=\"MVVM-的-iOS-架构\"><a href=\"#MVVM-的-iOS-架构\" class=\"headerlink\" title=\"MVVM 的 iOS 架构\"></a>MVVM 的 iOS 架构</h2><p><img src=\"https://i.imgur.com/d9IeLxf.png\" alt=\"图二\"></p>\n<h3 id=\"Controller（控制器）\"><a href=\"#Controller（控制器）\" class=\"headerlink\" title=\"Controller（控制器）\"></a>Controller（控制器）</h3><p>在 iOS 中，Controller（控制器）通常被放在 View 层中处理，但是这种做法可能会导致代码的混乱和耦合度的增加。</p>\n<p>在传统的 iOS 开发中，Controller 负责将数据从模型传递给视图，并响应视图的事件和用户交互。然而，随着应用程序变得越来越复杂，Controller 所承担的责任也变得越来越多，它可能包含大量的业务逻辑和用户交互代码，导致代码难以维护和测试。此外，Controller 与特定的视图耦合度较高，使得重用和测试变得更加困难。</p>\n<p>因此，为了避免这些问题，我们可以将 Controller 的职责进行分离，将视图控制和业务逻辑分别放置在不同的层中。在这种情况下，Controller 可以变得更加轻量级，并将其主要职责放在视图控制上，而将业务逻辑和用户交互放在其他层中。</p>\n<p>一种常见的做法是采用 MVVM 模式，将视图控制和视图模型分离开来。视图模型负责管理视图所需的数据和逻辑，并提供双向绑定机制，将视图与模型解耦。Controller 则只需要负责处理视图的生命周期和响应路由，将视图和视图模型连接起来。</p>\n<p>因此，虽然 Controller 在 iOS 中通常被放在 View 层中处理，但是为了避免代码的混乱和耦合度的增加，我们应该将其职责进行分离，并采用合适的模式来进行架构设计。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ViewController</span>: <span class=\"title class_\">UIViewController</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">viewDidLoad</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        <span class=\"comment\">// Do any additional setup after loading the view.</span></span><br><span class=\"line\">        setupView()</span><br><span class=\"line\">        setupViewModel()</span><br><span class=\"line\">        setupBuriedPoint()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// MARK: View &amp; ViewModel</span></span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">setupView</span>() &#123;</span><br><span class=\"line\">        view.addSubview(aView)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">setupViewModel</span>() &#123;</span><br><span class=\"line\">        aView.bind(viewModel: aViewModel)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// MARK: 埋点 &amp; 日志</span></span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">setupBuriedPoint</span>() &#123;</span><br><span class=\"line\">        aViewModel.searchEvent.subscribe &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        aViewModel.likeEvent.subscribe &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// MARK: Life Cycle</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">viewDidAppear</span>(<span class=\"keyword\">_</span> <span class=\"params\">animated</span>: <span class=\"type\">Bool</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidAppear(animated)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">viewDidDisappear</span>(<span class=\"keyword\">_</span> <span class=\"params\">animated</span>: <span class=\"type\">Bool</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidDisappear(animated)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// MARK: - View</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> aView <span class=\"operator\">=</span> <span class=\"type\">AView</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// MARK: - ViewModel</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> aViewModel <span class=\"operator\">=</span> <span class=\"type\">AViewModel</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// MARK: - Business Logic / Network Request / Event Handle 统统都不见了</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"View-和-ViewModel-数据绑定\"><a href=\"#View-和-ViewModel-数据绑定\" class=\"headerlink\" title=\"View 和 ViewModel 数据绑定\"></a>View 和 ViewModel 数据绑定</h3><p>双向绑定：双向数据绑定是指在数据模型和视图控件之间建立双向的关联，当数据模型发生变化时，自动更新关联的视图控件；当视图控件发生变化时，自动更新关联的数据模型。实现双向数据绑定可以提高应用程序的开发效率和用户体验，降低代码的复杂度和维护成本。</p>\n<p>单向绑定：单向数据绑定是指在数据模型和视图控件之间建立单向的关联，当数据模型发生变化时，自动更新关联的视图控件，但是当视图控件发生变化时，不会自动更新关联的数据模型。</p>\n<p><img src=\"https://i.imgur.com/mPKsPUN.png\" alt=\"图三\"></p>\n<h3 id=\"Model-应该是-Fat-还是-Thin\"><a href=\"#Model-应该是-Fat-还是-Thin\" class=\"headerlink\" title=\"Model 应该是 Fat 还是 Thin\"></a>Model 应该是 Fat 还是 Thin</h3><p>Fat Model 是指将所有的业务逻辑和数据操作都放在 Model 层中实现。在这种设计模式下，Model 层会变得比较庞大，甚至会包含一些与业务逻辑无关的代码，因此被称为“Fat Model”。</p>\n<p>Thin Model 是指将 Model 层中的业务逻辑和数据操作进行拆分，只保留最基本的数据存储和数据操作功能。在这种设计模式下，业务逻辑和数据操作通常被放在其他层中实现，比如 Controller 层或者 Service 层，因此 Model 层相对来说比较“瘦”，被称为“Thin Model”。</p>\n<p>在过去的项目中，我通常会将 Model 层定义为介于 Fat 和 Thin 之间，因为我会将跟 Model 相关的网络请求和弱业务逻辑的代码放在这一层。</p>\n<p>我们来看看一般情况下在 ViewModel 层如何处理数据和网络相关的代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ViewModel 层处理网络和数据的伪代码</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> response <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> <span class=\"type\">Network</span>.request(method, path, parameter)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> response.code <span class=\"operator\">==</span> <span class=\"number\">200</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> model <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"type\">AModel</span>.decode(from: response.data)</span><br><span class=\"line\">            <span class=\"type\">AModel</span>.saveToCache()</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理 decode 的异常情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> model <span class=\"operator\">=</span> <span class=\"type\">AModel</span>.getFromCache() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没有缓存返回 error</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理非 200 的业务代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理网络请求的 error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，上述的网络请求、业务代码处理以及数据解析在每个 Model 中都大致相同（缓存处理属于弱业务逻辑的一部分，因为每个 Model 的数据缓存策略可能会有一些不同的业务需求）。因此，我们希望将这部分代码封装起来以便复用。有些项目可能会新建工具类来处理这部分代码，但我通常会将这些代码放在 Model 的 Extension&#x2F;Category 中处理。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AModel.Extension.Swift</span></span><br><span class=\"line\">extesion <span class=\"type\">AModel</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> fetch() <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">AModel</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> response <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> <span class=\"type\">Network</span>.request(method, path, parameter)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> response.code <span class=\"operator\">==</span> <span class=\"number\">200</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">let</span> model <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"type\">AModel</span>.decode(from: response.data)</span><br><span class=\"line\">                    <span class=\"type\">AModel</span>.saveToCache()</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 处理 decode 的异常情况</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> model <span class=\"operator\">=</span> <span class=\"type\">AModel</span>.getFromCache() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 没有缓存返回 error</span></span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"type\">Error</span>.cache</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 处理非 200 的业务代码</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"type\">Error</span>.data</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理网络请求的 error</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">Error</span>.network</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AViewModel.Swift</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AViewModel</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">fetch</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">let</span> model <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> <span class=\"type\">AModel</span>.fetch()</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理不同类型的 error</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>弱业务逻辑（Weak Business Logic）是指应用程序中的业务逻辑缺乏严谨性或者可扩展性，并且散落在项目中的各个地方，导致应用程序难以维护和扩展。现在我们通过上面的优化相当把很多弱业务逻辑的代码放到统一的层级来进行管理，有利于我们的代码维护。</p>\n</blockquote>\n<p>对于图形界面来说，最重要的是拿到数据进行页面渲染，并响应用户的输入并交给数据去处理。它们并不需要关心数据的来源和如何处理数据。通过我们之前的优化，ViewModel 基本上不需要知道网络和缓存的存在。Model 层的数据可能是从网络系统、文件系统、本地缓存等方式获取的，但是这些细节 ViewModel 不需要关心。</p>\n<p><strong>Model 可以包含数据模型、网络模型、数据库模型等等，它们都负责对数据的获取、处理和存储。</strong></p>\n<hr>\n<p>参考文献：</p>\n<ol>\n<li><a href=\"https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.tliwdfd60\">iOS Architecture Patterns Demystifying MVC, MVP, MVVM and VIPER</a></li>\n<li><a href=\"https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html\">iOS 应用架构谈 view 层的组织和调用方案</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"MVVM-的基本介绍\"><a href=\"#MVVM-的基本介绍\" class=\"headerlink\" title=\"MVVM 的基本介绍\"></a>MVVM 的基本介绍</h2><p>MVVM（Model-View-ViewModel）是一种基于 MVC（Model-View-Controller）模式的衍生设计模式，它将应用程序分为三个部分：模型（Model）、视图（View）和视图模型（ViewModel）。</p>\n<ol>\n<li>模型（Model）<br>模型是应用程序中的数据和业务逻辑层，它是一个独立的组件，负责数据的存储和处理。模型通常是被动的，也就是说它不知道视图和视图模型的存在，只负责提供数据和业务逻辑的处理。 <strong>模型可以包含数据模型、网络模型、数据库模型等等，它们都负责对数据的获取、处理和存储</strong>。</li>\n<li>视图（View）<br>视图是应用程序的用户界面，它负责将模型中的数据展示给用户，并接收用户的操作反馈。视图负责应用程序的外观和交互，并且需要与用户进行直接的交互。视图通常由图形用户界面（GUI）组成，它包含了各种控件和布局信息，例如按钮、文本框、列表等等。</li>\n<li>视图模型（ViewModel）<br>视图模型是 MVVM 模式的核心部分，它充当了视图和模型之间的中间层，将模型中的数据转换成视图可以使用的数据，并将视图反馈转换成模型可以处理的操作。视图模型还负责处理用户交互逻辑，例如校验输入、调用模型方法等。 <strong>视图模型通过绑定机制将数据和视图绑定起来，当数据发生变化时，视图会自动更新</strong>。</li>\n</ol>\n<p>总之，MVVM 模式通过将应用程序分为三个部分来分离用户界面和业务逻辑，使得应用程序更加容易维护和扩展。模型和视图模型之间使用双向数据绑定机制，使得视图模型和视图之间的通信变得更加轻松和高效。在实际开发中，MVVM 模式已经被广泛应用于 iOS、Android 和 Web 等平台的应用程序中。</p>\n<h2 id=\"MVVM-的正常架构\"><a href=\"#MVVM-的正常架构\" class=\"headerlink\" title=\"MVVM 的正常架构\"></a>MVVM 的正常架构</h2><p><img src=\"https://i.imgur.com/nAFi2ds.png\" alt=\"图一\"></p>\n<p>这是一个很经典的 MVVM 架构图，但是当我们细化到 iOS 开发的时候这个架构图就有简单了。我们可以思考下面的几个问题：</p>\n<ol>\n<li>Controller 在这里被当成一个特殊的 View 对待的，合理么？</li>\n<li>View 层持有 ViewModel，方便测试么？</li>\n<li>Model 究竟是 Fat (胖) 还是 Thin (瘦) ？</li>\n</ol>\n<h2 id=\"MVVM-的-iOS-架构\"><a href=\"#MVVM-的-iOS-架构\" class=\"headerlink\" title=\"MVVM 的 iOS 架构\"></a>MVVM 的 iOS 架构</h2><p><img src=\"https://i.imgur.com/d9IeLxf.png\" alt=\"图二\"></p>\n<h3 id=\"Controller（控制器）\"><a href=\"#Controller（控制器）\" class=\"headerlink\" title=\"Controller（控制器）\"></a>Controller（控制器）</h3><p>在 iOS 中，Controller（控制器）通常被放在 View 层中处理，但是这种做法可能会导致代码的混乱和耦合度的增加。</p>\n<p>在传统的 iOS 开发中，Controller 负责将数据从模型传递给视图，并响应视图的事件和用户交互。然而，随着应用程序变得越来越复杂，Controller 所承担的责任也变得越来越多，它可能包含大量的业务逻辑和用户交互代码，导致代码难以维护和测试。此外，Controller 与特定的视图耦合度较高，使得重用和测试变得更加困难。</p>\n<p>因此，为了避免这些问题，我们可以将 Controller 的职责进行分离，将视图控制和业务逻辑分别放置在不同的层中。在这种情况下，Controller 可以变得更加轻量级，并将其主要职责放在视图控制上，而将业务逻辑和用户交互放在其他层中。</p>\n<p>一种常见的做法是采用 MVVM 模式，将视图控制和视图模型分离开来。视图模型负责管理视图所需的数据和逻辑，并提供双向绑定机制，将视图与模型解耦。Controller 则只需要负责处理视图的生命周期和响应路由，将视图和视图模型连接起来。</p>\n<p>因此，虽然 Controller 在 iOS 中通常被放在 View 层中处理，但是为了避免代码的混乱和耦合度的增加，我们应该将其职责进行分离，并采用合适的模式来进行架构设计。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ViewController</span>: <span class=\"title class_\">UIViewController</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">viewDidLoad</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        <span class=\"comment\">// Do any additional setup after loading the view.</span></span><br><span class=\"line\">        setupView()</span><br><span class=\"line\">        setupViewModel()</span><br><span class=\"line\">        setupBuriedPoint()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// MARK: View &amp; ViewModel</span></span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">setupView</span>() &#123;</span><br><span class=\"line\">        view.addSubview(aView)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">setupViewModel</span>() &#123;</span><br><span class=\"line\">        aView.bind(viewModel: aViewModel)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// MARK: 埋点 &amp; 日志</span></span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">setupBuriedPoint</span>() &#123;</span><br><span class=\"line\">        aViewModel.searchEvent.subscribe &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        aViewModel.likeEvent.subscribe &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// MARK: Life Cycle</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">viewDidAppear</span>(<span class=\"keyword\">_</span> <span class=\"params\">animated</span>: <span class=\"type\">Bool</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidAppear(animated)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">viewDidDisappear</span>(<span class=\"keyword\">_</span> <span class=\"params\">animated</span>: <span class=\"type\">Bool</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidDisappear(animated)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// MARK: - View</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> aView <span class=\"operator\">=</span> <span class=\"type\">AView</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// MARK: - ViewModel</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> aViewModel <span class=\"operator\">=</span> <span class=\"type\">AViewModel</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// MARK: - Business Logic / Network Request / Event Handle 统统都不见了</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"View-和-ViewModel-数据绑定\"><a href=\"#View-和-ViewModel-数据绑定\" class=\"headerlink\" title=\"View 和 ViewModel 数据绑定\"></a>View 和 ViewModel 数据绑定</h3><p>双向绑定：双向数据绑定是指在数据模型和视图控件之间建立双向的关联，当数据模型发生变化时，自动更新关联的视图控件；当视图控件发生变化时，自动更新关联的数据模型。实现双向数据绑定可以提高应用程序的开发效率和用户体验，降低代码的复杂度和维护成本。</p>\n<p>单向绑定：单向数据绑定是指在数据模型和视图控件之间建立单向的关联，当数据模型发生变化时，自动更新关联的视图控件，但是当视图控件发生变化时，不会自动更新关联的数据模型。</p>\n<p><img src=\"https://i.imgur.com/mPKsPUN.png\" alt=\"图三\"></p>\n<h3 id=\"Model-应该是-Fat-还是-Thin\"><a href=\"#Model-应该是-Fat-还是-Thin\" class=\"headerlink\" title=\"Model 应该是 Fat 还是 Thin\"></a>Model 应该是 Fat 还是 Thin</h3><p>Fat Model 是指将所有的业务逻辑和数据操作都放在 Model 层中实现。在这种设计模式下，Model 层会变得比较庞大，甚至会包含一些与业务逻辑无关的代码，因此被称为“Fat Model”。</p>\n<p>Thin Model 是指将 Model 层中的业务逻辑和数据操作进行拆分，只保留最基本的数据存储和数据操作功能。在这种设计模式下，业务逻辑和数据操作通常被放在其他层中实现，比如 Controller 层或者 Service 层，因此 Model 层相对来说比较“瘦”，被称为“Thin Model”。</p>\n<p>在过去的项目中，我通常会将 Model 层定义为介于 Fat 和 Thin 之间，因为我会将跟 Model 相关的网络请求和弱业务逻辑的代码放在这一层。</p>\n<p>我们来看看一般情况下在 ViewModel 层如何处理数据和网络相关的代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ViewModel 层处理网络和数据的伪代码</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> response <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> <span class=\"type\">Network</span>.request(method, path, parameter)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> response.code <span class=\"operator\">==</span> <span class=\"number\">200</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> model <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"type\">AModel</span>.decode(from: response.data)</span><br><span class=\"line\">            <span class=\"type\">AModel</span>.saveToCache()</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理 decode 的异常情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> model <span class=\"operator\">=</span> <span class=\"type\">AModel</span>.getFromCache() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没有缓存返回 error</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理非 200 的业务代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理网络请求的 error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，上述的网络请求、业务代码处理以及数据解析在每个 Model 中都大致相同（缓存处理属于弱业务逻辑的一部分，因为每个 Model 的数据缓存策略可能会有一些不同的业务需求）。因此，我们希望将这部分代码封装起来以便复用。有些项目可能会新建工具类来处理这部分代码，但我通常会将这些代码放在 Model 的 Extension&#x2F;Category 中处理。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AModel.Extension.Swift</span></span><br><span class=\"line\">extesion <span class=\"type\">AModel</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> fetch() <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">AModel</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> response <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> <span class=\"type\">Network</span>.request(method, path, parameter)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> response.code <span class=\"operator\">==</span> <span class=\"number\">200</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">let</span> model <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"type\">AModel</span>.decode(from: response.data)</span><br><span class=\"line\">                    <span class=\"type\">AModel</span>.saveToCache()</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 处理 decode 的异常情况</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> model <span class=\"operator\">=</span> <span class=\"type\">AModel</span>.getFromCache() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 没有缓存返回 error</span></span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"type\">Error</span>.cache</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 处理非 200 的业务代码</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"type\">Error</span>.data</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理网络请求的 error</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">Error</span>.network</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AViewModel.Swift</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AViewModel</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">fetch</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">let</span> model <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> <span class=\"type\">AModel</span>.fetch()</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理不同类型的 error</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>弱业务逻辑（Weak Business Logic）是指应用程序中的业务逻辑缺乏严谨性或者可扩展性，并且散落在项目中的各个地方，导致应用程序难以维护和扩展。现在我们通过上面的优化相当把很多弱业务逻辑的代码放到统一的层级来进行管理，有利于我们的代码维护。</p>\n</blockquote>\n<p>对于图形界面来说，最重要的是拿到数据进行页面渲染，并响应用户的输入并交给数据去处理。它们并不需要关心数据的来源和如何处理数据。通过我们之前的优化，ViewModel 基本上不需要知道网络和缓存的存在。Model 层的数据可能是从网络系统、文件系统、本地缓存等方式获取的，但是这些细节 ViewModel 不需要关心。</p>\n<p><strong>Model 可以包含数据模型、网络模型、数据库模型等等，它们都负责对数据的获取、处理和存储。</strong></p>\n<hr>\n<p>参考文献：</p>\n<ol>\n<li><a href=\"https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.tliwdfd60\">iOS Architecture Patterns Demystifying MVC, MVP, MVVM and VIPER</a></li>\n<li><a href=\"https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html\">iOS 应用架构谈 view 层的组织和调用方案</a></li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cldr5xjcd0001jbse0mk64o6z","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjcj000kjbsebnvx7r3y"},{"post_id":"cldr5xjch0009jbseddmp63iu","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjck000njbsef9ja5g6p"},{"post_id":"cldr5xjci000djbse2k2udjma","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjcl000rjbsebav53x4d"},{"post_id":"cldr5xjce0003jbse58249kfv","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjcl000ujbseazxs66a7"},{"post_id":"cldr5xjcj000fjbse8gb56nya","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjcl000yjbsecp7ybt4v"},{"post_id":"cldr5xjcj000jjbsec8gj5k4m","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjcm0011jbsecdg2311e"},{"post_id":"cldr5xjcg0007jbse5zuxhbby","category_id":"cldr5xjcj000hjbseen72d8ih","_id":"cldr5xjcm0014jbsegyh9doh6"},{"post_id":"cldr5xjck000mjbsehmq36kz3","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjcm0018jbsebc9uabew"},{"post_id":"cldr5xjck000qjbsecievhr1d","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjcn001bjbse1lced12r"},{"post_id":"cldr5xjcl000tjbseb7hj7soz","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjcn001fjbse5eud968s"},{"post_id":"cldr5xjcl000xjbse6expd1an","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjcn001ijbse4ohe0ggr"},{"post_id":"cldr5xjcl0010jbse5ffpc4od","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjco001mjbse6kbwearv"},{"post_id":"cldr5xjcm0013jbse3lm1fvj4","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjco001pjbseeoi1ftmf"},{"post_id":"cldr5xjcm0017jbse4b7l950g","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjco001sjbsegdf4ajni"},{"post_id":"cldr5xjcm001ajbseeq1vae8c","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjco001ujbse4cg0ezt2"},{"post_id":"cldr5xjcn001ejbsehb4gg1w0","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjco001xjbseeh59f7l9"},{"post_id":"cldr5xjcn001hjbse9z066sex","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjco001zjbsedv3pa3yj"},{"post_id":"cldr5xjcn001ljbsegq3d2xpq","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjco0021jbse9jdo9rsd"},{"post_id":"cldr5xjco001ojbse7ej2hae7","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjco0024jbse55tv4ohx"},{"post_id":"cldr5xjcq002mjbseda8qbjuv","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cldr5xjcq002pjbse4jnp9xfw"},{"post_id":"clegtszv300002esehbhv6zpd","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"clegtszv800022ese1v5l4v6f"},{"post_id":"cleknwjsm0000o5sefn4dhsfx","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cleknwjsw0006o5seh5pw8fnm"},{"post_id":"cleknwjst0001o5se8s4q6aa5","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cleknwjsw0008o5sefz3b0v5c"},{"post_id":"cleknwjsv0003o5sebp0ubuit","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cleknwjsw000ao5sebdfkeagh"},{"post_id":"cleknwjsv0005o5se81cxf2sd","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cleknwjsx000bo5seamk6bhm3"},{"post_id":"cleknwjsy000co5sebaekbx3f","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"cleknwjsz000eo5se8elg7qqf"},{"post_id":"clfzevzx800004hse6p4zbkyr","category_id":"cldr5xjcf0004jbse0tiafcq6","_id":"clfzevzxb00024hse5lkm55dk"}],"PostTag":[{"post_id":"cldr5xjch0009jbseddmp63iu","tag_id":"cldr5xjcg0005jbse23ho178e","_id":"cldr5xjcj000ejbse85ze4tze"},{"post_id":"cldr5xjcd0001jbse0mk64o6z","tag_id":"cldr5xjcg0005jbse23ho178e","_id":"cldr5xjcj000ljbse2ajh33uo"},{"post_id":"cldr5xjcd0001jbse0mk64o6z","tag_id":"cldr5xjch000bjbse0a843gen","_id":"cldr5xjck000ojbse2nzuge5j"},{"post_id":"cldr5xjcj000jjbsec8gj5k4m","tag_id":"cldr5xjcg0005jbse23ho178e","_id":"cldr5xjcl000sjbse06egehmc"},{"post_id":"cldr5xjcj000jjbsec8gj5k4m","tag_id":"cldr5xjch000bjbse0a843gen","_id":"cldr5xjcl000vjbse3th791in"},{"post_id":"cldr5xjce0003jbse58249kfv","tag_id":"cldr5xjcj000ijbse7k470sl6","_id":"cldr5xjcl000zjbse8s60f7q3"},{"post_id":"cldr5xjck000mjbsehmq36kz3","tag_id":"cldr5xjcg0005jbse23ho178e","_id":"cldr5xjcm0012jbse2w3h6nr6"},{"post_id":"cldr5xjck000mjbsehmq36kz3","tag_id":"cldr5xjch000bjbse0a843gen","_id":"cldr5xjcm0016jbse7zcafgq3"},{"post_id":"cldr5xjck000qjbsecievhr1d","tag_id":"cldr5xjcg0005jbse23ho178e","_id":"cldr5xjcm0019jbse371fehgi"},{"post_id":"cldr5xjck000qjbsecievhr1d","tag_id":"cldr5xjch000bjbse0a843gen","_id":"cldr5xjcn001cjbseaa3paogv"},{"post_id":"cldr5xjcg0007jbse5zuxhbby","tag_id":"cldr5xjck000pjbsed2ax1fll","_id":"cldr5xjcn001gjbseelxt089l"},{"post_id":"cldr5xjcl000tjbseb7hj7soz","tag_id":"cldr5xjcg0005jbse23ho178e","_id":"cldr5xjcn001jjbse8pdodbvp"},{"post_id":"cldr5xjcl0010jbse5ffpc4od","tag_id":"cldr5xjcg0005jbse23ho178e","_id":"cldr5xjco001njbse3wyq5l3v"},{"post_id":"cldr5xjci000djbse2k2udjma","tag_id":"cldr5xjcg0005jbse23ho178e","_id":"cldr5xjco001qjbseaxo12v87"},{"post_id":"cldr5xjci000djbse2k2udjma","tag_id":"cldr5xjcl000wjbseh5y09n2p","_id":"cldr5xjco001tjbsea73u59v0"},{"post_id":"cldr5xjcj000fjbse8gb56nya","tag_id":"cldr5xjcm0015jbsebmavfn6d","_id":"cldr5xjco001vjbseerrx3u2g"},{"post_id":"cldr5xjcl000xjbse6expd1an","tag_id":"cldr5xjcm0015jbsebmavfn6d","_id":"cldr5xjco001yjbsea35xck44"},{"post_id":"cldr5xjcn001ljbsegq3d2xpq","tag_id":"cldr5xjcg0005jbse23ho178e","_id":"cldr5xjco0020jbsebgm41wwa"},{"post_id":"cldr5xjco001ojbse7ej2hae7","tag_id":"cldr5xjcg0005jbse23ho178e","_id":"cldr5xjco0023jbse6ws0a215"},{"post_id":"cldr5xjco001ojbse7ej2hae7","tag_id":"cldr5xjch000bjbse0a843gen","_id":"cldr5xjcp0025jbse4ku9bsyh"},{"post_id":"cldr5xjcm0013jbse3lm1fvj4","tag_id":"cldr5xjcn001kjbse1jdhg40v","_id":"cldr5xjcp0026jbse6el7hywl"},{"post_id":"cldr5xjcm0013jbse3lm1fvj4","tag_id":"cldr5xjco001rjbsec2i89dp0","_id":"cldr5xjcp0028jbse9vksf721"},{"post_id":"cldr5xjcm0017jbse4b7l950g","tag_id":"cldr5xjcg0005jbse23ho178e","_id":"cldr5xjcp0029jbseeh78eb9s"},{"post_id":"cldr5xjcm0017jbse4b7l950g","tag_id":"cldr5xjco001wjbsedxyqc8q9","_id":"cldr5xjcp002bjbse38396m0w"},{"post_id":"cldr5xjcm0017jbse4b7l950g","tag_id":"cldr5xjco0022jbsegxn32iek","_id":"cldr5xjcp002cjbse9qxnf0k5"},{"post_id":"cldr5xjcm001ajbseeq1vae8c","tag_id":"cldr5xjcg0005jbse23ho178e","_id":"cldr5xjcp002ejbse4rp18ddb"},{"post_id":"cldr5xjcm001ajbseeq1vae8c","tag_id":"cldr5xjcp0027jbsehoz2gjc4","_id":"cldr5xjcp002fjbseh9ur604t"},{"post_id":"cldr5xjcn001ejbsehb4gg1w0","tag_id":"cldr5xjcg0005jbse23ho178e","_id":"cldr5xjcp002hjbsegklu8gxg"},{"post_id":"cldr5xjcn001ejbsehb4gg1w0","tag_id":"cldr5xjcn001kjbse1jdhg40v","_id":"cldr5xjcp002ijbse1cbq3zf7"},{"post_id":"cldr5xjcn001hjbse9z066sex","tag_id":"cldr5xjcg0005jbse23ho178e","_id":"cldr5xjcp002jjbseggg98n95"},{"post_id":"cldr5xjcn001hjbse9z066sex","tag_id":"cldr5xjco001wjbsedxyqc8q9","_id":"cldr5xjcp002kjbseaiqh352i"},{"post_id":"cldr5xjcn001hjbse9z066sex","tag_id":"cldr5xjcp0027jbsehoz2gjc4","_id":"cldr5xjcp002ljbse14ou1fb8"},{"post_id":"cldr5xjcq002mjbseda8qbjuv","tag_id":"cldr5xjcg0005jbse23ho178e","_id":"cldr5xjcq002njbse3hcj6dzz"},{"post_id":"cldr5xjcq002mjbseda8qbjuv","tag_id":"cldr5xjco001wjbsedxyqc8q9","_id":"cldr5xjcq002ojbse3aedbtr9"},{"post_id":"clegtszv300002esehbhv6zpd","tag_id":"cldr5xjcg0005jbse23ho178e","_id":"clegtszv800012ese5td91xyy"},{"post_id":"cleknwjsm0000o5sefn4dhsfx","tag_id":"cldr5xjcj000ijbse7k470sl6","_id":"cleknwjsv0002o5se070946in"},{"post_id":"cleknwjst0001o5se8s4q6aa5","tag_id":"cldr5xjcj000ijbse7k470sl6","_id":"cleknwjsv0004o5seaija6bq6"},{"post_id":"cleknwjsv0003o5sebp0ubuit","tag_id":"cldr5xjcj000ijbse7k470sl6","_id":"cleknwjsw0007o5se16bbbsnk"},{"post_id":"cleknwjsv0005o5se81cxf2sd","tag_id":"cldr5xjcj000ijbse7k470sl6","_id":"cleknwjsw0009o5sehqlu6gzw"},{"post_id":"cleknwjsy000co5sebaekbx3f","tag_id":"cldr5xjcj000ijbse7k470sl6","_id":"cleknwjsz000do5se9ay4h87g"},{"post_id":"clfzevzx800004hse6p4zbkyr","tag_id":"cldr5xjcg0005jbse23ho178e","_id":"clfzevzxb00014hse3pfmb4hk"}],"Tag":[{"name":"iOS","_id":"cldr5xjcg0005jbse23ho178e"},{"name":"Swift","_id":"cldr5xjch000bjbse0a843gen"},{"name":"其他","_id":"cldr5xjcj000ijbse7k470sl6"},{"name":"Raspberry PI","_id":"cldr5xjck000pjbsed2ax1fll"},{"name":"RAC","_id":"cldr5xjcl000wjbseh5y09n2p"},{"name":"tip","_id":"cldr5xjcm0015jbsebmavfn6d"},{"name":"RN","_id":"cldr5xjcn001kjbse1jdhg40v"},{"name":"redux","_id":"cldr5xjco001rjbsec2i89dp0"},{"name":"Objective-C","_id":"cldr5xjco001wjbsedxyqc8q9"},{"name":"Block","_id":"cldr5xjco0022jbsegxn32iek"},{"name":"GCD","_id":"cldr5xjcp0027jbsehoz2gjc4"}]}}