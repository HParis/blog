{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/images/logo.png","path":"css/images/logo.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/images/avatar.png","path":"css/images/avatar.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","path":"css/images/thumb-default-small.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/justified-gallery/justifiedGallery.min.css","path":"libs/justified-gallery/justifiedGallery.min.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/justified-gallery/jquery.justifiedGallery.min.js","path":"libs/justified-gallery/jquery.justifiedGallery.min.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/styles.css","path":"libs/open-sans/styles.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/source-code-pro/styles.css","path":"libs/source-code-pro/styles.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/css/font-awesome.css","path":"libs/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/css/font-awesome.min.css","path":"libs/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css","path":"libs/lightgallery/css/lg-fb-comment-box.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.min.css","path":"libs/lightgallery/css/lg-fb-comment-box.min.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css.map","path":"libs/lightgallery/css/lg-fb-comment-box.css.map","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css","path":"libs/lightgallery/css/lg-transitions.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css.map","path":"libs/lightgallery/css/lg-transitions.css.map","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css","path":"libs/lightgallery/css/lightgallery.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.min.css","path":"libs/lightgallery/css/lg-transitions.min.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css.map","path":"libs/lightgallery/css/lightgallery.css.map","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.svg","path":"libs/lightgallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.min.css","path":"libs/lightgallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.eot","path":"libs/lightgallery/fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.ttf","path":"libs/lightgallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.woff","path":"libs/lightgallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/loading.gif","path":"libs/lightgallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/vimeo-play.png","path":"libs/lightgallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/youtube-play.png","path":"libs/lightgallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/img/video-play.png","path":"libs/lightgallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.js","path":"libs/lightgallery/js/lg-autoplay.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.js","path":"libs/lightgallery/js/lg-hash.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.min.js","path":"libs/lightgallery/js/lg-fullscreen.min.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.min.js","path":"libs/lightgallery/js/lg-autoplay.min.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.js","path":"libs/lightgallery/js/lg-fullscreen.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.min.js","path":"libs/lightgallery/js/lg-pager.min.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.min.js","path":"libs/lightgallery/js/lg-hash.min.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.js","path":"libs/lightgallery/js/lg-pager.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.js","path":"libs/lightgallery/js/lg-share.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.min.js","path":"libs/lightgallery/js/lg-share.min.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.js","path":"libs/lightgallery/js/lg-thumbnail.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.min.js","path":"libs/lightgallery/js/lg-thumbnail.min.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.js","path":"libs/lightgallery/js/lg-video.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.min.js","path":"libs/lightgallery/js/lg-video.min.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.js","path":"libs/lightgallery/js/lg-zoom.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.min.js","path":"libs/lightgallery/js/lg-zoom.min.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.js","path":"libs/lightgallery/js/lightgallery.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.min.js","path":"libs/lightgallery/js/lightgallery.min.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","path":"libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","path":"libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","path":"libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","path":"libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","path":"libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/fonts/FontAwesome.otf","path":"libs/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.eot","path":"libs/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","path":"libs/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff","path":"libs/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/jquery/2.1.3/jquery.min.js","path":"libs/jquery/2.1.3/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","path":"libs/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.svg","path":"libs/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"48a7cc6f178a0489ee89f137b7519b9b66881768","modified":1520317456842},{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1520317319975},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1520317319975},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1520317319975},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1520317319976},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1520317319976},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1520317319990},{"_id":"source/_posts/Auto-Update.md","hash":"7d75762fa5efbfd295b80d55bbb5ae7656729d14","modified":1520320049378},{"_id":"source/_posts/Raspberry-PI-基本使用.md","hash":"845921c8860c009bde7905cca97d85bac5bedc4d","modified":1520320062313},{"_id":"source/_posts/Swift-High-Performance-Tip 1：Array和ContiguousArray.md","hash":"0fbbd143a290139a612712cc014f9f36c9492c71","modified":1520320003216},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1520318457666},{"_id":"source/_posts/Swift-High-Performance-Tip 2：final和private(fileprivate).md","hash":"a3e55d909bd4ed1475a5fe6f9411afa03c3512e1","modified":1520319997644},{"_id":"source/_posts/RAC和内存管理.md","hash":"83c242e52f1f62b9b868383d50422f1d5a580ba5","modified":1520320016944},{"_id":"source/_posts/Shell-Tip.md","hash":"39912fd9c379a4e98044a4e61e0a2a82eb4fa1b4","modified":1520320058178},{"_id":"source/_posts/Vim-Tip.md","hash":"ffe6d0aa6c798370e44f4c9a5f58c8c380a8a7fe","modified":1520320042896},{"_id":"source/_posts/include和import的区别.md","hash":"230a94fce26d017c230a5b2e95be7ec131b6c159","modified":1520490479110},{"_id":"source/_posts/初步了解GCD.md","hash":"70dedd04f065344a6a0388df0f72c5a9b083dd57","modified":1520490389292},{"_id":"source/_posts/启动.md","hash":"5396673ed2d8034a03f5baa687f2f85fc4fdcb9f","modified":1520320053154},{"_id":"source/_posts/redux-之页面跳转.md","hash":"8913b15d79e54a36dcc766b355ad5422883eaaab","modified":1520320033186},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1520317319976},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1520317319977},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1520317319977},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1520317319979},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1520317319978},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1520317319979},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1520317319979},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1520317319980},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1520317319980},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1520317319988},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1520317319980},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1520317319980},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1520317319988},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1520317319980},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1520317319988},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1520317319989},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1520317319989},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1520317319989},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1520317319990},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1520317319991},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1520317319981},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1520317319981},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1520317319982},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1520317319982},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1520317319982},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1520317319982},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1520317319983},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1520317319983},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1520317319983},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1520317319984},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1520317319986},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1520317319986},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1520317319986},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1520317319987},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1520317319986},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1520317319987},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1520317319991},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1520317319996},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1520317320009},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1520317320010},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1520317320009},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1520317320011},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1520317320012},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1520317320011},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1520317320015},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1520317320016},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1520317320016},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1520317320017},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1520317320010},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1520317319984},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1520317319985},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1520317319985},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1520317319984},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1520317319985},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1520317319986},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1520317319992},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1520317319992},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1520317319992},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1520317319993},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1520317319993},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1520317319993},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1520317319994},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1520317319994},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1520317319994},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1520317319995},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1520317319996},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1520317319995},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1520317319998},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1520317319998},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1520317320004},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1520317320012},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1520317320012},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1520317320013},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1520317320014},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1520317320013},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1520317320015},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1520317320002},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1520317320001},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1520317320007},{"_id":"themes/hexo-theme-icarus/.gitignore","hash":"542aaea07afe90211c6a45c90b7d6879a4503043","modified":1520490955279},{"_id":"themes/hexo-theme-icarus/README.md","hash":"acd2d5d12820b065345d68f88bfc3a739f8d8ae2","modified":1520490955280},{"_id":"themes/hexo-theme-icarus/LICENSE","hash":"df00918fa95de563927fd92b26f14c7affdc3052","modified":1520490955279},{"_id":"themes/hexo-theme-icarus/_config.yml.example","hash":"96b245d58abb6e2a7f59edfccd93dedbea48821d","modified":1520490955280},{"_id":"themes/hexo-theme-icarus/package.json","hash":"1bc52ef10a33df23e56bd73c927f605019c87d41","modified":1520490955321},{"_id":"themes/hexo-theme-icarus/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1520490955269},{"_id":"themes/hexo-theme-icarus/.git/config","hash":"ef1a4d603b1663bb35ba85daaebb8685271de92b","modified":1520490955275},{"_id":"themes/hexo-theme-icarus/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1520490947828},{"_id":"themes/hexo-theme-icarus/.git/index","hash":"f3fd109ff66a2fe18e6f457fb68b4801990773af","modified":1520490955513},{"_id":"themes/hexo-theme-icarus/.git/packed-refs","hash":"a3c13b37ddb6b9d47351f993eefc214f4f694e1c","modified":1520490955266},{"_id":"themes/hexo-theme-icarus/.github/ISSUE_TEMPLATE.md","hash":"9393fd3dbc943f1544facb66af7fd8b7a5b9ddbb","modified":1520490955279},{"_id":"themes/hexo-theme-icarus/languages/en.yml","hash":"ade241498b85503a8953a1deca963222f47067a7","modified":1520490955283},{"_id":"themes/hexo-theme-icarus/languages/es.yml","hash":"d7432219be5bee4cb569331378ade61b749688e0","modified":1520490955283},{"_id":"themes/hexo-theme-icarus/languages/fr.yml","hash":"cb3e597cbec7e8f458858c457bafd1f3a225083d","modified":1520490955284},{"_id":"themes/hexo-theme-icarus/languages/id.yml","hash":"e4961da507f66c8f7c37f85653a9437cb2056bf6","modified":1520490955285},{"_id":"themes/hexo-theme-icarus/languages/ko.yml","hash":"7c4ad4577dc0577ad2ca1c0410507f5e5fadf530","modified":1520490955285},{"_id":"themes/hexo-theme-icarus/languages/ja.yml","hash":"ff972961e5f468a695d80d21b62c3e9032cdf561","modified":1520490955285},{"_id":"themes/hexo-theme-icarus/languages/pt-BR.yml","hash":"3c5d5293575593705b9a2dfa9d97b017eb4bc8c3","modified":1520490955286},{"_id":"themes/hexo-theme-icarus/languages/zh-TW.yml","hash":"d8d96a0a17c20af11919ce036e87379a6b163db9","modified":1520490955288},{"_id":"themes/hexo-theme-icarus/languages/ru.yml","hash":"d1aab2b0c939d0c6020f881d664b660a01ee7327","modified":1520490955287},{"_id":"themes/hexo-theme-icarus/languages/tr.yml","hash":"8b7eb6aec264db50dbabea89f680acca256f4cd1","modified":1520490955288},{"_id":"themes/hexo-theme-icarus/languages/zh-CN.yml","hash":"3dc8ec524805afd090438be717908750da439204","modified":1520490955288},{"_id":"themes/hexo-theme-icarus/layout/archive.ejs","hash":"c1ecf667f40f34d61ab33eed46bab143eb1af36d","modified":1520490955289},{"_id":"themes/hexo-theme-icarus/layout/categories.ejs","hash":"aa95629b770cff8cca9d663aeb6b17928f070de5","modified":1520490955289},{"_id":"themes/hexo-theme-icarus/layout/category.ejs","hash":"1d407f9176db84e83062c52ad4755aaea9e74401","modified":1520490955289},{"_id":"themes/hexo-theme-icarus/layout/index.ejs","hash":"43e971ebc35657b18e08a049559790348a16666f","modified":1520490955307},{"_id":"themes/hexo-theme-icarus/layout/layout.ejs","hash":"6f01b3d46d184a820297f9542497808b152bb09e","modified":1520490955307},{"_id":"themes/hexo-theme-icarus/layout/page.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1520490955307},{"_id":"themes/hexo-theme-icarus/layout/post.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1520490955309},{"_id":"themes/hexo-theme-icarus/layout/tag.ejs","hash":"f6c220d4e5c231028bc71ddc11aec97d7b5a9943","modified":1520490955316},{"_id":"themes/hexo-theme-icarus/layout/tags.ejs","hash":"b0fcea68d7c11e5899bf0375d80997685111653f","modified":1520490955316},{"_id":"themes/hexo-theme-icarus/scripts/meta.js","hash":"1993754a2f3dffa283fa0538eb8f056385b69ad4","modified":1520490955322},{"_id":"themes/hexo-theme-icarus/scripts/thumbnail.js","hash":"e667a611f9baac270281b765832020d50bf8fb7f","modified":1520490955323},{"_id":"themes/hexo-theme-icarus/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1520490947830},{"_id":"themes/hexo-theme-icarus/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1520490947828},{"_id":"themes/hexo-theme-icarus/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1520490947830},{"_id":"themes/hexo-theme-icarus/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1520490947835},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1520490947835},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1520490947829},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1520490947836},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1520490947833},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1520490947829},{"_id":"themes/hexo-theme-icarus/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1520490947834},{"_id":"themes/hexo-theme-icarus/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1520490947837},{"_id":"themes/hexo-theme-icarus/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1520490947827},{"_id":"themes/hexo-theme-icarus/.git/logs/HEAD","hash":"729bdb4b9f9990a55cb5fa657171010421ac98bc","modified":1520490955273},{"_id":"themes/hexo-theme-icarus/_source/about/index.md","hash":"2847759c65295fdc47685cc32e10ae30b2f022ae","modified":1520490955280},{"_id":"themes/hexo-theme-icarus/_source/categories/index.md","hash":"55bee2cb88da438a2e8b1f29b1d7e954c07a9e60","modified":1520490955281},{"_id":"themes/hexo-theme-icarus/_source/tags/index.md","hash":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1520490955282},{"_id":"themes/hexo-theme-icarus/layout/comment/changyan.ejs","hash":"b4bd2e641af59e06becaa8f2dc97867f023b8dcf","modified":1520490955290},{"_id":"themes/hexo-theme-icarus/layout/comment/counter.ejs","hash":"57c194d0fa268ce2f3e9c755b3154b8a0709f613","modified":1520490955290},{"_id":"themes/hexo-theme-icarus/layout/comment/disqus.ejs","hash":"1b32a90f400dc580f4b8298de75b94429ca6de68","modified":1520490955290},{"_id":"themes/hexo-theme-icarus/layout/comment/duoshuo.ejs","hash":"ce46d7410a99b57704da32e9d09071cef6c9fa93","modified":1520490955291},{"_id":"themes/hexo-theme-icarus/layout/comment/gitment.ejs","hash":"c7998209b9a766eeba6976dd4bdffb1f87469358","modified":1520490955292},{"_id":"themes/hexo-theme-icarus/layout/comment/facebook.ejs","hash":"5ee16430a4435c2fead0275ff83fc98092d73d4c","modified":1520490955291},{"_id":"themes/hexo-theme-icarus/layout/comment/index.ejs","hash":"0bce9ca0767b49d2a9fc026a6004a8526a20624b","modified":1520490955292},{"_id":"themes/hexo-theme-icarus/layout/comment/isso.ejs","hash":"4f8b81ff5bb418ec11ce080d515f247bfe436014","modified":1520490955293},{"_id":"themes/hexo-theme-icarus/layout/comment/livere.ejs","hash":"792e4f0e93b2bdc5abd85d447d804a5c608a9c5c","modified":1520490955293},{"_id":"themes/hexo-theme-icarus/layout/comment/scripts.ejs","hash":"d45f652268671de96c86d8ca50b9deaf011274f0","modified":1520490955294},{"_id":"themes/hexo-theme-icarus/layout/comment/valine.ejs","hash":"0ea90a606f0d386a5ae0da83c0501cbb25319fde","modified":1520490955294},{"_id":"themes/hexo-theme-icarus/layout/comment/youyan.ejs","hash":"6fe807992832939caf6c3e7651d052df9520d88e","modified":1520490955294},{"_id":"themes/hexo-theme-icarus/layout/common/article.ejs","hash":"9c260a551596f71e93177f2289b5cb1c4bc7d96c","modified":1520490955295},{"_id":"themes/hexo-theme-icarus/layout/common/profile.ejs","hash":"0d5a9622d490652599e3ba3e4077a7d6bb2eb38e","modified":1520490955303},{"_id":"themes/hexo-theme-icarus/layout/common/footer.ejs","hash":"cbfe560fcab445d42ceeb5d1beba5957d5be5eaa","modified":1520490955295},{"_id":"themes/hexo-theme-icarus/layout/common/head.ejs","hash":"44f30945882afd27c89da2173da501fb1b531488","modified":1520490955296},{"_id":"themes/hexo-theme-icarus/layout/common/header.ejs","hash":"738c6a923b2a6de6a81c4892c8a47e03d8b34f88","modified":1520490955297},{"_id":"themes/hexo-theme-icarus/layout/common/scripts.ejs","hash":"c0a1a9e53f89440c42c325d5bd8c7234652c8937","modified":1520490955304},{"_id":"themes/hexo-theme-icarus/layout/common/sidebar.ejs","hash":"1ee2384f98c8ccaa7a5b00f14ad2a9a67022c143","modified":1520490955306},{"_id":"themes/hexo-theme-icarus/layout/common/thumbnail.ejs","hash":"1b70f8a98cd8650b159bda858dbee38dbdb7f0c5","modified":1520490955306},{"_id":"themes/hexo-theme-icarus/layout/common/timeline.ejs","hash":"6420e34e0332c9b6670011519f341340db989343","modified":1520490955306},{"_id":"themes/hexo-theme-icarus/layout/plugin/baidu-analytics.ejs","hash":"6a7bee18e666e627e62541a5e30906f87ba1bfe8","modified":1520490955308},{"_id":"themes/hexo-theme-icarus/layout/plugin/google-analytics.ejs","hash":"349f08b6521a16e79046b1f94f04317ac74f556e","modified":1520490955308},{"_id":"themes/hexo-theme-icarus/layout/plugin/scripts.ejs","hash":"e22f99652a220d926103801a3cad55ea9c450e05","modified":1520490955309},{"_id":"themes/hexo-theme-icarus/layout/search/baidu.ejs","hash":"3e603a702d20c53fd3bcbeb570a16a86d54781ce","modified":1520490955310},{"_id":"themes/hexo-theme-icarus/layout/search/index-mobile.ejs","hash":"50a727ac1dfe3073eb6fa6699ba01e66f4ac41c0","modified":1520490955310},{"_id":"themes/hexo-theme-icarus/layout/search/index.ejs","hash":"24935e32e61d4706454b174ea3bed0726ae7fb34","modified":1520490955311},{"_id":"themes/hexo-theme-icarus/layout/search/insight.ejs","hash":"130fe3d33ac71da0b50f7fee6a87979f30938a1b","modified":1520490955312},{"_id":"themes/hexo-theme-icarus/layout/share/addtoany.ejs","hash":"ac180c4c84b73a04d61b17e7dc18c257e20bf59f","modified":1520490955313},{"_id":"themes/hexo-theme-icarus/layout/search/swiftype.ejs","hash":"379e66d2c13526e72e4120c443f95fccf4edef71","modified":1520490955312},{"_id":"themes/hexo-theme-icarus/layout/share/bdshare.ejs","hash":"a1e772c5a6f174d585b0c1e574058f75dc8e2898","modified":1520490955313},{"_id":"themes/hexo-theme-icarus/layout/share/default.ejs","hash":"ebfb919dc525b3ed61a6a5ee05ee71410eedc541","modified":1520490955313},{"_id":"themes/hexo-theme-icarus/layout/share/index.ejs","hash":"2a2c0095b95b11e5692bd8ad6a2337aa644189a2","modified":1520490955314},{"_id":"themes/hexo-theme-icarus/layout/share/jiathis.ejs","hash":"21ebaa51e828cba2cefbeeaccb01514643565755","modified":1520490955316},{"_id":"themes/hexo-theme-icarus/layout/widget/archive.ejs","hash":"d9ebbb7f6ce2f25df5ae25e4a1fef3c08f7054b9","modified":1520490955317},{"_id":"themes/hexo-theme-icarus/layout/widget/category.ejs","hash":"583bda80cf15b3ef11fefbd1b502897dfff40100","modified":1520490955318},{"_id":"themes/hexo-theme-icarus/layout/widget/links.ejs","hash":"aad118699718b62c0d3f3cfd6f17a181139a76af","modified":1520490955319},{"_id":"themes/hexo-theme-icarus/layout/widget/recent_posts.ejs","hash":"2ca923465275fb38a7ac7d67211d6e94a977e957","modified":1520490955319},{"_id":"themes/hexo-theme-icarus/layout/widget/tag.ejs","hash":"3b8ae5953990436893da9d68f910ebe592005659","modified":1520490955320},{"_id":"themes/hexo-theme-icarus/layout/widget/tagcloud.ejs","hash":"ca8c7bf555fb6ce4904f2c59160548405c2c8a82","modified":1520490955320},{"_id":"themes/hexo-theme-icarus/source/css/_extend.styl","hash":"539e02107f35e8b3bdb9bf160dc212a433a7b60e","modified":1520490955324},{"_id":"themes/hexo-theme-icarus/source/css/_variables.styl","hash":"d62af931be6612ec8c3a917836379a8cd92fbce1","modified":1520490955365},{"_id":"themes/hexo-theme-icarus/source/css/style.styl","hash":"1716b199dba80b26086f325d69c36fa682465106","modified":1520490955366},{"_id":"themes/hexo-theme-icarus/source/js/insight.js","hash":"c1bafa7f87e9f25fca1e033fc6d1e0c82712ac99","modified":1520490955367},{"_id":"themes/hexo-theme-icarus/source/js/main.js","hash":"23b373067df0dbac27622bc7537bb4fda243a9c8","modified":1520490955368},{"_id":"themes/hexo-theme-icarus/.git/refs/heads/master","hash":"93cadec7110d74453ec94cf59c8dc39d1e7e6459","modified":1520490955272},{"_id":"themes/hexo-theme-icarus/.git/objects/pack/pack-d611b37c0bcd4551d83280da27dfe6b037cb9080.idx","hash":"d5f1880cc5e2a0af3346488f0fde44cbd75a0fa4","modified":1520490954968},{"_id":"themes/hexo-theme-icarus/layout/common/post/banner.ejs","hash":"47ced3f03525698c79c6b1c07b48383fb6c496b2","modified":1520490955299},{"_id":"themes/hexo-theme-icarus/layout/common/post/category.ejs","hash":"75c9dda2e7ec041943855ca163a6b1c4c8b4f260","modified":1520490955300},{"_id":"themes/hexo-theme-icarus/layout/common/post/date.ejs","hash":"45cb0bcad461036cdd1fe2e3fbb5f2f19940025c","modified":1520490955300},{"_id":"themes/hexo-theme-icarus/layout/common/post/gallery.ejs","hash":"659f019761116313169148ec61773e7b84abb739","modified":1520490955301},{"_id":"themes/hexo-theme-icarus/layout/common/post/nav.ejs","hash":"d7cd611e642327f33dff3963ef869c2b46824a11","modified":1520490955301},{"_id":"themes/hexo-theme-icarus/layout/common/post/tag.ejs","hash":"2e966216256321aa0c76fe1b9be689601c76ef31","modified":1520490955302},{"_id":"themes/hexo-theme-icarus/layout/common/post/title.ejs","hash":"669ddb46fefa100856588351a7a2d30ad996b755","modified":1520490955303},{"_id":"themes/hexo-theme-icarus/source/css/_partial/archive.styl","hash":"d35088c83ddd7a197d6d94e16a2ce3a7e29fa1dc","modified":1520490955360},{"_id":"themes/hexo-theme-icarus/source/css/_partial/comment.styl","hash":"784646796184d4f27918c22395288a2fafbf9554","modified":1520490955361},{"_id":"themes/hexo-theme-icarus/source/css/_partial/article.styl","hash":"77c4ae7fe3dc16c569bb45d365cc3c147c2e9498","modified":1520490955361},{"_id":"themes/hexo-theme-icarus/source/css/_partial/footer.styl","hash":"484776654e4c1691dc844e6e93786a08855c1c99","modified":1520490955361},{"_id":"themes/hexo-theme-icarus/source/css/_partial/header.styl","hash":"1e351f741144135871a3373fe7e969dc961b65e7","modified":1520490955362},{"_id":"themes/hexo-theme-icarus/source/css/_partial/insight.styl","hash":"19833cd127f26ad90b06c115f8a96a30e0c0e53b","modified":1520490955362},{"_id":"themes/hexo-theme-icarus/source/css/_partial/profile.styl","hash":"fb0170075dc2a41e01dd11bbfdbccbed544c479a","modified":1520490955363},{"_id":"themes/hexo-theme-icarus/source/css/_partial/sidebar.styl","hash":"f528ca7064d9fcecd737b9b71c9c54601365d7d3","modified":1520490955363},{"_id":"themes/hexo-theme-icarus/source/css/_partial/timeline.styl","hash":"c813b98f4fc45b64d2e07e5d944745a654c8c943","modified":1520490955363},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1520490955325},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1520490955325},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1520490955325},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/arta.styl","hash":"1a5accc115f41d1b669ed708ac6a29abac876599","modified":1520490955326},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1520490955326},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1520490955327},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1520490955327},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1520490955328},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1520490955328},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1520490955328},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1520490955329},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1520490955329},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1520490955329},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1520490955329},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1520490955330},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1520490955330},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1520490955331},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1520490955331},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1520490955331},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1520490955333},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1520490955333},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1520490955334},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1520490955334},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1520490955335},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1520490955335},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/brown-paper.styl","hash":"c2326ba20a5020a66ca7895258d18833327d4334","modified":1520490955335},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1520490955336},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1520490955336},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1520490955336},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1520490955337},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1520490955337},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1520490955338},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1520490955338},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1520490955339},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1520490955339},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1520490955339},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1520490955339},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1520490955340},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/highlightjs.styl","hash":"0e198b7a59191c7a39b641a4ddd22c948edb9358","modified":1520490955340},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1520490955340},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1520490955341},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1520490955341},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1520490955343},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1520490955342},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1520490955342},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1520490955344},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1520490955345},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1520490955346},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1520490955348},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/monokai.styl","hash":"5a4fe9f957fd7a368c21b62a818403db4270452f","modified":1520490955349},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1520490955350},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1520490955350},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1520490955350},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1520490955351},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1520490955351},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1520490955351},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1520490955352},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1520490955352},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/school-book.styl","hash":"d43560fe519a931ce6da7d57416d7aa148441b83","modified":1520490955353},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1520490955353},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1520490955354},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1520490955355},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1520490955356},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1520490955357},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1520490955358},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1520490955358},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1520490955358},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1520490955359},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1520490955359},{"_id":"themes/hexo-theme-icarus/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1520490955360},{"_id":"themes/hexo-theme-icarus/source/css/_util/grid.styl","hash":"93fb6f1e2f40cd7d88ad0d56dd73d3f9a7bc853e","modified":1520490955364},{"_id":"themes/hexo-theme-icarus/source/css/_util/mixin.styl","hash":"c8e1ddfc0fe9108bab592c7a73b73ce9344991fd","modified":1520490955364},{"_id":"themes/hexo-theme-icarus/source/css/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1520490955365},{"_id":"themes/hexo-theme-icarus/source/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1520490955366},{"_id":"themes/hexo-theme-icarus/source/css/images/logo.png","hash":"e606a0584f98268b2fe92303f3254520862ef659","modified":1520490955366},{"_id":"themes/hexo-theme-icarus/source/libs/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1520490955400},{"_id":"themes/hexo-theme-icarus/source/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1520490955398},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/styles.css","hash":"5ca6e111046232bde112d33201a60532aee7d3c4","modified":1520490955507},{"_id":"themes/hexo-theme-icarus/source/libs/source-code-pro/styles.css","hash":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1520490955511},{"_id":"themes/hexo-theme-icarus/.git/logs/refs/heads/master","hash":"729bdb4b9f9990a55cb5fa657171010421ac98bc","modified":1520490955273},{"_id":"themes/hexo-theme-icarus/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1520490955269},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/css/font-awesome.css","hash":"b5020c3860669185ba3f316fa7332cdf5c06f393","modified":1520490955370},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/css/font-awesome.min.css","hash":"7cd5a3384333f95c3d37d9488ad82cd6c4b03761","modified":1520490955371},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-fb-comment-box.css","hash":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1520490955407},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb","modified":1520490955408},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1520490955409},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-transitions.css","hash":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1520490955410},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1520490955413},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lightgallery.css","hash":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1520490955415},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lg-transitions.css.map","hash":"50c3348638b4d82fa08a449c690e8d2bb593005d","modified":1520490955411},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1520490955417},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1520490955418},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/css/lightgallery.css.map","hash":"3175b4107078674d25798979f7666f4daf31e624","modified":1520490955416},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1520490955423},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1520490955422},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1520490955419},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1520490955424},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1520490955425},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1520490955431},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1520490955427},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-autoplay.min.js","hash":"d845741bcaf961579622880eb2a445257efad1ac","modified":1520490955443},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-hash.js","hash":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1520490955450},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-fullscreen.js","hash":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1520490955446},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-autoplay.js","hash":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1520490955442},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-hash.min.js","hash":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1520490955451},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-fullscreen.min.js","hash":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1520490955448},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-pager.js","hash":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1520490955452},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-share.js","hash":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1520490955455},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-pager.min.js","hash":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1520490955454},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-share.min.js","hash":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1520490955457},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-thumbnail.js","hash":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1520490955459},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-thumbnail.min.js","hash":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1520490955460},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-video.js","hash":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1520490955462},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-zoom.js","hash":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1520490955464},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-video.min.js","hash":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1520490955463},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lg-zoom.min.js","hash":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1520490955465},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","hash":"c4248ea800bd5608344ce163f5658b57e7ef9410","modified":1520490955475},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lightgallery.js","hash":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1520490955468},{"_id":"themes/hexo-theme-icarus/source/libs/lightgallery/js/lightgallery.min.js","hash":"956ef9b706755318da69ad0b5d7786339d831251","modified":1520490955469},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","hash":"2c5b039b57f62625e88226a938679ec937431ad1","modified":1520490955477},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","hash":"e0350190d720a8fec0557ab47b318ec4e4486448","modified":1520490955476},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","hash":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f","modified":1520490955478},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","hash":"63eb74ef040aade256f2274a7f31a914edddb0ea","modified":1520490955479},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","hash":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f","modified":1520490955484},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","hash":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf","modified":1520490955486},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","hash":"415eee05976ab8b2471602a5ddb78a6c58fc21aa","modified":1520490955486},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","hash":"a0b0c389cf46d63c850e61fed572485ff0b68183","modified":1520490955488},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","hash":"c5f29fed6632efe0aa83318369f0d8c4061b775b","modified":1520490955490},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","hash":"be201d32a9aa5d186723ebb3c538be691aa8c53a","modified":1520490955492},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","hash":"afc44700053c9a28f9ab26f6aec4862ac1d0795d","modified":1520490955494},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","hash":"113978181dcac77baecef6115a9121d8f6e4fc3a","modified":1520490955495},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","hash":"5067c81462c15422853c94d21a1726865a61634f","modified":1520490955496},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","hash":"b366f2fda2e524eb5ef50058eefff249a3b96e6c","modified":1520490955497},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","hash":"d22904914469be735490e3c8cb093c7862896dd5","modified":1520490955500},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","hash":"ae80fb3cd16339aa7b5da280ab53975523dcaac2","modified":1520490955501},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","hash":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c","modified":1520490955503},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","hash":"e75607ba1417181397c700775b84303d5a2957b9","modified":1520490955504},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","hash":"be365eca44760ce3fc9b377c43d4634958479c69","modified":1520490955506},{"_id":"themes/hexo-theme-icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","hash":"d0b40a7848703556c6631f24e961a98ca5829255","modified":1520490955505},{"_id":"themes/hexo-theme-icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1520490955510},{"_id":"themes/hexo-theme-icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1520490955511},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1520490955376},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1520490955375},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1520490955395},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1520490955395},{"_id":"themes/hexo-theme-icarus/source/libs/jquery/2.1.3/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1520490955397},{"_id":"themes/hexo-theme-icarus/.git/logs/refs/remotes/origin/HEAD","hash":"729bdb4b9f9990a55cb5fa657171010421ac98bc","modified":1520490955268},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1520490955394},{"_id":"themes/hexo-theme-icarus/source/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1520490955390},{"_id":"themes/hexo-theme-icarus/.git/objects/pack/pack-d611b37c0bcd4551d83280da27dfe6b037cb9080.pack","hash":"e23244db5daa5b1caddcae6cfe0140b878c30145","modified":1520490954959},{"_id":"themes/icarus/.gitignore","hash":"542aaea07afe90211c6a45c90b7d6879a4503043","modified":1520490955279},{"_id":"themes/icarus/LICENSE","hash":"df00918fa95de563927fd92b26f14c7affdc3052","modified":1520490955279},{"_id":"themes/icarus/README.md","hash":"acd2d5d12820b065345d68f88bfc3a739f8d8ae2","modified":1520490955280},{"_id":"themes/icarus/_config.yml","hash":"f7973ed6a8de5067d47ad4f5c9c19e64285ae1a4","modified":1520493487012},{"_id":"themes/icarus/_config.yml.example","hash":"96b245d58abb6e2a7f59edfccd93dedbea48821d","modified":1520490955280},{"_id":"themes/icarus/package.json","hash":"1bc52ef10a33df23e56bd73c927f605019c87d41","modified":1520490955321},{"_id":"themes/icarus/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1520490955269},{"_id":"themes/icarus/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1520490947828},{"_id":"themes/icarus/.git/config","hash":"6da5507355104641d8fc20b1ad38cb869652321c","modified":1520493732278},{"_id":"themes/icarus/.git/index","hash":"7dbc848801a2ef7ed70d5876c691780977040023","modified":1520494051100},{"_id":"themes/icarus/.git/packed-refs","hash":"a3c13b37ddb6b9d47351f993eefc214f4f694e1c","modified":1520490955266},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE.md","hash":"9393fd3dbc943f1544facb66af7fd8b7a5b9ddbb","modified":1520490955279},{"_id":"themes/icarus/languages/en.yml","hash":"ade241498b85503a8953a1deca963222f47067a7","modified":1520490955283},{"_id":"themes/icarus/languages/es.yml","hash":"d7432219be5bee4cb569331378ade61b749688e0","modified":1520490955283},{"_id":"themes/icarus/languages/id.yml","hash":"e4961da507f66c8f7c37f85653a9437cb2056bf6","modified":1520490955285},{"_id":"themes/icarus/languages/fr.yml","hash":"cb3e597cbec7e8f458858c457bafd1f3a225083d","modified":1520490955284},{"_id":"themes/icarus/languages/ja.yml","hash":"ff972961e5f468a695d80d21b62c3e9032cdf561","modified":1520490955285},{"_id":"themes/icarus/languages/ko.yml","hash":"7c4ad4577dc0577ad2ca1c0410507f5e5fadf530","modified":1520490955285},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"3c5d5293575593705b9a2dfa9d97b017eb4bc8c3","modified":1520490955286},{"_id":"themes/icarus/languages/ru.yml","hash":"d1aab2b0c939d0c6020f881d664b660a01ee7327","modified":1520490955287},{"_id":"themes/icarus/languages/tr.yml","hash":"8b7eb6aec264db50dbabea89f680acca256f4cd1","modified":1520490955288},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"3dc8ec524805afd090438be717908750da439204","modified":1520490955288},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"d8d96a0a17c20af11919ce036e87379a6b163db9","modified":1520490955288},{"_id":"themes/icarus/layout/archive.ejs","hash":"c1ecf667f40f34d61ab33eed46bab143eb1af36d","modified":1520490955289},{"_id":"themes/icarus/layout/categories.ejs","hash":"aa95629b770cff8cca9d663aeb6b17928f070de5","modified":1520490955289},{"_id":"themes/icarus/layout/category.ejs","hash":"1d407f9176db84e83062c52ad4755aaea9e74401","modified":1520490955289},{"_id":"themes/icarus/layout/index.ejs","hash":"43e971ebc35657b18e08a049559790348a16666f","modified":1520490955307},{"_id":"themes/icarus/layout/layout.ejs","hash":"6f01b3d46d184a820297f9542497808b152bb09e","modified":1520490955307},{"_id":"themes/icarus/layout/page.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1520490955307},{"_id":"themes/icarus/layout/post.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1520490955309},{"_id":"themes/icarus/layout/tag.ejs","hash":"f6c220d4e5c231028bc71ddc11aec97d7b5a9943","modified":1520490955316},{"_id":"themes/icarus/layout/tags.ejs","hash":"b0fcea68d7c11e5899bf0375d80997685111653f","modified":1520490955316},{"_id":"themes/icarus/scripts/meta.js","hash":"1993754a2f3dffa283fa0538eb8f056385b69ad4","modified":1520490955322},{"_id":"themes/icarus/scripts/thumbnail.js","hash":"e667a611f9baac270281b765832020d50bf8fb7f","modified":1520490955323},{"_id":"themes/icarus/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1520490947830},{"_id":"themes/icarus/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1520490947828},{"_id":"themes/icarus/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1520490947830},{"_id":"themes/icarus/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1520490947835},{"_id":"themes/icarus/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1520490947835},{"_id":"themes/icarus/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1520490947829},{"_id":"themes/icarus/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1520490947829},{"_id":"themes/icarus/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1520490947836},{"_id":"themes/icarus/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1520490947834},{"_id":"themes/icarus/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1520490947833},{"_id":"themes/icarus/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1520490947837},{"_id":"themes/icarus/.git/logs/HEAD","hash":"ab1d6d8d66fd4f8a458e7cc8abc27811a80e5e1b","modified":1520493732275},{"_id":"themes/icarus/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1520490947827},{"_id":"themes/icarus/_source/about/index.md","hash":"2847759c65295fdc47685cc32e10ae30b2f022ae","modified":1520490955280},{"_id":"themes/icarus/_source/categories/index.md","hash":"55bee2cb88da438a2e8b1f29b1d7e954c07a9e60","modified":1520490955281},{"_id":"themes/icarus/_source/tags/index.md","hash":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1520490955282},{"_id":"themes/icarus/layout/comment/changyan.ejs","hash":"b4bd2e641af59e06becaa8f2dc97867f023b8dcf","modified":1520490955290},{"_id":"themes/icarus/layout/comment/counter.ejs","hash":"57c194d0fa268ce2f3e9c755b3154b8a0709f613","modified":1520490955290},{"_id":"themes/icarus/layout/comment/disqus.ejs","hash":"1b32a90f400dc580f4b8298de75b94429ca6de68","modified":1520490955290},{"_id":"themes/icarus/layout/comment/duoshuo.ejs","hash":"ce46d7410a99b57704da32e9d09071cef6c9fa93","modified":1520490955291},{"_id":"themes/icarus/layout/comment/facebook.ejs","hash":"5ee16430a4435c2fead0275ff83fc98092d73d4c","modified":1520490955291},{"_id":"themes/icarus/layout/comment/gitment.ejs","hash":"c7998209b9a766eeba6976dd4bdffb1f87469358","modified":1520490955292},{"_id":"themes/icarus/layout/comment/index.ejs","hash":"0bce9ca0767b49d2a9fc026a6004a8526a20624b","modified":1520490955292},{"_id":"themes/icarus/layout/comment/valine.ejs","hash":"0ea90a606f0d386a5ae0da83c0501cbb25319fde","modified":1520490955294},{"_id":"themes/icarus/layout/comment/isso.ejs","hash":"4f8b81ff5bb418ec11ce080d515f247bfe436014","modified":1520490955293},{"_id":"themes/icarus/layout/comment/livere.ejs","hash":"792e4f0e93b2bdc5abd85d447d804a5c608a9c5c","modified":1520490955293},{"_id":"themes/icarus/layout/comment/scripts.ejs","hash":"d45f652268671de96c86d8ca50b9deaf011274f0","modified":1520490955294},{"_id":"themes/icarus/layout/comment/youyan.ejs","hash":"6fe807992832939caf6c3e7651d052df9520d88e","modified":1520490955294},{"_id":"themes/icarus/layout/common/head.ejs","hash":"44f30945882afd27c89da2173da501fb1b531488","modified":1520490955296},{"_id":"themes/icarus/layout/common/article.ejs","hash":"9c260a551596f71e93177f2289b5cb1c4bc7d96c","modified":1520490955295},{"_id":"themes/icarus/layout/common/footer.ejs","hash":"cbfe560fcab445d42ceeb5d1beba5957d5be5eaa","modified":1520490955295},{"_id":"themes/icarus/layout/common/header.ejs","hash":"738c6a923b2a6de6a81c4892c8a47e03d8b34f88","modified":1520490955297},{"_id":"themes/icarus/layout/common/profile.ejs","hash":"0d5a9622d490652599e3ba3e4077a7d6bb2eb38e","modified":1520490955303},{"_id":"themes/icarus/layout/common/scripts.ejs","hash":"c0a1a9e53f89440c42c325d5bd8c7234652c8937","modified":1520490955304},{"_id":"themes/icarus/layout/common/sidebar.ejs","hash":"1ee2384f98c8ccaa7a5b00f14ad2a9a67022c143","modified":1520490955306},{"_id":"themes/icarus/layout/common/thumbnail.ejs","hash":"1b70f8a98cd8650b159bda858dbee38dbdb7f0c5","modified":1520490955306},{"_id":"themes/icarus/layout/plugin/baidu-analytics.ejs","hash":"6a7bee18e666e627e62541a5e30906f87ba1bfe8","modified":1520490955308},{"_id":"themes/icarus/layout/common/timeline.ejs","hash":"6420e34e0332c9b6670011519f341340db989343","modified":1520490955306},{"_id":"themes/icarus/layout/plugin/google-analytics.ejs","hash":"349f08b6521a16e79046b1f94f04317ac74f556e","modified":1520490955308},{"_id":"themes/icarus/layout/plugin/scripts.ejs","hash":"e22f99652a220d926103801a3cad55ea9c450e05","modified":1520490955309},{"_id":"themes/icarus/layout/search/baidu.ejs","hash":"3e603a702d20c53fd3bcbeb570a16a86d54781ce","modified":1520490955310},{"_id":"themes/icarus/layout/search/index-mobile.ejs","hash":"50a727ac1dfe3073eb6fa6699ba01e66f4ac41c0","modified":1520490955310},{"_id":"themes/icarus/layout/search/index.ejs","hash":"24935e32e61d4706454b174ea3bed0726ae7fb34","modified":1520490955311},{"_id":"themes/icarus/layout/search/insight.ejs","hash":"130fe3d33ac71da0b50f7fee6a87979f30938a1b","modified":1520490955312},{"_id":"themes/icarus/layout/search/swiftype.ejs","hash":"379e66d2c13526e72e4120c443f95fccf4edef71","modified":1520490955312},{"_id":"themes/icarus/layout/share/bdshare.ejs","hash":"a1e772c5a6f174d585b0c1e574058f75dc8e2898","modified":1520490955313},{"_id":"themes/icarus/layout/share/addtoany.ejs","hash":"ac180c4c84b73a04d61b17e7dc18c257e20bf59f","modified":1520490955313},{"_id":"themes/icarus/layout/share/default.ejs","hash":"ebfb919dc525b3ed61a6a5ee05ee71410eedc541","modified":1520490955313},{"_id":"themes/icarus/layout/share/index.ejs","hash":"2a2c0095b95b11e5692bd8ad6a2337aa644189a2","modified":1520490955314},{"_id":"themes/icarus/layout/share/jiathis.ejs","hash":"21ebaa51e828cba2cefbeeaccb01514643565755","modified":1520490955316},{"_id":"themes/icarus/layout/widget/category.ejs","hash":"583bda80cf15b3ef11fefbd1b502897dfff40100","modified":1520490955318},{"_id":"themes/icarus/layout/widget/archive.ejs","hash":"d9ebbb7f6ce2f25df5ae25e4a1fef3c08f7054b9","modified":1520490955317},{"_id":"themes/icarus/layout/widget/links.ejs","hash":"aad118699718b62c0d3f3cfd6f17a181139a76af","modified":1520490955319},{"_id":"themes/icarus/layout/widget/recent_posts.ejs","hash":"2ca923465275fb38a7ac7d67211d6e94a977e957","modified":1520490955319},{"_id":"themes/icarus/layout/widget/tag.ejs","hash":"3b8ae5953990436893da9d68f910ebe592005659","modified":1520490955320},{"_id":"themes/icarus/layout/widget/tagcloud.ejs","hash":"ca8c7bf555fb6ce4904f2c59160548405c2c8a82","modified":1520490955320},{"_id":"themes/icarus/source/css/_extend.styl","hash":"539e02107f35e8b3bdb9bf160dc212a433a7b60e","modified":1520490955324},{"_id":"themes/icarus/source/css/_variables.styl","hash":"d62af931be6612ec8c3a917836379a8cd92fbce1","modified":1520490955365},{"_id":"themes/icarus/source/css/style.styl","hash":"1716b199dba80b26086f325d69c36fa682465106","modified":1520490955366},{"_id":"themes/icarus/source/js/insight.js","hash":"c1bafa7f87e9f25fca1e033fc6d1e0c82712ac99","modified":1520490955367},{"_id":"themes/icarus/source/js/main.js","hash":"23b373067df0dbac27622bc7537bb4fda243a9c8","modified":1520490955368},{"_id":"themes/icarus/.git/objects/pack/pack-d611b37c0bcd4551d83280da27dfe6b037cb9080.idx","hash":"d5f1880cc5e2a0af3346488f0fde44cbd75a0fa4","modified":1520490954968},{"_id":"themes/icarus/.git/refs/heads/master","hash":"93cadec7110d74453ec94cf59c8dc39d1e7e6459","modified":1520490955272},{"_id":"themes/icarus/layout/common/post/banner.ejs","hash":"47ced3f03525698c79c6b1c07b48383fb6c496b2","modified":1520490955299},{"_id":"themes/icarus/layout/common/post/category.ejs","hash":"75c9dda2e7ec041943855ca163a6b1c4c8b4f260","modified":1520490955300},{"_id":"themes/icarus/layout/common/post/date.ejs","hash":"45cb0bcad461036cdd1fe2e3fbb5f2f19940025c","modified":1520490955300},{"_id":"themes/icarus/layout/common/post/gallery.ejs","hash":"659f019761116313169148ec61773e7b84abb739","modified":1520490955301},{"_id":"themes/icarus/layout/common/post/nav.ejs","hash":"d7cd611e642327f33dff3963ef869c2b46824a11","modified":1520490955301},{"_id":"themes/icarus/layout/common/post/tag.ejs","hash":"2e966216256321aa0c76fe1b9be689601c76ef31","modified":1520490955302},{"_id":"themes/icarus/layout/common/post/title.ejs","hash":"669ddb46fefa100856588351a7a2d30ad996b755","modified":1520490955303},{"_id":"themes/icarus/source/css/_partial/archive.styl","hash":"d35088c83ddd7a197d6d94e16a2ce3a7e29fa1dc","modified":1520490955360},{"_id":"themes/icarus/source/css/_partial/comment.styl","hash":"784646796184d4f27918c22395288a2fafbf9554","modified":1520490955361},{"_id":"themes/icarus/source/css/_partial/article.styl","hash":"77c4ae7fe3dc16c569bb45d365cc3c147c2e9498","modified":1520490955361},{"_id":"themes/icarus/source/css/_partial/footer.styl","hash":"484776654e4c1691dc844e6e93786a08855c1c99","modified":1520490955361},{"_id":"themes/icarus/source/css/_partial/profile.styl","hash":"fb0170075dc2a41e01dd11bbfdbccbed544c479a","modified":1520490955363},{"_id":"themes/icarus/source/css/_partial/header.styl","hash":"1e351f741144135871a3373fe7e969dc961b65e7","modified":1520490955362},{"_id":"themes/icarus/source/css/_partial/insight.styl","hash":"19833cd127f26ad90b06c115f8a96a30e0c0e53b","modified":1520490955362},{"_id":"themes/icarus/source/css/_partial/sidebar.styl","hash":"f528ca7064d9fcecd737b9b71c9c54601365d7d3","modified":1520490955363},{"_id":"themes/icarus/source/css/_partial/timeline.styl","hash":"c813b98f4fc45b64d2e07e5d944745a654c8c943","modified":1520490955363},{"_id":"themes/icarus/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1520490955325},{"_id":"themes/icarus/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1520490955325},{"_id":"themes/icarus/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1520490955325},{"_id":"themes/icarus/source/css/_highlight/arta.styl","hash":"1a5accc115f41d1b669ed708ac6a29abac876599","modified":1520490955326},{"_id":"themes/icarus/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1520490955326},{"_id":"themes/icarus/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1520490955327},{"_id":"themes/icarus/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1520490955327},{"_id":"themes/icarus/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1520490955328},{"_id":"themes/icarus/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1520490955328},{"_id":"themes/icarus/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1520490955328},{"_id":"themes/icarus/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1520490955329},{"_id":"themes/icarus/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1520490955329},{"_id":"themes/icarus/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1520490955329},{"_id":"themes/icarus/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1520490955329},{"_id":"themes/icarus/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1520490955330},{"_id":"themes/icarus/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1520490955330},{"_id":"themes/icarus/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1520490955331},{"_id":"themes/icarus/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1520490955331},{"_id":"themes/icarus/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1520490955331},{"_id":"themes/icarus/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1520490955333},{"_id":"themes/icarus/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1520490955333},{"_id":"themes/icarus/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1520490955334},{"_id":"themes/icarus/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1520490955334},{"_id":"themes/icarus/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1520490955335},{"_id":"themes/icarus/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1520490955335},{"_id":"themes/icarus/source/css/_highlight/brown-paper.styl","hash":"c2326ba20a5020a66ca7895258d18833327d4334","modified":1520490955335},{"_id":"themes/icarus/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1520490955336},{"_id":"themes/icarus/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1520490955336},{"_id":"themes/icarus/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1520490955336},{"_id":"themes/icarus/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1520490955337},{"_id":"themes/icarus/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1520490955337},{"_id":"themes/icarus/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1520490955338},{"_id":"themes/icarus/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1520490955338},{"_id":"themes/icarus/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1520490955339},{"_id":"themes/icarus/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1520490955339},{"_id":"themes/icarus/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1520490955340},{"_id":"themes/icarus/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1520490955339},{"_id":"themes/icarus/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1520490955339},{"_id":"themes/icarus/source/css/_highlight/highlightjs.styl","hash":"0e198b7a59191c7a39b641a4ddd22c948edb9358","modified":1520490955340},{"_id":"themes/icarus/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1520490955340},{"_id":"themes/icarus/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1520490955341},{"_id":"themes/icarus/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1520490955342},{"_id":"themes/icarus/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1520490955341},{"_id":"themes/icarus/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1520490955342},{"_id":"themes/icarus/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1520490955343},{"_id":"themes/icarus/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1520490955344},{"_id":"themes/icarus/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1520490955346},{"_id":"themes/icarus/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1520490955348},{"_id":"themes/icarus/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1520490955345},{"_id":"themes/icarus/source/css/_highlight/monokai.styl","hash":"5a4fe9f957fd7a368c21b62a818403db4270452f","modified":1520490955349},{"_id":"themes/icarus/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1520490955350},{"_id":"themes/icarus/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1520490955350},{"_id":"themes/icarus/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1520490955350},{"_id":"themes/icarus/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1520490955351},{"_id":"themes/icarus/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1520490955351},{"_id":"themes/icarus/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1520490955352},{"_id":"themes/icarus/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1520490955351},{"_id":"themes/icarus/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1520490955352},{"_id":"themes/icarus/source/css/_highlight/school-book.styl","hash":"d43560fe519a931ce6da7d57416d7aa148441b83","modified":1520490955353},{"_id":"themes/icarus/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1520490955354},{"_id":"themes/icarus/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1520490955353},{"_id":"themes/icarus/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1520490955355},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1520490955356},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1520490955357},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1520490955358},{"_id":"themes/icarus/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1520490955358},{"_id":"themes/icarus/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1520490955359},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1520490955358},{"_id":"themes/icarus/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1520490955359},{"_id":"themes/icarus/source/css/_util/grid.styl","hash":"93fb6f1e2f40cd7d88ad0d56dd73d3f9a7bc853e","modified":1520490955364},{"_id":"themes/icarus/source/css/_util/mixin.styl","hash":"c8e1ddfc0fe9108bab592c7a73b73ce9344991fd","modified":1520490955364},{"_id":"themes/icarus/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1520490955360},{"_id":"themes/icarus/source/css/images/logo.png","hash":"e606a0584f98268b2fe92303f3254520862ef659","modified":1520490955366},{"_id":"themes/icarus/source/css/images/avatar.png","hash":"4870887bed0b021cbc91359f7236f26129dd350e","modified":1520491680566},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1520490955366},{"_id":"themes/icarus/source/libs/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1520490955400},{"_id":"themes/icarus/source/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1520490955398},{"_id":"themes/icarus/source/libs/open-sans/styles.css","hash":"5ca6e111046232bde112d33201a60532aee7d3c4","modified":1520490955507},{"_id":"themes/icarus/source/libs/source-code-pro/styles.css","hash":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1520490955511},{"_id":"themes/icarus/.git/logs/refs/heads/master","hash":"ab1d6d8d66fd4f8a458e7cc8abc27811a80e5e1b","modified":1520493732276},{"_id":"themes/icarus/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1520490955269},{"_id":"themes/icarus/source/libs/font-awesome/css/font-awesome.css","hash":"b5020c3860669185ba3f316fa7332cdf5c06f393","modified":1520490955370},{"_id":"themes/icarus/source/libs/font-awesome/css/font-awesome.min.css","hash":"7cd5a3384333f95c3d37d9488ad82cd6c4b03761","modified":1520490955371},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css","hash":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1520490955407},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1520490955409},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb","modified":1520490955408},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css","hash":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1520490955410},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.css.map","hash":"50c3348638b4d82fa08a449c690e8d2bb593005d","modified":1520490955411},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css","hash":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1520490955415},{"_id":"themes/icarus/source/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1520490955413},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.css.map","hash":"3175b4107078674d25798979f7666f4daf31e624","modified":1520490955416},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1520490955419},{"_id":"themes/icarus/source/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1520490955417},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1520490955418},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1520490955422},{"_id":"themes/icarus/source/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1520490955423},{"_id":"themes/icarus/source/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1520490955424},{"_id":"themes/icarus/source/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1520490955427},{"_id":"themes/icarus/source/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1520490955431},{"_id":"themes/icarus/source/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1520490955425},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.js","hash":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1520490955442},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.js","hash":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1520490955450},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.min.js","hash":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1520490955448},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-autoplay.min.js","hash":"d845741bcaf961579622880eb2a445257efad1ac","modified":1520490955443},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-fullscreen.js","hash":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1520490955446},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.min.js","hash":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1520490955454},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-hash.min.js","hash":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1520490955451},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-pager.js","hash":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1520490955452},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.js","hash":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1520490955455},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-share.min.js","hash":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1520490955457},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.js","hash":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1520490955459},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-thumbnail.min.js","hash":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1520490955460},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.js","hash":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1520490955462},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-video.min.js","hash":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1520490955463},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.js","hash":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1520490955464},{"_id":"themes/icarus/source/libs/lightgallery/js/lg-zoom.min.js","hash":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1520490955465},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.js","hash":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1520490955468},{"_id":"themes/icarus/source/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","hash":"c4248ea800bd5608344ce163f5658b57e7ef9410","modified":1520490955475},{"_id":"themes/icarus/source/libs/lightgallery/js/lightgallery.min.js","hash":"956ef9b706755318da69ad0b5d7786339d831251","modified":1520490955469},{"_id":"themes/icarus/source/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","hash":"e0350190d720a8fec0557ab47b318ec4e4486448","modified":1520490955476},{"_id":"themes/icarus/source/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","hash":"2c5b039b57f62625e88226a938679ec937431ad1","modified":1520490955477},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","hash":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f","modified":1520490955478},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","hash":"63eb74ef040aade256f2274a7f31a914edddb0ea","modified":1520490955479},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","hash":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f","modified":1520490955484},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","hash":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf","modified":1520490955486},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","hash":"415eee05976ab8b2471602a5ddb78a6c58fc21aa","modified":1520490955486},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","hash":"c5f29fed6632efe0aa83318369f0d8c4061b775b","modified":1520490955490},{"_id":"themes/icarus/source/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","hash":"a0b0c389cf46d63c850e61fed572485ff0b68183","modified":1520490955488},{"_id":"themes/icarus/source/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","hash":"be201d32a9aa5d186723ebb3c538be691aa8c53a","modified":1520490955492},{"_id":"themes/icarus/source/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","hash":"113978181dcac77baecef6115a9121d8f6e4fc3a","modified":1520490955495},{"_id":"themes/icarus/source/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","hash":"afc44700053c9a28f9ab26f6aec4862ac1d0795d","modified":1520490955494},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","hash":"5067c81462c15422853c94d21a1726865a61634f","modified":1520490955496},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","hash":"b366f2fda2e524eb5ef50058eefff249a3b96e6c","modified":1520490955497},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","hash":"ae80fb3cd16339aa7b5da280ab53975523dcaac2","modified":1520490955501},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","hash":"d22904914469be735490e3c8cb093c7862896dd5","modified":1520490955500},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","hash":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c","modified":1520490955503},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","hash":"d0b40a7848703556c6631f24e961a98ca5829255","modified":1520490955505},{"_id":"themes/icarus/source/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","hash":"e75607ba1417181397c700775b84303d5a2957b9","modified":1520490955504},{"_id":"themes/icarus/source/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","hash":"be365eca44760ce3fc9b377c43d4634958479c69","modified":1520490955506},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1520490955510},{"_id":"themes/icarus/source/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1520490955511},{"_id":"themes/icarus/source/libs/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1520490955375},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1520490955376},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1520490955395},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1520490955395},{"_id":"themes/icarus/source/libs/jquery/2.1.3/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1520490955397},{"_id":"themes/icarus/.git/logs/refs/remotes/origin/HEAD","hash":"ab1d6d8d66fd4f8a458e7cc8abc27811a80e5e1b","modified":1520493732273},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1520490955394},{"_id":"themes/icarus/source/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1520490955390},{"_id":"themes/icarus/.git/objects/pack/pack-d611b37c0bcd4551d83280da27dfe6b037cb9080.pack","hash":"e23244db5daa5b1caddcae6cfe0140b878c30145","modified":1520490954959},{"_id":"public/content.json","hash":"f7a0fdc205b70dd48a986332324a6f3b327a0e7c","modified":1520491387311},{"_id":"public/2018/03/06/Raspberry-PI-基本使用/index.html","hash":"86fff17c73337ddf98b77fc84fbf0ebd4f51ad69","modified":1520494021925},{"_id":"public/2018/02/27/redux-之页面跳转/index.html","hash":"b67cbe754b15ec03360a417dcebd1f3fc18b0378","modified":1520494021925},{"_id":"public/2017/09/05/Swift-High-Performance-Tip 1：Array和ContiguousArray/index.html","hash":"bc56167bdadec50ce29582533403eb2955a819dd","modified":1520494021925},{"_id":"public/2017/09/05/Swift-High-Performance-Tip 2：final和private(fileprivate)/index.html","hash":"6d486d3c909bd3c9ef7816062e5594d26c710a0f","modified":1520494021925},{"_id":"public/2017/09/05/RAC和内存管理/index.html","hash":"af1158795b1c9f3f9d77073ffcbed5e10f3f52c5","modified":1520494021925},{"_id":"public/2017/09/05/Vim-Tip/index.html","hash":"d585c8c63bd0a500d65235aee5921948f778ca24","modified":1520494021926},{"_id":"public/2017/09/05/Auto-Update/index.html","hash":"75bd3513945c45f72c1f7c07126656a991338ec4","modified":1520494021926},{"_id":"public/2017/09/05/include和import的区别/index.html","hash":"f74fb62a96c53ab7b1fa11abf16f4cbe0e85c11c","modified":1520494021926},{"_id":"public/2017/09/05/初步了解GCD/index.html","hash":"2332a349b3d223f5000733cb093f39863f460b63","modified":1520494021926},{"_id":"public/2017/09/05/启动/index.html","hash":"53749d1dd6f44d917b7a81f5cd61a749f9812f02","modified":1520494021926},{"_id":"public/2017/09/05/Shell-Tip/index.html","hash":"95cd1413943c28a13d4eaa28a69195c2446baa8a","modified":1520494021926},{"_id":"public/archives/index.html","hash":"645c8edb21d5e00d0845dd4d14fbdbbb4d897d02","modified":1520494021926},{"_id":"public/archives/page/2/index.html","hash":"4dbf40b29f4c643e178d8fe90bcb93643d95e7b9","modified":1520494021926},{"_id":"public/archives/2017/index.html","hash":"b59dc1b153836218f989b93d87b6da9917fb0b3f","modified":1520494021927},{"_id":"public/archives/2017/09/index.html","hash":"5fc252b8c5a39eaa366652861d7a8164a743029f","modified":1520494021927},{"_id":"public/archives/2018/index.html","hash":"70e1fc1299d6aaeecc3dc8298694920b059eab51","modified":1520494021927},{"_id":"public/archives/2018/02/index.html","hash":"6fc130a5ef107162f90c8cbc72e57ec2ea38e344","modified":1520494021927},{"_id":"public/archives/2018/03/index.html","hash":"518da937c425c572af14c47a410aca5ec085c047","modified":1520494021927},{"_id":"public/categories/tip/index.html","hash":"14969b883a3dbd9cf3b58c4989c162b4c7f63f7b","modified":1520494021927},{"_id":"public/categories/iOS/index.html","hash":"5127a8918056f170becd8a469d05980d76f18eed","modified":1520494021927},{"_id":"public/categories/other/index.html","hash":"c0691d5ed8d0d4e99a120feb21bd46ea9e55362e","modified":1520494021927},{"_id":"public/categories/React/index.html","hash":"501d0f3d19be66ca1e1b6e2c663618f164bba546","modified":1520494021927},{"_id":"public/index.html","hash":"a80ff93e1719ce93129b94bc9e223007dbd6e0a9","modified":1520494021927},{"_id":"public/page/2/index.html","hash":"d1f9890f3cd4e896272000ce70048381000d24e5","modified":1520494021927},{"_id":"public/tags/tip/index.html","hash":"ab386d7f49ff9e0fdbbcaa19a79d618042782ccb","modified":1520494021925},{"_id":"public/tags/iOS/index.html","hash":"20f69ff2e4500f27d0a5b709f08ed46111f3a24b","modified":1520494021924},{"_id":"public/tags/other/index.html","hash":"333862b370a4ab9055144ea42b83fac12bff942e","modified":1520494021925},{"_id":"public/tags/React/index.html","hash":"d2fae92638390ca03fa008b2df31a78cf7b0073b","modified":1520494021924},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1520491387336},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1520491387336},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1520491387336},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1520491387336},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1520491387336},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1520491387336},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1520491387336},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1520491387336},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1520491387337},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1520491387337},{"_id":"public/css/images/logo.png","hash":"e606a0584f98268b2fe92303f3254520862ef659","modified":1520491387337},{"_id":"public/css/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1520491387337},{"_id":"public/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1520491387337},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.css.map","hash":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb","modified":1520491387337},{"_id":"public/libs/lightgallery/css/lg-transitions.css.map","hash":"50c3348638b4d82fa08a449c690e8d2bb593005d","modified":1520491387337},{"_id":"public/libs/lightgallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1520491387337},{"_id":"public/libs/lightgallery/css/lightgallery.css.map","hash":"3175b4107078674d25798979f7666f4daf31e624","modified":1520491387338},{"_id":"public/libs/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1520491387338},{"_id":"public/libs/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1520491387338},{"_id":"public/libs/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1520491387338},{"_id":"public/libs/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1520491387338},{"_id":"public/libs/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1520491387338},{"_id":"public/libs/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1520491387338},{"_id":"public/libs/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","hash":"c4248ea800bd5608344ce163f5658b57e7ef9410","modified":1520491387338},{"_id":"public/libs/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","hash":"e0350190d720a8fec0557ab47b318ec4e4486448","modified":1520491387338},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","hash":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f","modified":1520491387339},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","hash":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f","modified":1520491387339},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","hash":"63eb74ef040aade256f2274a7f31a914edddb0ea","modified":1520491387339},{"_id":"public/libs/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1520491387339},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","hash":"c5f29fed6632efe0aa83318369f0d8c4061b775b","modified":1520491387339},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","hash":"415eee05976ab8b2471602a5ddb78a6c58fc21aa","modified":1520491387339},{"_id":"public/libs/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","hash":"2c5b039b57f62625e88226a938679ec937431ad1","modified":1520491387339},{"_id":"public/libs/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","hash":"be201d32a9aa5d186723ebb3c538be691aa8c53a","modified":1520491387339},{"_id":"public/libs/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","hash":"113978181dcac77baecef6115a9121d8f6e4fc3a","modified":1520491387339},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","hash":"a0b0c389cf46d63c850e61fed572485ff0b68183","modified":1520491387340},{"_id":"public/libs/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","hash":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf","modified":1520491387340},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","hash":"5067c81462c15422853c94d21a1726865a61634f","modified":1520491387340},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","hash":"ae80fb3cd16339aa7b5da280ab53975523dcaac2","modified":1520491387340},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","hash":"b366f2fda2e524eb5ef50058eefff249a3b96e6c","modified":1520491387340},{"_id":"public/libs/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","hash":"afc44700053c9a28f9ab26f6aec4862ac1d0795d","modified":1520491387340},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","hash":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c","modified":1520491387340},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","hash":"d0b40a7848703556c6631f24e961a98ca5829255","modified":1520491387340},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","hash":"d22904914469be735490e3c8cb093c7862896dd5","modified":1520491387340},{"_id":"public/libs/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","hash":"e75607ba1417181397c700775b84303d5a2957b9","modified":1520491387341},{"_id":"public/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1520491387341},{"_id":"public/libs/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1520491387341},{"_id":"public/libs/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","hash":"be365eca44760ce3fc9b377c43d4634958479c69","modified":1520491387341},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1520491388161},{"_id":"public/libs/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1520491388164},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1520491388167},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1520491388167},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1520491388167},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1520491388176},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1520491388177},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1520491388177},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1520491388177},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1520491388177},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1520491388177},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1520491388177},{"_id":"public/js/insight.js","hash":"c1bafa7f87e9f25fca1e033fc6d1e0c82712ac99","modified":1520491388177},{"_id":"public/js/main.js","hash":"23b373067df0dbac27622bc7537bb4fda243a9c8","modified":1520491388177},{"_id":"public/libs/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1520491388177},{"_id":"public/libs/open-sans/styles.css","hash":"5ca6e111046232bde112d33201a60532aee7d3c4","modified":1520491388177},{"_id":"public/libs/source-code-pro/styles.css","hash":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1520491388177},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.css","hash":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1520491388177},{"_id":"public/libs/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1520491388177},{"_id":"public/libs/lightgallery/js/lg-autoplay.js","hash":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1520491388177},{"_id":"public/libs/lightgallery/js/lg-hash.js","hash":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1520491388177},{"_id":"public/libs/lightgallery/js/lg-fullscreen.min.js","hash":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1520491388177},{"_id":"public/libs/lightgallery/js/lg-autoplay.min.js","hash":"d845741bcaf961579622880eb2a445257efad1ac","modified":1520491388177},{"_id":"public/libs/lightgallery/js/lg-fullscreen.js","hash":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1520491388177},{"_id":"public/libs/lightgallery/js/lg-pager.min.js","hash":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1520491388177},{"_id":"public/libs/lightgallery/js/lg-hash.min.js","hash":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1520491388178},{"_id":"public/libs/lightgallery/js/lg-pager.js","hash":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1520491388178},{"_id":"public/libs/lightgallery/js/lg-share.js","hash":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1520491388178},{"_id":"public/libs/lightgallery/js/lg-share.min.js","hash":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1520491388178},{"_id":"public/libs/lightgallery/js/lg-thumbnail.min.js","hash":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1520491388178},{"_id":"public/libs/lightgallery/js/lg-video.js","hash":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1520491388178},{"_id":"public/libs/lightgallery/js/lg-video.min.js","hash":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1520491388178},{"_id":"public/libs/lightgallery/js/lg-zoom.min.js","hash":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1520491388178},{"_id":"public/css/style.css","hash":"f48d9ebb230859086fa29957616afd3d1b962cb1","modified":1520491388178},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1520491388178},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1520491388178},{"_id":"public/libs/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1520491388178},{"_id":"public/libs/font-awesome/css/font-awesome.css","hash":"b5020c3860669185ba3f316fa7332cdf5c06f393","modified":1520491388178},{"_id":"public/libs/font-awesome/css/font-awesome.min.css","hash":"7cd5a3384333f95c3d37d9488ad82cd6c4b03761","modified":1520491388179},{"_id":"public/libs/lightgallery/css/lg-transitions.css","hash":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1520491388179},{"_id":"public/libs/lightgallery/css/lightgallery.css","hash":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1520491388179},{"_id":"public/libs/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1520491388179},{"_id":"public/libs/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1520491388179},{"_id":"public/libs/lightgallery/js/lg-thumbnail.js","hash":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1520491388179},{"_id":"public/libs/lightgallery/js/lg-zoom.js","hash":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1520491388179},{"_id":"public/libs/lightgallery/js/lightgallery.js","hash":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1520491388179},{"_id":"public/libs/lightgallery/js/lightgallery.min.js","hash":"956ef9b706755318da69ad0b5d7786339d831251","modified":1520491388179},{"_id":"public/libs/jquery/2.1.3/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1520491388179},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1520491388179},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1520491388183},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1520491388183},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1520491388190},{"_id":"themes/icarus/source/about/index.md","hash":"2847759c65295fdc47685cc32e10ae30b2f022ae","modified":1520490955280},{"_id":"themes/icarus/source/categories/index.md","hash":"55bee2cb88da438a2e8b1f29b1d7e954c07a9e60","modified":1520490955281},{"_id":"themes/icarus/source/tags/index.md","hash":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1520490955282},{"_id":"themes/icarus/.git/objects/c7/37bb814e53ccbfb854421efcf6407831975fd9","hash":"2cb438c02780b1faa4568db79ca41320f34731f8","modified":1520493142115},{"_id":"themes/icarus/source/categories/other/index.html","hash":"8b1778f780a5d09e847ddad29bd4a1698f89278e","modified":1520493382428},{"_id":"themes/icarus/source/categories/iOS/index.html","hash":"4179e24ff6787ccdb7db596d15826a84ed875888","modified":1520493382428},{"_id":"themes/icarus/source/categories/tip/index.html","hash":"9547e1bb4b45b2069f1466e65f6ce72854d534a7","modified":1520493382428},{"_id":"themes/icarus/source/categories/index.html","hash":"a0e7b2d1eee9ebe76a48f5ee8374ff0fedb9c0ba","modified":1520492210735},{"_id":"themes/icarus/source/categories/React/index.html","hash":"37dee540ad25a40376540d9b8ec2387f6f1228b4","modified":1520493382428},{"_id":"themes/icarus/source/tags/other/index.html","hash":"333862b370a4ab9055144ea42b83fac12bff942e","modified":1520493502154},{"_id":"themes/icarus/source/tags/iOS/index.html","hash":"20f69ff2e4500f27d0a5b709f08ed46111f3a24b","modified":1520493502154},{"_id":"themes/icarus/source/tags/tip/index.html","hash":"ab386d7f49ff9e0fdbbcaa19a79d618042782ccb","modified":1520493502154},{"_id":"themes/icarus/source/tags/React/index.html","hash":"d2fae92638390ca03fa008b2df31a78cf7b0073b","modified":1520493502154},{"_id":"themes/icarus/source/tags/index.html","hash":"e2c3686d48a74d9bd7a076203ed0c33a797d71ce","modified":1520492210735},{"_id":"themes/icarus/.git/objects/6d/0987dd882c573bf3474af70d1392d39564835a","hash":"09ae28238d627bfb89757f40d819d121abceec4f","modified":1520493488656},{"_id":"themes/icarus/.git/objects/78/02eafe4a3d1d9a4373391156ca4f839a20215c","hash":"50bed4bd46ef90cd18259c4803fdaf99e503fd6c","modified":1520493488658},{"_id":"themes/icarus/.git/objects/13/0e220f78f3647b2455fa041dce2003e02b3a47","hash":"2786d0f913f504e6a360c72958a8fbf8120cad4e","modified":1520493488660},{"_id":"themes/icarus/.git/objects/1d/7bef0e3c54aa34c76734d642de9501ad0791e4","hash":"7f641910e6cb9ab129b6c11bd8087838c07f06c8","modified":1520493488662},{"_id":"themes/icarus/.git/objects/52/48a31be0aeb1166394bdf8f719b75e3bad4030","hash":"b340dd64b92c1ddc2cb005c4a78208a93539e876","modified":1520493488663},{"_id":"themes/icarus/.git/objects/c1/946d478ed98f6881fdca51eb18238f69d55d88","hash":"d75971ad47f377a7966172ec56fc52122cb01b8d","modified":1520493488664},{"_id":"themes/icarus/.git/objects/d9/1aea48adcdbd70f905477c0caa20191e1e21fb","hash":"599e297be8e498079d75ae689d12876af19b5130","modified":1520493488657},{"_id":"themes/icarus/.git/objects/d9/5d7ed1d72cf92d1f7c36282e4ea173be797adb","hash":"8dec2f85f5727ad85d6c46fd37069956775c3b42","modified":1520493488665},{"_id":"themes/icarus/.git/objects/9c/228d20a50d6692715fb29f9029ac7f6839c5a9","hash":"25f75ee12bea44b14c933d62270d2f721e0de5a6","modified":1520493488667},{"_id":"themes/icarus/.git/objects/b5/06cb1ec878f9e8387a6d64764f18ef734e8a9a","hash":"c76791dde23aa446750dbd1cd7ad8f470726cde6","modified":1520493488670},{"_id":"themes/icarus/source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1520494080252},{"_id":"themes/icarus/.git/objects/36/280d07f3a5e502929b3c5952d6374c1683c256","hash":"8f6bd752ef89e2b4d80a0dd1e0e81ede9b0eea7e","modified":1520494051092},{"_id":"themes/icarus/.git/objects/3e/1540ab20cd0d121f7156bf48f79783ff408a95","hash":"259534e75fcc2fe968999b18ac013a1d9dcb5409","modified":1520494051099},{"_id":"themes/icarus/.git/objects/4c/b31b9a79d75c786faacc075a0d391075473900","hash":"d9dbeab3bba22c2727b22947ae71225c4cb187a1","modified":1520494051088},{"_id":"themes/icarus/.git/objects/5d/97ea5a693f8accce288974108c9fc659c061a3","hash":"75205b51f5e5197352efac8522dc99a715f8f1b8","modified":1520494051098},{"_id":"themes/icarus/source/_source/about/index.md","hash":"2847759c65295fdc47685cc32e10ae30b2f022ae","modified":1520493732283},{"_id":"themes/icarus/source/_source/categories/index.md","hash":"55bee2cb88da438a2e8b1f29b1d7e954c07a9e60","modified":1520493732283},{"_id":"themes/icarus/source/_source/tags/index.md","hash":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1520493732283}],"Category":[{"name":"tip","_id":"cjei470s30002u5vbxcftd4yq"},{"name":"iOS","_id":"cjei470sl000cu5vb5g4kajds"},{"name":"other","_id":"cjei470t3000yu5vbuncm8asd"},{"name":"React","_id":"cjei470t50014u5vb2n8z04ma"}],"Data":[],"Page":[],"Post":[{"layout":"post","title":"Auto Update","subtitle":"","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n```\n#!/bin/sh\n# 此脚本是用来自动更新 Mac 上的一些软件或配置\n\necho \"Begin gem update ...\"\ngem update\necho \"End gem update!\"\n\n#echo \"Begin gem install cocoapods ...\"\n#gem install cocoapods\n#echo \"End gem install cocoapods!\"\n\necho \"\\n\"\necho \"Begin pod setup ...\"\npod setup\necho \"End pod setup!\"\n\necho \"\\n\"\necho \"Begin brew update ...\"\nbrew update\necho \"End brew update\"\n```\n\n\n\n\n","source":"_posts/Auto-Update.md","raw":"---\nlayout: post \ntitle: Auto Update\nsubtitle: \"\"\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: tip\ntag: tip\n---\n\n```\n#!/bin/sh\n# 此脚本是用来自动更新 Mac 上的一些软件或配置\n\necho \"Begin gem update ...\"\ngem update\necho \"End gem update!\"\n\n#echo \"Begin gem install cocoapods ...\"\n#gem install cocoapods\n#echo \"End gem install cocoapods!\"\n\necho \"\\n\"\necho \"Begin pod setup ...\"\npod setup\necho \"End pod setup!\"\n\necho \"\\n\"\necho \"Begin brew update ...\"\nbrew update\necho \"End brew update\"\n```\n\n\n\n\n","slug":"Auto-Update","published":1,"updated":"2018-03-06T07:07:29.378Z","_id":"cjei470ru0000u5vbks7wgwm2","comments":1,"photos":[],"link":"","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\"># 此脚本是用来自动更新 Mac 上的一些软件或配置</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;Begin gem update ...&quot;</span><br><span class=\"line\">gem update</span><br><span class=\"line\">echo &quot;End gem update!&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#echo &quot;Begin gem install cocoapods ...&quot;</span><br><span class=\"line\">#gem install cocoapods</span><br><span class=\"line\">#echo &quot;End gem install cocoapods!&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;\\n&quot;</span><br><span class=\"line\">echo &quot;Begin pod setup ...&quot;</span><br><span class=\"line\">pod setup</span><br><span class=\"line\">echo &quot;End pod setup!&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;\\n&quot;</span><br><span class=\"line\">echo &quot;Begin brew update ...&quot;</span><br><span class=\"line\">brew update</span><br><span class=\"line\">echo &quot;End brew update&quot;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\"># 此脚本是用来自动更新 Mac 上的一些软件或配置</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;Begin gem update ...&quot;</span><br><span class=\"line\">gem update</span><br><span class=\"line\">echo &quot;End gem update!&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#echo &quot;Begin gem install cocoapods ...&quot;</span><br><span class=\"line\">#gem install cocoapods</span><br><span class=\"line\">#echo &quot;End gem install cocoapods!&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;\\n&quot;</span><br><span class=\"line\">echo &quot;Begin pod setup ...&quot;</span><br><span class=\"line\">pod setup</span><br><span class=\"line\">echo &quot;End pod setup!&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;\\n&quot;</span><br><span class=\"line\">echo &quot;Begin brew update ...&quot;</span><br><span class=\"line\">brew update</span><br><span class=\"line\">echo &quot;End brew update&quot;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"Raspberry PI 基本使用","subtitle":"记录自己在 RaspberryPI 比较频繁使用的命令","author":"帕帕","date":"2018-03-05T22:04:56.000Z","_content":"\n\n## 1. 保证 Raspberry PI 能够在外网使用\n\n```\n// 在你的 Raspberry PI 上使用 autossh 来实现不掉线的反向代理：\nautossh -M 5678 -fNR 2018:localhost:22 root@54.219.12.213\n```\n\n```\n// 在你的外网服务器（比如上面例子中的：54.219.12.213）上可以使用 ssh 登录你的 Raspberry PI\nssh -p 2018 pi@127.0.0.1\n```\n\n","source":"_posts/Raspberry-PI-基本使用.md","raw":"---\nlayout: post \ntitle: Raspberry PI 基本使用\nsubtitle: 记录自己在 RaspberryPI 比较频繁使用的命令\nauthor: 帕帕\ndate: 2018-03-05 22:04:56 +0800\ncategories: tip\ntag: tip\n---\n\n\n## 1. 保证 Raspberry PI 能够在外网使用\n\n```\n// 在你的 Raspberry PI 上使用 autossh 来实现不掉线的反向代理：\nautossh -M 5678 -fNR 2018:localhost:22 root@54.219.12.213\n```\n\n```\n// 在你的外网服务器（比如上面例子中的：54.219.12.213）上可以使用 ssh 登录你的 Raspberry PI\nssh -p 2018 pi@127.0.0.1\n```\n\n","slug":"Raspberry-PI-基本使用","published":1,"updated":"2018-03-06T07:07:42.313Z","comments":1,"photos":[],"link":"","_id":"cjei470s00001u5vb5jdyqmnu","content":"<h2 id=\"1-保证-Raspberry-PI-能够在外网使用\"><a href=\"#1-保证-Raspberry-PI-能够在外网使用\" class=\"headerlink\" title=\"1. 保证 Raspberry PI 能够在外网使用\"></a>1. 保证 Raspberry PI 能够在外网使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在你的 Raspberry PI 上使用 autossh 来实现不掉线的反向代理：</span><br><span class=\"line\">autossh -M 5678 -fNR 2018:localhost:22 root@54.219.12.213</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在你的外网服务器（比如上面例子中的：54.219.12.213）上可以使用 ssh 登录你的 Raspberry PI</span><br><span class=\"line\">ssh -p 2018 pi@127.0.0.1</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-保证-Raspberry-PI-能够在外网使用\"><a href=\"#1-保证-Raspberry-PI-能够在外网使用\" class=\"headerlink\" title=\"1. 保证 Raspberry PI 能够在外网使用\"></a>1. 保证 Raspberry PI 能够在外网使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在你的 Raspberry PI 上使用 autossh 来实现不掉线的反向代理：</span><br><span class=\"line\">autossh -M 5678 -fNR 2018:localhost:22 root@54.219.12.213</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在你的外网服务器（比如上面例子中的：54.219.12.213）上可以使用 ssh 登录你的 Raspberry PI</span><br><span class=\"line\">ssh -p 2018 pi@127.0.0.1</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"Swift High-Performance Tip 1：Array 和 ContiguousArray","subtitle":"简单了解一下 Swift 中的 Array 的性能","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n> Array 是随机存储的（random-access）集合类型。\n\n> ContiguousArray 是连续存储（contiguously stored）的数组，并且不允许和 NSArray 进行桥接的。\n\n当我们的数组元素是 Class 或 @objc protocol 类型的话，并且我们不需要在 Objective-C 中使用该数组的话，那么我们最好使用 ContiguousArray。这是因为 Array 需要额外的资源来处理跟 NSArray 的桥接功能，但是 ContiguousArray 则不需要，所以 ContiguousArray 比 Array 的效率要高。\n\n```Swift\nclass A {\n\n}\n\n// 不要用Array: let array = Array<A>()\n\nlet contiguousArray = ContiguousArray<A>()\n```\n\n另外需要注意的是官方文档说如果数组元素不是 Class 和 @objc protocol 类型的话，Array 和 ContiguousArray 的效率是一样的。（我猜测是因为如果 Array 的元素都是 Struct 类型的话，它就不需要消耗资源来处理桥接的问题了。）\n\n> Efficiency is equivalent to that of Array, unless Element is a class or @objc protocol type, in which case using ContiguousArray may be more efficient.\n\n但是 [@Paul Hudson](https://twitter.com/twostraws) 在他的[《Pro Swift》](https://gumroad.com/l/proswift)中说他发现即使数组元素是 Struct 类型的话，ContiguousArray 也要比 Array 更快。我们来看看他给出的例子：\n\n```Swift\nlet array2 = Array<Int>(1...1000000)\nlet array3 = ContiguousArray<Int>(1...1000000)\n\nvar start = CFAbsoluteTimeGetCurrent()\narray2.reduce(0, combine: +)\nvar end = CFAbsoluteTimeGetCurrent() - start\nprint(\"Took \\(end) seconds\")\n\nstart = CFAbsoluteTimeGetCurrent()\narray3.reduce(0, combine: +)\nend = CFAbsoluteTimeGetCurrent() - start\nprint(\"Took \\(end) seconds\")\n```\n\n经过我的测试，上面的代码中 ContiguousArray 只用了0.19秒而 Array 用了0.38秒，所以 ContiguousArray 确实要比 Array 快。\n\n如果大家想在性能上有所提升的话，建议大家可以用 ContiguousArray 试一试。\n\n","source":"_posts/Swift-High-Performance-Tip 1：Array和ContiguousArray.md","raw":"---\nlayout: post \ntitle: Swift High-Performance Tip 1：Array 和 ContiguousArray\nsubtitle: 简单了解一下 Swift 中的 Array 的性能\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: iOS\ntag: iOS\n---\n\n> Array 是随机存储的（random-access）集合类型。\n\n> ContiguousArray 是连续存储（contiguously stored）的数组，并且不允许和 NSArray 进行桥接的。\n\n当我们的数组元素是 Class 或 @objc protocol 类型的话，并且我们不需要在 Objective-C 中使用该数组的话，那么我们最好使用 ContiguousArray。这是因为 Array 需要额外的资源来处理跟 NSArray 的桥接功能，但是 ContiguousArray 则不需要，所以 ContiguousArray 比 Array 的效率要高。\n\n```Swift\nclass A {\n\n}\n\n// 不要用Array: let array = Array<A>()\n\nlet contiguousArray = ContiguousArray<A>()\n```\n\n另外需要注意的是官方文档说如果数组元素不是 Class 和 @objc protocol 类型的话，Array 和 ContiguousArray 的效率是一样的。（我猜测是因为如果 Array 的元素都是 Struct 类型的话，它就不需要消耗资源来处理桥接的问题了。）\n\n> Efficiency is equivalent to that of Array, unless Element is a class or @objc protocol type, in which case using ContiguousArray may be more efficient.\n\n但是 [@Paul Hudson](https://twitter.com/twostraws) 在他的[《Pro Swift》](https://gumroad.com/l/proswift)中说他发现即使数组元素是 Struct 类型的话，ContiguousArray 也要比 Array 更快。我们来看看他给出的例子：\n\n```Swift\nlet array2 = Array<Int>(1...1000000)\nlet array3 = ContiguousArray<Int>(1...1000000)\n\nvar start = CFAbsoluteTimeGetCurrent()\narray2.reduce(0, combine: +)\nvar end = CFAbsoluteTimeGetCurrent() - start\nprint(\"Took \\(end) seconds\")\n\nstart = CFAbsoluteTimeGetCurrent()\narray3.reduce(0, combine: +)\nend = CFAbsoluteTimeGetCurrent() - start\nprint(\"Took \\(end) seconds\")\n```\n\n经过我的测试，上面的代码中 ContiguousArray 只用了0.19秒而 Array 用了0.38秒，所以 ContiguousArray 确实要比 Array 快。\n\n如果大家想在性能上有所提升的话，建议大家可以用 ContiguousArray 试一试。\n\n","slug":"Swift-High-Performance-Tip 1：Array和ContiguousArray","published":1,"updated":"2018-03-06T07:06:43.216Z","_id":"cjei470s60004u5vbwmhenkn7","comments":1,"photos":[],"link":"","content":"<blockquote>\n<p>Array 是随机存储的（random-access）集合类型。</p>\n</blockquote>\n<blockquote>\n<p>ContiguousArray 是连续存储（contiguously stored）的数组，并且不允许和 NSArray 进行桥接的。</p>\n</blockquote>\n<p>当我们的数组元素是 Class 或 @objc protocol 类型的话，并且我们不需要在 Objective-C 中使用该数组的话，那么我们最好使用 ContiguousArray。这是因为 Array 需要额外的资源来处理跟 NSArray 的桥接功能，但是 ContiguousArray 则不需要，所以 ContiguousArray 比 Array 的效率要高。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不要用Array: let array = Array&lt;A&gt;()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> contiguousArray = <span class=\"type\">ContiguousArray</span>&lt;<span class=\"type\">A</span>&gt;()</span><br></pre></td></tr></table></figure>\n<p>另外需要注意的是官方文档说如果数组元素不是 Class 和 @objc protocol 类型的话，Array 和 ContiguousArray 的效率是一样的。（我猜测是因为如果 Array 的元素都是 Struct 类型的话，它就不需要消耗资源来处理桥接的问题了。）</p>\n<blockquote>\n<p>Efficiency is equivalent to that of Array, unless Element is a class or @objc protocol type, in which case using ContiguousArray may be more efficient.</p>\n</blockquote>\n<p>但是 <a href=\"https://twitter.com/twostraws\" target=\"_blank\" rel=\"noopener\">@Paul Hudson</a> 在他的<a href=\"https://gumroad.com/l/proswift\" target=\"_blank\" rel=\"noopener\">《Pro Swift》</a>中说他发现即使数组元素是 Struct 类型的话，ContiguousArray 也要比 Array 更快。我们来看看他给出的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> array2 = <span class=\"type\">Array</span>&lt;<span class=\"type\">Int</span>&gt;(<span class=\"number\">1</span>...<span class=\"number\">1000000</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> array3 = <span class=\"type\">ContiguousArray</span>&lt;<span class=\"type\">Int</span>&gt;(<span class=\"number\">1</span>...<span class=\"number\">1000000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> start = <span class=\"type\">CFAbsoluteTimeGetCurrent</span>()</span><br><span class=\"line\">array2.<span class=\"built_in\">reduce</span>(<span class=\"number\">0</span>, combine: +)</span><br><span class=\"line\"><span class=\"keyword\">var</span> end = <span class=\"type\">CFAbsoluteTimeGetCurrent</span>() - start</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Took <span class=\"subst\">\\(end)</span> seconds\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">start = <span class=\"type\">CFAbsoluteTimeGetCurrent</span>()</span><br><span class=\"line\">array3.<span class=\"built_in\">reduce</span>(<span class=\"number\">0</span>, combine: +)</span><br><span class=\"line\">end = <span class=\"type\">CFAbsoluteTimeGetCurrent</span>() - start</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Took <span class=\"subst\">\\(end)</span> seconds\"</span>)</span><br></pre></td></tr></table></figure>\n<p>经过我的测试，上面的代码中 ContiguousArray 只用了0.19秒而 Array 用了0.38秒，所以 ContiguousArray 确实要比 Array 快。</p>\n<p>如果大家想在性能上有所提升的话，建议大家可以用 ContiguousArray 试一试。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Array 是随机存储的（random-access）集合类型。</p>\n</blockquote>\n<blockquote>\n<p>ContiguousArray 是连续存储（contiguously stored）的数组，并且不允许和 NSArray 进行桥接的。</p>\n</blockquote>\n<p>当我们的数组元素是 Class 或 @objc protocol 类型的话，并且我们不需要在 Objective-C 中使用该数组的话，那么我们最好使用 ContiguousArray。这是因为 Array 需要额外的资源来处理跟 NSArray 的桥接功能，但是 ContiguousArray 则不需要，所以 ContiguousArray 比 Array 的效率要高。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不要用Array: let array = Array&lt;A&gt;()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> contiguousArray = <span class=\"type\">ContiguousArray</span>&lt;<span class=\"type\">A</span>&gt;()</span><br></pre></td></tr></table></figure>\n<p>另外需要注意的是官方文档说如果数组元素不是 Class 和 @objc protocol 类型的话，Array 和 ContiguousArray 的效率是一样的。（我猜测是因为如果 Array 的元素都是 Struct 类型的话，它就不需要消耗资源来处理桥接的问题了。）</p>\n<blockquote>\n<p>Efficiency is equivalent to that of Array, unless Element is a class or @objc protocol type, in which case using ContiguousArray may be more efficient.</p>\n</blockquote>\n<p>但是 <a href=\"https://twitter.com/twostraws\" target=\"_blank\" rel=\"noopener\">@Paul Hudson</a> 在他的<a href=\"https://gumroad.com/l/proswift\" target=\"_blank\" rel=\"noopener\">《Pro Swift》</a>中说他发现即使数组元素是 Struct 类型的话，ContiguousArray 也要比 Array 更快。我们来看看他给出的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> array2 = <span class=\"type\">Array</span>&lt;<span class=\"type\">Int</span>&gt;(<span class=\"number\">1</span>...<span class=\"number\">1000000</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> array3 = <span class=\"type\">ContiguousArray</span>&lt;<span class=\"type\">Int</span>&gt;(<span class=\"number\">1</span>...<span class=\"number\">1000000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> start = <span class=\"type\">CFAbsoluteTimeGetCurrent</span>()</span><br><span class=\"line\">array2.<span class=\"built_in\">reduce</span>(<span class=\"number\">0</span>, combine: +)</span><br><span class=\"line\"><span class=\"keyword\">var</span> end = <span class=\"type\">CFAbsoluteTimeGetCurrent</span>() - start</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Took <span class=\"subst\">\\(end)</span> seconds\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">start = <span class=\"type\">CFAbsoluteTimeGetCurrent</span>()</span><br><span class=\"line\">array3.<span class=\"built_in\">reduce</span>(<span class=\"number\">0</span>, combine: +)</span><br><span class=\"line\">end = <span class=\"type\">CFAbsoluteTimeGetCurrent</span>() - start</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Took <span class=\"subst\">\\(end)</span> seconds\"</span>)</span><br></pre></td></tr></table></figure>\n<p>经过我的测试，上面的代码中 ContiguousArray 只用了0.19秒而 Array 用了0.38秒，所以 ContiguousArray 确实要比 Array 快。</p>\n<p>如果大家想在性能上有所提升的话，建议大家可以用 ContiguousArray 试一试。</p>\n"},{"layout":"post","title":"Swift High-Performance Tip 2：final 和 private(fileprivate)","subtitle":"简单了解一下 Swift 权限控制对性能的影响","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n> Dynamic dispatch means that program has to determine at run time which method or property is being referred to and then perform an indirect call or indirect access.\n\n我们都知道 Swift 的 class 是可以被继承，function 和 property 是可以被重写的，而这就意味着 Swift 需要 dynamic dispatch 这种机制来完成这些功能。Swift 的 dynamic dispatch 首先会再 method table 查找方法，然后间接调用。很明显这种方式要比直接调用的效率慢，并且用间接调用的方式还会阻止编译器的一些优化无法实现。\n\n**那么应该怎么优化呢？**\n\n当我们明确的知道 class、function、property 是不需要 overridden，我们可以通过使用 final 和 private(fileprivate) 这些关键字减少动态派发的发生，从而有效的提高效率。\n\n在 Swift 中，如果被 final 或 private(fileprivate) 修饰的 class、function、property 是不能 overridden，并且调用这些 class、function、property 的时候不再通过 dynamic dispatch 去间接调用，而是直接调用。\n\n所以，通过在必要的代码中使用 final 或 private(fileprivate) 这些关键字进行优化的话，将可以有效提高的效率。\n\n**Whole Module Optimization**\n\nSwift 的 class、function、property 的默认权限都是 internal ，除非我们明确的加上 public 或 private(fileprivate) 关键字才能改变它们的默认权限。\n\n编译器在编译 Module 的时候都是对里面的源文件进行单独编译，这样的话编译器就无法确切的知道被 internal 修饰的 class、function、property 究竟有没有被 overridden。一旦我们开启 Whole Module Optimization 的优化选项，编译器就会同时对整个 Module 的所有源文件进行编译，这个时候编译器就可以知道哪些被 internal 修饰的 class、function、property 没有被 overridden，从而把它们的权限从 internal 修改为 final。这样的话，就可以减少 dynamic dispatch 的发生从而提高效率。\n\n开启编译优化选项的步骤如下：Xcode -> Build Settings -> Swift Compiler -> Optimization Level。\n\n![](http://i.imgur.com/0AxWEVA.jpg)\n\n---\n\n**参考文献**\n\n1. https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/\n\n2. https://developer.apple.com/swift/blog/?id=27\n\n3. https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations\n\n","source":"_posts/Swift-High-Performance-Tip 2：final和private(fileprivate).md","raw":"---\nlayout: post \ntitle: Swift High-Performance Tip 2：final 和 private(fileprivate)\nsubtitle: 简单了解一下 Swift 权限控制对性能的影响 \nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: iOS\ntag: iOS\n---\n\n> Dynamic dispatch means that program has to determine at run time which method or property is being referred to and then perform an indirect call or indirect access.\n\n我们都知道 Swift 的 class 是可以被继承，function 和 property 是可以被重写的，而这就意味着 Swift 需要 dynamic dispatch 这种机制来完成这些功能。Swift 的 dynamic dispatch 首先会再 method table 查找方法，然后间接调用。很明显这种方式要比直接调用的效率慢，并且用间接调用的方式还会阻止编译器的一些优化无法实现。\n\n**那么应该怎么优化呢？**\n\n当我们明确的知道 class、function、property 是不需要 overridden，我们可以通过使用 final 和 private(fileprivate) 这些关键字减少动态派发的发生，从而有效的提高效率。\n\n在 Swift 中，如果被 final 或 private(fileprivate) 修饰的 class、function、property 是不能 overridden，并且调用这些 class、function、property 的时候不再通过 dynamic dispatch 去间接调用，而是直接调用。\n\n所以，通过在必要的代码中使用 final 或 private(fileprivate) 这些关键字进行优化的话，将可以有效提高的效率。\n\n**Whole Module Optimization**\n\nSwift 的 class、function、property 的默认权限都是 internal ，除非我们明确的加上 public 或 private(fileprivate) 关键字才能改变它们的默认权限。\n\n编译器在编译 Module 的时候都是对里面的源文件进行单独编译，这样的话编译器就无法确切的知道被 internal 修饰的 class、function、property 究竟有没有被 overridden。一旦我们开启 Whole Module Optimization 的优化选项，编译器就会同时对整个 Module 的所有源文件进行编译，这个时候编译器就可以知道哪些被 internal 修饰的 class、function、property 没有被 overridden，从而把它们的权限从 internal 修改为 final。这样的话，就可以减少 dynamic dispatch 的发生从而提高效率。\n\n开启编译优化选项的步骤如下：Xcode -> Build Settings -> Swift Compiler -> Optimization Level。\n\n![](http://i.imgur.com/0AxWEVA.jpg)\n\n---\n\n**参考文献**\n\n1. https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/\n\n2. https://developer.apple.com/swift/blog/?id=27\n\n3. https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations\n\n","slug":"Swift-High-Performance-Tip 2：final和private(fileprivate)","published":1,"updated":"2018-03-06T07:06:37.644Z","comments":1,"photos":[],"link":"","_id":"cjei470s90005u5vb8ivr8y63","content":"<blockquote>\n<p>Dynamic dispatch means that program has to determine at run time which method or property is being referred to and then perform an indirect call or indirect access.</p>\n</blockquote>\n<p>我们都知道 Swift 的 class 是可以被继承，function 和 property 是可以被重写的，而这就意味着 Swift 需要 dynamic dispatch 这种机制来完成这些功能。Swift 的 dynamic dispatch 首先会再 method table 查找方法，然后间接调用。很明显这种方式要比直接调用的效率慢，并且用间接调用的方式还会阻止编译器的一些优化无法实现。</p>\n<p><strong>那么应该怎么优化呢？</strong></p>\n<p>当我们明确的知道 class、function、property 是不需要 overridden，我们可以通过使用 final 和 private(fileprivate) 这些关键字减少动态派发的发生，从而有效的提高效率。</p>\n<p>在 Swift 中，如果被 final 或 private(fileprivate) 修饰的 class、function、property 是不能 overridden，并且调用这些 class、function、property 的时候不再通过 dynamic dispatch 去间接调用，而是直接调用。</p>\n<p>所以，通过在必要的代码中使用 final 或 private(fileprivate) 这些关键字进行优化的话，将可以有效提高的效率。</p>\n<p><strong>Whole Module Optimization</strong></p>\n<p>Swift 的 class、function、property 的默认权限都是 internal ，除非我们明确的加上 public 或 private(fileprivate) 关键字才能改变它们的默认权限。</p>\n<p>编译器在编译 Module 的时候都是对里面的源文件进行单独编译，这样的话编译器就无法确切的知道被 internal 修饰的 class、function、property 究竟有没有被 overridden。一旦我们开启 Whole Module Optimization 的优化选项，编译器就会同时对整个 Module 的所有源文件进行编译，这个时候编译器就可以知道哪些被 internal 修饰的 class、function、property 没有被 overridden，从而把它们的权限从 internal 修改为 final。这样的话，就可以减少 dynamic dispatch 的发生从而提高效率。</p>\n<p>开启编译优化选项的步骤如下：Xcode -&gt; Build Settings -&gt; Swift Compiler -&gt; Optimization Level。</p>\n<p><img src=\"http://i.imgur.com/0AxWEVA.jpg\" alt=\"\"></p>\n<hr>\n<p><strong>参考文献</strong></p>\n<ol>\n<li><p><a href=\"https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/\" target=\"_blank\" rel=\"noopener\">https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/</a></p>\n</li>\n<li><p><a href=\"https://developer.apple.com/swift/blog/?id=27\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/swift/blog/?id=27</a></p>\n</li>\n<li><p><a href=\"https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations\" target=\"_blank\" rel=\"noopener\">https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Dynamic dispatch means that program has to determine at run time which method or property is being referred to and then perform an indirect call or indirect access.</p>\n</blockquote>\n<p>我们都知道 Swift 的 class 是可以被继承，function 和 property 是可以被重写的，而这就意味着 Swift 需要 dynamic dispatch 这种机制来完成这些功能。Swift 的 dynamic dispatch 首先会再 method table 查找方法，然后间接调用。很明显这种方式要比直接调用的效率慢，并且用间接调用的方式还会阻止编译器的一些优化无法实现。</p>\n<p><strong>那么应该怎么优化呢？</strong></p>\n<p>当我们明确的知道 class、function、property 是不需要 overridden，我们可以通过使用 final 和 private(fileprivate) 这些关键字减少动态派发的发生，从而有效的提高效率。</p>\n<p>在 Swift 中，如果被 final 或 private(fileprivate) 修饰的 class、function、property 是不能 overridden，并且调用这些 class、function、property 的时候不再通过 dynamic dispatch 去间接调用，而是直接调用。</p>\n<p>所以，通过在必要的代码中使用 final 或 private(fileprivate) 这些关键字进行优化的话，将可以有效提高的效率。</p>\n<p><strong>Whole Module Optimization</strong></p>\n<p>Swift 的 class、function、property 的默认权限都是 internal ，除非我们明确的加上 public 或 private(fileprivate) 关键字才能改变它们的默认权限。</p>\n<p>编译器在编译 Module 的时候都是对里面的源文件进行单独编译，这样的话编译器就无法确切的知道被 internal 修饰的 class、function、property 究竟有没有被 overridden。一旦我们开启 Whole Module Optimization 的优化选项，编译器就会同时对整个 Module 的所有源文件进行编译，这个时候编译器就可以知道哪些被 internal 修饰的 class、function、property 没有被 overridden，从而把它们的权限从 internal 修改为 final。这样的话，就可以减少 dynamic dispatch 的发生从而提高效率。</p>\n<p>开启编译优化选项的步骤如下：Xcode -&gt; Build Settings -&gt; Swift Compiler -&gt; Optimization Level。</p>\n<p><img src=\"http://i.imgur.com/0AxWEVA.jpg\" alt=\"\"></p>\n<hr>\n<p><strong>参考文献</strong></p>\n<ol>\n<li><p><a href=\"https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/\" target=\"_blank\" rel=\"noopener\">https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/</a></p>\n</li>\n<li><p><a href=\"https://developer.apple.com/swift/blog/?id=27\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/swift/blog/?id=27</a></p>\n</li>\n<li><p><a href=\"https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations\" target=\"_blank\" rel=\"noopener\">https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations</a></p>\n</li>\n</ol>\n"},{"layout":"post","title":"RAC和内存管理","subtitle":"最近在用 RAC 的时候发现自己对内存管理还是有些困惑...","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n最近在用 RAC 的时候发现自己对内存管理还是有些困惑，于是自己写了一些代码来验证自己的一些理解。\n在一开始接触 RAC 的时候，我们知道 RAC 对于 block 都是 copy 赋值的。\n\n```\n@implementation RACSignal\n\n#pragma mark Lifecycle\n\n+ (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe {\n    return [RACDynamicSignal createSignal:didSubscribe];\n}\n```\n\n```\n@implementation RACDynamicSignal\n\n#pragma mark Lifecycle\n\n+ (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe {\n    RACDynamicSignal *signal = [[self alloc] init];\n    signal->_didSubscribe = [didSubscribe copy];\n    return [signal setNameWithFormat:@\"+createSignal:\"];\n}\n```\n\n在创建 RACSingal 的时候会调用其子类 RACDynamicSignal 去创建，我们也看到 RACDynamicSignal 对 didSuscribe 这个 block 是进行了 copy。所以大家可能会被要求注意循环引用的问题，于是大家都用 @weakify(target) 和 @strongify(target) 来避免循环引用的问题。那是不是所有用到 RAC 的地方都需要使用这些宏来避免循环引用的问题，不尽然。比如下面这个：\n\n```\n// 场景1\n[RACObserve(self, title) subscribeNext:^(id x) {\n    NSLog(@\"%@\", x);\n}];\n```\n\n接下来，我们来对比以下的几种用法\n\n```\n@interface ViewController()\n@property (strong, nonatomic) ViewModel * viewModel;\n@end\n\n@implementation ViewController\n\n- (void)viewDidiLoad {\n    [super viewDidLoad];\n\n    self.viewModel = [ViewModel new];\n\n    // 场景2\n    dispatch_async(dispatch_get_main_queue(), ^{\n        self.title = @\"你好\";\n    });\n\n    // 场景3\n    [self.viewModel.titleSignal subscribeNext:^(NSString * title) {\n        self.title = title;\n    }];\n\n    // 场景4\n    [RACObserve(self.viewModel, title) subscribeNext:^(NSString * title)     {\n        self.title = title;\n    }]; \n}\n\n@end\n```\n\n场景2是我们平常都会用到的，而且我们也没有在这种场景下去考虑循环引用的问题，这是因为 dispatch 的 block 不是属于 self 的（至于这个 block 是属于谁的，回头我再查点资料或者请各位指教），所以即使你在 block 使用了 self 也不会有循环应用的问题。\n\n场景3很明显是有循环引用的问题：**self->viewModel->titleSignal->block->self**，这个时候如果我们不做处理的话，那么 self 就永远不会被释放。正确的做法应该是使用 @weakify(self) 和 @strongify(self)：\n\n```\n// 场景3\n@weakify(self);\n[self.viewModel.titleSignal subscribeNext:^(NSString * title) {\n    @strongify(self);\n    self.title = title;\n}];\n```\n\n场景4在我们看来是没有问题的，因为这里看起来只有 **singal->block->self** 的引用，它们之间并没有造成循环引用的问题。我们先来看看 RACObserve 的实现：\n\n```\n#define RACObserve(TARGET, KEYPATH) \\\n({ \\\n_Pragma(\"clang diagnostic push\") \\\n_Pragma(\"clang diagnostic ignored \\\"-Wreceiver-is-weak\\\"\") \\\n__weak id target_ = (TARGET); \\\n[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \\\n_Pragma(\"clang diagnostic pop\") \\\n})\n\n- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak NSObject *)observer;\n```\n\n其实，看到这里你会认为这里只是调用了一个方法创建了一个 Signal，而且这个 Signal 也并不属于任何对象。我们再来看看具体的实现是怎么样的？\n\n```\n- (RACSignal *)rac_valuesAndChangesForKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options observer:(__weak NSObject *)weakObserver {\n    NSObject *strongObserver = weakObserver;\n    keyPath = [keyPath copy];\n\n    NSRecursiveLock *objectLock = [[NSRecursiveLock alloc] init];\n    objectLock.name = @\"org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing\";\n\n    __weak NSObject *weakSelf = self;\n\n    RACSignal *deallocSignal = [[RACSignal zip:@[\n                            self.rac_willDeallocSignal,\n                            strongObserver.rac_willDeallocSignal ?: [RACSignal never]\n    ]] doCompleted:^{\n        // Forces deallocation to wait if the object variables are currently\n        // being read on another thread.\n        [objectLock lock];\n        @onExit {\n            [objectLock unlock];\n        };\n    }];\n\n    return [[[RACSignal createSignal:^ RACDisposable * (id<RACSubscriber> subscriber) {\n        // Hold onto the lock the whole time we're setting up the KVO\n        // observation, because any resurrection that might be caused by our\n        // retaining below must be balanced out by the time -dealloc returns\n        // (if another thread is waiting on the lock above).\n        [objectLock lock];\n        @onExit {\n            [objectLock unlock];\n        };\n    \n        __strong NSObject *observer __attribute__((objc_precise_lifetime)) = weakObserver;\n        __strong NSObject *self __attribute__((objc_precise_lifetime)) = weakSelf;\n    \n        if (self == nil) {\n            [subscriber sendCompleted];\n            return nil;\n        }\n    \n        return [self rac_observeKeyPath:keyPath options:options observer:observer block:^(id value, NSDictionary *change, BOOL causedByDealloc, BOOL affectedOnlyLastComponent) {\n                [subscriber sendNext:RACTuplePack(value, change)];\n        }];\n    }] takeUntil:deallocSignal] setNameWithFormat:@\"%@ -rac_valueAndChangesForKeyPath: %@ options: %lu observer: %@\", self.rac_description, keyPath, (unsigned long)options, strongObserver.rac_description];\n}\n```\n\n重点观察 **deallocSignal** 和 **[signal takeUntile:deallocSignal]**，我们把 deallocSignal 单独拿出来看看：\n\n```\nRACSignal *deallocSignal = [[RACSignal zip:@[\n                        self.rac_willDeallocSignal,\n                        strongObserver.rac_willDeallocSignal ?: [RACSignal never]\n                        ]] doCompleted:^{\n    // Forces deallocation to wait if the object variables are currently\n    // being read on another thread.\n    [objectLock lock];\n    @onExit {\n    [objectLock unlock];\n    };\n}];\n```\n\n这里的 deallocSignal 是只有在 self 和 strongObserve 都将要发生 dealloc 的时候才会触发的。即用 RACObserve 创建的信号只有在其 target 和 observe 都发生 dealloc 的时候才会被 disposable (这个好像是 RAC 用来销毁自己资源的东西)。不明白的童鞋，我们回头来分析一下场景4的代码：\n\n```\n// 场景4\n[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) {\n    self.title = title;\n}];\n```\n\n用 RACObserve 创建的信号看起来只要出了函数体其资源应该就会被回收，但是这个信号其实是只有在 self.viewModel.rac_willDeallocSignal 和 self.rac_willDeallocSignal 都发生的情况下才会被释放。所以场景4的引用关系看起来只有 signal->block->self，但是这个 signal 只有在 self.rac_willDeallocSignal 的时候才会被释放。所以这里如果不打断这种关系的话就会造成循环引用的问题，正确做法应该是：\n\n```\n// 场景4\n@weakify(self);\n[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) {\n    @strongify(self);\n    self.title = title;\n}];\n```\n\n最后，在说一个特别需要注意的，就是 UITableViewCell 和 UICollectionViewCell 复用和 RAC 的问题。\n\n```\n- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return 1000;\n}\n\n- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath {\n    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"TableViewCell\"];\n\n    @weakify(self);\n    [RACObserve(cell.textLabel, text) subscribeNext:^(id x) {\n        @strongify(self);\n        NSLog(@\"%@\", self);\n    }];\n\n    return cell;\n}\n```\n\n我们看到这里的 RACObserve 创建的 Signal 和 self 之间已经去掉了循环引用的问题，所以应该是没有什么问题的。但是结合之前我们对 RACObserve 的理解再仔细分析一下，这里的 Signal 只要 self 没有被 dealloc 的话就不会被释放。虽然每次 UITableViewCell 都会被重用，但是每次重用过程中创建的信号确实无法被 disposable。那我们该怎么做呢？\n\n```\n- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return 1000;\n}\n\n- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath {\n    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"TableViewCell\"];\n\n    @weakify(self);\n    [[RACObserve(cell.textLabel, text) takeUntil:cell.rac_prepareForReuseSignal] subscribeNext:^(id x) {\n        @strongify(self);\n        NSLog(@\"%@\", self);\n    }];\n\n    return cell;\n}\n```\n\n注意，我们在cell里面创建的信号加上 takeUntil:cell.rac_prepareForReuseSignal，这个是让 cell 在每次重用的时候都去 disposable 创建的信号。\n\n以上所说的关于内存的东西我都用 Instrument 的 Allocations 验证过了，但是依旧建议大家自己也去试试。\n\n\n","source":"_posts/RAC和内存管理.md","raw":"---\nlayout: post \ntitle: RAC和内存管理\nsubtitle: 最近在用 RAC 的时候发现自己对内存管理还是有些困惑...\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: iOS\ntag: iOS \n---\n\n最近在用 RAC 的时候发现自己对内存管理还是有些困惑，于是自己写了一些代码来验证自己的一些理解。\n在一开始接触 RAC 的时候，我们知道 RAC 对于 block 都是 copy 赋值的。\n\n```\n@implementation RACSignal\n\n#pragma mark Lifecycle\n\n+ (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe {\n    return [RACDynamicSignal createSignal:didSubscribe];\n}\n```\n\n```\n@implementation RACDynamicSignal\n\n#pragma mark Lifecycle\n\n+ (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe {\n    RACDynamicSignal *signal = [[self alloc] init];\n    signal->_didSubscribe = [didSubscribe copy];\n    return [signal setNameWithFormat:@\"+createSignal:\"];\n}\n```\n\n在创建 RACSingal 的时候会调用其子类 RACDynamicSignal 去创建，我们也看到 RACDynamicSignal 对 didSuscribe 这个 block 是进行了 copy。所以大家可能会被要求注意循环引用的问题，于是大家都用 @weakify(target) 和 @strongify(target) 来避免循环引用的问题。那是不是所有用到 RAC 的地方都需要使用这些宏来避免循环引用的问题，不尽然。比如下面这个：\n\n```\n// 场景1\n[RACObserve(self, title) subscribeNext:^(id x) {\n    NSLog(@\"%@\", x);\n}];\n```\n\n接下来，我们来对比以下的几种用法\n\n```\n@interface ViewController()\n@property (strong, nonatomic) ViewModel * viewModel;\n@end\n\n@implementation ViewController\n\n- (void)viewDidiLoad {\n    [super viewDidLoad];\n\n    self.viewModel = [ViewModel new];\n\n    // 场景2\n    dispatch_async(dispatch_get_main_queue(), ^{\n        self.title = @\"你好\";\n    });\n\n    // 场景3\n    [self.viewModel.titleSignal subscribeNext:^(NSString * title) {\n        self.title = title;\n    }];\n\n    // 场景4\n    [RACObserve(self.viewModel, title) subscribeNext:^(NSString * title)     {\n        self.title = title;\n    }]; \n}\n\n@end\n```\n\n场景2是我们平常都会用到的，而且我们也没有在这种场景下去考虑循环引用的问题，这是因为 dispatch 的 block 不是属于 self 的（至于这个 block 是属于谁的，回头我再查点资料或者请各位指教），所以即使你在 block 使用了 self 也不会有循环应用的问题。\n\n场景3很明显是有循环引用的问题：**self->viewModel->titleSignal->block->self**，这个时候如果我们不做处理的话，那么 self 就永远不会被释放。正确的做法应该是使用 @weakify(self) 和 @strongify(self)：\n\n```\n// 场景3\n@weakify(self);\n[self.viewModel.titleSignal subscribeNext:^(NSString * title) {\n    @strongify(self);\n    self.title = title;\n}];\n```\n\n场景4在我们看来是没有问题的，因为这里看起来只有 **singal->block->self** 的引用，它们之间并没有造成循环引用的问题。我们先来看看 RACObserve 的实现：\n\n```\n#define RACObserve(TARGET, KEYPATH) \\\n({ \\\n_Pragma(\"clang diagnostic push\") \\\n_Pragma(\"clang diagnostic ignored \\\"-Wreceiver-is-weak\\\"\") \\\n__weak id target_ = (TARGET); \\\n[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \\\n_Pragma(\"clang diagnostic pop\") \\\n})\n\n- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak NSObject *)observer;\n```\n\n其实，看到这里你会认为这里只是调用了一个方法创建了一个 Signal，而且这个 Signal 也并不属于任何对象。我们再来看看具体的实现是怎么样的？\n\n```\n- (RACSignal *)rac_valuesAndChangesForKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options observer:(__weak NSObject *)weakObserver {\n    NSObject *strongObserver = weakObserver;\n    keyPath = [keyPath copy];\n\n    NSRecursiveLock *objectLock = [[NSRecursiveLock alloc] init];\n    objectLock.name = @\"org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing\";\n\n    __weak NSObject *weakSelf = self;\n\n    RACSignal *deallocSignal = [[RACSignal zip:@[\n                            self.rac_willDeallocSignal,\n                            strongObserver.rac_willDeallocSignal ?: [RACSignal never]\n    ]] doCompleted:^{\n        // Forces deallocation to wait if the object variables are currently\n        // being read on another thread.\n        [objectLock lock];\n        @onExit {\n            [objectLock unlock];\n        };\n    }];\n\n    return [[[RACSignal createSignal:^ RACDisposable * (id<RACSubscriber> subscriber) {\n        // Hold onto the lock the whole time we're setting up the KVO\n        // observation, because any resurrection that might be caused by our\n        // retaining below must be balanced out by the time -dealloc returns\n        // (if another thread is waiting on the lock above).\n        [objectLock lock];\n        @onExit {\n            [objectLock unlock];\n        };\n    \n        __strong NSObject *observer __attribute__((objc_precise_lifetime)) = weakObserver;\n        __strong NSObject *self __attribute__((objc_precise_lifetime)) = weakSelf;\n    \n        if (self == nil) {\n            [subscriber sendCompleted];\n            return nil;\n        }\n    \n        return [self rac_observeKeyPath:keyPath options:options observer:observer block:^(id value, NSDictionary *change, BOOL causedByDealloc, BOOL affectedOnlyLastComponent) {\n                [subscriber sendNext:RACTuplePack(value, change)];\n        }];\n    }] takeUntil:deallocSignal] setNameWithFormat:@\"%@ -rac_valueAndChangesForKeyPath: %@ options: %lu observer: %@\", self.rac_description, keyPath, (unsigned long)options, strongObserver.rac_description];\n}\n```\n\n重点观察 **deallocSignal** 和 **[signal takeUntile:deallocSignal]**，我们把 deallocSignal 单独拿出来看看：\n\n```\nRACSignal *deallocSignal = [[RACSignal zip:@[\n                        self.rac_willDeallocSignal,\n                        strongObserver.rac_willDeallocSignal ?: [RACSignal never]\n                        ]] doCompleted:^{\n    // Forces deallocation to wait if the object variables are currently\n    // being read on another thread.\n    [objectLock lock];\n    @onExit {\n    [objectLock unlock];\n    };\n}];\n```\n\n这里的 deallocSignal 是只有在 self 和 strongObserve 都将要发生 dealloc 的时候才会触发的。即用 RACObserve 创建的信号只有在其 target 和 observe 都发生 dealloc 的时候才会被 disposable (这个好像是 RAC 用来销毁自己资源的东西)。不明白的童鞋，我们回头来分析一下场景4的代码：\n\n```\n// 场景4\n[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) {\n    self.title = title;\n}];\n```\n\n用 RACObserve 创建的信号看起来只要出了函数体其资源应该就会被回收，但是这个信号其实是只有在 self.viewModel.rac_willDeallocSignal 和 self.rac_willDeallocSignal 都发生的情况下才会被释放。所以场景4的引用关系看起来只有 signal->block->self，但是这个 signal 只有在 self.rac_willDeallocSignal 的时候才会被释放。所以这里如果不打断这种关系的话就会造成循环引用的问题，正确做法应该是：\n\n```\n// 场景4\n@weakify(self);\n[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) {\n    @strongify(self);\n    self.title = title;\n}];\n```\n\n最后，在说一个特别需要注意的，就是 UITableViewCell 和 UICollectionViewCell 复用和 RAC 的问题。\n\n```\n- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return 1000;\n}\n\n- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath {\n    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"TableViewCell\"];\n\n    @weakify(self);\n    [RACObserve(cell.textLabel, text) subscribeNext:^(id x) {\n        @strongify(self);\n        NSLog(@\"%@\", self);\n    }];\n\n    return cell;\n}\n```\n\n我们看到这里的 RACObserve 创建的 Signal 和 self 之间已经去掉了循环引用的问题，所以应该是没有什么问题的。但是结合之前我们对 RACObserve 的理解再仔细分析一下，这里的 Signal 只要 self 没有被 dealloc 的话就不会被释放。虽然每次 UITableViewCell 都会被重用，但是每次重用过程中创建的信号确实无法被 disposable。那我们该怎么做呢？\n\n```\n- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section {\n    return 1000;\n}\n\n- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath {\n    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"TableViewCell\"];\n\n    @weakify(self);\n    [[RACObserve(cell.textLabel, text) takeUntil:cell.rac_prepareForReuseSignal] subscribeNext:^(id x) {\n        @strongify(self);\n        NSLog(@\"%@\", self);\n    }];\n\n    return cell;\n}\n```\n\n注意，我们在cell里面创建的信号加上 takeUntil:cell.rac_prepareForReuseSignal，这个是让 cell 在每次重用的时候都去 disposable 创建的信号。\n\n以上所说的关于内存的东西我都用 Instrument 的 Allocations 验证过了，但是依旧建议大家自己也去试试。\n\n\n","slug":"RAC和内存管理","published":1,"updated":"2018-03-06T07:06:56.944Z","_id":"cjei470sc0006u5vbhk35gkur","comments":1,"photos":[],"link":"","content":"<p>最近在用 RAC 的时候发现自己对内存管理还是有些困惑，于是自己写了一些代码来验证自己的一些理解。<br>在一开始接触 RAC 的时候，我们知道 RAC 对于 block 都是 copy 赋值的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation RACSignal</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark Lifecycle</span><br><span class=\"line\"></span><br><span class=\"line\">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class=\"line\">    return [RACDynamicSignal createSignal:didSubscribe];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation RACDynamicSignal</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark Lifecycle</span><br><span class=\"line\"></span><br><span class=\"line\">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class=\"line\">    RACDynamicSignal *signal = [[self alloc] init];</span><br><span class=\"line\">    signal-&gt;_didSubscribe = [didSubscribe copy];</span><br><span class=\"line\">    return [signal setNameWithFormat:@&quot;+createSignal:&quot;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在创建 RACSingal 的时候会调用其子类 RACDynamicSignal 去创建，我们也看到 RACDynamicSignal 对 didSuscribe 这个 block 是进行了 copy。所以大家可能会被要求注意循环引用的问题，于是大家都用 @weakify(target) 和 @strongify(target) 来避免循环引用的问题。那是不是所有用到 RAC 的地方都需要使用这些宏来避免循环引用的问题，不尽然。比如下面这个：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景1</span><br><span class=\"line\">[RACObserve(self, title) subscribeNext:^(id x) &#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;, x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>接下来，我们来对比以下的几种用法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface ViewController()</span><br><span class=\"line\">@property (strong, nonatomic) ViewModel * viewModel;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidiLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    self.viewModel = [ViewModel new];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 场景2</span><br><span class=\"line\">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        self.title = @&quot;你好&quot;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 场景3</span><br><span class=\"line\">    [self.viewModel.titleSignal subscribeNext:^(NSString * title) &#123;</span><br><span class=\"line\">        self.title = title;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 场景4</span><br><span class=\"line\">    [RACObserve(self.viewModel, title) subscribeNext:^(NSString * title)     &#123;</span><br><span class=\"line\">        self.title = title;</span><br><span class=\"line\">    &#125;]; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>场景2是我们平常都会用到的，而且我们也没有在这种场景下去考虑循环引用的问题，这是因为 dispatch 的 block 不是属于 self 的（至于这个 block 是属于谁的，回头我再查点资料或者请各位指教），所以即使你在 block 使用了 self 也不会有循环应用的问题。</p>\n<p>场景3很明显是有循环引用的问题：<strong>self-&gt;viewModel-&gt;titleSignal-&gt;block-&gt;self</strong>，这个时候如果我们不做处理的话，那么 self 就永远不会被释放。正确的做法应该是使用 @weakify(self) 和 @strongify(self)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景3</span><br><span class=\"line\">@weakify(self);</span><br><span class=\"line\">[self.viewModel.titleSignal subscribeNext:^(NSString * title) &#123;</span><br><span class=\"line\">    @strongify(self);</span><br><span class=\"line\">    self.title = title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>场景4在我们看来是没有问题的，因为这里看起来只有 <strong>singal-&gt;block-&gt;self</strong> 的引用，它们之间并没有造成循环引用的问题。我们先来看看 RACObserve 的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define RACObserve(TARGET, KEYPATH) \\</span><br><span class=\"line\">(&#123; \\</span><br><span class=\"line\">_Pragma(&quot;clang diagnostic push&quot;) \\</span><br><span class=\"line\">_Pragma(&quot;clang diagnostic ignored \\&quot;-Wreceiver-is-weak\\&quot;&quot;) \\</span><br><span class=\"line\">__weak id target_ = (TARGET); \\</span><br><span class=\"line\">[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \\</span><br><span class=\"line\">_Pragma(&quot;clang diagnostic pop&quot;) \\</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak NSObject *)observer;</span><br></pre></td></tr></table></figure>\n<p>其实，看到这里你会认为这里只是调用了一个方法创建了一个 Signal，而且这个 Signal 也并不属于任何对象。我们再来看看具体的实现是怎么样的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (RACSignal *)rac_valuesAndChangesForKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options observer:(__weak NSObject *)weakObserver &#123;</span><br><span class=\"line\">    NSObject *strongObserver = weakObserver;</span><br><span class=\"line\">    keyPath = [keyPath copy];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSRecursiveLock *objectLock = [[NSRecursiveLock alloc] init];</span><br><span class=\"line\">    objectLock.name = @&quot;org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    __weak NSObject *weakSelf = self;</span><br><span class=\"line\"></span><br><span class=\"line\">    RACSignal *deallocSignal = [[RACSignal zip:@[</span><br><span class=\"line\">                            self.rac_willDeallocSignal,</span><br><span class=\"line\">                            strongObserver.rac_willDeallocSignal ?: [RACSignal never]</span><br><span class=\"line\">    ]] doCompleted:^&#123;</span><br><span class=\"line\">        // Forces deallocation to wait if the object variables are currently</span><br><span class=\"line\">        // being read on another thread.</span><br><span class=\"line\">        [objectLock lock];</span><br><span class=\"line\">        @onExit &#123;</span><br><span class=\"line\">            [objectLock unlock];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    return [[[RACSignal createSignal:^ RACDisposable * (id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class=\"line\">        // Hold onto the lock the whole time we&apos;re setting up the KVO</span><br><span class=\"line\">        // observation, because any resurrection that might be caused by our</span><br><span class=\"line\">        // retaining below must be balanced out by the time -dealloc returns</span><br><span class=\"line\">        // (if another thread is waiting on the lock above).</span><br><span class=\"line\">        [objectLock lock];</span><br><span class=\"line\">        @onExit &#123;</span><br><span class=\"line\">            [objectLock unlock];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">        __strong NSObject *observer __attribute__((objc_precise_lifetime)) = weakObserver;</span><br><span class=\"line\">        __strong NSObject *self __attribute__((objc_precise_lifetime)) = weakSelf;</span><br><span class=\"line\">    </span><br><span class=\"line\">        if (self == nil) &#123;</span><br><span class=\"line\">            [subscriber sendCompleted];</span><br><span class=\"line\">            return nil;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        return [self rac_observeKeyPath:keyPath options:options observer:observer block:^(id value, NSDictionary *change, BOOL causedByDealloc, BOOL affectedOnlyLastComponent) &#123;</span><br><span class=\"line\">                [subscriber sendNext:RACTuplePack(value, change)];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;] takeUntil:deallocSignal] setNameWithFormat:@&quot;%@ -rac_valueAndChangesForKeyPath: %@ options: %lu observer: %@&quot;, self.rac_description, keyPath, (unsigned long)options, strongObserver.rac_description];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重点观察 <strong>deallocSignal</strong> 和 <strong>[signal takeUntile:deallocSignal]</strong>，我们把 deallocSignal 单独拿出来看看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *deallocSignal = [[RACSignal zip:@[</span><br><span class=\"line\">                        self.rac_willDeallocSignal,</span><br><span class=\"line\">                        strongObserver.rac_willDeallocSignal ?: [RACSignal never]</span><br><span class=\"line\">                        ]] doCompleted:^&#123;</span><br><span class=\"line\">    // Forces deallocation to wait if the object variables are currently</span><br><span class=\"line\">    // being read on another thread.</span><br><span class=\"line\">    [objectLock lock];</span><br><span class=\"line\">    @onExit &#123;</span><br><span class=\"line\">    [objectLock unlock];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>这里的 deallocSignal 是只有在 self 和 strongObserve 都将要发生 dealloc 的时候才会触发的。即用 RACObserve 创建的信号只有在其 target 和 observe 都发生 dealloc 的时候才会被 disposable (这个好像是 RAC 用来销毁自己资源的东西)。不明白的童鞋，我们回头来分析一下场景4的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景4</span><br><span class=\"line\">[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) &#123;</span><br><span class=\"line\">    self.title = title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>用 RACObserve 创建的信号看起来只要出了函数体其资源应该就会被回收，但是这个信号其实是只有在 self.viewModel.rac_willDeallocSignal 和 self.rac_willDeallocSignal 都发生的情况下才会被释放。所以场景4的引用关系看起来只有 signal-&gt;block-&gt;self，但是这个 signal 只有在 self.rac_willDeallocSignal 的时候才会被释放。所以这里如果不打断这种关系的话就会造成循环引用的问题，正确做法应该是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景4</span><br><span class=\"line\">@weakify(self);</span><br><span class=\"line\">[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) &#123;</span><br><span class=\"line\">    @strongify(self);</span><br><span class=\"line\">    self.title = title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>最后，在说一个特别需要注意的，就是 UITableViewCell 和 UICollectionViewCell 复用和 RAC 的问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</span><br><span class=\"line\">    return 1000;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath &#123;</span><br><span class=\"line\">    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@&quot;TableViewCell&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">    @weakify(self);</span><br><span class=\"line\">    [RACObserve(cell.textLabel, text) subscribeNext:^(id x) &#123;</span><br><span class=\"line\">        @strongify(self);</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;, self);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    return cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看到这里的 RACObserve 创建的 Signal 和 self 之间已经去掉了循环引用的问题，所以应该是没有什么问题的。但是结合之前我们对 RACObserve 的理解再仔细分析一下，这里的 Signal 只要 self 没有被 dealloc 的话就不会被释放。虽然每次 UITableViewCell 都会被重用，但是每次重用过程中创建的信号确实无法被 disposable。那我们该怎么做呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</span><br><span class=\"line\">    return 1000;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath &#123;</span><br><span class=\"line\">    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@&quot;TableViewCell&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">    @weakify(self);</span><br><span class=\"line\">    [[RACObserve(cell.textLabel, text) takeUntil:cell.rac_prepareForReuseSignal] subscribeNext:^(id x) &#123;</span><br><span class=\"line\">        @strongify(self);</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;, self);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    return cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，我们在cell里面创建的信号加上 takeUntil:cell.rac_prepareForReuseSignal，这个是让 cell 在每次重用的时候都去 disposable 创建的信号。</p>\n<p>以上所说的关于内存的东西我都用 Instrument 的 Allocations 验证过了，但是依旧建议大家自己也去试试。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在用 RAC 的时候发现自己对内存管理还是有些困惑，于是自己写了一些代码来验证自己的一些理解。<br>在一开始接触 RAC 的时候，我们知道 RAC 对于 block 都是 copy 赋值的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation RACSignal</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark Lifecycle</span><br><span class=\"line\"></span><br><span class=\"line\">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class=\"line\">    return [RACDynamicSignal createSignal:didSubscribe];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation RACDynamicSignal</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark Lifecycle</span><br><span class=\"line\"></span><br><span class=\"line\">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class=\"line\">    RACDynamicSignal *signal = [[self alloc] init];</span><br><span class=\"line\">    signal-&gt;_didSubscribe = [didSubscribe copy];</span><br><span class=\"line\">    return [signal setNameWithFormat:@&quot;+createSignal:&quot;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在创建 RACSingal 的时候会调用其子类 RACDynamicSignal 去创建，我们也看到 RACDynamicSignal 对 didSuscribe 这个 block 是进行了 copy。所以大家可能会被要求注意循环引用的问题，于是大家都用 @weakify(target) 和 @strongify(target) 来避免循环引用的问题。那是不是所有用到 RAC 的地方都需要使用这些宏来避免循环引用的问题，不尽然。比如下面这个：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景1</span><br><span class=\"line\">[RACObserve(self, title) subscribeNext:^(id x) &#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;, x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>接下来，我们来对比以下的几种用法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface ViewController()</span><br><span class=\"line\">@property (strong, nonatomic) ViewModel * viewModel;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidiLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    self.viewModel = [ViewModel new];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 场景2</span><br><span class=\"line\">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        self.title = @&quot;你好&quot;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 场景3</span><br><span class=\"line\">    [self.viewModel.titleSignal subscribeNext:^(NSString * title) &#123;</span><br><span class=\"line\">        self.title = title;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 场景4</span><br><span class=\"line\">    [RACObserve(self.viewModel, title) subscribeNext:^(NSString * title)     &#123;</span><br><span class=\"line\">        self.title = title;</span><br><span class=\"line\">    &#125;]; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>场景2是我们平常都会用到的，而且我们也没有在这种场景下去考虑循环引用的问题，这是因为 dispatch 的 block 不是属于 self 的（至于这个 block 是属于谁的，回头我再查点资料或者请各位指教），所以即使你在 block 使用了 self 也不会有循环应用的问题。</p>\n<p>场景3很明显是有循环引用的问题：<strong>self-&gt;viewModel-&gt;titleSignal-&gt;block-&gt;self</strong>，这个时候如果我们不做处理的话，那么 self 就永远不会被释放。正确的做法应该是使用 @weakify(self) 和 @strongify(self)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景3</span><br><span class=\"line\">@weakify(self);</span><br><span class=\"line\">[self.viewModel.titleSignal subscribeNext:^(NSString * title) &#123;</span><br><span class=\"line\">    @strongify(self);</span><br><span class=\"line\">    self.title = title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>场景4在我们看来是没有问题的，因为这里看起来只有 <strong>singal-&gt;block-&gt;self</strong> 的引用，它们之间并没有造成循环引用的问题。我们先来看看 RACObserve 的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define RACObserve(TARGET, KEYPATH) \\</span><br><span class=\"line\">(&#123; \\</span><br><span class=\"line\">_Pragma(&quot;clang diagnostic push&quot;) \\</span><br><span class=\"line\">_Pragma(&quot;clang diagnostic ignored \\&quot;-Wreceiver-is-weak\\&quot;&quot;) \\</span><br><span class=\"line\">__weak id target_ = (TARGET); \\</span><br><span class=\"line\">[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \\</span><br><span class=\"line\">_Pragma(&quot;clang diagnostic pop&quot;) \\</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak NSObject *)observer;</span><br></pre></td></tr></table></figure>\n<p>其实，看到这里你会认为这里只是调用了一个方法创建了一个 Signal，而且这个 Signal 也并不属于任何对象。我们再来看看具体的实现是怎么样的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (RACSignal *)rac_valuesAndChangesForKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options observer:(__weak NSObject *)weakObserver &#123;</span><br><span class=\"line\">    NSObject *strongObserver = weakObserver;</span><br><span class=\"line\">    keyPath = [keyPath copy];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSRecursiveLock *objectLock = [[NSRecursiveLock alloc] init];</span><br><span class=\"line\">    objectLock.name = @&quot;org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    __weak NSObject *weakSelf = self;</span><br><span class=\"line\"></span><br><span class=\"line\">    RACSignal *deallocSignal = [[RACSignal zip:@[</span><br><span class=\"line\">                            self.rac_willDeallocSignal,</span><br><span class=\"line\">                            strongObserver.rac_willDeallocSignal ?: [RACSignal never]</span><br><span class=\"line\">    ]] doCompleted:^&#123;</span><br><span class=\"line\">        // Forces deallocation to wait if the object variables are currently</span><br><span class=\"line\">        // being read on another thread.</span><br><span class=\"line\">        [objectLock lock];</span><br><span class=\"line\">        @onExit &#123;</span><br><span class=\"line\">            [objectLock unlock];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    return [[[RACSignal createSignal:^ RACDisposable * (id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class=\"line\">        // Hold onto the lock the whole time we&apos;re setting up the KVO</span><br><span class=\"line\">        // observation, because any resurrection that might be caused by our</span><br><span class=\"line\">        // retaining below must be balanced out by the time -dealloc returns</span><br><span class=\"line\">        // (if another thread is waiting on the lock above).</span><br><span class=\"line\">        [objectLock lock];</span><br><span class=\"line\">        @onExit &#123;</span><br><span class=\"line\">            [objectLock unlock];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">        __strong NSObject *observer __attribute__((objc_precise_lifetime)) = weakObserver;</span><br><span class=\"line\">        __strong NSObject *self __attribute__((objc_precise_lifetime)) = weakSelf;</span><br><span class=\"line\">    </span><br><span class=\"line\">        if (self == nil) &#123;</span><br><span class=\"line\">            [subscriber sendCompleted];</span><br><span class=\"line\">            return nil;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        return [self rac_observeKeyPath:keyPath options:options observer:observer block:^(id value, NSDictionary *change, BOOL causedByDealloc, BOOL affectedOnlyLastComponent) &#123;</span><br><span class=\"line\">                [subscriber sendNext:RACTuplePack(value, change)];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;] takeUntil:deallocSignal] setNameWithFormat:@&quot;%@ -rac_valueAndChangesForKeyPath: %@ options: %lu observer: %@&quot;, self.rac_description, keyPath, (unsigned long)options, strongObserver.rac_description];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重点观察 <strong>deallocSignal</strong> 和 <strong>[signal takeUntile:deallocSignal]</strong>，我们把 deallocSignal 单独拿出来看看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *deallocSignal = [[RACSignal zip:@[</span><br><span class=\"line\">                        self.rac_willDeallocSignal,</span><br><span class=\"line\">                        strongObserver.rac_willDeallocSignal ?: [RACSignal never]</span><br><span class=\"line\">                        ]] doCompleted:^&#123;</span><br><span class=\"line\">    // Forces deallocation to wait if the object variables are currently</span><br><span class=\"line\">    // being read on another thread.</span><br><span class=\"line\">    [objectLock lock];</span><br><span class=\"line\">    @onExit &#123;</span><br><span class=\"line\">    [objectLock unlock];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>这里的 deallocSignal 是只有在 self 和 strongObserve 都将要发生 dealloc 的时候才会触发的。即用 RACObserve 创建的信号只有在其 target 和 observe 都发生 dealloc 的时候才会被 disposable (这个好像是 RAC 用来销毁自己资源的东西)。不明白的童鞋，我们回头来分析一下场景4的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景4</span><br><span class=\"line\">[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) &#123;</span><br><span class=\"line\">    self.title = title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>用 RACObserve 创建的信号看起来只要出了函数体其资源应该就会被回收，但是这个信号其实是只有在 self.viewModel.rac_willDeallocSignal 和 self.rac_willDeallocSignal 都发生的情况下才会被释放。所以场景4的引用关系看起来只有 signal-&gt;block-&gt;self，但是这个 signal 只有在 self.rac_willDeallocSignal 的时候才会被释放。所以这里如果不打断这种关系的话就会造成循环引用的问题，正确做法应该是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景4</span><br><span class=\"line\">@weakify(self);</span><br><span class=\"line\">[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) &#123;</span><br><span class=\"line\">    @strongify(self);</span><br><span class=\"line\">    self.title = title;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>最后，在说一个特别需要注意的，就是 UITableViewCell 和 UICollectionViewCell 复用和 RAC 的问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</span><br><span class=\"line\">    return 1000;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath &#123;</span><br><span class=\"line\">    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@&quot;TableViewCell&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">    @weakify(self);</span><br><span class=\"line\">    [RACObserve(cell.textLabel, text) subscribeNext:^(id x) &#123;</span><br><span class=\"line\">        @strongify(self);</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;, self);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    return cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看到这里的 RACObserve 创建的 Signal 和 self 之间已经去掉了循环引用的问题，所以应该是没有什么问题的。但是结合之前我们对 RACObserve 的理解再仔细分析一下，这里的 Signal 只要 self 没有被 dealloc 的话就不会被释放。虽然每次 UITableViewCell 都会被重用，但是每次重用过程中创建的信号确实无法被 disposable。那我们该怎么做呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</span><br><span class=\"line\">    return 1000;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath &#123;</span><br><span class=\"line\">    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@&quot;TableViewCell&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">    @weakify(self);</span><br><span class=\"line\">    [[RACObserve(cell.textLabel, text) takeUntil:cell.rac_prepareForReuseSignal] subscribeNext:^(id x) &#123;</span><br><span class=\"line\">        @strongify(self);</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;, self);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    return cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，我们在cell里面创建的信号加上 takeUntil:cell.rac_prepareForReuseSignal，这个是让 cell 在每次重用的时候都去 disposable 创建的信号。</p>\n<p>以上所说的关于内存的东西我都用 Instrument 的 Allocations 验证过了，但是依旧建议大家自己也去试试。</p>\n"},{"layout":"post","title":"Shell Tip","subtitle":"记录日常中用到的一些 Bash 脚本，经常更新","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n## Tip 1 : 修改文件里面的内容\n早上产品有一个小需求就是把工程中的所有网页的标题修改为黑米流量通，可以使用以下命令来实现\n\n```\nfind . -name '*.html' -print0 | xargs -0 sed -i '' -e 's/<title>.*<\\/title>/<title>黑米流量通<\\/title>/g'\n```\n\n* `find`          查找命令，可以用 man find 查看更多的信息\n* `.`             代表当前目录\n* `-name`         find 命令的参数，表示要查找的文件名\n* `-print0`       是一种不换行的输出格式，以 ASCII NUL 字符（也就是\\0）作为分隔符。上面的例子可能是 `a.html\\0b.html\\0c.html`\n* `|`             这是一个管道符，表示把前面命令的输出作为后面命令的输入\n* `xargs`         是用来构造输入参数，并且循环执行每一个参数\n* `-0`            表示让 xargs 使用 ASCII NUL 来分隔参数。上面的例子将被分隔成 `a.html` `b.html` `c.html` 三个参数依次执行\n* `sed`           这是一个流编辑器，如果传的是文件名会把文件内容读入内存，如果只是普通字符串就会把字符串读入内存\n* `-i`            表示要把原来的文件内容做一次备份，后面的 `''` 是表示要备份的文件名字，如果没有文件名字就表示不需要备份\n* `-e`            表示后面的字符串是一个命令，需要被执行\n* `s/old/new/g`   这个是用来替换字符串的命令\n\n## Tip 2 : 查找文件的内容\n把匹配的文件内容的相关文件列出来\n\n```\nfind . -name '*.html' -print0 | xargs -0 grep 'PATTERN'\n```\n\n## Tip 3 : 解决 Homebrew 的权限问题\n查看 Homebrew 的所有权\n\n```\nls -al `which brew`\n```\n\n把 Homebrew 的用户和分组修改为 root 和 wheel\n\n```\nsudo chown root:wheel `which brew`\n```\n\n最后还原 Homebrew 的权限（安全）\n\n```\nsudo chown : `chown brew`\n```\n\n## Tip 4 : 利用 Shell 生成生成 ICON\n\n```\n#!/bin/sh\n#此脚本是用来生成 iPhone 和 iPad 所需 icon 的不同尺寸的，最好是准备一张 1024x1024 的 Icon 图片\n\n\nfilename=\"icon.png\"\n\ndirname=\"icon\"\n\nname_array=(\"Icon-20.png\" \"Icon-20@2x.png\" \"Icon-20@3x.png\"\n\"Icon-29.png\" \"Icon-29@2x.png\" \"Icon-29@3x.png\"\n\"Icon-40.png\" \"Icon-40@2x.png\" \"Icon-40@3x.png\"\n\"Icon-60@2x.png\" \"Icon-60@3x.png\"\n\"Icon-76.png\" \"Icon-76@2x.png\"\n\"Icon-83.5@2x.png\")\nsize_array=(\"20\" \"40\" \"80\"\n\"29\" \"58\" \"87\"\n\"40\" \"80\" \"120\"\n\"120\" \"180\"\n\"76\" \"152\"\n\"167\")\n\nmkdir $dirname\n\nfor ((i=0;i<${#name_array[@]};++i)); do\n    m_dir=$dirname/${name_array[i]}\n    cp $filename $m_dir\n    sips -Z ${size_array[i]} $m_dir\ndone\n```\n\n## Tip5 : 使用 Python 共享当前目录\n\n利用下面的命令可以暂时开启一个端口号为 8000 的 HTTP 服务，其他人只需要在浏览器输入 `http://ip-address:8000` 即可浏览共享目录下的文件\n\n```\npython -m SimpleHTTPServer\n```\n\n\n## Tip6 : 加密和解密文件\n\n* 加密\n\n```\ntar czf - {SRC_DIR} | openssl des3 -salt -k \"{KEY}\" -out {DIST_PACKAGE}.tar.gz\n```\n\n示例：\n\n目录名 `paris_code`，秘钥 `meta#com`，输出包 `paris_code_20161008.tar.gz`\n\n```\ntar czf - paris_code | openssl des3 -salt -k \"meta#com\" -out paris_code_20161008.tar.gz\n```\n\n* 解密\n\n第一步：获取代码压缩文件包\n\n下载地址 `http://XXXX.com/paris_code_20161008.tar.gz`\n\n第二步：解密文件（OS X / Linux only）\n\n在 Terminal 进入压缩文件包同级目录，输入以下命令：\n\n```\nopenssl des3 -d -k \"meta#com\" -salt -in paris_code_20161008.tar.gz | tar xzf -\n```\n\n## Tip7: iOS 打包命令\n\n```\necho \"----------------\"\necho \"Begin Build!\"\nPROJECT_NAME=\"orbit\"\nBUILD_DATE=\"$(date +'%Y%m%d')\"\nBUNDLE_ID=\"com.meta.paris\"\ncd ${WORKSPACE}\n\n#/usr/local/bin/npm install\n\nif [ -d \"${WORKSPACE}/build\" ]; then \n    if ls ${WORKSPACE}/build/**/*.ipa 1> /dev/null 2>&1; then\n        rm -rf ${WORKSPACE}/build/**/*.ipa; \n    fi;\n    if ls ${WORKSPACE}/build/**/*.xcarchive 1> /dev/null 2>&1; then\n        rm -rf ${WORKSPACE}/build/**/*.xcarchive; \n    fi;\nelse \n    mkdir ${WORKSPACE}/build; \nfi;\n\necho \"计算今天的 Build Version\"\nif [ -d \"${WORKSPACE}/build/${BUILD_DATE}\" ]; then \n   #如果不加上面的 if, Jenkins 无法直接执行下面的命令❓\n\tBUILD_DATE_COUNT=$(ls ${WORKSPACE}/build | grep \"^${BUILD_DATE}\" -c)\n    if [ ${BUILD_DATE_COUNT} -lt 10 ]; then\n        BUILD_DATE_COUNT=\"0${BUILD_DATE_COUNT}\"\n    fi;\n\tBUILD_VERSION=\"${BUILD_DATE}${BUILD_DATE_COUNT}\"\nelse \n  \tBUILD_VERSION=${BUILD_DATE}\nfi;\necho \"今天的 Build Version 是 ${BUILD_VERSION}\"\n\nif [ -d \"${WORKSPACE}/build/${BUILD_VERSION}\" ]; then \n    rm -rf ${WORKSPACE}/build/${BUILD_VERSION}; \nfi;\nmkdir ${WORKSPACE}/build/${BUILD_VERSION};\n\nif [ -d \"${WORKSPACE}/Enterprise.plist\" ]; then\n    rm ${WORKSPACE}/Enterprise.plist; \nfi;\n\n#http://www.matrixprojects.net/p/xcodebuild-export-options-plist/\nEnterprise='<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n        <key>teamID</key>\n        <string></string>\n        <key>method</key>\n        <string>app-store</string>\n        <key>uploadSymbols</key>\n        <true/>\n        <key>uploadBitcode</key>\n        <false/>\n</dict>\n</plist>'\necho ${Enterprise} > ${WORKSPACE}/Enterprise.plist\n\nsed -i '' 's/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g' \\\n${WORKSPACE}/${PROJECT_NAME}.xcodeproj/project.pbxproj\n\nsed -i '' 's/DEVELOPMENT_TEAM = .*;/DEVELOPMENT_TEAM = \"\";/g' \\\n${WORKSPACE}/${PROJECT_NAME}.xcodeproj/project.pbxproj\n\n#动态生成 Build Version\nsed -i '' \"/<key>CFBundleVersion<\\/key>/{N;s/<string>.*<\\/string>/<string>${BUILD_VERSION}<\\/string>/g;}\" \\\n${WORKSPACE}/${PROJECT_NAME}/${PROJECT_NAME}-Info.plist\n\nxcodebuild -workspace ${WORKSPACE}/${PROJECT_NAME}.xcworkspace \\\n-scheme ${PROJECT_NAME} -sdk iphoneos \\\nbuild CODE_SIGN_IDENTITY=\"iPhone Distribution: Beijing PS Technology Co., Ltd.\" \\\nPROVISIONING_PROFILE=\"\" \\\n-configuration Release clean archive \\\n-archivePath ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.xcarchive\n\nxcodebuild -exportArchive -exportOptionsPlist ${WORKSPACE}/Enterprise.plist \\\n-archivePath ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.xcarchive \\\n-exportPath ${WORKSPACE}/build/${BUILD_VERSION}/\n\necho \"----------------\"\necho \"Build successfully!\"\n\n\necho \"Begin Upload to itunes...\"\n#Use [shenzhen](https://github.com/nomad/shenzhen) to upload the ipa file to itunes connect.\n/usr/local/bin/ipa distribute:itunesconnect -f ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.ipa -a YourAppleID -p YourPassword -i ${BUNDLE_ID} --upload\necho \"Upload successfully!\"\n```\n\n\n","source":"_posts/Shell-Tip.md","raw":"---\nlayout: post \ntitle: Shell Tip\nsubtitle: 记录日常中用到的一些 Bash 脚本，经常更新\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: tip\ntag: tip\n---\n\n## Tip 1 : 修改文件里面的内容\n早上产品有一个小需求就是把工程中的所有网页的标题修改为黑米流量通，可以使用以下命令来实现\n\n```\nfind . -name '*.html' -print0 | xargs -0 sed -i '' -e 's/<title>.*<\\/title>/<title>黑米流量通<\\/title>/g'\n```\n\n* `find`          查找命令，可以用 man find 查看更多的信息\n* `.`             代表当前目录\n* `-name`         find 命令的参数，表示要查找的文件名\n* `-print0`       是一种不换行的输出格式，以 ASCII NUL 字符（也就是\\0）作为分隔符。上面的例子可能是 `a.html\\0b.html\\0c.html`\n* `|`             这是一个管道符，表示把前面命令的输出作为后面命令的输入\n* `xargs`         是用来构造输入参数，并且循环执行每一个参数\n* `-0`            表示让 xargs 使用 ASCII NUL 来分隔参数。上面的例子将被分隔成 `a.html` `b.html` `c.html` 三个参数依次执行\n* `sed`           这是一个流编辑器，如果传的是文件名会把文件内容读入内存，如果只是普通字符串就会把字符串读入内存\n* `-i`            表示要把原来的文件内容做一次备份，后面的 `''` 是表示要备份的文件名字，如果没有文件名字就表示不需要备份\n* `-e`            表示后面的字符串是一个命令，需要被执行\n* `s/old/new/g`   这个是用来替换字符串的命令\n\n## Tip 2 : 查找文件的内容\n把匹配的文件内容的相关文件列出来\n\n```\nfind . -name '*.html' -print0 | xargs -0 grep 'PATTERN'\n```\n\n## Tip 3 : 解决 Homebrew 的权限问题\n查看 Homebrew 的所有权\n\n```\nls -al `which brew`\n```\n\n把 Homebrew 的用户和分组修改为 root 和 wheel\n\n```\nsudo chown root:wheel `which brew`\n```\n\n最后还原 Homebrew 的权限（安全）\n\n```\nsudo chown : `chown brew`\n```\n\n## Tip 4 : 利用 Shell 生成生成 ICON\n\n```\n#!/bin/sh\n#此脚本是用来生成 iPhone 和 iPad 所需 icon 的不同尺寸的，最好是准备一张 1024x1024 的 Icon 图片\n\n\nfilename=\"icon.png\"\n\ndirname=\"icon\"\n\nname_array=(\"Icon-20.png\" \"Icon-20@2x.png\" \"Icon-20@3x.png\"\n\"Icon-29.png\" \"Icon-29@2x.png\" \"Icon-29@3x.png\"\n\"Icon-40.png\" \"Icon-40@2x.png\" \"Icon-40@3x.png\"\n\"Icon-60@2x.png\" \"Icon-60@3x.png\"\n\"Icon-76.png\" \"Icon-76@2x.png\"\n\"Icon-83.5@2x.png\")\nsize_array=(\"20\" \"40\" \"80\"\n\"29\" \"58\" \"87\"\n\"40\" \"80\" \"120\"\n\"120\" \"180\"\n\"76\" \"152\"\n\"167\")\n\nmkdir $dirname\n\nfor ((i=0;i<${#name_array[@]};++i)); do\n    m_dir=$dirname/${name_array[i]}\n    cp $filename $m_dir\n    sips -Z ${size_array[i]} $m_dir\ndone\n```\n\n## Tip5 : 使用 Python 共享当前目录\n\n利用下面的命令可以暂时开启一个端口号为 8000 的 HTTP 服务，其他人只需要在浏览器输入 `http://ip-address:8000` 即可浏览共享目录下的文件\n\n```\npython -m SimpleHTTPServer\n```\n\n\n## Tip6 : 加密和解密文件\n\n* 加密\n\n```\ntar czf - {SRC_DIR} | openssl des3 -salt -k \"{KEY}\" -out {DIST_PACKAGE}.tar.gz\n```\n\n示例：\n\n目录名 `paris_code`，秘钥 `meta#com`，输出包 `paris_code_20161008.tar.gz`\n\n```\ntar czf - paris_code | openssl des3 -salt -k \"meta#com\" -out paris_code_20161008.tar.gz\n```\n\n* 解密\n\n第一步：获取代码压缩文件包\n\n下载地址 `http://XXXX.com/paris_code_20161008.tar.gz`\n\n第二步：解密文件（OS X / Linux only）\n\n在 Terminal 进入压缩文件包同级目录，输入以下命令：\n\n```\nopenssl des3 -d -k \"meta#com\" -salt -in paris_code_20161008.tar.gz | tar xzf -\n```\n\n## Tip7: iOS 打包命令\n\n```\necho \"----------------\"\necho \"Begin Build!\"\nPROJECT_NAME=\"orbit\"\nBUILD_DATE=\"$(date +'%Y%m%d')\"\nBUNDLE_ID=\"com.meta.paris\"\ncd ${WORKSPACE}\n\n#/usr/local/bin/npm install\n\nif [ -d \"${WORKSPACE}/build\" ]; then \n    if ls ${WORKSPACE}/build/**/*.ipa 1> /dev/null 2>&1; then\n        rm -rf ${WORKSPACE}/build/**/*.ipa; \n    fi;\n    if ls ${WORKSPACE}/build/**/*.xcarchive 1> /dev/null 2>&1; then\n        rm -rf ${WORKSPACE}/build/**/*.xcarchive; \n    fi;\nelse \n    mkdir ${WORKSPACE}/build; \nfi;\n\necho \"计算今天的 Build Version\"\nif [ -d \"${WORKSPACE}/build/${BUILD_DATE}\" ]; then \n   #如果不加上面的 if, Jenkins 无法直接执行下面的命令❓\n\tBUILD_DATE_COUNT=$(ls ${WORKSPACE}/build | grep \"^${BUILD_DATE}\" -c)\n    if [ ${BUILD_DATE_COUNT} -lt 10 ]; then\n        BUILD_DATE_COUNT=\"0${BUILD_DATE_COUNT}\"\n    fi;\n\tBUILD_VERSION=\"${BUILD_DATE}${BUILD_DATE_COUNT}\"\nelse \n  \tBUILD_VERSION=${BUILD_DATE}\nfi;\necho \"今天的 Build Version 是 ${BUILD_VERSION}\"\n\nif [ -d \"${WORKSPACE}/build/${BUILD_VERSION}\" ]; then \n    rm -rf ${WORKSPACE}/build/${BUILD_VERSION}; \nfi;\nmkdir ${WORKSPACE}/build/${BUILD_VERSION};\n\nif [ -d \"${WORKSPACE}/Enterprise.plist\" ]; then\n    rm ${WORKSPACE}/Enterprise.plist; \nfi;\n\n#http://www.matrixprojects.net/p/xcodebuild-export-options-plist/\nEnterprise='<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n        <key>teamID</key>\n        <string></string>\n        <key>method</key>\n        <string>app-store</string>\n        <key>uploadSymbols</key>\n        <true/>\n        <key>uploadBitcode</key>\n        <false/>\n</dict>\n</plist>'\necho ${Enterprise} > ${WORKSPACE}/Enterprise.plist\n\nsed -i '' 's/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g' \\\n${WORKSPACE}/${PROJECT_NAME}.xcodeproj/project.pbxproj\n\nsed -i '' 's/DEVELOPMENT_TEAM = .*;/DEVELOPMENT_TEAM = \"\";/g' \\\n${WORKSPACE}/${PROJECT_NAME}.xcodeproj/project.pbxproj\n\n#动态生成 Build Version\nsed -i '' \"/<key>CFBundleVersion<\\/key>/{N;s/<string>.*<\\/string>/<string>${BUILD_VERSION}<\\/string>/g;}\" \\\n${WORKSPACE}/${PROJECT_NAME}/${PROJECT_NAME}-Info.plist\n\nxcodebuild -workspace ${WORKSPACE}/${PROJECT_NAME}.xcworkspace \\\n-scheme ${PROJECT_NAME} -sdk iphoneos \\\nbuild CODE_SIGN_IDENTITY=\"iPhone Distribution: Beijing PS Technology Co., Ltd.\" \\\nPROVISIONING_PROFILE=\"\" \\\n-configuration Release clean archive \\\n-archivePath ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.xcarchive\n\nxcodebuild -exportArchive -exportOptionsPlist ${WORKSPACE}/Enterprise.plist \\\n-archivePath ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.xcarchive \\\n-exportPath ${WORKSPACE}/build/${BUILD_VERSION}/\n\necho \"----------------\"\necho \"Build successfully!\"\n\n\necho \"Begin Upload to itunes...\"\n#Use [shenzhen](https://github.com/nomad/shenzhen) to upload the ipa file to itunes connect.\n/usr/local/bin/ipa distribute:itunesconnect -f ${WORKSPACE}/build/${BUILD_VERSION}/${PROJECT_NAME}.ipa -a YourAppleID -p YourPassword -i ${BUNDLE_ID} --upload\necho \"Upload successfully!\"\n```\n\n\n","slug":"Shell-Tip","published":1,"updated":"2018-03-06T07:07:38.178Z","_id":"cjei470sh000au5vb5suebogh","comments":1,"photos":[],"link":"","content":"<h2 id=\"Tip-1-修改文件里面的内容\"><a href=\"#Tip-1-修改文件里面的内容\" class=\"headerlink\" title=\"Tip 1 : 修改文件里面的内容\"></a>Tip 1 : 修改文件里面的内容</h2><p>早上产品有一个小需求就是把工程中的所有网页的标题修改为黑米流量通，可以使用以下命令来实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . -name &apos;*.html&apos; -print0 | xargs -0 sed -i &apos;&apos; -e &apos;s/&lt;title&gt;.*&lt;\\/title&gt;/&lt;title&gt;黑米流量通&lt;\\/title&gt;/g&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>find</code>          查找命令，可以用 man find 查看更多的信息</li>\n<li><code>.</code>             代表当前目录</li>\n<li><code>-name</code>         find 命令的参数，表示要查找的文件名</li>\n<li><code>-print0</code>       是一种不换行的输出格式，以 ASCII NUL 字符（也就是\\0）作为分隔符。上面的例子可能是 <code>a.html\\0b.html\\0c.html</code></li>\n<li><code>|</code>             这是一个管道符，表示把前面命令的输出作为后面命令的输入</li>\n<li><code>xargs</code>         是用来构造输入参数，并且循环执行每一个参数</li>\n<li><code>-0</code>            表示让 xargs 使用 ASCII NUL 来分隔参数。上面的例子将被分隔成 <code>a.html</code> <code>b.html</code> <code>c.html</code> 三个参数依次执行</li>\n<li><code>sed</code>           这是一个流编辑器，如果传的是文件名会把文件内容读入内存，如果只是普通字符串就会把字符串读入内存</li>\n<li><code>-i</code>            表示要把原来的文件内容做一次备份，后面的 <code>&#39;&#39;</code> 是表示要备份的文件名字，如果没有文件名字就表示不需要备份</li>\n<li><code>-e</code>            表示后面的字符串是一个命令，需要被执行</li>\n<li><code>s/old/new/g</code>   这个是用来替换字符串的命令</li>\n</ul>\n<h2 id=\"Tip-2-查找文件的内容\"><a href=\"#Tip-2-查找文件的内容\" class=\"headerlink\" title=\"Tip 2 : 查找文件的内容\"></a>Tip 2 : 查找文件的内容</h2><p>把匹配的文件内容的相关文件列出来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . -name &apos;*.html&apos; -print0 | xargs -0 grep &apos;PATTERN&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Tip-3-解决-Homebrew-的权限问题\"><a href=\"#Tip-3-解决-Homebrew-的权限问题\" class=\"headerlink\" title=\"Tip 3 : 解决 Homebrew 的权限问题\"></a>Tip 3 : 解决 Homebrew 的权限问题</h2><p>查看 Homebrew 的所有权</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -al `which brew`</span><br></pre></td></tr></table></figure>\n<p>把 Homebrew 的用户和分组修改为 root 和 wheel</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chown root:wheel `which brew`</span><br></pre></td></tr></table></figure>\n<p>最后还原 Homebrew 的权限（安全）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chown : `chown brew`</span><br></pre></td></tr></table></figure>\n<h2 id=\"Tip-4-利用-Shell-生成生成-ICON\"><a href=\"#Tip-4-利用-Shell-生成生成-ICON\" class=\"headerlink\" title=\"Tip 4 : 利用 Shell 生成生成 ICON\"></a>Tip 4 : 利用 Shell 生成生成 ICON</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\">#此脚本是用来生成 iPhone 和 iPad 所需 icon 的不同尺寸的，最好是准备一张 1024x1024 的 Icon 图片</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">filename=&quot;icon.png&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">dirname=&quot;icon&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">name_array=(&quot;Icon-20.png&quot; &quot;Icon-20@2x.png&quot; &quot;Icon-20@3x.png&quot;</span><br><span class=\"line\">&quot;Icon-29.png&quot; &quot;Icon-29@2x.png&quot; &quot;Icon-29@3x.png&quot;</span><br><span class=\"line\">&quot;Icon-40.png&quot; &quot;Icon-40@2x.png&quot; &quot;Icon-40@3x.png&quot;</span><br><span class=\"line\">&quot;Icon-60@2x.png&quot; &quot;Icon-60@3x.png&quot;</span><br><span class=\"line\">&quot;Icon-76.png&quot; &quot;Icon-76@2x.png&quot;</span><br><span class=\"line\">&quot;Icon-83.5@2x.png&quot;)</span><br><span class=\"line\">size_array=(&quot;20&quot; &quot;40&quot; &quot;80&quot;</span><br><span class=\"line\">&quot;29&quot; &quot;58&quot; &quot;87&quot;</span><br><span class=\"line\">&quot;40&quot; &quot;80&quot; &quot;120&quot;</span><br><span class=\"line\">&quot;120&quot; &quot;180&quot;</span><br><span class=\"line\">&quot;76&quot; &quot;152&quot;</span><br><span class=\"line\">&quot;167&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">mkdir $dirname</span><br><span class=\"line\"></span><br><span class=\"line\">for ((i=0;i&lt;$&#123;#name_array[@]&#125;;++i)); do</span><br><span class=\"line\">    m_dir=$dirname/$&#123;name_array[i]&#125;</span><br><span class=\"line\">    cp $filename $m_dir</span><br><span class=\"line\">    sips -Z $&#123;size_array[i]&#125; $m_dir</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h2 id=\"Tip5-使用-Python-共享当前目录\"><a href=\"#Tip5-使用-Python-共享当前目录\" class=\"headerlink\" title=\"Tip5 : 使用 Python 共享当前目录\"></a>Tip5 : 使用 Python 共享当前目录</h2><p>利用下面的命令可以暂时开启一个端口号为 8000 的 HTTP 服务，其他人只需要在浏览器输入 <code>http://ip-address:8000</code> 即可浏览共享目录下的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure>\n<h2 id=\"Tip6-加密和解密文件\"><a href=\"#Tip6-加密和解密文件\" class=\"headerlink\" title=\"Tip6 : 加密和解密文件\"></a>Tip6 : 加密和解密文件</h2><ul>\n<li>加密</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar czf - &#123;SRC_DIR&#125; | openssl des3 -salt -k &quot;&#123;KEY&#125;&quot; -out &#123;DIST_PACKAGE&#125;.tar.gz</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<p>目录名 <code>paris_code</code>，秘钥 <code>meta#com</code>，输出包 <code>paris_code_20161008.tar.gz</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar czf - paris_code | openssl des3 -salt -k &quot;meta#com&quot; -out paris_code_20161008.tar.gz</span><br></pre></td></tr></table></figure>\n<ul>\n<li>解密</li>\n</ul>\n<p>第一步：获取代码压缩文件包</p>\n<p>下载地址 <code>http://XXXX.com/paris_code_20161008.tar.gz</code></p>\n<p>第二步：解密文件（OS X / Linux only）</p>\n<p>在 Terminal 进入压缩文件包同级目录，输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl des3 -d -k &quot;meta#com&quot; -salt -in paris_code_20161008.tar.gz | tar xzf -</span><br></pre></td></tr></table></figure>\n<h2 id=\"Tip7-iOS-打包命令\"><a href=\"#Tip7-iOS-打包命令\" class=\"headerlink\" title=\"Tip7: iOS 打包命令\"></a>Tip7: iOS 打包命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;----------------&quot;</span><br><span class=\"line\">echo &quot;Begin Build!&quot;</span><br><span class=\"line\">PROJECT_NAME=&quot;orbit&quot;</span><br><span class=\"line\">BUILD_DATE=&quot;$(date +&apos;%Y%m%d&apos;)&quot;</span><br><span class=\"line\">BUNDLE_ID=&quot;com.meta.paris&quot;</span><br><span class=\"line\">cd $&#123;WORKSPACE&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#/usr/local/bin/npm install</span><br><span class=\"line\"></span><br><span class=\"line\">if [ -d &quot;$&#123;WORKSPACE&#125;/build&quot; ]; then </span><br><span class=\"line\">    if ls $&#123;WORKSPACE&#125;/build/**/*.ipa 1&gt; /dev/null 2&gt;&amp;1; then</span><br><span class=\"line\">        rm -rf $&#123;WORKSPACE&#125;/build/**/*.ipa; </span><br><span class=\"line\">    fi;</span><br><span class=\"line\">    if ls $&#123;WORKSPACE&#125;/build/**/*.xcarchive 1&gt; /dev/null 2&gt;&amp;1; then</span><br><span class=\"line\">        rm -rf $&#123;WORKSPACE&#125;/build/**/*.xcarchive; </span><br><span class=\"line\">    fi;</span><br><span class=\"line\">else </span><br><span class=\"line\">    mkdir $&#123;WORKSPACE&#125;/build; </span><br><span class=\"line\">fi;</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;计算今天的 Build Version&quot;</span><br><span class=\"line\">if [ -d &quot;$&#123;WORKSPACE&#125;/build/$&#123;BUILD_DATE&#125;&quot; ]; then </span><br><span class=\"line\">   #如果不加上面的 if, Jenkins 无法直接执行下面的命令❓</span><br><span class=\"line\">\tBUILD_DATE_COUNT=$(ls $&#123;WORKSPACE&#125;/build | grep &quot;^$&#123;BUILD_DATE&#125;&quot; -c)</span><br><span class=\"line\">    if [ $&#123;BUILD_DATE_COUNT&#125; -lt 10 ]; then</span><br><span class=\"line\">        BUILD_DATE_COUNT=&quot;0$&#123;BUILD_DATE_COUNT&#125;&quot;</span><br><span class=\"line\">    fi;</span><br><span class=\"line\">\tBUILD_VERSION=&quot;$&#123;BUILD_DATE&#125;$&#123;BUILD_DATE_COUNT&#125;&quot;</span><br><span class=\"line\">else </span><br><span class=\"line\">  \tBUILD_VERSION=$&#123;BUILD_DATE&#125;</span><br><span class=\"line\">fi;</span><br><span class=\"line\">echo &quot;今天的 Build Version 是 $&#123;BUILD_VERSION&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">if [ -d &quot;$&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;&quot; ]; then </span><br><span class=\"line\">    rm -rf $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;; </span><br><span class=\"line\">fi;</span><br><span class=\"line\">mkdir $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">if [ -d &quot;$&#123;WORKSPACE&#125;/Enterprise.plist&quot; ]; then</span><br><span class=\"line\">    rm $&#123;WORKSPACE&#125;/Enterprise.plist; </span><br><span class=\"line\">fi;</span><br><span class=\"line\"></span><br><span class=\"line\">#http://www.matrixprojects.net/p/xcodebuild-export-options-plist/</span><br><span class=\"line\">Enterprise=&apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class=\"line\">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class=\"line\">&lt;dict&gt;</span><br><span class=\"line\">        &lt;key&gt;teamID&lt;/key&gt;</span><br><span class=\"line\">        &lt;string&gt;&lt;/string&gt;</span><br><span class=\"line\">        &lt;key&gt;method&lt;/key&gt;</span><br><span class=\"line\">        &lt;string&gt;app-store&lt;/string&gt;</span><br><span class=\"line\">        &lt;key&gt;uploadSymbols&lt;/key&gt;</span><br><span class=\"line\">        &lt;true/&gt;</span><br><span class=\"line\">        &lt;key&gt;uploadBitcode&lt;/key&gt;</span><br><span class=\"line\">        &lt;false/&gt;</span><br><span class=\"line\">&lt;/dict&gt;</span><br><span class=\"line\">&lt;/plist&gt;&apos;</span><br><span class=\"line\">echo $&#123;Enterprise&#125; &gt; $&#123;WORKSPACE&#125;/Enterprise.plist</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i &apos;&apos; &apos;s/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g&apos; \\</span><br><span class=\"line\">$&#123;WORKSPACE&#125;/$&#123;PROJECT_NAME&#125;.xcodeproj/project.pbxproj</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i &apos;&apos; &apos;s/DEVELOPMENT_TEAM = .*;/DEVELOPMENT_TEAM = &quot;&quot;;/g&apos; \\</span><br><span class=\"line\">$&#123;WORKSPACE&#125;/$&#123;PROJECT_NAME&#125;.xcodeproj/project.pbxproj</span><br><span class=\"line\"></span><br><span class=\"line\">#动态生成 Build Version</span><br><span class=\"line\">sed -i &apos;&apos; &quot;/&lt;key&gt;CFBundleVersion&lt;\\/key&gt;/&#123;N;s/&lt;string&gt;.*&lt;\\/string&gt;/&lt;string&gt;$&#123;BUILD_VERSION&#125;&lt;\\/string&gt;/g;&#125;&quot; \\</span><br><span class=\"line\">$&#123;WORKSPACE&#125;/$&#123;PROJECT_NAME&#125;/$&#123;PROJECT_NAME&#125;-Info.plist</span><br><span class=\"line\"></span><br><span class=\"line\">xcodebuild -workspace $&#123;WORKSPACE&#125;/$&#123;PROJECT_NAME&#125;.xcworkspace \\</span><br><span class=\"line\">-scheme $&#123;PROJECT_NAME&#125; -sdk iphoneos \\</span><br><span class=\"line\">build CODE_SIGN_IDENTITY=&quot;iPhone Distribution: Beijing PS Technology Co., Ltd.&quot; \\</span><br><span class=\"line\">PROVISIONING_PROFILE=&quot;&quot; \\</span><br><span class=\"line\">-configuration Release clean archive \\</span><br><span class=\"line\">-archivePath $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;/$&#123;PROJECT_NAME&#125;.xcarchive</span><br><span class=\"line\"></span><br><span class=\"line\">xcodebuild -exportArchive -exportOptionsPlist $&#123;WORKSPACE&#125;/Enterprise.plist \\</span><br><span class=\"line\">-archivePath $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;/$&#123;PROJECT_NAME&#125;.xcarchive \\</span><br><span class=\"line\">-exportPath $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;/</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;----------------&quot;</span><br><span class=\"line\">echo &quot;Build successfully!&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;Begin Upload to itunes...&quot;</span><br><span class=\"line\">#Use [shenzhen](https://github.com/nomad/shenzhen) to upload the ipa file to itunes connect.</span><br><span class=\"line\">/usr/local/bin/ipa distribute:itunesconnect -f $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;/$&#123;PROJECT_NAME&#125;.ipa -a YourAppleID -p YourPassword -i $&#123;BUNDLE_ID&#125; --upload</span><br><span class=\"line\">echo &quot;Upload successfully!&quot;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Tip-1-修改文件里面的内容\"><a href=\"#Tip-1-修改文件里面的内容\" class=\"headerlink\" title=\"Tip 1 : 修改文件里面的内容\"></a>Tip 1 : 修改文件里面的内容</h2><p>早上产品有一个小需求就是把工程中的所有网页的标题修改为黑米流量通，可以使用以下命令来实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . -name &apos;*.html&apos; -print0 | xargs -0 sed -i &apos;&apos; -e &apos;s/&lt;title&gt;.*&lt;\\/title&gt;/&lt;title&gt;黑米流量通&lt;\\/title&gt;/g&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>find</code>          查找命令，可以用 man find 查看更多的信息</li>\n<li><code>.</code>             代表当前目录</li>\n<li><code>-name</code>         find 命令的参数，表示要查找的文件名</li>\n<li><code>-print0</code>       是一种不换行的输出格式，以 ASCII NUL 字符（也就是\\0）作为分隔符。上面的例子可能是 <code>a.html\\0b.html\\0c.html</code></li>\n<li><code>|</code>             这是一个管道符，表示把前面命令的输出作为后面命令的输入</li>\n<li><code>xargs</code>         是用来构造输入参数，并且循环执行每一个参数</li>\n<li><code>-0</code>            表示让 xargs 使用 ASCII NUL 来分隔参数。上面的例子将被分隔成 <code>a.html</code> <code>b.html</code> <code>c.html</code> 三个参数依次执行</li>\n<li><code>sed</code>           这是一个流编辑器，如果传的是文件名会把文件内容读入内存，如果只是普通字符串就会把字符串读入内存</li>\n<li><code>-i</code>            表示要把原来的文件内容做一次备份，后面的 <code>&#39;&#39;</code> 是表示要备份的文件名字，如果没有文件名字就表示不需要备份</li>\n<li><code>-e</code>            表示后面的字符串是一个命令，需要被执行</li>\n<li><code>s/old/new/g</code>   这个是用来替换字符串的命令</li>\n</ul>\n<h2 id=\"Tip-2-查找文件的内容\"><a href=\"#Tip-2-查找文件的内容\" class=\"headerlink\" title=\"Tip 2 : 查找文件的内容\"></a>Tip 2 : 查找文件的内容</h2><p>把匹配的文件内容的相关文件列出来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . -name &apos;*.html&apos; -print0 | xargs -0 grep &apos;PATTERN&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Tip-3-解决-Homebrew-的权限问题\"><a href=\"#Tip-3-解决-Homebrew-的权限问题\" class=\"headerlink\" title=\"Tip 3 : 解决 Homebrew 的权限问题\"></a>Tip 3 : 解决 Homebrew 的权限问题</h2><p>查看 Homebrew 的所有权</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -al `which brew`</span><br></pre></td></tr></table></figure>\n<p>把 Homebrew 的用户和分组修改为 root 和 wheel</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chown root:wheel `which brew`</span><br></pre></td></tr></table></figure>\n<p>最后还原 Homebrew 的权限（安全）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chown : `chown brew`</span><br></pre></td></tr></table></figure>\n<h2 id=\"Tip-4-利用-Shell-生成生成-ICON\"><a href=\"#Tip-4-利用-Shell-生成生成-ICON\" class=\"headerlink\" title=\"Tip 4 : 利用 Shell 生成生成 ICON\"></a>Tip 4 : 利用 Shell 生成生成 ICON</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\">#此脚本是用来生成 iPhone 和 iPad 所需 icon 的不同尺寸的，最好是准备一张 1024x1024 的 Icon 图片</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">filename=&quot;icon.png&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">dirname=&quot;icon&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">name_array=(&quot;Icon-20.png&quot; &quot;Icon-20@2x.png&quot; &quot;Icon-20@3x.png&quot;</span><br><span class=\"line\">&quot;Icon-29.png&quot; &quot;Icon-29@2x.png&quot; &quot;Icon-29@3x.png&quot;</span><br><span class=\"line\">&quot;Icon-40.png&quot; &quot;Icon-40@2x.png&quot; &quot;Icon-40@3x.png&quot;</span><br><span class=\"line\">&quot;Icon-60@2x.png&quot; &quot;Icon-60@3x.png&quot;</span><br><span class=\"line\">&quot;Icon-76.png&quot; &quot;Icon-76@2x.png&quot;</span><br><span class=\"line\">&quot;Icon-83.5@2x.png&quot;)</span><br><span class=\"line\">size_array=(&quot;20&quot; &quot;40&quot; &quot;80&quot;</span><br><span class=\"line\">&quot;29&quot; &quot;58&quot; &quot;87&quot;</span><br><span class=\"line\">&quot;40&quot; &quot;80&quot; &quot;120&quot;</span><br><span class=\"line\">&quot;120&quot; &quot;180&quot;</span><br><span class=\"line\">&quot;76&quot; &quot;152&quot;</span><br><span class=\"line\">&quot;167&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">mkdir $dirname</span><br><span class=\"line\"></span><br><span class=\"line\">for ((i=0;i&lt;$&#123;#name_array[@]&#125;;++i)); do</span><br><span class=\"line\">    m_dir=$dirname/$&#123;name_array[i]&#125;</span><br><span class=\"line\">    cp $filename $m_dir</span><br><span class=\"line\">    sips -Z $&#123;size_array[i]&#125; $m_dir</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h2 id=\"Tip5-使用-Python-共享当前目录\"><a href=\"#Tip5-使用-Python-共享当前目录\" class=\"headerlink\" title=\"Tip5 : 使用 Python 共享当前目录\"></a>Tip5 : 使用 Python 共享当前目录</h2><p>利用下面的命令可以暂时开启一个端口号为 8000 的 HTTP 服务，其他人只需要在浏览器输入 <code>http://ip-address:8000</code> 即可浏览共享目录下的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure>\n<h2 id=\"Tip6-加密和解密文件\"><a href=\"#Tip6-加密和解密文件\" class=\"headerlink\" title=\"Tip6 : 加密和解密文件\"></a>Tip6 : 加密和解密文件</h2><ul>\n<li>加密</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar czf - &#123;SRC_DIR&#125; | openssl des3 -salt -k &quot;&#123;KEY&#125;&quot; -out &#123;DIST_PACKAGE&#125;.tar.gz</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<p>目录名 <code>paris_code</code>，秘钥 <code>meta#com</code>，输出包 <code>paris_code_20161008.tar.gz</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar czf - paris_code | openssl des3 -salt -k &quot;meta#com&quot; -out paris_code_20161008.tar.gz</span><br></pre></td></tr></table></figure>\n<ul>\n<li>解密</li>\n</ul>\n<p>第一步：获取代码压缩文件包</p>\n<p>下载地址 <code>http://XXXX.com/paris_code_20161008.tar.gz</code></p>\n<p>第二步：解密文件（OS X / Linux only）</p>\n<p>在 Terminal 进入压缩文件包同级目录，输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl des3 -d -k &quot;meta#com&quot; -salt -in paris_code_20161008.tar.gz | tar xzf -</span><br></pre></td></tr></table></figure>\n<h2 id=\"Tip7-iOS-打包命令\"><a href=\"#Tip7-iOS-打包命令\" class=\"headerlink\" title=\"Tip7: iOS 打包命令\"></a>Tip7: iOS 打包命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;----------------&quot;</span><br><span class=\"line\">echo &quot;Begin Build!&quot;</span><br><span class=\"line\">PROJECT_NAME=&quot;orbit&quot;</span><br><span class=\"line\">BUILD_DATE=&quot;$(date +&apos;%Y%m%d&apos;)&quot;</span><br><span class=\"line\">BUNDLE_ID=&quot;com.meta.paris&quot;</span><br><span class=\"line\">cd $&#123;WORKSPACE&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#/usr/local/bin/npm install</span><br><span class=\"line\"></span><br><span class=\"line\">if [ -d &quot;$&#123;WORKSPACE&#125;/build&quot; ]; then </span><br><span class=\"line\">    if ls $&#123;WORKSPACE&#125;/build/**/*.ipa 1&gt; /dev/null 2&gt;&amp;1; then</span><br><span class=\"line\">        rm -rf $&#123;WORKSPACE&#125;/build/**/*.ipa; </span><br><span class=\"line\">    fi;</span><br><span class=\"line\">    if ls $&#123;WORKSPACE&#125;/build/**/*.xcarchive 1&gt; /dev/null 2&gt;&amp;1; then</span><br><span class=\"line\">        rm -rf $&#123;WORKSPACE&#125;/build/**/*.xcarchive; </span><br><span class=\"line\">    fi;</span><br><span class=\"line\">else </span><br><span class=\"line\">    mkdir $&#123;WORKSPACE&#125;/build; </span><br><span class=\"line\">fi;</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;计算今天的 Build Version&quot;</span><br><span class=\"line\">if [ -d &quot;$&#123;WORKSPACE&#125;/build/$&#123;BUILD_DATE&#125;&quot; ]; then </span><br><span class=\"line\">   #如果不加上面的 if, Jenkins 无法直接执行下面的命令❓</span><br><span class=\"line\">\tBUILD_DATE_COUNT=$(ls $&#123;WORKSPACE&#125;/build | grep &quot;^$&#123;BUILD_DATE&#125;&quot; -c)</span><br><span class=\"line\">    if [ $&#123;BUILD_DATE_COUNT&#125; -lt 10 ]; then</span><br><span class=\"line\">        BUILD_DATE_COUNT=&quot;0$&#123;BUILD_DATE_COUNT&#125;&quot;</span><br><span class=\"line\">    fi;</span><br><span class=\"line\">\tBUILD_VERSION=&quot;$&#123;BUILD_DATE&#125;$&#123;BUILD_DATE_COUNT&#125;&quot;</span><br><span class=\"line\">else </span><br><span class=\"line\">  \tBUILD_VERSION=$&#123;BUILD_DATE&#125;</span><br><span class=\"line\">fi;</span><br><span class=\"line\">echo &quot;今天的 Build Version 是 $&#123;BUILD_VERSION&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">if [ -d &quot;$&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;&quot; ]; then </span><br><span class=\"line\">    rm -rf $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;; </span><br><span class=\"line\">fi;</span><br><span class=\"line\">mkdir $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">if [ -d &quot;$&#123;WORKSPACE&#125;/Enterprise.plist&quot; ]; then</span><br><span class=\"line\">    rm $&#123;WORKSPACE&#125;/Enterprise.plist; </span><br><span class=\"line\">fi;</span><br><span class=\"line\"></span><br><span class=\"line\">#http://www.matrixprojects.net/p/xcodebuild-export-options-plist/</span><br><span class=\"line\">Enterprise=&apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class=\"line\">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class=\"line\">&lt;dict&gt;</span><br><span class=\"line\">        &lt;key&gt;teamID&lt;/key&gt;</span><br><span class=\"line\">        &lt;string&gt;&lt;/string&gt;</span><br><span class=\"line\">        &lt;key&gt;method&lt;/key&gt;</span><br><span class=\"line\">        &lt;string&gt;app-store&lt;/string&gt;</span><br><span class=\"line\">        &lt;key&gt;uploadSymbols&lt;/key&gt;</span><br><span class=\"line\">        &lt;true/&gt;</span><br><span class=\"line\">        &lt;key&gt;uploadBitcode&lt;/key&gt;</span><br><span class=\"line\">        &lt;false/&gt;</span><br><span class=\"line\">&lt;/dict&gt;</span><br><span class=\"line\">&lt;/plist&gt;&apos;</span><br><span class=\"line\">echo $&#123;Enterprise&#125; &gt; $&#123;WORKSPACE&#125;/Enterprise.plist</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i &apos;&apos; &apos;s/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g&apos; \\</span><br><span class=\"line\">$&#123;WORKSPACE&#125;/$&#123;PROJECT_NAME&#125;.xcodeproj/project.pbxproj</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i &apos;&apos; &apos;s/DEVELOPMENT_TEAM = .*;/DEVELOPMENT_TEAM = &quot;&quot;;/g&apos; \\</span><br><span class=\"line\">$&#123;WORKSPACE&#125;/$&#123;PROJECT_NAME&#125;.xcodeproj/project.pbxproj</span><br><span class=\"line\"></span><br><span class=\"line\">#动态生成 Build Version</span><br><span class=\"line\">sed -i &apos;&apos; &quot;/&lt;key&gt;CFBundleVersion&lt;\\/key&gt;/&#123;N;s/&lt;string&gt;.*&lt;\\/string&gt;/&lt;string&gt;$&#123;BUILD_VERSION&#125;&lt;\\/string&gt;/g;&#125;&quot; \\</span><br><span class=\"line\">$&#123;WORKSPACE&#125;/$&#123;PROJECT_NAME&#125;/$&#123;PROJECT_NAME&#125;-Info.plist</span><br><span class=\"line\"></span><br><span class=\"line\">xcodebuild -workspace $&#123;WORKSPACE&#125;/$&#123;PROJECT_NAME&#125;.xcworkspace \\</span><br><span class=\"line\">-scheme $&#123;PROJECT_NAME&#125; -sdk iphoneos \\</span><br><span class=\"line\">build CODE_SIGN_IDENTITY=&quot;iPhone Distribution: Beijing PS Technology Co., Ltd.&quot; \\</span><br><span class=\"line\">PROVISIONING_PROFILE=&quot;&quot; \\</span><br><span class=\"line\">-configuration Release clean archive \\</span><br><span class=\"line\">-archivePath $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;/$&#123;PROJECT_NAME&#125;.xcarchive</span><br><span class=\"line\"></span><br><span class=\"line\">xcodebuild -exportArchive -exportOptionsPlist $&#123;WORKSPACE&#125;/Enterprise.plist \\</span><br><span class=\"line\">-archivePath $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;/$&#123;PROJECT_NAME&#125;.xcarchive \\</span><br><span class=\"line\">-exportPath $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;/</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;----------------&quot;</span><br><span class=\"line\">echo &quot;Build successfully!&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;Begin Upload to itunes...&quot;</span><br><span class=\"line\">#Use [shenzhen](https://github.com/nomad/shenzhen) to upload the ipa file to itunes connect.</span><br><span class=\"line\">/usr/local/bin/ipa distribute:itunesconnect -f $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;/$&#123;PROJECT_NAME&#125;.ipa -a YourAppleID -p YourPassword -i $&#123;BUNDLE_ID&#125; --upload</span><br><span class=\"line\">echo &quot;Upload successfully!&quot;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"Vim Tip","subtitle":"记录日常中使用的 Vim 命令，经常更新","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n## 1、替换第n1行到第n2行的内容\n\n```Vim\n:n1,n2/origin/replace/g\n```\n\n## 2、替换整个文件的内容\n\n```Vim\n:%s/origin/replace/g\n```\n\n## 3、移动n1-n2行(包括n1,n2)到n3行之下\n\n```Vim\nn1,n2 m n3     \n```\n\n## 4、复制n1-n2行(包括n1,n2)到n3行之下\n\n```Vim\n:n1,n2 co n3\n```\n\n## 5、删除文件的空行\n\n```Vim\n:g/^$/d\n```\n\n## 6、在文本中插入一个1到100的序列（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\n:r!seq 100\n```\n\n## 7、在当前的每一行文字前面增加“序号. ”（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\n:let i=1 | g /^/ s//\\=i.\". \"/ | let i+=1\n```\n\n## 8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\nvim\n:n **/*.java\n:argdo %s/apache/eclipse/ge | update \n```\n\n","source":"_posts/Vim-Tip.md","raw":"---\nlayout: post \ntitle: Vim Tip\nsubtitle: 记录日常中使用的 Vim 命令，经常更新\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: tip\ntag: tip\n---\n\n## 1、替换第n1行到第n2行的内容\n\n```Vim\n:n1,n2/origin/replace/g\n```\n\n## 2、替换整个文件的内容\n\n```Vim\n:%s/origin/replace/g\n```\n\n## 3、移动n1-n2行(包括n1,n2)到n3行之下\n\n```Vim\nn1,n2 m n3     \n```\n\n## 4、复制n1-n2行(包括n1,n2)到n3行之下\n\n```Vim\n:n1,n2 co n3\n```\n\n## 5、删除文件的空行\n\n```Vim\n:g/^$/d\n```\n\n## 6、在文本中插入一个1到100的序列（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\n:r!seq 100\n```\n\n## 7、在当前的每一行文字前面增加“序号. ”（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\n:let i=1 | g /^/ s//\\=i.\". \"/ | let i+=1\n```\n\n## 8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师[《说，谁才是最帅的编程工具？》](http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&mid=2650712546&idx=1&sn=c4db99547b75d6001b3cfaa6cbc0e715&scene=1&srcid=0805j7ny3Ua1WufWDEpnhwOG#rd)）\n\n```Vim\nvim\n:n **/*.java\n:argdo %s/apache/eclipse/ge | update \n```\n\n","slug":"Vim-Tip","published":1,"updated":"2018-03-06T07:07:22.896Z","_id":"cjei470sk000bu5vbz0sa4dl7","comments":1,"photos":[],"link":"","content":"<h2 id=\"1、替换第n1行到第n2行的内容\"><a href=\"#1、替换第n1行到第n2行的内容\" class=\"headerlink\" title=\"1、替换第n1行到第n2行的内容\"></a>1、替换第n1行到第n2行的内容</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:n1,n2/origin/replace/g</span><br></pre></td></tr></table></figure>\n<h2 id=\"2、替换整个文件的内容\"><a href=\"#2、替换整个文件的内容\" class=\"headerlink\" title=\"2、替换整个文件的内容\"></a>2、替换整个文件的内容</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:%s/origin/replace/g</span><br></pre></td></tr></table></figure>\n<h2 id=\"3、移动n1-n2行-包括n1-n2-到n3行之下\"><a href=\"#3、移动n1-n2行-包括n1-n2-到n3行之下\" class=\"headerlink\" title=\"3、移动n1-n2行(包括n1,n2)到n3行之下\"></a>3、移动n1-n2行(包括n1,n2)到n3行之下</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n1,n2 <span class=\"keyword\">m</span> n3</span><br></pre></td></tr></table></figure>\n<h2 id=\"4、复制n1-n2行-包括n1-n2-到n3行之下\"><a href=\"#4、复制n1-n2行-包括n1-n2-到n3行之下\" class=\"headerlink\" title=\"4、复制n1-n2行(包括n1,n2)到n3行之下\"></a>4、复制n1-n2行(包括n1,n2)到n3行之下</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:n1,n2 <span class=\"keyword\">co</span> n3</span><br></pre></td></tr></table></figure>\n<h2 id=\"5、删除文件的空行\"><a href=\"#5、删除文件的空行\" class=\"headerlink\" title=\"5、删除文件的空行\"></a>5、删除文件的空行</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:g/^$/d</span><br></pre></td></tr></table></figure>\n<h2 id=\"6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\"></a>6、在文本中插入一个1到100的序列（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650712546&amp;idx=1&amp;sn=c4db99547b75d6001b3cfaa6cbc0e715&amp;scene=1&amp;srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\" target=\"_blank\" rel=\"noopener\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:r!seq <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"7、在当前的每一行文字前面增加“序号-”（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#7、在当前的每一行文字前面增加“序号-”（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"7、在当前的每一行文字前面增加“序号. ”（来自池老师《说，谁才是最帅的编程工具？》）\"></a>7、在当前的每一行文字前面增加“序号. ”（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650712546&amp;idx=1&amp;sn=c4db99547b75d6001b3cfaa6cbc0e715&amp;scene=1&amp;srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\" target=\"_blank\" rel=\"noopener\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:<span class=\"keyword\">let</span> i=<span class=\"number\">1</span> | g /^/ s//\\=i.<span class=\"string\">\". \"</span>/ | <span class=\"keyword\">let</span> i+=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"8、当前目录下（包括子文件夹）所有后缀为-java-的文件中的-apache-替换成-eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#8、当前目录下（包括子文件夹）所有后缀为-java-的文件中的-apache-替换成-eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\"></a>8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650712546&amp;idx=1&amp;sn=c4db99547b75d6001b3cfaa6cbc0e715&amp;scene=1&amp;srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\" target=\"_blank\" rel=\"noopener\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">vim</span></span><br><span class=\"line\">:n **/*.java</span><br><span class=\"line\">:<span class=\"keyword\">argdo</span> %s/apache/eclipse/ge | <span class=\"keyword\">update</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1、替换第n1行到第n2行的内容\"><a href=\"#1、替换第n1行到第n2行的内容\" class=\"headerlink\" title=\"1、替换第n1行到第n2行的内容\"></a>1、替换第n1行到第n2行的内容</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:n1,n2/origin/replace/g</span><br></pre></td></tr></table></figure>\n<h2 id=\"2、替换整个文件的内容\"><a href=\"#2、替换整个文件的内容\" class=\"headerlink\" title=\"2、替换整个文件的内容\"></a>2、替换整个文件的内容</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:%s/origin/replace/g</span><br></pre></td></tr></table></figure>\n<h2 id=\"3、移动n1-n2行-包括n1-n2-到n3行之下\"><a href=\"#3、移动n1-n2行-包括n1-n2-到n3行之下\" class=\"headerlink\" title=\"3、移动n1-n2行(包括n1,n2)到n3行之下\"></a>3、移动n1-n2行(包括n1,n2)到n3行之下</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n1,n2 <span class=\"keyword\">m</span> n3</span><br></pre></td></tr></table></figure>\n<h2 id=\"4、复制n1-n2行-包括n1-n2-到n3行之下\"><a href=\"#4、复制n1-n2行-包括n1-n2-到n3行之下\" class=\"headerlink\" title=\"4、复制n1-n2行(包括n1,n2)到n3行之下\"></a>4、复制n1-n2行(包括n1,n2)到n3行之下</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:n1,n2 <span class=\"keyword\">co</span> n3</span><br></pre></td></tr></table></figure>\n<h2 id=\"5、删除文件的空行\"><a href=\"#5、删除文件的空行\" class=\"headerlink\" title=\"5、删除文件的空行\"></a>5、删除文件的空行</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:g/^$/d</span><br></pre></td></tr></table></figure>\n<h2 id=\"6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）\"></a>6、在文本中插入一个1到100的序列（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650712546&amp;idx=1&amp;sn=c4db99547b75d6001b3cfaa6cbc0e715&amp;scene=1&amp;srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\" target=\"_blank\" rel=\"noopener\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:r!seq <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"7、在当前的每一行文字前面增加“序号-”（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#7、在当前的每一行文字前面增加“序号-”（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"7、在当前的每一行文字前面增加“序号. ”（来自池老师《说，谁才是最帅的编程工具？》）\"></a>7、在当前的每一行文字前面增加“序号. ”（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650712546&amp;idx=1&amp;sn=c4db99547b75d6001b3cfaa6cbc0e715&amp;scene=1&amp;srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\" target=\"_blank\" rel=\"noopener\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:<span class=\"keyword\">let</span> i=<span class=\"number\">1</span> | g /^/ s//\\=i.<span class=\"string\">\". \"</span>/ | <span class=\"keyword\">let</span> i+=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"8、当前目录下（包括子文件夹）所有后缀为-java-的文件中的-apache-替换成-eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\"><a href=\"#8、当前目录下（包括子文件夹）所有后缀为-java-的文件中的-apache-替换成-eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\" class=\"headerlink\" title=\"8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）\"></a>8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650712546&amp;idx=1&amp;sn=c4db99547b75d6001b3cfaa6cbc0e715&amp;scene=1&amp;srcid=0805j7ny3Ua1WufWDEpnhwOG#rd\" target=\"_blank\" rel=\"noopener\">《说，谁才是最帅的编程工具？》</a>）</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">vim</span></span><br><span class=\"line\">:n **/*.java</span><br><span class=\"line\">:<span class=\"keyword\">argdo</span> %s/apache/eclipse/ge | <span class=\"keyword\">update</span></span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"include 和 import 的区别","subtitle":null,"author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":" \n今天我们来了解下面这几种包含文件的方式有什么特点和区别：\n\n```\n#include \"fiel\"\n#include <file>\n#import \"file\"\n#import <file>\n@import Module\n```\n\n---\n\n## 一、#include\n\n学过 C 语言的人都知道，#include 其实是一个预处理命令。它会在预处理的时候简单的把被 #include 包含的文件内容进行复制粘贴。我们来看看下面的代码：\n\n```\n// A.h\nvoid sampleA() {\n  // A code\n}\n\n```\n\n```\n// B.h\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们使用 gcc -E B.h 命令来看看经过预处理后的文件内容大概如下：\n\n```\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n我们可以看到经过预处理之后，A.h 文件中的内容被直接复制并粘贴到 B.h 文件中来。如果我们在 B.h 文件中多次包含了 A.h 文件，会出现什么情况？比如：\n\n```\n// A.h\nvoid sampleA() {\n  // A code\n}\n```\n\n```\n// B.h\n#include \"A.h\"\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n经过预处理之后的内容大概如下：\n\n```\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 3 \"B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\nA.h 文件中的 sampleA() 函数出现了两次，所以我们需要利用其他的一些预处理命令来规避这种情况，看看下面的代码：\n\n```\n// A.h\n#ifndef FILE_A\n#define FILE_A\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```\n// B.h\n#include \"A.h\"\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们再来看看增加了这些预处理命令之后的预处理文件内容：\n\n```\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n\n\n\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n\n\nvoid sampleB() {\n\n}\n```\n\nOK，这就正常了。如果我们在 A.h 中包含 B.h，然后又在 B.h 中包含 A.h，具体代码如下：\n\n```\n// A.h\n#include \"B.h\"\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```\n// B.h\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们再来看看经过 gcc -E B.h 处理之后的文件内容：\n\n```\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\n...\n...\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\n...\n...\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\n./A.h:1:10: error: #include nested too deeply\n#include \"B.h\"\n         ^\n\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n...\n...\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n1 error generated.\n```\n\n我们发现 A.h 和 B.h 重复出现，这是因为这个时候 A.h 和 B.h 文件互相引用导致的。从理论上来讲，这个时候会无限循环下去，直至世界终结。在这里最后会出现一句 *1 error generated.*的提示是 gcc 强行中断了这个预处理的过程，所以我们才能看到这样的结果。那我们可以怎么做？当然是利用前面说的预处理命令来避免循环引用的问题。看下面的代码：\n\n```\n// A.h\n#ifndef FILE_A\n#define FILE_A\n\n#include \"B.h\"\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```\n// B.h\n#ifndef FILE_B\n#define FILE_B\n\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n#endif\n```\n\n这个时候使用 gcc -E B.h 就可以正常的进行预处理，最后的结果如下：\n\n```\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n\n\n\n# 1 \"./A.h\" 1\n\n\n\n# 1 \"./B.h\" 1\n# 5 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 5 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n所以C程序员总是需要通过各种手段（比如：[#pragma once](https://en.wikipedia.org/wiki/Pragma_once)）来防范此类事件的发生。\n\n\n## 二、#import\n\n我们在文件中通过#import来导入 iAd Framework：\n![](http://i.imgur.com/nLPSsNN.jpg)\n\n\n编译报错：\n![](http://i.imgur.com/XBXD8wu.jpg)\n\n需要重新导入和链接 Framework：\n![](http://i.imgur.com/rUnKJGb.jpg)\n![](http://i.imgur.com/XuxVI6b.jpg)\n\n编译成功：\n![](http://i.imgur.com/QvyQunr.jpg)\n\n从上面的过程中我们就知道在 Objective-C 项目中使用 #import 需要注意导入和链接 Framework，否则是会报错的。\n\n预处理器在碰到 #import 命令的时候，它会采用递归的方式把被所有头文件的内容复制并粘贴到当前文件中，如果文件依赖层次比较深就会造成预处理后的文件内容体积大幅度变大。\n\n比如导入 UIKit 的时候只需要一行代码：\n\n```Objective-C\n#import <UIKit/UIKit.h>\n```\n\n预处理之后会变成200多行（UIKit.h 文件有200多行代码）：\n\n```Objective-C\n#import <UIKit/UIKitDefines.h>\n\n#if __has_include(<UIKit/UIAccelerometer.h>)\n#import <UIKit/UIAccelerometer.h>\n.....\n#import <UIKit/UIRegion.h>\n#endif\n```\n\n接下来还需要递归的把每个头文件的内容展开，最后的结果就是一行代码变成超过11000行代码。如果有多个文件都包含来 UIKit 的头文件，这样就会让每个文件的体积都会变得很大，编译过程也会变得越来越慢。这种递归的方式会让项目的编译时间变成：*M source files + N headers => M x N compile time*。\n\n所以这个时候有一个优化方法就是把项目中频繁被引用的文件放到 PCH（Pre-Compile Header）文件中。PCH 会被编译一次并且会被缓存，这就可以缩短编译时间，我们也不需要在不同的文件里面添加import语法。\n\n当然，PCH 也有自己的缺点：\n\n* 维护负担：随着项目变得越来越复杂，我们就会不停的往PCH文件加入内容，内容一旦变多就会变得不好维护。（这也是我们平常在项目中要避免在 ViewController 做太多事情的，要研究 MVVM的缘故。）\n\n* 命名空间污染\n\n\n最后，给大家提供一个例子看看 #import 编译出来之后的文件内容：\n\n```\n// A.h\n#import \"B.h\"\n \nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```\n// B.h\n#import \"A.h\"\n#import \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n使用 gcc -E B.h 进行预处理之后的内容如下：\n\n```\n\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n我们在B.h中有两个 #import \"A.h\"，但是这些内容跟我们之前在 A.h 和 B.h 文件中使用 #include 和其他预处理命令之后的处理结果很相似，所以我们就明白了 #import 大概做了什么事。\n\n## 三、@import\n\n在2012年的 LLVM 大会上，苹果的 Doug Gregor 首次提出了 Objective-C 中的 Module。使用 @import 方式导入有几个好处：\n\n* 不需要像 #import 一样得手动去链接 Framework，@import会自动去链接\n\n* @import 工作方式和 PCH 很像，但是 @import 要比 PCH 的效率高出许多\n\n* @import 导入 Modul 优化文件体积变大、编译速度变慢的问题\n\n* 可以部分导入（@import Framework.A）或全部导入（@import Framework）\n\n所以，建议大家尽量使用 @import 来导入文件。如果你以前的项目用的是 #import，那么你也不需要担心，我们只通过 Build Settings 开启 Modules 选项（看下图），#import 和 #include 会自动被映射成 @import，所以你不需要更改原来的代码也能享受 @import带来的好处。\n\n![](http://i.imgur.com/l7ZMUy6.jpg)\n\n详细内容可以看看苹果2013年的 [Advances in Objective-C](https://developer.apple.com/videos/play/wwdc2013/404/)，里面就详细介绍了 Module。\n\n## 四、文件路径\n\n接下来我们来了解一下 *#include <file>* 和 *#include \"file\"*：\n\n* \\#include \\<file>: 表示编译器会直接到系统设定的目录下寻找指定的文件。\n \n* \\#include \"file\": 表示编译器会到当前的目录下寻找指定的文件，如果找不到，则会去系统设定的目录下寻找指定的文件。\n\n---\n参考文献：\n\n1. https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html\n\n2. http://stackoverflow.com/questions/18947516/import-vs-import-ios-7\n\n3. https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7\n\n","source":"_posts/include和import的区别.md","raw":"---\nlayout: post \ntitle: include 和 import 的区别\nsubtitle: \nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: iOS \ntag: iOS \n---\n \n今天我们来了解下面这几种包含文件的方式有什么特点和区别：\n\n```\n#include \"fiel\"\n#include <file>\n#import \"file\"\n#import <file>\n@import Module\n```\n\n---\n\n## 一、#include\n\n学过 C 语言的人都知道，#include 其实是一个预处理命令。它会在预处理的时候简单的把被 #include 包含的文件内容进行复制粘贴。我们来看看下面的代码：\n\n```\n// A.h\nvoid sampleA() {\n  // A code\n}\n\n```\n\n```\n// B.h\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们使用 gcc -E B.h 命令来看看经过预处理后的文件内容大概如下：\n\n```\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n我们可以看到经过预处理之后，A.h 文件中的内容被直接复制并粘贴到 B.h 文件中来。如果我们在 B.h 文件中多次包含了 A.h 文件，会出现什么情况？比如：\n\n```\n// A.h\nvoid sampleA() {\n  // A code\n}\n```\n\n```\n// B.h\n#include \"A.h\"\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n经过预处理之后的内容大概如下：\n\n```\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n# 1 \"./A.h\" 1\nvoid sampleA() {\n\n}\n# 3 \"B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\nA.h 文件中的 sampleA() 函数出现了两次，所以我们需要利用其他的一些预处理命令来规避这种情况，看看下面的代码：\n\n```\n// A.h\n#ifndef FILE_A\n#define FILE_A\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```\n// B.h\n#include \"A.h\"\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们再来看看增加了这些预处理命令之后的预处理文件内容：\n\n```\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n\n\n\nvoid sampleA() {\n\n}\n# 2 \"B.h\" 2\n\n\nvoid sampleB() {\n\n}\n```\n\nOK，这就正常了。如果我们在 A.h 中包含 B.h，然后又在 B.h 中包含 A.h，具体代码如下：\n\n```\n// A.h\n#include \"B.h\"\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```\n// B.h\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n我们再来看看经过 gcc -E B.h 处理之后的文件内容：\n\n```\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\n...\n...\n# 1 \"./A.h\" 1\n# 1 \"./B.h\" 1\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\n...\n...\nIn file included from ./B.h:1:\nIn file included from ./A.h:1:\n./A.h:1:10: error: #include nested too deeply\n#include \"B.h\"\n         ^\n\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n...\n...\n# 2 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n1 error generated.\n```\n\n我们发现 A.h 和 B.h 重复出现，这是因为这个时候 A.h 和 B.h 文件互相引用导致的。从理论上来讲，这个时候会无限循环下去，直至世界终结。在这里最后会出现一句 *1 error generated.*的提示是 gcc 强行中断了这个预处理的过程，所以我们才能看到这样的结果。那我们可以怎么做？当然是利用前面说的预处理命令来避免循环引用的问题。看下面的代码：\n\n```\n// A.h\n#ifndef FILE_A\n#define FILE_A\n\n#include \"B.h\"\n\nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```\n// B.h\n#ifndef FILE_B\n#define FILE_B\n\n#include \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n#endif\n```\n\n这个时候使用 gcc -E B.h 就可以正常的进行预处理，最后的结果如下：\n\n```\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n\n\n\n# 1 \"./A.h\" 1\n\n\n\n# 1 \"./B.h\" 1\n# 5 \"./A.h\" 2\n\nvoid sampleA() {\n\n}\n# 5 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n所以C程序员总是需要通过各种手段（比如：[#pragma once](https://en.wikipedia.org/wiki/Pragma_once)）来防范此类事件的发生。\n\n\n## 二、#import\n\n我们在文件中通过#import来导入 iAd Framework：\n![](http://i.imgur.com/nLPSsNN.jpg)\n\n\n编译报错：\n![](http://i.imgur.com/XBXD8wu.jpg)\n\n需要重新导入和链接 Framework：\n![](http://i.imgur.com/rUnKJGb.jpg)\n![](http://i.imgur.com/XuxVI6b.jpg)\n\n编译成功：\n![](http://i.imgur.com/QvyQunr.jpg)\n\n从上面的过程中我们就知道在 Objective-C 项目中使用 #import 需要注意导入和链接 Framework，否则是会报错的。\n\n预处理器在碰到 #import 命令的时候，它会采用递归的方式把被所有头文件的内容复制并粘贴到当前文件中，如果文件依赖层次比较深就会造成预处理后的文件内容体积大幅度变大。\n\n比如导入 UIKit 的时候只需要一行代码：\n\n```Objective-C\n#import <UIKit/UIKit.h>\n```\n\n预处理之后会变成200多行（UIKit.h 文件有200多行代码）：\n\n```Objective-C\n#import <UIKit/UIKitDefines.h>\n\n#if __has_include(<UIKit/UIAccelerometer.h>)\n#import <UIKit/UIAccelerometer.h>\n.....\n#import <UIKit/UIRegion.h>\n#endif\n```\n\n接下来还需要递归的把每个头文件的内容展开，最后的结果就是一行代码变成超过11000行代码。如果有多个文件都包含来 UIKit 的头文件，这样就会让每个文件的体积都会变得很大，编译过程也会变得越来越慢。这种递归的方式会让项目的编译时间变成：*M source files + N headers => M x N compile time*。\n\n所以这个时候有一个优化方法就是把项目中频繁被引用的文件放到 PCH（Pre-Compile Header）文件中。PCH 会被编译一次并且会被缓存，这就可以缩短编译时间，我们也不需要在不同的文件里面添加import语法。\n\n当然，PCH 也有自己的缺点：\n\n* 维护负担：随着项目变得越来越复杂，我们就会不停的往PCH文件加入内容，内容一旦变多就会变得不好维护。（这也是我们平常在项目中要避免在 ViewController 做太多事情的，要研究 MVVM的缘故。）\n\n* 命名空间污染\n\n\n最后，给大家提供一个例子看看 #import 编译出来之后的文件内容：\n\n```\n// A.h\n#import \"B.h\"\n \nvoid sampleA() {\n  // A code\n}\n#endif\n```\n\n```\n// B.h\n#import \"A.h\"\n#import \"A.h\"\n\nvoid sampleB() {\n  // B code\n}\n```\n\n使用 gcc -E B.h 进行预处理之后的内容如下：\n\n```\n\n# 1 \"B.h\"\n# 1 \"<built-in>\" 1\n# 1 \"<built-in>\" 3\n# 329 \"<built-in>\" 3\n# 1 \"<command line>\" 1\n# 1 \"<built-in>\" 2\n# 1 \"B.h\" 2\n# 1 \"./A.h\" 1\n\n\nvoid sampleA() {\n\n}\n# 2 \"./B.h\" 2\n\nvoid sampleB() {\n\n}\n```\n\n我们在B.h中有两个 #import \"A.h\"，但是这些内容跟我们之前在 A.h 和 B.h 文件中使用 #include 和其他预处理命令之后的处理结果很相似，所以我们就明白了 #import 大概做了什么事。\n\n## 三、@import\n\n在2012年的 LLVM 大会上，苹果的 Doug Gregor 首次提出了 Objective-C 中的 Module。使用 @import 方式导入有几个好处：\n\n* 不需要像 #import 一样得手动去链接 Framework，@import会自动去链接\n\n* @import 工作方式和 PCH 很像，但是 @import 要比 PCH 的效率高出许多\n\n* @import 导入 Modul 优化文件体积变大、编译速度变慢的问题\n\n* 可以部分导入（@import Framework.A）或全部导入（@import Framework）\n\n所以，建议大家尽量使用 @import 来导入文件。如果你以前的项目用的是 #import，那么你也不需要担心，我们只通过 Build Settings 开启 Modules 选项（看下图），#import 和 #include 会自动被映射成 @import，所以你不需要更改原来的代码也能享受 @import带来的好处。\n\n![](http://i.imgur.com/l7ZMUy6.jpg)\n\n详细内容可以看看苹果2013年的 [Advances in Objective-C](https://developer.apple.com/videos/play/wwdc2013/404/)，里面就详细介绍了 Module。\n\n## 四、文件路径\n\n接下来我们来了解一下 *#include <file>* 和 *#include \"file\"*：\n\n* \\#include \\<file>: 表示编译器会直接到系统设定的目录下寻找指定的文件。\n \n* \\#include \"file\": 表示编译器会到当前的目录下寻找指定的文件，如果找不到，则会去系统设定的目录下寻找指定的文件。\n\n---\n参考文献：\n\n1. https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html\n\n2. http://stackoverflow.com/questions/18947516/import-vs-import-ios-7\n\n3. https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7\n\n","slug":"include和import的区别","published":1,"updated":"2018-03-08T06:27:59.110Z","_id":"cjei470sn000gu5vbg148h2u0","comments":1,"photos":[],"link":"","content":"<p>今天我们来了解下面这几种包含文件的方式有什么特点和区别：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;fiel&quot;</span><br><span class=\"line\">#include &lt;file&gt;</span><br><span class=\"line\">#import &quot;file&quot;</span><br><span class=\"line\">#import &lt;file&gt;</span><br><span class=\"line\">@import Module</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"一、-include\"><a href=\"#一、-include\" class=\"headerlink\" title=\"一、#include\"></a>一、#include</h2><p>学过 C 语言的人都知道，#include 其实是一个预处理命令。它会在预处理的时候简单的把被 #include 包含的文件内容进行复制粘贴。我们来看看下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// A.h</span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\">  // A code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// B.h</span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\">  // B code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们使用 gcc -E B.h 命令来看看经过预处理后的文件内容大概如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1 &quot;B.h&quot;</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 329 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 1 &quot;&lt;command line&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 2</span><br><span class=\"line\"># 1 &quot;B.h&quot; 2</span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到经过预处理之后，A.h 文件中的内容被直接复制并粘贴到 B.h 文件中来。如果我们在 B.h 文件中多次包含了 A.h 文件，会出现什么情况？比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// A.h</span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\">  // A code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// B.h</span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\">  // B code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过预处理之后的内容大概如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1 &quot;B.h&quot;</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 329 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 1 &quot;&lt;command line&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 2</span><br><span class=\"line\"># 1 &quot;B.h&quot; 2</span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;B.h&quot; 2</span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 3 &quot;B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>A.h 文件中的 sampleA() 函数出现了两次，所以我们需要利用其他的一些预处理命令来规避这种情况，看看下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// A.h</span><br><span class=\"line\">#ifndef FILE_A</span><br><span class=\"line\">#define FILE_A</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\">  // A code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// B.h</span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\">  // B code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们再来看看增加了这些预处理命令之后的预处理文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1 &quot;B.h&quot;</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 329 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 1 &quot;&lt;command line&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 2</span><br><span class=\"line\"># 1 &quot;B.h&quot; 2</span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>OK，这就正常了。如果我们在 A.h 中包含 B.h，然后又在 B.h 中包含 A.h，具体代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// A.h</span><br><span class=\"line\">#include &quot;B.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\">  // A code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// B.h</span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\">  // B code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们再来看看经过 gcc -E B.h 处理之后的文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1 &quot;B.h&quot;</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 329 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 1 &quot;&lt;command line&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 2</span><br><span class=\"line\"># 1 &quot;B.h&quot; 2</span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\"># 1 &quot;./B.h&quot; 1</span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\"># 1 &quot;./B.h&quot; 1</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\"># 1 &quot;./B.h&quot; 1</span><br><span class=\"line\">In file included from ./B.h:1:</span><br><span class=\"line\">In file included from ./A.h:1:</span><br><span class=\"line\">In file included from ./B.h:1:</span><br><span class=\"line\">In file included from ./A.h:1:</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">In file included from ./B.h:1:</span><br><span class=\"line\">In file included from ./A.h:1:</span><br><span class=\"line\">./A.h:1:10: error: #include nested too deeply</span><br><span class=\"line\">#include &quot;B.h&quot;</span><br><span class=\"line\">         ^</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;./B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;./A.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;./B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;./A.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"># 2 &quot;./A.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;./B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">1 error generated.</span><br></pre></td></tr></table></figure>\n<p>我们发现 A.h 和 B.h 重复出现，这是因为这个时候 A.h 和 B.h 文件互相引用导致的。从理论上来讲，这个时候会无限循环下去，直至世界终结。在这里最后会出现一句 <em>1 error generated.</em>的提示是 gcc 强行中断了这个预处理的过程，所以我们才能看到这样的结果。那我们可以怎么做？当然是利用前面说的预处理命令来避免循环引用的问题。看下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// A.h</span><br><span class=\"line\">#ifndef FILE_A</span><br><span class=\"line\">#define FILE_A</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;B.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\">  // A code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// B.h</span><br><span class=\"line\">#ifndef FILE_B</span><br><span class=\"line\">#define FILE_B</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\">  // B code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<p>这个时候使用 gcc -E B.h 就可以正常的进行预处理，最后的结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1 &quot;B.h&quot;</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 329 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 1 &quot;&lt;command line&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 2</span><br><span class=\"line\"># 1 &quot;B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 1 &quot;./B.h&quot; 1</span><br><span class=\"line\"># 5 &quot;./A.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 5 &quot;./B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以C程序员总是需要通过各种手段（比如：<a href=\"https://en.wikipedia.org/wiki/Pragma_once\" target=\"_blank\" rel=\"noopener\">#pragma once</a>）来防范此类事件的发生。</p>\n<h2 id=\"二、-import\"><a href=\"#二、-import\" class=\"headerlink\" title=\"二、#import\"></a>二、#import</h2><p>我们在文件中通过#import来导入 iAd Framework：<br><img src=\"http://i.imgur.com/nLPSsNN.jpg\" alt=\"\"></p>\n<p>编译报错：<br><img src=\"http://i.imgur.com/XBXD8wu.jpg\" alt=\"\"></p>\n<p>需要重新导入和链接 Framework：<br><img src=\"http://i.imgur.com/rUnKJGb.jpg\" alt=\"\"><br><img src=\"http://i.imgur.com/XuxVI6b.jpg\" alt=\"\"></p>\n<p>编译成功：<br><img src=\"http://i.imgur.com/QvyQunr.jpg\" alt=\"\"></p>\n<p>从上面的过程中我们就知道在 Objective-C 项目中使用 #import 需要注意导入和链接 Framework，否则是会报错的。</p>\n<p>预处理器在碰到 #import 命令的时候，它会采用递归的方式把被所有头文件的内容复制并粘贴到当前文件中，如果文件依赖层次比较深就会造成预处理后的文件内容体积大幅度变大。</p>\n<p>比如导入 UIKit 的时候只需要一行代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br></pre></td></tr></table></figure>\n<p>预处理之后会变成200多行（UIKit.h 文件有200多行代码）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;UIKit/UIKitDefines.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#if __has_include(&lt;UIKit/UIAccelerometer.h&gt;)</span><br><span class=\"line\">#import &lt;UIKit/UIAccelerometer.h&gt;</span><br><span class=\"line\">.....</span><br><span class=\"line\">#import &lt;UIKit/UIRegion.h&gt;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<p>接下来还需要递归的把每个头文件的内容展开，最后的结果就是一行代码变成超过11000行代码。如果有多个文件都包含来 UIKit 的头文件，这样就会让每个文件的体积都会变得很大，编译过程也会变得越来越慢。这种递归的方式会让项目的编译时间变成：<em>M source files + N headers =&gt; M x N compile time</em>。</p>\n<p>所以这个时候有一个优化方法就是把项目中频繁被引用的文件放到 PCH（Pre-Compile Header）文件中。PCH 会被编译一次并且会被缓存，这就可以缩短编译时间，我们也不需要在不同的文件里面添加import语法。</p>\n<p>当然，PCH 也有自己的缺点：</p>\n<ul>\n<li><p>维护负担：随着项目变得越来越复杂，我们就会不停的往PCH文件加入内容，内容一旦变多就会变得不好维护。（这也是我们平常在项目中要避免在 ViewController 做太多事情的，要研究 MVVM的缘故。）</p>\n</li>\n<li><p>命名空间污染</p>\n</li>\n</ul>\n<p>最后，给大家提供一个例子看看 #import 编译出来之后的文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// A.h</span><br><span class=\"line\">#import &quot;B.h&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\">  // A code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// B.h</span><br><span class=\"line\">#import &quot;A.h&quot;</span><br><span class=\"line\">#import &quot;A.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\">  // B code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 gcc -E B.h 进行预处理之后的内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 1 &quot;B.h&quot;</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 329 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 1 &quot;&lt;command line&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 2</span><br><span class=\"line\"># 1 &quot;B.h&quot; 2</span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;./B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在B.h中有两个 #import “A.h”，但是这些内容跟我们之前在 A.h 和 B.h 文件中使用 #include 和其他预处理命令之后的处理结果很相似，所以我们就明白了 #import 大概做了什么事。</p>\n<h2 id=\"三、-import\"><a href=\"#三、-import\" class=\"headerlink\" title=\"三、@import\"></a>三、@import</h2><p>在2012年的 LLVM 大会上，苹果的 Doug Gregor 首次提出了 Objective-C 中的 Module。使用 @import 方式导入有几个好处：</p>\n<ul>\n<li><p>不需要像 #import 一样得手动去链接 Framework，@import会自动去链接</p>\n</li>\n<li><p>@import 工作方式和 PCH 很像，但是 @import 要比 PCH 的效率高出许多</p>\n</li>\n<li><p>@import 导入 Modul 优化文件体积变大、编译速度变慢的问题</p>\n</li>\n<li><p>可以部分导入（@import Framework.A）或全部导入（@import Framework）</p>\n</li>\n</ul>\n<p>所以，建议大家尽量使用 @import 来导入文件。如果你以前的项目用的是 #import，那么你也不需要担心，我们只通过 Build Settings 开启 Modules 选项（看下图），#import 和 #include 会自动被映射成 @import，所以你不需要更改原来的代码也能享受 @import带来的好处。</p>\n<p><img src=\"http://i.imgur.com/l7ZMUy6.jpg\" alt=\"\"></p>\n<p>详细内容可以看看苹果2013年的 <a href=\"https://developer.apple.com/videos/play/wwdc2013/404/\" target=\"_blank\" rel=\"noopener\">Advances in Objective-C</a>，里面就详细介绍了 Module。</p>\n<h2 id=\"四、文件路径\"><a href=\"#四、文件路径\" class=\"headerlink\" title=\"四、文件路径\"></a>四、文件路径</h2><p>接下来我们来了解一下 <em>#include <file></file></em> 和 <em>#include “file”</em>：</p>\n<ul>\n<li><p>#include \\<file>: 表示编译器会直接到系统设定的目录下寻找指定的文件。</file></p>\n</li>\n<li><p>#include “file”: 表示编译器会到当前的目录下寻找指定的文件，如果找不到，则会去系统设定的目录下寻找指定的文件。</p>\n</li>\n</ul>\n<hr>\n<p>参考文献：</p>\n<ol>\n<li><p><a href=\"https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html\" target=\"_blank\" rel=\"noopener\">https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html</a></p>\n</li>\n<li><p><a href=\"http://stackoverflow.com/questions/18947516/import-vs-import-ios-7\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/18947516/import-vs-import-ios-7</a></p>\n</li>\n<li><p><a href=\"https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7\" target=\"_blank\" rel=\"noopener\">https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>今天我们来了解下面这几种包含文件的方式有什么特点和区别：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;fiel&quot;</span><br><span class=\"line\">#include &lt;file&gt;</span><br><span class=\"line\">#import &quot;file&quot;</span><br><span class=\"line\">#import &lt;file&gt;</span><br><span class=\"line\">@import Module</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"一、-include\"><a href=\"#一、-include\" class=\"headerlink\" title=\"一、#include\"></a>一、#include</h2><p>学过 C 语言的人都知道，#include 其实是一个预处理命令。它会在预处理的时候简单的把被 #include 包含的文件内容进行复制粘贴。我们来看看下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// A.h</span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\">  // A code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// B.h</span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\">  // B code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们使用 gcc -E B.h 命令来看看经过预处理后的文件内容大概如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1 &quot;B.h&quot;</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 329 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 1 &quot;&lt;command line&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 2</span><br><span class=\"line\"># 1 &quot;B.h&quot; 2</span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到经过预处理之后，A.h 文件中的内容被直接复制并粘贴到 B.h 文件中来。如果我们在 B.h 文件中多次包含了 A.h 文件，会出现什么情况？比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// A.h</span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\">  // A code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// B.h</span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\">  // B code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过预处理之后的内容大概如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1 &quot;B.h&quot;</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 329 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 1 &quot;&lt;command line&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 2</span><br><span class=\"line\"># 1 &quot;B.h&quot; 2</span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;B.h&quot; 2</span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 3 &quot;B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>A.h 文件中的 sampleA() 函数出现了两次，所以我们需要利用其他的一些预处理命令来规避这种情况，看看下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// A.h</span><br><span class=\"line\">#ifndef FILE_A</span><br><span class=\"line\">#define FILE_A</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\">  // A code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// B.h</span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\">  // B code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们再来看看增加了这些预处理命令之后的预处理文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1 &quot;B.h&quot;</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 329 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 1 &quot;&lt;command line&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 2</span><br><span class=\"line\"># 1 &quot;B.h&quot; 2</span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>OK，这就正常了。如果我们在 A.h 中包含 B.h，然后又在 B.h 中包含 A.h，具体代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// A.h</span><br><span class=\"line\">#include &quot;B.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\">  // A code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// B.h</span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\">  // B code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们再来看看经过 gcc -E B.h 处理之后的文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1 &quot;B.h&quot;</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 329 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 1 &quot;&lt;command line&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 2</span><br><span class=\"line\"># 1 &quot;B.h&quot; 2</span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\"># 1 &quot;./B.h&quot; 1</span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\"># 1 &quot;./B.h&quot; 1</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\"># 1 &quot;./B.h&quot; 1</span><br><span class=\"line\">In file included from ./B.h:1:</span><br><span class=\"line\">In file included from ./A.h:1:</span><br><span class=\"line\">In file included from ./B.h:1:</span><br><span class=\"line\">In file included from ./A.h:1:</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">In file included from ./B.h:1:</span><br><span class=\"line\">In file included from ./A.h:1:</span><br><span class=\"line\">./A.h:1:10: error: #include nested too deeply</span><br><span class=\"line\">#include &quot;B.h&quot;</span><br><span class=\"line\">         ^</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;./B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;./A.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;./B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;./A.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\"># 2 &quot;./A.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;./B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">1 error generated.</span><br></pre></td></tr></table></figure>\n<p>我们发现 A.h 和 B.h 重复出现，这是因为这个时候 A.h 和 B.h 文件互相引用导致的。从理论上来讲，这个时候会无限循环下去，直至世界终结。在这里最后会出现一句 <em>1 error generated.</em>的提示是 gcc 强行中断了这个预处理的过程，所以我们才能看到这样的结果。那我们可以怎么做？当然是利用前面说的预处理命令来避免循环引用的问题。看下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// A.h</span><br><span class=\"line\">#ifndef FILE_A</span><br><span class=\"line\">#define FILE_A</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;B.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\">  // A code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// B.h</span><br><span class=\"line\">#ifndef FILE_B</span><br><span class=\"line\">#define FILE_B</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;A.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\">  // B code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<p>这个时候使用 gcc -E B.h 就可以正常的进行预处理，最后的结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1 &quot;B.h&quot;</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 329 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 1 &quot;&lt;command line&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 2</span><br><span class=\"line\"># 1 &quot;B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 1 &quot;./B.h&quot; 1</span><br><span class=\"line\"># 5 &quot;./A.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 5 &quot;./B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以C程序员总是需要通过各种手段（比如：<a href=\"https://en.wikipedia.org/wiki/Pragma_once\" target=\"_blank\" rel=\"noopener\">#pragma once</a>）来防范此类事件的发生。</p>\n<h2 id=\"二、-import\"><a href=\"#二、-import\" class=\"headerlink\" title=\"二、#import\"></a>二、#import</h2><p>我们在文件中通过#import来导入 iAd Framework：<br><img src=\"http://i.imgur.com/nLPSsNN.jpg\" alt=\"\"></p>\n<p>编译报错：<br><img src=\"http://i.imgur.com/XBXD8wu.jpg\" alt=\"\"></p>\n<p>需要重新导入和链接 Framework：<br><img src=\"http://i.imgur.com/rUnKJGb.jpg\" alt=\"\"><br><img src=\"http://i.imgur.com/XuxVI6b.jpg\" alt=\"\"></p>\n<p>编译成功：<br><img src=\"http://i.imgur.com/QvyQunr.jpg\" alt=\"\"></p>\n<p>从上面的过程中我们就知道在 Objective-C 项目中使用 #import 需要注意导入和链接 Framework，否则是会报错的。</p>\n<p>预处理器在碰到 #import 命令的时候，它会采用递归的方式把被所有头文件的内容复制并粘贴到当前文件中，如果文件依赖层次比较深就会造成预处理后的文件内容体积大幅度变大。</p>\n<p>比如导入 UIKit 的时候只需要一行代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br></pre></td></tr></table></figure>\n<p>预处理之后会变成200多行（UIKit.h 文件有200多行代码）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;UIKit/UIKitDefines.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#if __has_include(&lt;UIKit/UIAccelerometer.h&gt;)</span><br><span class=\"line\">#import &lt;UIKit/UIAccelerometer.h&gt;</span><br><span class=\"line\">.....</span><br><span class=\"line\">#import &lt;UIKit/UIRegion.h&gt;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<p>接下来还需要递归的把每个头文件的内容展开，最后的结果就是一行代码变成超过11000行代码。如果有多个文件都包含来 UIKit 的头文件，这样就会让每个文件的体积都会变得很大，编译过程也会变得越来越慢。这种递归的方式会让项目的编译时间变成：<em>M source files + N headers =&gt; M x N compile time</em>。</p>\n<p>所以这个时候有一个优化方法就是把项目中频繁被引用的文件放到 PCH（Pre-Compile Header）文件中。PCH 会被编译一次并且会被缓存，这就可以缩短编译时间，我们也不需要在不同的文件里面添加import语法。</p>\n<p>当然，PCH 也有自己的缺点：</p>\n<ul>\n<li><p>维护负担：随着项目变得越来越复杂，我们就会不停的往PCH文件加入内容，内容一旦变多就会变得不好维护。（这也是我们平常在项目中要避免在 ViewController 做太多事情的，要研究 MVVM的缘故。）</p>\n</li>\n<li><p>命名空间污染</p>\n</li>\n</ul>\n<p>最后，给大家提供一个例子看看 #import 编译出来之后的文件内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// A.h</span><br><span class=\"line\">#import &quot;B.h&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\">  // A code</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// B.h</span><br><span class=\"line\">#import &quot;A.h&quot;</span><br><span class=\"line\">#import &quot;A.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\">  // B code</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 gcc -E B.h 进行预处理之后的内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 1 &quot;B.h&quot;</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 329 &quot;&lt;built-in&gt;&quot; 3</span><br><span class=\"line\"># 1 &quot;&lt;command line&gt;&quot; 1</span><br><span class=\"line\"># 1 &quot;&lt;built-in&gt;&quot; 2</span><br><span class=\"line\"># 1 &quot;B.h&quot; 2</span><br><span class=\"line\"># 1 &quot;./A.h&quot; 1</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">void sampleA() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># 2 &quot;./B.h&quot; 2</span><br><span class=\"line\"></span><br><span class=\"line\">void sampleB() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在B.h中有两个 #import “A.h”，但是这些内容跟我们之前在 A.h 和 B.h 文件中使用 #include 和其他预处理命令之后的处理结果很相似，所以我们就明白了 #import 大概做了什么事。</p>\n<h2 id=\"三、-import\"><a href=\"#三、-import\" class=\"headerlink\" title=\"三、@import\"></a>三、@import</h2><p>在2012年的 LLVM 大会上，苹果的 Doug Gregor 首次提出了 Objective-C 中的 Module。使用 @import 方式导入有几个好处：</p>\n<ul>\n<li><p>不需要像 #import 一样得手动去链接 Framework，@import会自动去链接</p>\n</li>\n<li><p>@import 工作方式和 PCH 很像，但是 @import 要比 PCH 的效率高出许多</p>\n</li>\n<li><p>@import 导入 Modul 优化文件体积变大、编译速度变慢的问题</p>\n</li>\n<li><p>可以部分导入（@import Framework.A）或全部导入（@import Framework）</p>\n</li>\n</ul>\n<p>所以，建议大家尽量使用 @import 来导入文件。如果你以前的项目用的是 #import，那么你也不需要担心，我们只通过 Build Settings 开启 Modules 选项（看下图），#import 和 #include 会自动被映射成 @import，所以你不需要更改原来的代码也能享受 @import带来的好处。</p>\n<p><img src=\"http://i.imgur.com/l7ZMUy6.jpg\" alt=\"\"></p>\n<p>详细内容可以看看苹果2013年的 <a href=\"https://developer.apple.com/videos/play/wwdc2013/404/\" target=\"_blank\" rel=\"noopener\">Advances in Objective-C</a>，里面就详细介绍了 Module。</p>\n<h2 id=\"四、文件路径\"><a href=\"#四、文件路径\" class=\"headerlink\" title=\"四、文件路径\"></a>四、文件路径</h2><p>接下来我们来了解一下 <em>#include <file></file></em> 和 <em>#include “file”</em>：</p>\n<ul>\n<li><p>#include \\<file>: 表示编译器会直接到系统设定的目录下寻找指定的文件。</file></p>\n</li>\n<li><p>#include “file”: 表示编译器会到当前的目录下寻找指定的文件，如果找不到，则会去系统设定的目录下寻找指定的文件。</p>\n</li>\n</ul>\n<hr>\n<p>参考文献：</p>\n<ol>\n<li><p><a href=\"https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html\" target=\"_blank\" rel=\"noopener\">https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html</a></p>\n</li>\n<li><p><a href=\"http://stackoverflow.com/questions/18947516/import-vs-import-ios-7\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/18947516/import-vs-import-ios-7</a></p>\n</li>\n<li><p><a href=\"https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7\" target=\"_blank\" rel=\"noopener\">https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7</a></p>\n</li>\n</ol>\n"},{"layout":"post","title":"初步了解 GCD","subtitle":"GCD(Grand Central Dispatch) 是苹果提供的一套多线程编程技术。","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n## GCD简介\n\nGCD(Grand Central Dispatch) 是苹果提供的一套多线程编程技术。想象一下，如果让你编写一个可以高效的跑在不同计算机、不同内核的应用程序，你会怎么做呢？你要看看硬件是什么，看看有有多少个内核，想想用什么算法，想想在什么时候去切换线程...总之，你要做的东西多了去了。而 GCD 帮我们屏蔽了这些技术细节，但是如果要用好 GCD 的话，还是要多了解一些知识点。\n\n## Dispatch对象和内存管理\n\n在 Objective-C 里面，所有的 dispatch 对象都是 Objective-C 对象，所以他们同样适用引用技术的内存管理。如果你是使用 ARC 的话，dispatch 对象会向普通的 Objective-C 对象一样自动进行 retain 和 release 操作；如果你是使用 MRC，要记住使用 dispatch_retain 和 dispatch_release 来进行管理。\n\n## 常用API\n\n### dispatch_queue_t（调度队列）\n\n```Swift\npublic func dispatch_queue_create(label: UnsafePointer<Int8>, _ attr: dispatch_queue_attr_t!) -> dispatch_queue_t!\n```\n\n在 GCD 中只能通过上面的 API 来创建调度队列，我们可以通过创建各种各样的 Block 形式的任务并由该调度队列来决定如何去执行这些 Block 任务。上面创建调度队列的函数需要两个参数：\n\n* label: 这个参数是用来给你创建的调度队列进行命名的，特别是在调试的时候你可以通过该参数来判断是哪个调度队列的任务在执行。\n* attr: 这个参数只有 DISPATCH_QUEUE_SERIAL 和 DISPATCH_QUEUE_CONCURRENT 两种值（在 Objective-C 中这个参数可以为 NULL，这个时候默认是 DISPATCH_QUEUE_SERIAL）。DISPATCH_QUEUE_SERIAL 是告诉调度队列以串行的方式去执行任务，DISPATCH_QUEUE_CONCURRENT 是告诉调度队列以并发的方式去执行任务。\n\n当然我们还可以通过下面的方法来获取系统已经创建好的调度队列：\n\n```Swift\n// 获取全局队列\npublic func dispatch_get_global_queue(identifier: Int, _ flags: UInt) -> dispatch_queue_t!\n```\n```Swift\n// 获取主线程的com.apple.main-thread (serial)队列\npublic func dispatch_get_main_queue() -> dispatch_queue_t!\n```\n\n注意，所有 pending 状态的 Block 任务都会持有该调度队列的引用，所以我们不需要显示的去持有调度队列，而调度队列会在所有的 Block 任务都从 pending 变为 finished 之后才会被释放。\n\n总之，现在大家要知道的是我们可以把不同的 Block任务提交到调度队列，具体的细节和实现看看后面内容。\n\n### dispatch_sync和dispatch_async（同步和异步）\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建调度队列\nprint(\"Begin Sync\")\n// 同步调用\ndispatch_sync(queue) {\n    // Block任务\n    print(\"Execute Block Task1\")   \n}\ndispatch_sync(queue) {\n    // Block任务\n    print(\"Execute Block Task2\")   \n}\nprint(\"After Sync\")\n```\n\n这段代码的输出结果如下：\n\n```Swift\nBegin Sync\nExecute Block Task1\nExecute Block Task2\nAfter Sync\n```\n\n上面的例子就是我们平常对 dispatch_sync 的用法，并且我们可以看到第一个 Block 任务执行之后才会执行第二个 Block 任务。dispatch_sync 需要等待 Block的任务执行完成之后，才能继续往后执行。但是使用 dispatch_sync 的时候，有几点是需要注意的：\n\n1. 当调用 dispatch_sync 方法的时候，系统默认情况下会在当前线程去执行调度队列里的任务，只有在一些特殊情况下才会把调度队列的任务分配到其他线程去执行。所以我们就知道，线程和调度队列并不是一对一的关系。至于为什么默认情况下会在当前线程去执行调度队列里的任务，我的猜测是为了性能。大家想一想，dispatch_sync 会同步执行 Block任务， Block任务没有结束的情况下，后面的代码是无法执行的。基于这样一个同步的机制，GCD 还有必要先把当前线程挂起，然后去创建新线程，然后切换到新的线程去执行调度队列里的任务，然后再把线程切换到当前线程，然后再让当前线程恢复么？结论是没有必要。\n\n2. 你不能够在当前的串行调度队列的任务里面去添加新的任务到当前的调度队列里面，否则会造成死锁。这句话怎么理解呢，我们来来看看下面的例子：\n    \n    ```Swift\n    // 例1\n    let queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n    // 同步调用\n    dispatch_sync(queue) {\n        // Block1\n        print(\"Begin Execute Block Task1\")\n        dispatch_sync(queue) {\n            // Block2\n            print(\"Execute Block Task2\")   \n        }\n        print(\"End Execute Block Task1\")\n    }\n\n    // 例1的结果\n    Begin Execute Block Task1\n    \n    ```\n    \n    为什么会 Block1 后面的 print 和 Block2 的 print 都不执行了呢？首先我们要知道被 DISPATCH_QUEUE_SERIAL 声明的调度队列是串行调度队列，串行调度队列里的任务是同时只能有一个任务在执行，并且当前任务没有执行完成，下一个任务也无法执行。上面的例子中会先输出 Block1 中的 *Begin Execute Block Task1*，然后这个时候再把 Block2 添加到同一个串行调度队列中去。这个时候的 Block1 还没有执行完成，它需要等 dispatch_sync 的 Block2 执行完成之后才能继续执行，而 Block2 又必须等待 Block1 执行完成之后才能执行，所以这个时候就造成 Block1 等着 Block2，Block2 等着 Block1 的死锁。\n    \n    我们再把调度队列属性改为 DISPAT_QUEUE_CONCURRENT，然后再看看执行结果是什么：\n\n\n    ```Swift\n    // 例2\n    let queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n    // 同步调用\n    dispatch_sync(queue) {\n        // Block1\n        print(\"Begin Execute Block Task1\")\n        dispatch_sync(queue) {\n            // Block2\n            print(\"Execute Block Task2\")   \n        }\n        print(\"End Execute Block Task1\")\n    }\n    ```\n    \n    ```Swift\n    // 例2的结果\n    Begin Execute Block Task1\n    Execute Block Task2\n    End Execute Block Task1\n    ```\n    \n    被 DISPATCH_QUEUE_CONCURRENT 声明的并发调度队列就没有这种死锁的问题。并发调度队列里的任务是不会霸占资源不放的，每一个任务执行一个时间片段之后会把资源交出来给别的任务去执行。所以例2中的 Block1 虽然需要等待 Block2 执行完成之后才能继续执行，但是当 Block1 在等待的过程中，是可以把资源释放出来交给 Block2 去执行，Block2 执行完成之后 Block1 就可以继续执行了。所以，这个时候就不会造成死锁来。\n    \n    再来看看下面的例子会不会造成死锁：\n\n    ```Swift\n    override func viewDidLoad() {\n        dispatch_sync(dispatch_get_main_queue()) {\n            print(\"Excute Block Task\")\n        }\n    }\n    ```\n    \n    答案是会的。给大家一点提示，主线程的默认调度队列是串行（DISPATCH_QUEUE_SERIAL）的，viewDidLoad() 是在主线程的调度队列 com.apple.main-thread (serial) 执行的。\n    \n    上面的例子主要是希望大家理解串行和并发的概念，同时要明白造成死锁的原因。而要解决死锁一般可以用 DISPATCH_QUEUE_CONCURRENT 或接下来我们要讲的 dispatch_async 来解决。\n\n通过对 dispatch_sync 的了解，我们可以利用 dispatch_async 很快的写出异步代码：\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建调度队列\nprint(\"Begin Async\")\n// 异步调用\ndispatch_async(queue) {\n    // Block1\n    print(\"Execute Block Task1\")   \n}\ndispatch_async(queue) {\n    // Block2\n    print(\"Execute Block Task2\")   \n}\nprint(\"After Async\")\n```\n\n这个例子的结果有好几种：\n\n```Swift\n// 结果1\nBegin Async\nAfter Async\nExecute Block Task1\nExEcute Block Task2\n```\n```Swift\n// 结果2\nBegin Async\nExecute Block Task1\nExEcute Block Task2\nAfter Async\n```\n\n上面只是列出来两种可能，但实际上还有其他的可能。当我们调用 dispatch_async 的时候，它总是会在 Block 任务被提交之后马上返回，而不会傻傻的等待 Block 任务执行完成。由于上面创建的是串行调度队列，所以我们可以保证 Block1 要比 Block2 优先执行，但是 After Async 就无法确定是在 Block1 的前后还是 Block2 的前后。\n\n如果我们把上面的 DISPATCH_QUEUE_SERIAL 改成 DISPATCH_QUEUE_CONCURRENT，那我们就无法确定 After Async、Block1 和 Block2 这三者的执行顺序了。\n\n我们刚才说到用 dispatch_async 可以解决死锁的问题，那它是怎么解决的呢？\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n// 异步调用\ndispatch_async(queue) {\n    // Block1\n    print(\"Begin Execute Block Task1\")\n    dispatch_async(queue) {\n        // Block2\n        print(\"Execute Block Task2\")   \n    }\n    print(\"End Execute Block Task1\")\n}\n```\n\n上面的例子会优先输出 Block1 的 *Begin Execute Block Task1* 之后，通过 dispatch_async 把 Block2 提交到串行队列里面，然后又马上返回到 Block1 去输出 *End Execute Block Task1*，这个时候的 Block1 就结束了，接下来就开始执行 Block2。所以上面的代码是不会造成死锁的，虽然上面的例子也是创建了一个串行调度队列，但是该调度队列只是保证了 Block1 要比 Block2 优先执行。\n\n### dispatch_once\n\n写过 Objective-C 的人都知道，dispatch_once 一般会被用来创建单例对象：\n\n```Objective-C\n@implementation Single\n+ (Single *)sharedInstance {\n    static Single * _single = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        _single = [[Single alloc] init];\n    });\n    return _single; \n}\n@end\n```\n\n这是由于 dispatch_once 是线程安全且只会执行一次，所以才会被用来作为单例的实现。这里需要注意的是 dispatch_once_t 必须是静态的或全局的才能保证 dispatch_once 的 Block 只会被执行一次，所以上面的代码用了 static 来修饰 dispatch_once_t。\n\n### dispatch_apply\n\n```Swift\npublic func dispatch_apply(iterations: Int, _ queue: dispatch_queue_t!, _ block: (Int) -> Void)\n```\n\n其中的 interations 是表明要执行多少次 block，block 中的 Int 是该 Block 被执行的序号。调用这个方法的时候要注意该方法跟 dispatch_sync 一样会阻塞当前线程，所以我们需要注意在主线程中调用该方法。\n\n### dispatch_after\n\n```Swift\npublic func dispatch_after(when: dispatch_time_t, _ queue: dispatch_queue_t, _ block: dispatch_block_t)\n```\n\n调用这个方法的时候需要注意的是 when 这个参数，你需要通过 dispatch_time 或 dispatch_walltime 来创建。并且该方法是异步执行的，并不会阻塞当前线程。\n\n一般的写法如下：\n\n```Swift\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(5 * NSEC_PER_SEC)), queue) {\n    print(\"5s \\(NSThread.currentThread())\")\n}\n```\n\n### dispatch_group_t\n\ndispatch_group_t 是用来做聚合同步的，它可以用来跟踪你提交的所有任务（即使是在不同的调度队列也可以）的完成状态。\n\n接下来我们来看看 dispatch group 的一些常见用法：\n\n```Swift\n// 创建dispatch_group_t对象\nlet group = dispatch_group_create()\n\n// 创建串行队列\nlet serialQueue = dispatch_queue_create(\"Serial Queue\", DISPATCH_QUEUE_SERIAL)\n\n// 提交两个Block任务到serialQueue，同时关联serialQueue和group的关系\ndispatch_group_async(group, serialQueue) {\n    print(\"Execute Block1 within Serial Queue\")\n}\ndispatch_group_async(group, serialQueue) {\n    print(\"Execute Block2 within Serial Queue\")\n}\n\n// 创建并发队列，并提交Block任务，同时关联该并发队列和group的关系\ndispatch_group_async(group, dispatch_queue_create(\"Concurrent Queue\", DISPATCH_QUEUE_CONCURRENT)) {\n    print(\"Execute Block within Concurrent Queue\")\n}\n\n// 下面的代码只有当前面被关联到group的所有任务完成之后才会被触发\ndispatch_group_notify(group, dispatch_queue_create(\"Finished\")) {\n    print(\"Finished\")\n}\n```\n\n注意，关联到 group 的方法只有 dispatch_group_async 而没有 dispatch_group_sync。\n\n但是还有另外一种方法可以让我们关联一个普通的任务：\n\n```Swift\n// 创建dispatch_group_t对象\nlet group = dispatch_group_create()\n\n// 使用dispatch_group_enter和dispatch_group_leave的话，我们不需要调用\n// dispatch_group_async也能关联一个任务到group上\ndispatch_group_enter(group)\nself.executeTask {\n    // 执行代码\n    \n    dispatch_group_leave(group)\n}\n\n// 下面的代码只有当前面被关联到group的所有任务完成之后才会被触发\ndispatch_group_notify(group, dispatch_queue_create(\"Finished\")) {\n    print(\"Finished\")\n}\n```\n\n使用 dispatch_group_enter 和 dispatch_group_leave 的时候，它们必须成双成对出现，否则 dispatch_group_notify 是不会被调用的。\n\n接下来我们还要了解一下 dispatch_group_wait：\n\n```Swift\npublic func dispatch_group_wait(group: dispatch_group_t, _ timeout: dispatch_time_t) -> Int\n```\n\ndispatch_group_wait 可以指定一个 timeout 的参数，当 group 的任务没有在规定的时间内完成，它会返回一个非零的值，当 group 的任务能够在规定的时间内完成就返回0。同时，大家要注意这个方法会挂起当前线程，所以在主线程的时候要慎重使用该方法。\n\n### dispatch_barrier_t\n\n我们先来试想一个场景，假如现在有多个线程要去读取一份文件的内容，同时又有其他线程想要去更新该文件的内容，那么就有可能会发生你读错文件内容的现象。这个时候我们可以把所有读写操作都放到我们之前学习的串行队列去执行，但是我们都知道同时有多个线程去读取一份文件内容是没有问题的。\n\n使用 dispatch barrier 可以解决上面的问题：\n\n```Swift\n// 创建操作文件的并发队列\nlet queue = dispatch_queue_create(\"File\", DISPATCH_QUEUE_CONCURRENT)\ndispatch_async(queue) {\n    // Read1\n}\ndispatch_async(queue) {\n    // Read2\n}\ndispatch_barrier_async(queue) {\n    // Write\n}\ndispatch_async(queue) {\n    // Read3\n}\n```\n\n通过 dispatch_barrier_async 或 dispatch_barrier_sync 提交的任务会等待当前队列里正在执行的任务执行完毕才会执行，并且其他还没有执行的任务都必须等待提交到 dispatch barrier 的任务执行完毕之后才会开始执行。所以上面的代码中，当 Write 任务被提交的时候，如果当前队列中只有 Read1 在执行，那么 Write 会等待 Read1 执行完成之后才会执行，Read2  和 Read3 都必须等待 Write 执行完之后才会执行。另外，上面的代码中创建的是并发队列，因为如果是串行队列的话就没有必要用 dispatch barrier 了。\n\n### dispatch_semaphore_t\n\ndispatch semaphore 是一个效率非常高的传统计数信号量，所以我们一般可以用这个来控制最大的并发数量。\n\n```Swift\n// 创建初始值为2的信号量，最大并发数量为2\nlet semaphore = dispatch_semaphore_create(2)\n// 创建并发队列\nlet queue = dispatch_queue_create(\"Semaphore\", DISPATCH_QUEUE_CONCURRENT)\n// 创建100个并发任务\nfor index in 1...100 {\n    // 这个方法会进行信号量减1的操作，并且如果信号量减1之后的结果小于0的话，该方法会造成线程的挂起直\n    // 到该信号量进行加1操作才会恢复，所以在主线程要注意该方法的使用。\n    // 注意：这个方法要放在dispatch_async外面，否则系统依旧会创建超过2个线程同时来处理该调度队列\n    // 的任务\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)\n    dispatch_async(queue) {\n        \n        // 释放资源，信号量增加1\n        dispatch_semaphore_signal(semaphore)\n    }\n}\n```\n\n## 其他\n\nGCD 在 Swift3 的语法跟现在的语法不太一样了，有兴趣的可以自行去了解。在未来可能会考虑把本文章的代码都用 Swift3 的语法来重新写一下。\n\n\n\n\n","source":"_posts/初步了解GCD.md","raw":"---\nlayout: post \ntitle: 初步了解 GCD\nsubtitle: GCD(Grand Central Dispatch) 是苹果提供的一套多线程编程技术。\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: iOS \ntag: iOS\n---\n\n## GCD简介\n\nGCD(Grand Central Dispatch) 是苹果提供的一套多线程编程技术。想象一下，如果让你编写一个可以高效的跑在不同计算机、不同内核的应用程序，你会怎么做呢？你要看看硬件是什么，看看有有多少个内核，想想用什么算法，想想在什么时候去切换线程...总之，你要做的东西多了去了。而 GCD 帮我们屏蔽了这些技术细节，但是如果要用好 GCD 的话，还是要多了解一些知识点。\n\n## Dispatch对象和内存管理\n\n在 Objective-C 里面，所有的 dispatch 对象都是 Objective-C 对象，所以他们同样适用引用技术的内存管理。如果你是使用 ARC 的话，dispatch 对象会向普通的 Objective-C 对象一样自动进行 retain 和 release 操作；如果你是使用 MRC，要记住使用 dispatch_retain 和 dispatch_release 来进行管理。\n\n## 常用API\n\n### dispatch_queue_t（调度队列）\n\n```Swift\npublic func dispatch_queue_create(label: UnsafePointer<Int8>, _ attr: dispatch_queue_attr_t!) -> dispatch_queue_t!\n```\n\n在 GCD 中只能通过上面的 API 来创建调度队列，我们可以通过创建各种各样的 Block 形式的任务并由该调度队列来决定如何去执行这些 Block 任务。上面创建调度队列的函数需要两个参数：\n\n* label: 这个参数是用来给你创建的调度队列进行命名的，特别是在调试的时候你可以通过该参数来判断是哪个调度队列的任务在执行。\n* attr: 这个参数只有 DISPATCH_QUEUE_SERIAL 和 DISPATCH_QUEUE_CONCURRENT 两种值（在 Objective-C 中这个参数可以为 NULL，这个时候默认是 DISPATCH_QUEUE_SERIAL）。DISPATCH_QUEUE_SERIAL 是告诉调度队列以串行的方式去执行任务，DISPATCH_QUEUE_CONCURRENT 是告诉调度队列以并发的方式去执行任务。\n\n当然我们还可以通过下面的方法来获取系统已经创建好的调度队列：\n\n```Swift\n// 获取全局队列\npublic func dispatch_get_global_queue(identifier: Int, _ flags: UInt) -> dispatch_queue_t!\n```\n```Swift\n// 获取主线程的com.apple.main-thread (serial)队列\npublic func dispatch_get_main_queue() -> dispatch_queue_t!\n```\n\n注意，所有 pending 状态的 Block 任务都会持有该调度队列的引用，所以我们不需要显示的去持有调度队列，而调度队列会在所有的 Block 任务都从 pending 变为 finished 之后才会被释放。\n\n总之，现在大家要知道的是我们可以把不同的 Block任务提交到调度队列，具体的细节和实现看看后面内容。\n\n### dispatch_sync和dispatch_async（同步和异步）\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建调度队列\nprint(\"Begin Sync\")\n// 同步调用\ndispatch_sync(queue) {\n    // Block任务\n    print(\"Execute Block Task1\")   \n}\ndispatch_sync(queue) {\n    // Block任务\n    print(\"Execute Block Task2\")   \n}\nprint(\"After Sync\")\n```\n\n这段代码的输出结果如下：\n\n```Swift\nBegin Sync\nExecute Block Task1\nExecute Block Task2\nAfter Sync\n```\n\n上面的例子就是我们平常对 dispatch_sync 的用法，并且我们可以看到第一个 Block 任务执行之后才会执行第二个 Block 任务。dispatch_sync 需要等待 Block的任务执行完成之后，才能继续往后执行。但是使用 dispatch_sync 的时候，有几点是需要注意的：\n\n1. 当调用 dispatch_sync 方法的时候，系统默认情况下会在当前线程去执行调度队列里的任务，只有在一些特殊情况下才会把调度队列的任务分配到其他线程去执行。所以我们就知道，线程和调度队列并不是一对一的关系。至于为什么默认情况下会在当前线程去执行调度队列里的任务，我的猜测是为了性能。大家想一想，dispatch_sync 会同步执行 Block任务， Block任务没有结束的情况下，后面的代码是无法执行的。基于这样一个同步的机制，GCD 还有必要先把当前线程挂起，然后去创建新线程，然后切换到新的线程去执行调度队列里的任务，然后再把线程切换到当前线程，然后再让当前线程恢复么？结论是没有必要。\n\n2. 你不能够在当前的串行调度队列的任务里面去添加新的任务到当前的调度队列里面，否则会造成死锁。这句话怎么理解呢，我们来来看看下面的例子：\n    \n    ```Swift\n    // 例1\n    let queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n    // 同步调用\n    dispatch_sync(queue) {\n        // Block1\n        print(\"Begin Execute Block Task1\")\n        dispatch_sync(queue) {\n            // Block2\n            print(\"Execute Block Task2\")   \n        }\n        print(\"End Execute Block Task1\")\n    }\n\n    // 例1的结果\n    Begin Execute Block Task1\n    \n    ```\n    \n    为什么会 Block1 后面的 print 和 Block2 的 print 都不执行了呢？首先我们要知道被 DISPATCH_QUEUE_SERIAL 声明的调度队列是串行调度队列，串行调度队列里的任务是同时只能有一个任务在执行，并且当前任务没有执行完成，下一个任务也无法执行。上面的例子中会先输出 Block1 中的 *Begin Execute Block Task1*，然后这个时候再把 Block2 添加到同一个串行调度队列中去。这个时候的 Block1 还没有执行完成，它需要等 dispatch_sync 的 Block2 执行完成之后才能继续执行，而 Block2 又必须等待 Block1 执行完成之后才能执行，所以这个时候就造成 Block1 等着 Block2，Block2 等着 Block1 的死锁。\n    \n    我们再把调度队列属性改为 DISPAT_QUEUE_CONCURRENT，然后再看看执行结果是什么：\n\n\n    ```Swift\n    // 例2\n    let queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n    // 同步调用\n    dispatch_sync(queue) {\n        // Block1\n        print(\"Begin Execute Block Task1\")\n        dispatch_sync(queue) {\n            // Block2\n            print(\"Execute Block Task2\")   \n        }\n        print(\"End Execute Block Task1\")\n    }\n    ```\n    \n    ```Swift\n    // 例2的结果\n    Begin Execute Block Task1\n    Execute Block Task2\n    End Execute Block Task1\n    ```\n    \n    被 DISPATCH_QUEUE_CONCURRENT 声明的并发调度队列就没有这种死锁的问题。并发调度队列里的任务是不会霸占资源不放的，每一个任务执行一个时间片段之后会把资源交出来给别的任务去执行。所以例2中的 Block1 虽然需要等待 Block2 执行完成之后才能继续执行，但是当 Block1 在等待的过程中，是可以把资源释放出来交给 Block2 去执行，Block2 执行完成之后 Block1 就可以继续执行了。所以，这个时候就不会造成死锁来。\n    \n    再来看看下面的例子会不会造成死锁：\n\n    ```Swift\n    override func viewDidLoad() {\n        dispatch_sync(dispatch_get_main_queue()) {\n            print(\"Excute Block Task\")\n        }\n    }\n    ```\n    \n    答案是会的。给大家一点提示，主线程的默认调度队列是串行（DISPATCH_QUEUE_SERIAL）的，viewDidLoad() 是在主线程的调度队列 com.apple.main-thread (serial) 执行的。\n    \n    上面的例子主要是希望大家理解串行和并发的概念，同时要明白造成死锁的原因。而要解决死锁一般可以用 DISPATCH_QUEUE_CONCURRENT 或接下来我们要讲的 dispatch_async 来解决。\n\n通过对 dispatch_sync 的了解，我们可以利用 dispatch_async 很快的写出异步代码：\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建调度队列\nprint(\"Begin Async\")\n// 异步调用\ndispatch_async(queue) {\n    // Block1\n    print(\"Execute Block Task1\")   \n}\ndispatch_async(queue) {\n    // Block2\n    print(\"Execute Block Task2\")   \n}\nprint(\"After Async\")\n```\n\n这个例子的结果有好几种：\n\n```Swift\n// 结果1\nBegin Async\nAfter Async\nExecute Block Task1\nExEcute Block Task2\n```\n```Swift\n// 结果2\nBegin Async\nExecute Block Task1\nExEcute Block Task2\nAfter Async\n```\n\n上面只是列出来两种可能，但实际上还有其他的可能。当我们调用 dispatch_async 的时候，它总是会在 Block 任务被提交之后马上返回，而不会傻傻的等待 Block 任务执行完成。由于上面创建的是串行调度队列，所以我们可以保证 Block1 要比 Block2 优先执行，但是 After Async 就无法确定是在 Block1 的前后还是 Block2 的前后。\n\n如果我们把上面的 DISPATCH_QUEUE_SERIAL 改成 DISPATCH_QUEUE_CONCURRENT，那我们就无法确定 After Async、Block1 和 Block2 这三者的执行顺序了。\n\n我们刚才说到用 dispatch_async 可以解决死锁的问题，那它是怎么解决的呢？\n\n```Swift\nlet queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL)  // 创建串行的调度队列\n// 异步调用\ndispatch_async(queue) {\n    // Block1\n    print(\"Begin Execute Block Task1\")\n    dispatch_async(queue) {\n        // Block2\n        print(\"Execute Block Task2\")   \n    }\n    print(\"End Execute Block Task1\")\n}\n```\n\n上面的例子会优先输出 Block1 的 *Begin Execute Block Task1* 之后，通过 dispatch_async 把 Block2 提交到串行队列里面，然后又马上返回到 Block1 去输出 *End Execute Block Task1*，这个时候的 Block1 就结束了，接下来就开始执行 Block2。所以上面的代码是不会造成死锁的，虽然上面的例子也是创建了一个串行调度队列，但是该调度队列只是保证了 Block1 要比 Block2 优先执行。\n\n### dispatch_once\n\n写过 Objective-C 的人都知道，dispatch_once 一般会被用来创建单例对象：\n\n```Objective-C\n@implementation Single\n+ (Single *)sharedInstance {\n    static Single * _single = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        _single = [[Single alloc] init];\n    });\n    return _single; \n}\n@end\n```\n\n这是由于 dispatch_once 是线程安全且只会执行一次，所以才会被用来作为单例的实现。这里需要注意的是 dispatch_once_t 必须是静态的或全局的才能保证 dispatch_once 的 Block 只会被执行一次，所以上面的代码用了 static 来修饰 dispatch_once_t。\n\n### dispatch_apply\n\n```Swift\npublic func dispatch_apply(iterations: Int, _ queue: dispatch_queue_t!, _ block: (Int) -> Void)\n```\n\n其中的 interations 是表明要执行多少次 block，block 中的 Int 是该 Block 被执行的序号。调用这个方法的时候要注意该方法跟 dispatch_sync 一样会阻塞当前线程，所以我们需要注意在主线程中调用该方法。\n\n### dispatch_after\n\n```Swift\npublic func dispatch_after(when: dispatch_time_t, _ queue: dispatch_queue_t, _ block: dispatch_block_t)\n```\n\n调用这个方法的时候需要注意的是 when 这个参数，你需要通过 dispatch_time 或 dispatch_walltime 来创建。并且该方法是异步执行的，并不会阻塞当前线程。\n\n一般的写法如下：\n\n```Swift\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(5 * NSEC_PER_SEC)), queue) {\n    print(\"5s \\(NSThread.currentThread())\")\n}\n```\n\n### dispatch_group_t\n\ndispatch_group_t 是用来做聚合同步的，它可以用来跟踪你提交的所有任务（即使是在不同的调度队列也可以）的完成状态。\n\n接下来我们来看看 dispatch group 的一些常见用法：\n\n```Swift\n// 创建dispatch_group_t对象\nlet group = dispatch_group_create()\n\n// 创建串行队列\nlet serialQueue = dispatch_queue_create(\"Serial Queue\", DISPATCH_QUEUE_SERIAL)\n\n// 提交两个Block任务到serialQueue，同时关联serialQueue和group的关系\ndispatch_group_async(group, serialQueue) {\n    print(\"Execute Block1 within Serial Queue\")\n}\ndispatch_group_async(group, serialQueue) {\n    print(\"Execute Block2 within Serial Queue\")\n}\n\n// 创建并发队列，并提交Block任务，同时关联该并发队列和group的关系\ndispatch_group_async(group, dispatch_queue_create(\"Concurrent Queue\", DISPATCH_QUEUE_CONCURRENT)) {\n    print(\"Execute Block within Concurrent Queue\")\n}\n\n// 下面的代码只有当前面被关联到group的所有任务完成之后才会被触发\ndispatch_group_notify(group, dispatch_queue_create(\"Finished\")) {\n    print(\"Finished\")\n}\n```\n\n注意，关联到 group 的方法只有 dispatch_group_async 而没有 dispatch_group_sync。\n\n但是还有另外一种方法可以让我们关联一个普通的任务：\n\n```Swift\n// 创建dispatch_group_t对象\nlet group = dispatch_group_create()\n\n// 使用dispatch_group_enter和dispatch_group_leave的话，我们不需要调用\n// dispatch_group_async也能关联一个任务到group上\ndispatch_group_enter(group)\nself.executeTask {\n    // 执行代码\n    \n    dispatch_group_leave(group)\n}\n\n// 下面的代码只有当前面被关联到group的所有任务完成之后才会被触发\ndispatch_group_notify(group, dispatch_queue_create(\"Finished\")) {\n    print(\"Finished\")\n}\n```\n\n使用 dispatch_group_enter 和 dispatch_group_leave 的时候，它们必须成双成对出现，否则 dispatch_group_notify 是不会被调用的。\n\n接下来我们还要了解一下 dispatch_group_wait：\n\n```Swift\npublic func dispatch_group_wait(group: dispatch_group_t, _ timeout: dispatch_time_t) -> Int\n```\n\ndispatch_group_wait 可以指定一个 timeout 的参数，当 group 的任务没有在规定的时间内完成，它会返回一个非零的值，当 group 的任务能够在规定的时间内完成就返回0。同时，大家要注意这个方法会挂起当前线程，所以在主线程的时候要慎重使用该方法。\n\n### dispatch_barrier_t\n\n我们先来试想一个场景，假如现在有多个线程要去读取一份文件的内容，同时又有其他线程想要去更新该文件的内容，那么就有可能会发生你读错文件内容的现象。这个时候我们可以把所有读写操作都放到我们之前学习的串行队列去执行，但是我们都知道同时有多个线程去读取一份文件内容是没有问题的。\n\n使用 dispatch barrier 可以解决上面的问题：\n\n```Swift\n// 创建操作文件的并发队列\nlet queue = dispatch_queue_create(\"File\", DISPATCH_QUEUE_CONCURRENT)\ndispatch_async(queue) {\n    // Read1\n}\ndispatch_async(queue) {\n    // Read2\n}\ndispatch_barrier_async(queue) {\n    // Write\n}\ndispatch_async(queue) {\n    // Read3\n}\n```\n\n通过 dispatch_barrier_async 或 dispatch_barrier_sync 提交的任务会等待当前队列里正在执行的任务执行完毕才会执行，并且其他还没有执行的任务都必须等待提交到 dispatch barrier 的任务执行完毕之后才会开始执行。所以上面的代码中，当 Write 任务被提交的时候，如果当前队列中只有 Read1 在执行，那么 Write 会等待 Read1 执行完成之后才会执行，Read2  和 Read3 都必须等待 Write 执行完之后才会执行。另外，上面的代码中创建的是并发队列，因为如果是串行队列的话就没有必要用 dispatch barrier 了。\n\n### dispatch_semaphore_t\n\ndispatch semaphore 是一个效率非常高的传统计数信号量，所以我们一般可以用这个来控制最大的并发数量。\n\n```Swift\n// 创建初始值为2的信号量，最大并发数量为2\nlet semaphore = dispatch_semaphore_create(2)\n// 创建并发队列\nlet queue = dispatch_queue_create(\"Semaphore\", DISPATCH_QUEUE_CONCURRENT)\n// 创建100个并发任务\nfor index in 1...100 {\n    // 这个方法会进行信号量减1的操作，并且如果信号量减1之后的结果小于0的话，该方法会造成线程的挂起直\n    // 到该信号量进行加1操作才会恢复，所以在主线程要注意该方法的使用。\n    // 注意：这个方法要放在dispatch_async外面，否则系统依旧会创建超过2个线程同时来处理该调度队列\n    // 的任务\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)\n    dispatch_async(queue) {\n        \n        // 释放资源，信号量增加1\n        dispatch_semaphore_signal(semaphore)\n    }\n}\n```\n\n## 其他\n\nGCD 在 Swift3 的语法跟现在的语法不太一样了，有兴趣的可以自行去了解。在未来可能会考虑把本文章的代码都用 Swift3 的语法来重新写一下。\n\n\n\n\n","slug":"初步了解GCD","published":1,"updated":"2018-03-08T06:26:29.292Z","_id":"cjei470sp000iu5vbs0vg6tgb","comments":1,"photos":[],"link":"","content":"<h2 id=\"GCD简介\"><a href=\"#GCD简介\" class=\"headerlink\" title=\"GCD简介\"></a>GCD简介</h2><p>GCD(Grand Central Dispatch) 是苹果提供的一套多线程编程技术。想象一下，如果让你编写一个可以高效的跑在不同计算机、不同内核的应用程序，你会怎么做呢？你要看看硬件是什么，看看有有多少个内核，想想用什么算法，想想在什么时候去切换线程…总之，你要做的东西多了去了。而 GCD 帮我们屏蔽了这些技术细节，但是如果要用好 GCD 的话，还是要多了解一些知识点。</p>\n<h2 id=\"Dispatch对象和内存管理\"><a href=\"#Dispatch对象和内存管理\" class=\"headerlink\" title=\"Dispatch对象和内存管理\"></a>Dispatch对象和内存管理</h2><p>在 Objective-C 里面，所有的 dispatch 对象都是 Objective-C 对象，所以他们同样适用引用技术的内存管理。如果你是使用 ARC 的话，dispatch 对象会向普通的 Objective-C 对象一样自动进行 retain 和 release 操作；如果你是使用 MRC，要记住使用 dispatch_retain 和 dispatch_release 来进行管理。</p>\n<h2 id=\"常用API\"><a href=\"#常用API\" class=\"headerlink\" title=\"常用API\"></a>常用API</h2><h3 id=\"dispatch-queue-t（调度队列）\"><a href=\"#dispatch-queue-t（调度队列）\" class=\"headerlink\" title=\"dispatch_queue_t（调度队列）\"></a>dispatch_queue_t（调度队列）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dispatch_queue_create</span><span class=\"params\">(label: UnsafePointer&lt;Int8&gt;, <span class=\"number\">_</span> attr: dispatch_queue_attr_t!)</span></span> -&gt; dispatch_queue_t!</span><br></pre></td></tr></table></figure>\n<p>在 GCD 中只能通过上面的 API 来创建调度队列，我们可以通过创建各种各样的 Block 形式的任务并由该调度队列来决定如何去执行这些 Block 任务。上面创建调度队列的函数需要两个参数：</p>\n<ul>\n<li>label: 这个参数是用来给你创建的调度队列进行命名的，特别是在调试的时候你可以通过该参数来判断是哪个调度队列的任务在执行。</li>\n<li>attr: 这个参数只有 DISPATCH_QUEUE_SERIAL 和 DISPATCH_QUEUE_CONCURRENT 两种值（在 Objective-C 中这个参数可以为 NULL，这个时候默认是 DISPATCH_QUEUE_SERIAL）。DISPATCH_QUEUE_SERIAL 是告诉调度队列以串行的方式去执行任务，DISPATCH_QUEUE_CONCURRENT 是告诉调度队列以并发的方式去执行任务。</li>\n</ul>\n<p>当然我们还可以通过下面的方法来获取系统已经创建好的调度队列：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取全局队列</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dispatch_get_global_queue</span><span class=\"params\">(identifier: Int, <span class=\"number\">_</span> flags: UInt)</span></span> -&gt; dispatch_queue_t!</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取主线程的com.apple.main-thread (serial)队列</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dispatch_get_main_queue</span><span class=\"params\">()</span></span> -&gt; dispatch_queue_t!</span><br></pre></td></tr></table></figure>\n<p>注意，所有 pending 状态的 Block 任务都会持有该调度队列的引用，所以我们不需要显示的去持有调度队列，而调度队列会在所有的 Block 任务都从 pending 变为 finished 之后才会被释放。</p>\n<p>总之，现在大家要知道的是我们可以把不同的 Block任务提交到调度队列，具体的细节和实现看看后面内容。</p>\n<h3 id=\"dispatch-sync和dispatch-async（同步和异步）\"><a href=\"#dispatch-sync和dispatch-async（同步和异步）\" class=\"headerlink\" title=\"dispatch_sync和dispatch_async（同步和异步）\"></a>dispatch_sync和dispatch_async（同步和异步）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue = dispatch_queue_create(<span class=\"string\">\"com.PS.Queue\"</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建调度队列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Begin Sync\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block任务</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block Task1\"</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block任务</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block Task2\"</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"After Sync\"</span>)</span><br></pre></td></tr></table></figure>\n<p>这段代码的输出结果如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Sync</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Sync</span></span><br></pre></td></tr></table></figure>\n<p>上面的例子就是我们平常对 dispatch_sync 的用法，并且我们可以看到第一个 Block 任务执行之后才会执行第二个 Block 任务。dispatch_sync 需要等待 Block的任务执行完成之后，才能继续往后执行。但是使用 dispatch_sync 的时候，有几点是需要注意的：</p>\n<ol>\n<li><p>当调用 dispatch_sync 方法的时候，系统默认情况下会在当前线程去执行调度队列里的任务，只有在一些特殊情况下才会把调度队列的任务分配到其他线程去执行。所以我们就知道，线程和调度队列并不是一对一的关系。至于为什么默认情况下会在当前线程去执行调度队列里的任务，我的猜测是为了性能。大家想一想，dispatch_sync 会同步执行 Block任务， Block任务没有结束的情况下，后面的代码是无法执行的。基于这样一个同步的机制，GCD 还有必要先把当前线程挂起，然后去创建新线程，然后切换到新的线程去执行调度队列里的任务，然后再把线程切换到当前线程，然后再让当前线程恢复么？结论是没有必要。</p>\n</li>\n<li><p>你不能够在当前的串行调度队列的任务里面去添加新的任务到当前的调度队列里面，否则会造成死锁。这句话怎么理解呢，我们来来看看下面的例子：</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue = dispatch_queue_create(<span class=\"string\">\"com.PS.Queue\"</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Begin Execute Block Task1\"</span>)</span><br><span class=\"line\">    dispatch_sync(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block Task2\"</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"End Execute Block Task1\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例1的结果</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>为什么会 Block1 后面的 print 和 Block2 的 print 都不执行了呢？首先我们要知道被 DISPATCH_QUEUE_SERIAL 声明的调度队列是串行调度队列，串行调度队列里的任务是同时只能有一个任务在执行，并且当前任务没有执行完成，下一个任务也无法执行。上面的例子中会先输出 Block1 中的 *Begin Execute Block Task1*，然后这个时候再把 Block2 添加到同一个串行调度队列中去。这个时候的 Block1 还没有执行完成，它需要等 dispatch_sync 的 Block2 执行完成之后才能继续执行，而 Block2 又必须等待 Block1 执行完成之后才能执行，所以这个时候就造成 Block1 等着 Block2，Block2 等着 Block1 的死锁。\n\n我们再把调度队列属性改为 DISPAT_QUEUE_CONCURRENT，然后再看看执行结果是什么：\n\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue = dispatch_queue_create(<span class=\"string\">\"com.PS.Queue\"</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Begin Execute Block Task1\"</span>)</span><br><span class=\"line\">    dispatch_sync(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block Task2\"</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"End Execute Block Task1\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2的结果</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">End</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br></pre></td></tr></table></figure>\n\n\n被 DISPATCH_QUEUE_CONCURRENT 声明的并发调度队列就没有这种死锁的问题。并发调度队列里的任务是不会霸占资源不放的，每一个任务执行一个时间片段之后会把资源交出来给别的任务去执行。所以例2中的 Block1 虽然需要等待 Block2 执行完成之后才能继续执行，但是当 Block1 在等待的过程中，是可以把资源释放出来交给 Block2 去执行，Block2 执行完成之后 Block1 就可以继续执行了。所以，这个时候就不会造成死锁来。\n\n再来看看下面的例子会不会造成死锁：\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    dispatch_sync(dispatch_get_main_queue()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Excute Block Task\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n答案是会的。给大家一点提示，主线程的默认调度队列是串行（DISPATCH_QUEUE_SERIAL）的，viewDidLoad() 是在主线程的调度队列 com.apple.main-thread (serial) 执行的。\n\n上面的例子主要是希望大家理解串行和并发的概念，同时要明白造成死锁的原因。而要解决死锁一般可以用 DISPATCH_QUEUE_CONCURRENT 或接下来我们要讲的 dispatch_async 来解决。\n</code></pre><p>通过对 dispatch_sync 的了解，我们可以利用 dispatch_async 很快的写出异步代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue = dispatch_queue_create(<span class=\"string\">\"com.PS.Queue\"</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建调度队列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Begin Async\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 异步调用</span></span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block Task1\"</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block2</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block Task2\"</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"After Async\"</span>)</span><br></pre></td></tr></table></figure>\n<p>这个例子的结果有好几种：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结果1</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">ExEcute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结果2</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">ExEcute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Async</span></span><br></pre></td></tr></table></figure>\n<p>上面只是列出来两种可能，但实际上还有其他的可能。当我们调用 dispatch_async 的时候，它总是会在 Block 任务被提交之后马上返回，而不会傻傻的等待 Block 任务执行完成。由于上面创建的是串行调度队列，所以我们可以保证 Block1 要比 Block2 优先执行，但是 After Async 就无法确定是在 Block1 的前后还是 Block2 的前后。</p>\n<p>如果我们把上面的 DISPATCH_QUEUE_SERIAL 改成 DISPATCH_QUEUE_CONCURRENT，那我们就无法确定 After Async、Block1 和 Block2 这三者的执行顺序了。</p>\n<p>我们刚才说到用 dispatch_async 可以解决死锁的问题，那它是怎么解决的呢？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue = dispatch_queue_create(<span class=\"string\">\"com.PS.Queue\"</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 异步调用</span></span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Begin Execute Block Task1\"</span>)</span><br><span class=\"line\">    dispatch_async(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block Task2\"</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"End Execute Block Task1\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的例子会优先输出 Block1 的 <em>Begin Execute Block Task1</em> 之后，通过 dispatch_async 把 Block2 提交到串行队列里面，然后又马上返回到 Block1 去输出 <em>End Execute Block Task1</em>，这个时候的 Block1 就结束了，接下来就开始执行 Block2。所以上面的代码是不会造成死锁的，虽然上面的例子也是创建了一个串行调度队列，但是该调度队列只是保证了 Block1 要比 Block2 优先执行。</p>\n<h3 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h3><p>写过 Objective-C 的人都知道，dispatch_once 一般会被用来创建单例对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Single</span><br><span class=\"line\">+ (Single *)sharedInstance &#123;</span><br><span class=\"line\">    static Single * _single = nil;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        _single = [[Single alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return _single; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>这是由于 dispatch_once 是线程安全且只会执行一次，所以才会被用来作为单例的实现。这里需要注意的是 dispatch_once_t 必须是静态的或全局的才能保证 dispatch_once 的 Block 只会被执行一次，所以上面的代码用了 static 来修饰 dispatch_once_t。</p>\n<h3 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dispatch_apply</span><span class=\"params\">(iterations: Int, <span class=\"number\">_</span> queue: dispatch_queue_t!, <span class=\"number\">_</span> block: <span class=\"params\">(Int)</span></span></span> -&gt; <span class=\"type\">Void</span>)</span><br></pre></td></tr></table></figure>\n<p>其中的 interations 是表明要执行多少次 block，block 中的 Int 是该 Block 被执行的序号。调用这个方法的时候要注意该方法跟 dispatch_sync 一样会阻塞当前线程，所以我们需要注意在主线程中调用该方法。</p>\n<h3 id=\"dispatch-after\"><a href=\"#dispatch-after\" class=\"headerlink\" title=\"dispatch_after\"></a>dispatch_after</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dispatch_after</span><span class=\"params\">(when: dispatch_time_t, <span class=\"number\">_</span> queue: dispatch_queue_t, <span class=\"number\">_</span> block: dispatch_block_t)</span></span></span><br></pre></td></tr></table></figure>\n<p>调用这个方法的时候需要注意的是 when 这个参数，你需要通过 dispatch_time 或 dispatch_walltime 来创建。并且该方法是异步执行的，并不会阻塞当前线程。</p>\n<p>一般的写法如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_after(dispatch_time(<span class=\"type\">DISPATCH_TIME_NOW</span>, <span class=\"type\">Int64</span>(<span class=\"number\">5</span> * <span class=\"type\">NSEC_PER_SEC</span>)), queue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"5s <span class=\"subst\">\\(NSThread.currentThread()</span>)\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"dispatch-group-t\"><a href=\"#dispatch-group-t\" class=\"headerlink\" title=\"dispatch_group_t\"></a>dispatch_group_t</h3><p>dispatch_group_t 是用来做聚合同步的，它可以用来跟踪你提交的所有任务（即使是在不同的调度队列也可以）的完成状态。</p>\n<p>接下来我们来看看 dispatch group 的一些常见用法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建dispatch_group_t对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> group = dispatch_group_create()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建串行队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> serialQueue = dispatch_queue_create(<span class=\"string\">\"Serial Queue\"</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提交两个Block任务到serialQueue，同时关联serialQueue和group的关系</span></span><br><span class=\"line\">dispatch_group_async(group, serialQueue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block1 within Serial Queue\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_group_async(group, serialQueue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block2 within Serial Queue\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并发队列，并提交Block任务，同时关联该并发队列和group的关系</span></span><br><span class=\"line\">dispatch_group_async(group, dispatch_queue_create(<span class=\"string\">\"Concurrent Queue\"</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block within Concurrent Queue\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的代码只有当前面被关联到group的所有任务完成之后才会被触发</span></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_queue_create(<span class=\"string\">\"Finished\"</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Finished\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，关联到 group 的方法只有 dispatch_group_async 而没有 dispatch_group_sync。</p>\n<p>但是还有另外一种方法可以让我们关联一个普通的任务：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建dispatch_group_t对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> group = dispatch_group_create()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用dispatch_group_enter和dispatch_group_leave的话，我们不需要调用</span></span><br><span class=\"line\"><span class=\"comment\">// dispatch_group_async也能关联一个任务到group上</span></span><br><span class=\"line\">dispatch_group_enter(group)</span><br><span class=\"line\"><span class=\"keyword\">self</span>.executeTask &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行代码</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_group_leave(group)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的代码只有当前面被关联到group的所有任务完成之后才会被触发</span></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_queue_create(<span class=\"string\">\"Finished\"</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Finished\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 dispatch_group_enter 和 dispatch_group_leave 的时候，它们必须成双成对出现，否则 dispatch_group_notify 是不会被调用的。</p>\n<p>接下来我们还要了解一下 dispatch_group_wait：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dispatch_group_wait</span><span class=\"params\">(group: dispatch_group_t, <span class=\"number\">_</span> timeout: dispatch_time_t)</span></span> -&gt; <span class=\"type\">Int</span></span><br></pre></td></tr></table></figure>\n<p>dispatch_group_wait 可以指定一个 timeout 的参数，当 group 的任务没有在规定的时间内完成，它会返回一个非零的值，当 group 的任务能够在规定的时间内完成就返回0。同时，大家要注意这个方法会挂起当前线程，所以在主线程的时候要慎重使用该方法。</p>\n<h3 id=\"dispatch-barrier-t\"><a href=\"#dispatch-barrier-t\" class=\"headerlink\" title=\"dispatch_barrier_t\"></a>dispatch_barrier_t</h3><p>我们先来试想一个场景，假如现在有多个线程要去读取一份文件的内容，同时又有其他线程想要去更新该文件的内容，那么就有可能会发生你读错文件内容的现象。这个时候我们可以把所有读写操作都放到我们之前学习的串行队列去执行，但是我们都知道同时有多个线程去读取一份文件内容是没有问题的。</p>\n<p>使用 dispatch barrier 可以解决上面的问题：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建操作文件的并发队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue = dispatch_queue_create(<span class=\"string\">\"File\"</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_barrier_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Write</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 dispatch_barrier_async 或 dispatch_barrier_sync 提交的任务会等待当前队列里正在执行的任务执行完毕才会执行，并且其他还没有执行的任务都必须等待提交到 dispatch barrier 的任务执行完毕之后才会开始执行。所以上面的代码中，当 Write 任务被提交的时候，如果当前队列中只有 Read1 在执行，那么 Write 会等待 Read1 执行完成之后才会执行，Read2  和 Read3 都必须等待 Write 执行完之后才会执行。另外，上面的代码中创建的是并发队列，因为如果是串行队列的话就没有必要用 dispatch barrier 了。</p>\n<h3 id=\"dispatch-semaphore-t\"><a href=\"#dispatch-semaphore-t\" class=\"headerlink\" title=\"dispatch_semaphore_t\"></a>dispatch_semaphore_t</h3><p>dispatch semaphore 是一个效率非常高的传统计数信号量，所以我们一般可以用这个来控制最大的并发数量。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建初始值为2的信号量，最大并发数量为2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> semaphore = dispatch_semaphore_create(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建并发队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue = dispatch_queue_create(<span class=\"string\">\"Semaphore\"</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建100个并发任务</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">100</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个方法会进行信号量减1的操作，并且如果信号量减1之后的结果小于0的话，该方法会造成线程的挂起直</span></span><br><span class=\"line\">    <span class=\"comment\">// 到该信号量进行加1操作才会恢复，所以在主线程要注意该方法的使用。</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意：这个方法要放在dispatch_async外面，否则系统依旧会创建超过2个线程同时来处理该调度队列</span></span><br><span class=\"line\">    <span class=\"comment\">// 的任务</span></span><br><span class=\"line\">    dispatch_semaphore_wait(semaphore, <span class=\"type\">DISPATCH_TIME_FOREVER</span>)</span><br><span class=\"line\">    dispatch_async(queue) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 释放资源，信号量增加1</span></span><br><span class=\"line\">        dispatch_semaphore_signal(semaphore)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>GCD 在 Swift3 的语法跟现在的语法不太一样了，有兴趣的可以自行去了解。在未来可能会考虑把本文章的代码都用 Swift3 的语法来重新写一下。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"GCD简介\"><a href=\"#GCD简介\" class=\"headerlink\" title=\"GCD简介\"></a>GCD简介</h2><p>GCD(Grand Central Dispatch) 是苹果提供的一套多线程编程技术。想象一下，如果让你编写一个可以高效的跑在不同计算机、不同内核的应用程序，你会怎么做呢？你要看看硬件是什么，看看有有多少个内核，想想用什么算法，想想在什么时候去切换线程…总之，你要做的东西多了去了。而 GCD 帮我们屏蔽了这些技术细节，但是如果要用好 GCD 的话，还是要多了解一些知识点。</p>\n<h2 id=\"Dispatch对象和内存管理\"><a href=\"#Dispatch对象和内存管理\" class=\"headerlink\" title=\"Dispatch对象和内存管理\"></a>Dispatch对象和内存管理</h2><p>在 Objective-C 里面，所有的 dispatch 对象都是 Objective-C 对象，所以他们同样适用引用技术的内存管理。如果你是使用 ARC 的话，dispatch 对象会向普通的 Objective-C 对象一样自动进行 retain 和 release 操作；如果你是使用 MRC，要记住使用 dispatch_retain 和 dispatch_release 来进行管理。</p>\n<h2 id=\"常用API\"><a href=\"#常用API\" class=\"headerlink\" title=\"常用API\"></a>常用API</h2><h3 id=\"dispatch-queue-t（调度队列）\"><a href=\"#dispatch-queue-t（调度队列）\" class=\"headerlink\" title=\"dispatch_queue_t（调度队列）\"></a>dispatch_queue_t（调度队列）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dispatch_queue_create</span><span class=\"params\">(label: UnsafePointer&lt;Int8&gt;, <span class=\"number\">_</span> attr: dispatch_queue_attr_t!)</span></span> -&gt; dispatch_queue_t!</span><br></pre></td></tr></table></figure>\n<p>在 GCD 中只能通过上面的 API 来创建调度队列，我们可以通过创建各种各样的 Block 形式的任务并由该调度队列来决定如何去执行这些 Block 任务。上面创建调度队列的函数需要两个参数：</p>\n<ul>\n<li>label: 这个参数是用来给你创建的调度队列进行命名的，特别是在调试的时候你可以通过该参数来判断是哪个调度队列的任务在执行。</li>\n<li>attr: 这个参数只有 DISPATCH_QUEUE_SERIAL 和 DISPATCH_QUEUE_CONCURRENT 两种值（在 Objective-C 中这个参数可以为 NULL，这个时候默认是 DISPATCH_QUEUE_SERIAL）。DISPATCH_QUEUE_SERIAL 是告诉调度队列以串行的方式去执行任务，DISPATCH_QUEUE_CONCURRENT 是告诉调度队列以并发的方式去执行任务。</li>\n</ul>\n<p>当然我们还可以通过下面的方法来获取系统已经创建好的调度队列：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取全局队列</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dispatch_get_global_queue</span><span class=\"params\">(identifier: Int, <span class=\"number\">_</span> flags: UInt)</span></span> -&gt; dispatch_queue_t!</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取主线程的com.apple.main-thread (serial)队列</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dispatch_get_main_queue</span><span class=\"params\">()</span></span> -&gt; dispatch_queue_t!</span><br></pre></td></tr></table></figure>\n<p>注意，所有 pending 状态的 Block 任务都会持有该调度队列的引用，所以我们不需要显示的去持有调度队列，而调度队列会在所有的 Block 任务都从 pending 变为 finished 之后才会被释放。</p>\n<p>总之，现在大家要知道的是我们可以把不同的 Block任务提交到调度队列，具体的细节和实现看看后面内容。</p>\n<h3 id=\"dispatch-sync和dispatch-async（同步和异步）\"><a href=\"#dispatch-sync和dispatch-async（同步和异步）\" class=\"headerlink\" title=\"dispatch_sync和dispatch_async（同步和异步）\"></a>dispatch_sync和dispatch_async（同步和异步）</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue = dispatch_queue_create(<span class=\"string\">\"com.PS.Queue\"</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建调度队列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Begin Sync\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block任务</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block Task1\"</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block任务</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block Task2\"</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"After Sync\"</span>)</span><br></pre></td></tr></table></figure>\n<p>这段代码的输出结果如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Sync</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Sync</span></span><br></pre></td></tr></table></figure>\n<p>上面的例子就是我们平常对 dispatch_sync 的用法，并且我们可以看到第一个 Block 任务执行之后才会执行第二个 Block 任务。dispatch_sync 需要等待 Block的任务执行完成之后，才能继续往后执行。但是使用 dispatch_sync 的时候，有几点是需要注意的：</p>\n<ol>\n<li><p>当调用 dispatch_sync 方法的时候，系统默认情况下会在当前线程去执行调度队列里的任务，只有在一些特殊情况下才会把调度队列的任务分配到其他线程去执行。所以我们就知道，线程和调度队列并不是一对一的关系。至于为什么默认情况下会在当前线程去执行调度队列里的任务，我的猜测是为了性能。大家想一想，dispatch_sync 会同步执行 Block任务， Block任务没有结束的情况下，后面的代码是无法执行的。基于这样一个同步的机制，GCD 还有必要先把当前线程挂起，然后去创建新线程，然后切换到新的线程去执行调度队列里的任务，然后再把线程切换到当前线程，然后再让当前线程恢复么？结论是没有必要。</p>\n</li>\n<li><p>你不能够在当前的串行调度队列的任务里面去添加新的任务到当前的调度队列里面，否则会造成死锁。这句话怎么理解呢，我们来来看看下面的例子：</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue = dispatch_queue_create(<span class=\"string\">\"com.PS.Queue\"</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Begin Execute Block Task1\"</span>)</span><br><span class=\"line\">    dispatch_sync(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block Task2\"</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"End Execute Block Task1\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例1的结果</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>为什么会 Block1 后面的 print 和 Block2 的 print 都不执行了呢？首先我们要知道被 DISPATCH_QUEUE_SERIAL 声明的调度队列是串行调度队列，串行调度队列里的任务是同时只能有一个任务在执行，并且当前任务没有执行完成，下一个任务也无法执行。上面的例子中会先输出 Block1 中的 *Begin Execute Block Task1*，然后这个时候再把 Block2 添加到同一个串行调度队列中去。这个时候的 Block1 还没有执行完成，它需要等 dispatch_sync 的 Block2 执行完成之后才能继续执行，而 Block2 又必须等待 Block1 执行完成之后才能执行，所以这个时候就造成 Block1 等着 Block2，Block2 等着 Block1 的死锁。\n\n我们再把调度队列属性改为 DISPAT_QUEUE_CONCURRENT，然后再看看执行结果是什么：\n\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue = dispatch_queue_create(<span class=\"string\">\"com.PS.Queue\"</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 同步调用</span></span><br><span class=\"line\">dispatch_sync(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Begin Execute Block Task1\"</span>)</span><br><span class=\"line\">    dispatch_sync(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block Task2\"</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"End Execute Block Task1\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例2的结果</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">End</span> <span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br></pre></td></tr></table></figure>\n\n\n被 DISPATCH_QUEUE_CONCURRENT 声明的并发调度队列就没有这种死锁的问题。并发调度队列里的任务是不会霸占资源不放的，每一个任务执行一个时间片段之后会把资源交出来给别的任务去执行。所以例2中的 Block1 虽然需要等待 Block2 执行完成之后才能继续执行，但是当 Block1 在等待的过程中，是可以把资源释放出来交给 Block2 去执行，Block2 执行完成之后 Block1 就可以继续执行了。所以，这个时候就不会造成死锁来。\n\n再来看看下面的例子会不会造成死锁：\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    dispatch_sync(dispatch_get_main_queue()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Excute Block Task\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n答案是会的。给大家一点提示，主线程的默认调度队列是串行（DISPATCH_QUEUE_SERIAL）的，viewDidLoad() 是在主线程的调度队列 com.apple.main-thread (serial) 执行的。\n\n上面的例子主要是希望大家理解串行和并发的概念，同时要明白造成死锁的原因。而要解决死锁一般可以用 DISPATCH_QUEUE_CONCURRENT 或接下来我们要讲的 dispatch_async 来解决。\n</code></pre><p>通过对 dispatch_sync 的了解，我们可以利用 dispatch_async 很快的写出异步代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue = dispatch_queue_create(<span class=\"string\">\"com.PS.Queue\"</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建调度队列</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Begin Async\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 异步调用</span></span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block Task1\"</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block2</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block Task2\"</span>)   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"After Async\"</span>)</span><br></pre></td></tr></table></figure>\n<p>这个例子的结果有好几种：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结果1</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">ExEcute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结果2</span></span><br><span class=\"line\"><span class=\"type\">Begin</span> <span class=\"type\">Async</span></span><br><span class=\"line\"><span class=\"type\">Execute</span> <span class=\"type\">Block</span> <span class=\"type\">Task1</span></span><br><span class=\"line\"><span class=\"type\">ExEcute</span> <span class=\"type\">Block</span> <span class=\"type\">Task2</span></span><br><span class=\"line\"><span class=\"type\">After</span> <span class=\"type\">Async</span></span><br></pre></td></tr></table></figure>\n<p>上面只是列出来两种可能，但实际上还有其他的可能。当我们调用 dispatch_async 的时候，它总是会在 Block 任务被提交之后马上返回，而不会傻傻的等待 Block 任务执行完成。由于上面创建的是串行调度队列，所以我们可以保证 Block1 要比 Block2 优先执行，但是 After Async 就无法确定是在 Block1 的前后还是 Block2 的前后。</p>\n<p>如果我们把上面的 DISPATCH_QUEUE_SERIAL 改成 DISPATCH_QUEUE_CONCURRENT，那我们就无法确定 After Async、Block1 和 Block2 这三者的执行顺序了。</p>\n<p>我们刚才说到用 dispatch_async 可以解决死锁的问题，那它是怎么解决的呢？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue = dispatch_queue_create(<span class=\"string\">\"com.PS.Queue\"</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)  <span class=\"comment\">// 创建串行的调度队列</span></span><br><span class=\"line\"><span class=\"comment\">// 异步调用</span></span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Block1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Begin Execute Block Task1\"</span>)</span><br><span class=\"line\">    dispatch_async(queue) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Block2</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block Task2\"</span>)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"End Execute Block Task1\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的例子会优先输出 Block1 的 <em>Begin Execute Block Task1</em> 之后，通过 dispatch_async 把 Block2 提交到串行队列里面，然后又马上返回到 Block1 去输出 <em>End Execute Block Task1</em>，这个时候的 Block1 就结束了，接下来就开始执行 Block2。所以上面的代码是不会造成死锁的，虽然上面的例子也是创建了一个串行调度队列，但是该调度队列只是保证了 Block1 要比 Block2 优先执行。</p>\n<h3 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h3><p>写过 Objective-C 的人都知道，dispatch_once 一般会被用来创建单例对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Single</span><br><span class=\"line\">+ (Single *)sharedInstance &#123;</span><br><span class=\"line\">    static Single * _single = nil;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        _single = [[Single alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return _single; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>这是由于 dispatch_once 是线程安全且只会执行一次，所以才会被用来作为单例的实现。这里需要注意的是 dispatch_once_t 必须是静态的或全局的才能保证 dispatch_once 的 Block 只会被执行一次，所以上面的代码用了 static 来修饰 dispatch_once_t。</p>\n<h3 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dispatch_apply</span><span class=\"params\">(iterations: Int, <span class=\"number\">_</span> queue: dispatch_queue_t!, <span class=\"number\">_</span> block: <span class=\"params\">(Int)</span></span></span> -&gt; <span class=\"type\">Void</span>)</span><br></pre></td></tr></table></figure>\n<p>其中的 interations 是表明要执行多少次 block，block 中的 Int 是该 Block 被执行的序号。调用这个方法的时候要注意该方法跟 dispatch_sync 一样会阻塞当前线程，所以我们需要注意在主线程中调用该方法。</p>\n<h3 id=\"dispatch-after\"><a href=\"#dispatch-after\" class=\"headerlink\" title=\"dispatch_after\"></a>dispatch_after</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dispatch_after</span><span class=\"params\">(when: dispatch_time_t, <span class=\"number\">_</span> queue: dispatch_queue_t, <span class=\"number\">_</span> block: dispatch_block_t)</span></span></span><br></pre></td></tr></table></figure>\n<p>调用这个方法的时候需要注意的是 when 这个参数，你需要通过 dispatch_time 或 dispatch_walltime 来创建。并且该方法是异步执行的，并不会阻塞当前线程。</p>\n<p>一般的写法如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_after(dispatch_time(<span class=\"type\">DISPATCH_TIME_NOW</span>, <span class=\"type\">Int64</span>(<span class=\"number\">5</span> * <span class=\"type\">NSEC_PER_SEC</span>)), queue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"5s <span class=\"subst\">\\(NSThread.currentThread()</span>)\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"dispatch-group-t\"><a href=\"#dispatch-group-t\" class=\"headerlink\" title=\"dispatch_group_t\"></a>dispatch_group_t</h3><p>dispatch_group_t 是用来做聚合同步的，它可以用来跟踪你提交的所有任务（即使是在不同的调度队列也可以）的完成状态。</p>\n<p>接下来我们来看看 dispatch group 的一些常见用法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建dispatch_group_t对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> group = dispatch_group_create()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建串行队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> serialQueue = dispatch_queue_create(<span class=\"string\">\"Serial Queue\"</span>, <span class=\"type\">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提交两个Block任务到serialQueue，同时关联serialQueue和group的关系</span></span><br><span class=\"line\">dispatch_group_async(group, serialQueue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block1 within Serial Queue\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_group_async(group, serialQueue) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block2 within Serial Queue\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并发队列，并提交Block任务，同时关联该并发队列和group的关系</span></span><br><span class=\"line\">dispatch_group_async(group, dispatch_queue_create(<span class=\"string\">\"Concurrent Queue\"</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Execute Block within Concurrent Queue\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的代码只有当前面被关联到group的所有任务完成之后才会被触发</span></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_queue_create(<span class=\"string\">\"Finished\"</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Finished\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，关联到 group 的方法只有 dispatch_group_async 而没有 dispatch_group_sync。</p>\n<p>但是还有另外一种方法可以让我们关联一个普通的任务：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建dispatch_group_t对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> group = dispatch_group_create()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用dispatch_group_enter和dispatch_group_leave的话，我们不需要调用</span></span><br><span class=\"line\"><span class=\"comment\">// dispatch_group_async也能关联一个任务到group上</span></span><br><span class=\"line\">dispatch_group_enter(group)</span><br><span class=\"line\"><span class=\"keyword\">self</span>.executeTask &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行代码</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_group_leave(group)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的代码只有当前面被关联到group的所有任务完成之后才会被触发</span></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_queue_create(<span class=\"string\">\"Finished\"</span>)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Finished\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 dispatch_group_enter 和 dispatch_group_leave 的时候，它们必须成双成对出现，否则 dispatch_group_notify 是不会被调用的。</p>\n<p>接下来我们还要了解一下 dispatch_group_wait：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dispatch_group_wait</span><span class=\"params\">(group: dispatch_group_t, <span class=\"number\">_</span> timeout: dispatch_time_t)</span></span> -&gt; <span class=\"type\">Int</span></span><br></pre></td></tr></table></figure>\n<p>dispatch_group_wait 可以指定一个 timeout 的参数，当 group 的任务没有在规定的时间内完成，它会返回一个非零的值，当 group 的任务能够在规定的时间内完成就返回0。同时，大家要注意这个方法会挂起当前线程，所以在主线程的时候要慎重使用该方法。</p>\n<h3 id=\"dispatch-barrier-t\"><a href=\"#dispatch-barrier-t\" class=\"headerlink\" title=\"dispatch_barrier_t\"></a>dispatch_barrier_t</h3><p>我们先来试想一个场景，假如现在有多个线程要去读取一份文件的内容，同时又有其他线程想要去更新该文件的内容，那么就有可能会发生你读错文件内容的现象。这个时候我们可以把所有读写操作都放到我们之前学习的串行队列去执行，但是我们都知道同时有多个线程去读取一份文件内容是没有问题的。</p>\n<p>使用 dispatch barrier 可以解决上面的问题：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建操作文件的并发队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue = dispatch_queue_create(<span class=\"string\">\"File\"</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_barrier_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Write</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dispatch_async(queue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Read3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 dispatch_barrier_async 或 dispatch_barrier_sync 提交的任务会等待当前队列里正在执行的任务执行完毕才会执行，并且其他还没有执行的任务都必须等待提交到 dispatch barrier 的任务执行完毕之后才会开始执行。所以上面的代码中，当 Write 任务被提交的时候，如果当前队列中只有 Read1 在执行，那么 Write 会等待 Read1 执行完成之后才会执行，Read2  和 Read3 都必须等待 Write 执行完之后才会执行。另外，上面的代码中创建的是并发队列，因为如果是串行队列的话就没有必要用 dispatch barrier 了。</p>\n<h3 id=\"dispatch-semaphore-t\"><a href=\"#dispatch-semaphore-t\" class=\"headerlink\" title=\"dispatch_semaphore_t\"></a>dispatch_semaphore_t</h3><p>dispatch semaphore 是一个效率非常高的传统计数信号量，所以我们一般可以用这个来控制最大的并发数量。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建初始值为2的信号量，最大并发数量为2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> semaphore = dispatch_semaphore_create(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建并发队列</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> queue = dispatch_queue_create(<span class=\"string\">\"Semaphore\"</span>, <span class=\"type\">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建100个并发任务</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">100</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个方法会进行信号量减1的操作，并且如果信号量减1之后的结果小于0的话，该方法会造成线程的挂起直</span></span><br><span class=\"line\">    <span class=\"comment\">// 到该信号量进行加1操作才会恢复，所以在主线程要注意该方法的使用。</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意：这个方法要放在dispatch_async外面，否则系统依旧会创建超过2个线程同时来处理该调度队列</span></span><br><span class=\"line\">    <span class=\"comment\">// 的任务</span></span><br><span class=\"line\">    dispatch_semaphore_wait(semaphore, <span class=\"type\">DISPATCH_TIME_FOREVER</span>)</span><br><span class=\"line\">    dispatch_async(queue) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 释放资源，信号量增加1</span></span><br><span class=\"line\">        dispatch_semaphore_signal(semaphore)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>GCD 在 Swift3 的语法跟现在的语法不太一样了，有兴趣的可以自行去了解。在未来可能会考虑把本文章的代码都用 Swift3 的语法来重新写一下。</p>\n"},{"layout":"post","title":"计算机的启动过程","subtitle":"记录自己的理解","author":"帕帕","date":"2017-09-05T15:30:56.000Z","_content":"\n一、启动\n\n1. 启动电源\n2. CPU(只能执行指令，不能保存指令，它的指令全存在内存中)去内存地址 0xFFFFFFF0 找到第一条需要执行的指令（跳转指令）\n3. 跳转到 BIOS 系统，运行 BIOS 的一大堆指令，只要是做系统自检（硬盘、内存、显卡等）。如果有问题会通过喇叭声音的长短组合进行提示\n4. BIOS 在自检之后生成中断向量表\n5. 当 BIOS 的所有工作都完成之后，会给 CPU 发送一条中断指令，比如 `int 0x19`\n6. CPU 接到中断指令之后就去中断向量表找到第 19 号对应的一大堆指令\n7. 这堆指令主要是把磁盘的第一扇区（磁盘最开始的 512 Byte）的数据运到内存中，之后 CPU 就开始执行这些指令\n8. 这些精巧的指令会把 OS(操作系统) 从磁盘运到内存中\n\n二、运行\n\n1. OS 进入内存之后，立刻就是老大\n2. OS 告诉 CPU 开始运行 A 程序\n3. CPU 会去硬盘把 A 程序装载到内存中，CPU 才能执行 A 程序的指令\n4. 如果此时 OS 告诉 CPU 去执行 B 程序，那么 CPU 会保存好现场，然后去执行 B 程序的指令\n\n三、缓存\n\n1. 因为硬盘的读写速度太慢了，所以都需要先把硬盘的数据装载到内存中之后，CPU 再去内存取指令来执行\n2. 但是内存的读写速度依旧还是要比 CPU 慢，一旦指令多起来之后内存的读写速度也会让 CPU 觉得受不了\n3. 经过一段时间的运行之后，我们会发现 CPU 去内存取指令是有规律的，这个规律叫**程序的局部性原理**。CPU 在访问一个内存位置以后过不多久还会多次访问；一个内存位置被访问了， 附近的位置很快也会访问到。\n4. CPU 需要读写指令和数据的时候直接从缓存要，如果缓存没有才会去找内存\n5. 局部性原理在程序切换之后，缓存就会失效。因为两个程序之间没什么联系，局部性原理就不起作用了，所以需要重建缓存。\n\n四、流水线\n\n1. CPU 在计算的过程分成四个步骤：从内存读取指令 - 翻译指令 - 执行 - 把结果写回内存（该步骤有时候没有）\n2. CPU 可以同时执行上面四个步骤，比如：\n\n```\n读取指令 A\n读取指令 B - 翻译指令 A\n读取指令 C - 翻译指令 B - 执行指令 C\n读取指令 D - 翻译指令 C - 执行指令 B - 把指令 A 的结果写回内存\n```\n\n---\n参考文献：\n\n1. https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513017&idx=1&sn=5550ee714abd36d0b580713f673e670b&scene=21#wechat_redirect\n\n\n","source":"_posts/启动.md","raw":"---\nlayout: post \ntitle: 计算机的启动过程\nsubtitle: 记录自己的理解\nauthor: 帕帕\ndate: 2017-09-05 15:30:56 +0800\ncategories: other \ntag: other\n---\n\n一、启动\n\n1. 启动电源\n2. CPU(只能执行指令，不能保存指令，它的指令全存在内存中)去内存地址 0xFFFFFFF0 找到第一条需要执行的指令（跳转指令）\n3. 跳转到 BIOS 系统，运行 BIOS 的一大堆指令，只要是做系统自检（硬盘、内存、显卡等）。如果有问题会通过喇叭声音的长短组合进行提示\n4. BIOS 在自检之后生成中断向量表\n5. 当 BIOS 的所有工作都完成之后，会给 CPU 发送一条中断指令，比如 `int 0x19`\n6. CPU 接到中断指令之后就去中断向量表找到第 19 号对应的一大堆指令\n7. 这堆指令主要是把磁盘的第一扇区（磁盘最开始的 512 Byte）的数据运到内存中，之后 CPU 就开始执行这些指令\n8. 这些精巧的指令会把 OS(操作系统) 从磁盘运到内存中\n\n二、运行\n\n1. OS 进入内存之后，立刻就是老大\n2. OS 告诉 CPU 开始运行 A 程序\n3. CPU 会去硬盘把 A 程序装载到内存中，CPU 才能执行 A 程序的指令\n4. 如果此时 OS 告诉 CPU 去执行 B 程序，那么 CPU 会保存好现场，然后去执行 B 程序的指令\n\n三、缓存\n\n1. 因为硬盘的读写速度太慢了，所以都需要先把硬盘的数据装载到内存中之后，CPU 再去内存取指令来执行\n2. 但是内存的读写速度依旧还是要比 CPU 慢，一旦指令多起来之后内存的读写速度也会让 CPU 觉得受不了\n3. 经过一段时间的运行之后，我们会发现 CPU 去内存取指令是有规律的，这个规律叫**程序的局部性原理**。CPU 在访问一个内存位置以后过不多久还会多次访问；一个内存位置被访问了， 附近的位置很快也会访问到。\n4. CPU 需要读写指令和数据的时候直接从缓存要，如果缓存没有才会去找内存\n5. 局部性原理在程序切换之后，缓存就会失效。因为两个程序之间没什么联系，局部性原理就不起作用了，所以需要重建缓存。\n\n四、流水线\n\n1. CPU 在计算的过程分成四个步骤：从内存读取指令 - 翻译指令 - 执行 - 把结果写回内存（该步骤有时候没有）\n2. CPU 可以同时执行上面四个步骤，比如：\n\n```\n读取指令 A\n读取指令 B - 翻译指令 A\n读取指令 C - 翻译指令 B - 执行指令 C\n读取指令 D - 翻译指令 C - 执行指令 B - 把指令 A 的结果写回内存\n```\n\n---\n参考文献：\n\n1. https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513017&idx=1&sn=5550ee714abd36d0b580713f673e670b&scene=21#wechat_redirect\n\n\n","slug":"启动","published":1,"updated":"2018-03-06T07:07:33.154Z","_id":"cjei470su000nu5vbvr0nefky","comments":1,"photos":[],"link":"","content":"<p>一、启动</p>\n<ol>\n<li>启动电源</li>\n<li>CPU(只能执行指令，不能保存指令，它的指令全存在内存中)去内存地址 0xFFFFFFF0 找到第一条需要执行的指令（跳转指令）</li>\n<li>跳转到 BIOS 系统，运行 BIOS 的一大堆指令，只要是做系统自检（硬盘、内存、显卡等）。如果有问题会通过喇叭声音的长短组合进行提示</li>\n<li>BIOS 在自检之后生成中断向量表</li>\n<li>当 BIOS 的所有工作都完成之后，会给 CPU 发送一条中断指令，比如 <code>int 0x19</code></li>\n<li>CPU 接到中断指令之后就去中断向量表找到第 19 号对应的一大堆指令</li>\n<li>这堆指令主要是把磁盘的第一扇区（磁盘最开始的 512 Byte）的数据运到内存中，之后 CPU 就开始执行这些指令</li>\n<li>这些精巧的指令会把 OS(操作系统) 从磁盘运到内存中</li>\n</ol>\n<p>二、运行</p>\n<ol>\n<li>OS 进入内存之后，立刻就是老大</li>\n<li>OS 告诉 CPU 开始运行 A 程序</li>\n<li>CPU 会去硬盘把 A 程序装载到内存中，CPU 才能执行 A 程序的指令</li>\n<li>如果此时 OS 告诉 CPU 去执行 B 程序，那么 CPU 会保存好现场，然后去执行 B 程序的指令</li>\n</ol>\n<p>三、缓存</p>\n<ol>\n<li>因为硬盘的读写速度太慢了，所以都需要先把硬盘的数据装载到内存中之后，CPU 再去内存取指令来执行</li>\n<li>但是内存的读写速度依旧还是要比 CPU 慢，一旦指令多起来之后内存的读写速度也会让 CPU 觉得受不了</li>\n<li>经过一段时间的运行之后，我们会发现 CPU 去内存取指令是有规律的，这个规律叫<strong>程序的局部性原理</strong>。CPU 在访问一个内存位置以后过不多久还会多次访问；一个内存位置被访问了， 附近的位置很快也会访问到。</li>\n<li>CPU 需要读写指令和数据的时候直接从缓存要，如果缓存没有才会去找内存</li>\n<li>局部性原理在程序切换之后，缓存就会失效。因为两个程序之间没什么联系，局部性原理就不起作用了，所以需要重建缓存。</li>\n</ol>\n<p>四、流水线</p>\n<ol>\n<li>CPU 在计算的过程分成四个步骤：从内存读取指令 - 翻译指令 - 执行 - 把结果写回内存（该步骤有时候没有）</li>\n<li>CPU 可以同时执行上面四个步骤，比如：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">读取指令 A</span><br><span class=\"line\">读取指令 B - 翻译指令 A</span><br><span class=\"line\">读取指令 C - 翻译指令 B - 执行指令 C</span><br><span class=\"line\">读取指令 D - 翻译指令 C - 执行指令 B - 把指令 A 的结果写回内存</span><br></pre></td></tr></table></figure>\n<hr>\n<p>参考文献：</p>\n<ol>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513017&amp;idx=1&amp;sn=5550ee714abd36d0b580713f673e670b&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513017&amp;idx=1&amp;sn=5550ee714abd36d0b580713f673e670b&amp;scene=21#wechat_redirect</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>一、启动</p>\n<ol>\n<li>启动电源</li>\n<li>CPU(只能执行指令，不能保存指令，它的指令全存在内存中)去内存地址 0xFFFFFFF0 找到第一条需要执行的指令（跳转指令）</li>\n<li>跳转到 BIOS 系统，运行 BIOS 的一大堆指令，只要是做系统自检（硬盘、内存、显卡等）。如果有问题会通过喇叭声音的长短组合进行提示</li>\n<li>BIOS 在自检之后生成中断向量表</li>\n<li>当 BIOS 的所有工作都完成之后，会给 CPU 发送一条中断指令，比如 <code>int 0x19</code></li>\n<li>CPU 接到中断指令之后就去中断向量表找到第 19 号对应的一大堆指令</li>\n<li>这堆指令主要是把磁盘的第一扇区（磁盘最开始的 512 Byte）的数据运到内存中，之后 CPU 就开始执行这些指令</li>\n<li>这些精巧的指令会把 OS(操作系统) 从磁盘运到内存中</li>\n</ol>\n<p>二、运行</p>\n<ol>\n<li>OS 进入内存之后，立刻就是老大</li>\n<li>OS 告诉 CPU 开始运行 A 程序</li>\n<li>CPU 会去硬盘把 A 程序装载到内存中，CPU 才能执行 A 程序的指令</li>\n<li>如果此时 OS 告诉 CPU 去执行 B 程序，那么 CPU 会保存好现场，然后去执行 B 程序的指令</li>\n</ol>\n<p>三、缓存</p>\n<ol>\n<li>因为硬盘的读写速度太慢了，所以都需要先把硬盘的数据装载到内存中之后，CPU 再去内存取指令来执行</li>\n<li>但是内存的读写速度依旧还是要比 CPU 慢，一旦指令多起来之后内存的读写速度也会让 CPU 觉得受不了</li>\n<li>经过一段时间的运行之后，我们会发现 CPU 去内存取指令是有规律的，这个规律叫<strong>程序的局部性原理</strong>。CPU 在访问一个内存位置以后过不多久还会多次访问；一个内存位置被访问了， 附近的位置很快也会访问到。</li>\n<li>CPU 需要读写指令和数据的时候直接从缓存要，如果缓存没有才会去找内存</li>\n<li>局部性原理在程序切换之后，缓存就会失效。因为两个程序之间没什么联系，局部性原理就不起作用了，所以需要重建缓存。</li>\n</ol>\n<p>四、流水线</p>\n<ol>\n<li>CPU 在计算的过程分成四个步骤：从内存读取指令 - 翻译指令 - 执行 - 把结果写回内存（该步骤有时候没有）</li>\n<li>CPU 可以同时执行上面四个步骤，比如：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">读取指令 A</span><br><span class=\"line\">读取指令 B - 翻译指令 A</span><br><span class=\"line\">读取指令 C - 翻译指令 B - 执行指令 C</span><br><span class=\"line\">读取指令 D - 翻译指令 C - 执行指令 B - 把指令 A 的结果写回内存</span><br></pre></td></tr></table></figure>\n<hr>\n<p>参考文献：</p>\n<ol>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513017&amp;idx=1&amp;sn=5550ee714abd36d0b580713f673e670b&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513017&amp;idx=1&amp;sn=5550ee714abd36d0b580713f673e670b&amp;scene=21#wechat_redirect</a></li>\n</ol>\n"},{"layout":"post","title":"redux 之页面跳转","subtitle":"关于 React Native 的页面跳转逻辑的一点思考","author":"帕帕","date":"2018-02-26T17:48:56.000Z","_content":"\n最近正在用 React Native 重构整个项目，我们用了 **[react-native-navigation](https://github.com/krystofcelba/react-native-navigation#rn52)** 这个库来作为项目的导航控制器。\n所以，我们平常会把页面跳转逻辑的时候放在 Screen 里面的，比如:\n\n```\nclass FirstScreen extends React.Component {\n    \n    // 点击事件\n    _someAction = () => {\n        this.props.navigator.push({\n          screen: 'example.SecondScreen',\n        });\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n一般情况下，上面的写法没有问题。但是直到我们碰到这样一个需求的时候就抓瞎了：点击一个 PDF 文件，如果 PDF 文件没有下载就先去下载，下载完成之后自动跳转到 PDF 阅读器。由于用了 redux 之后，我们就增加一个 finished 的 state 来判断是否已经下载完成。示例代码如下：\n\n```\nclass ExampleScreen extends React.Component {\n\n    componentWillReceiveProps = (nextProps) => {\n        // 这里判断下载状态是否已完成，完成的话就去跳转\n        if (nextProps.finished === true) {\n            // 这里需要重置一下状态，不然其他 state 发生变化会多次触发页面的跳转\n            this.props.dispatch(resetFinished());\n            this.props.navigator.push({\n              screen: 'example.PDFScreen',\n            });\n        }\n    }\n    \n    // 点击事件\n    _someAction = () => {\n        // openPDF() 这个 action 会自动去下载 PDF 文件，然后修改 finished 的状态\n        this.props.dispatch(openPDF());\n    }\n    \n    render = () => {\n        ...\n    }\n}\n\nconst mapStateToProps = state => {\n  return {\n    finished: state.finished\n  }\n};\n\nexport default connect(mapStateToProps)(ExampleScreen);\n```\n\n上面的做法是可以实现我们的需求，但是这种写法很蛋疼。因为当你在调用用 openPDF() 的时候，你以为后面的事不需要你操心，然后这个时候有人告诉你还需要在其他地方增加一个中间状态去补充 openPDF() 的后续逻辑处理。\n\n经过讨论之后，我们决定改成用 callback 的方式来实现：\n\n```\nclass ExampleScreen extends React.Component {\n\n    // 点击事件\n    _someAction = () => {\n        // openPDF() 是一个异步 action\n        this.props.dispatch(openPDF(callback: () => {\n            this.props.navigator.push({\n              screen: 'example.PDFScreen',\n            });\n        }));\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n使用 callback 的好处就是去掉了一个烦人的中间状态，并且从阅读体验来说很容易让读者明白这个点击事件在干什么。但是在 redux 的 action 方法中增加一个 callback 的调用，看起来也有点不伦不类的。虽然我认为 callback 和其他参数具有相同的法律地位。\n\n其实最好的实现是，这个点击事件应该连页面的跳转逻辑也不需要处理：\n\n```\nclass ExampleScreen extends React.Component {\n\n    // 点击事件，这个事件只做一件事就是去 dispatch 一个 openPDF() 的 action\n    _someAction = () => {\n        this.props.dispatch(openPDF());\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n像上面这种实现，我们也就只能在 openPDF() 里动手脚了：\n\n```\n// action.js\nexport const openPDF = await () => {\n    return dispatch => {\n        // 异步下载 PDF\n        async downloadPDF();\n        // 完成之后通过 router 去实现页面跳转\n        dispatch(openRouter('PDFScreen'));\n    };\n}\n```\n\n> 这里就不再详细说 router 的实现细节了，因为网上有很多现成的资料。（PS: 主要是我也还没看到这一块）\n\n从页面（Screen）的角度来说，我认为这样的处理是最合适的。因为 Screen 只需要关注本页面的 state 和 action，至于跳转的逻辑交给后面的 action 来处理是最好的。\n\n\n\n\n","source":"_posts/redux-之页面跳转.md","raw":"---\nlayout: post \ntitle: redux 之页面跳转\nsubtitle: 关于 React Native 的页面跳转逻辑的一点思考\nauthor: 帕帕\ndate: 2018-02-26 17:48:56 +0800\ncategories: React\ntag: React\n---\n\n最近正在用 React Native 重构整个项目，我们用了 **[react-native-navigation](https://github.com/krystofcelba/react-native-navigation#rn52)** 这个库来作为项目的导航控制器。\n所以，我们平常会把页面跳转逻辑的时候放在 Screen 里面的，比如:\n\n```\nclass FirstScreen extends React.Component {\n    \n    // 点击事件\n    _someAction = () => {\n        this.props.navigator.push({\n          screen: 'example.SecondScreen',\n        });\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n一般情况下，上面的写法没有问题。但是直到我们碰到这样一个需求的时候就抓瞎了：点击一个 PDF 文件，如果 PDF 文件没有下载就先去下载，下载完成之后自动跳转到 PDF 阅读器。由于用了 redux 之后，我们就增加一个 finished 的 state 来判断是否已经下载完成。示例代码如下：\n\n```\nclass ExampleScreen extends React.Component {\n\n    componentWillReceiveProps = (nextProps) => {\n        // 这里判断下载状态是否已完成，完成的话就去跳转\n        if (nextProps.finished === true) {\n            // 这里需要重置一下状态，不然其他 state 发生变化会多次触发页面的跳转\n            this.props.dispatch(resetFinished());\n            this.props.navigator.push({\n              screen: 'example.PDFScreen',\n            });\n        }\n    }\n    \n    // 点击事件\n    _someAction = () => {\n        // openPDF() 这个 action 会自动去下载 PDF 文件，然后修改 finished 的状态\n        this.props.dispatch(openPDF());\n    }\n    \n    render = () => {\n        ...\n    }\n}\n\nconst mapStateToProps = state => {\n  return {\n    finished: state.finished\n  }\n};\n\nexport default connect(mapStateToProps)(ExampleScreen);\n```\n\n上面的做法是可以实现我们的需求，但是这种写法很蛋疼。因为当你在调用用 openPDF() 的时候，你以为后面的事不需要你操心，然后这个时候有人告诉你还需要在其他地方增加一个中间状态去补充 openPDF() 的后续逻辑处理。\n\n经过讨论之后，我们决定改成用 callback 的方式来实现：\n\n```\nclass ExampleScreen extends React.Component {\n\n    // 点击事件\n    _someAction = () => {\n        // openPDF() 是一个异步 action\n        this.props.dispatch(openPDF(callback: () => {\n            this.props.navigator.push({\n              screen: 'example.PDFScreen',\n            });\n        }));\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n使用 callback 的好处就是去掉了一个烦人的中间状态，并且从阅读体验来说很容易让读者明白这个点击事件在干什么。但是在 redux 的 action 方法中增加一个 callback 的调用，看起来也有点不伦不类的。虽然我认为 callback 和其他参数具有相同的法律地位。\n\n其实最好的实现是，这个点击事件应该连页面的跳转逻辑也不需要处理：\n\n```\nclass ExampleScreen extends React.Component {\n\n    // 点击事件，这个事件只做一件事就是去 dispatch 一个 openPDF() 的 action\n    _someAction = () => {\n        this.props.dispatch(openPDF());\n    }\n    \n    render = () => {\n        ...\n    }\n}\n```\n\n像上面这种实现，我们也就只能在 openPDF() 里动手脚了：\n\n```\n// action.js\nexport const openPDF = await () => {\n    return dispatch => {\n        // 异步下载 PDF\n        async downloadPDF();\n        // 完成之后通过 router 去实现页面跳转\n        dispatch(openRouter('PDFScreen'));\n    };\n}\n```\n\n> 这里就不再详细说 router 的实现细节了，因为网上有很多现成的资料。（PS: 主要是我也还没看到这一块）\n\n从页面（Screen）的角度来说，我认为这样的处理是最合适的。因为 Screen 只需要关注本页面的 state 和 action，至于跳转的逻辑交给后面的 action 来处理是最好的。\n\n\n\n\n","slug":"redux-之页面跳转","published":1,"updated":"2018-03-06T07:07:13.186Z","comments":1,"photos":[],"link":"","_id":"cjei470sy000qu5vbc3471g1f","content":"<p>最近正在用 React Native 重构整个项目，我们用了 <strong><a href=\"https://github.com/krystofcelba/react-native-navigation#rn52\" target=\"_blank\" rel=\"noopener\">react-native-navigation</a></strong> 这个库来作为项目的导航控制器。<br>所以，我们平常会把页面跳转逻辑的时候放在 Screen 里面的，比如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class FirstScreen extends React.Component &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 点击事件</span><br><span class=\"line\">    _someAction = () =&gt; &#123;</span><br><span class=\"line\">        this.props.navigator.push(&#123;</span><br><span class=\"line\">          screen: &apos;example.SecondScreen&apos;,</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = () =&gt; &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般情况下，上面的写法没有问题。但是直到我们碰到这样一个需求的时候就抓瞎了：点击一个 PDF 文件，如果 PDF 文件没有下载就先去下载，下载完成之后自动跳转到 PDF 阅读器。由于用了 redux 之后，我们就增加一个 finished 的 state 来判断是否已经下载完成。示例代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ExampleScreen extends React.Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillReceiveProps = (nextProps) =&gt; &#123;</span><br><span class=\"line\">        // 这里判断下载状态是否已完成，完成的话就去跳转</span><br><span class=\"line\">        if (nextProps.finished === true) &#123;</span><br><span class=\"line\">            // 这里需要重置一下状态，不然其他 state 发生变化会多次触发页面的跳转</span><br><span class=\"line\">            this.props.dispatch(resetFinished());</span><br><span class=\"line\">            this.props.navigator.push(&#123;</span><br><span class=\"line\">              screen: &apos;example.PDFScreen&apos;,</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 点击事件</span><br><span class=\"line\">    _someAction = () =&gt; &#123;</span><br><span class=\"line\">        // openPDF() 这个 action 会自动去下载 PDF 文件，然后修改 finished 的状态</span><br><span class=\"line\">        this.props.dispatch(openPDF());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = () =&gt; &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const mapStateToProps = state =&gt; &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    finished: state.finished</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default connect(mapStateToProps)(ExampleScreen);</span><br></pre></td></tr></table></figure>\n<p>上面的做法是可以实现我们的需求，但是这种写法很蛋疼。因为当你在调用用 openPDF() 的时候，你以为后面的事不需要你操心，然后这个时候有人告诉你还需要在其他地方增加一个中间状态去补充 openPDF() 的后续逻辑处理。</p>\n<p>经过讨论之后，我们决定改成用 callback 的方式来实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ExampleScreen extends React.Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 点击事件</span><br><span class=\"line\">    _someAction = () =&gt; &#123;</span><br><span class=\"line\">        // openPDF() 是一个异步 action</span><br><span class=\"line\">        this.props.dispatch(openPDF(callback: () =&gt; &#123;</span><br><span class=\"line\">            this.props.navigator.push(&#123;</span><br><span class=\"line\">              screen: &apos;example.PDFScreen&apos;,</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = () =&gt; &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 callback 的好处就是去掉了一个烦人的中间状态，并且从阅读体验来说很容易让读者明白这个点击事件在干什么。但是在 redux 的 action 方法中增加一个 callback 的调用，看起来也有点不伦不类的。虽然我认为 callback 和其他参数具有相同的法律地位。</p>\n<p>其实最好的实现是，这个点击事件应该连页面的跳转逻辑也不需要处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ExampleScreen extends React.Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 点击事件，这个事件只做一件事就是去 dispatch 一个 openPDF() 的 action</span><br><span class=\"line\">    _someAction = () =&gt; &#123;</span><br><span class=\"line\">        this.props.dispatch(openPDF());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = () =&gt; &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>像上面这种实现，我们也就只能在 openPDF() 里动手脚了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// action.js</span><br><span class=\"line\">export const openPDF = await () =&gt; &#123;</span><br><span class=\"line\">    return dispatch =&gt; &#123;</span><br><span class=\"line\">        // 异步下载 PDF</span><br><span class=\"line\">        async downloadPDF();</span><br><span class=\"line\">        // 完成之后通过 router 去实现页面跳转</span><br><span class=\"line\">        dispatch(openRouter(&apos;PDFScreen&apos;));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里就不再详细说 router 的实现细节了，因为网上有很多现成的资料。（PS: 主要是我也还没看到这一块）</p>\n</blockquote>\n<p>从页面（Screen）的角度来说，我认为这样的处理是最合适的。因为 Screen 只需要关注本页面的 state 和 action，至于跳转的逻辑交给后面的 action 来处理是最好的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近正在用 React Native 重构整个项目，我们用了 <strong><a href=\"https://github.com/krystofcelba/react-native-navigation#rn52\" target=\"_blank\" rel=\"noopener\">react-native-navigation</a></strong> 这个库来作为项目的导航控制器。<br>所以，我们平常会把页面跳转逻辑的时候放在 Screen 里面的，比如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class FirstScreen extends React.Component &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 点击事件</span><br><span class=\"line\">    _someAction = () =&gt; &#123;</span><br><span class=\"line\">        this.props.navigator.push(&#123;</span><br><span class=\"line\">          screen: &apos;example.SecondScreen&apos;,</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = () =&gt; &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般情况下，上面的写法没有问题。但是直到我们碰到这样一个需求的时候就抓瞎了：点击一个 PDF 文件，如果 PDF 文件没有下载就先去下载，下载完成之后自动跳转到 PDF 阅读器。由于用了 redux 之后，我们就增加一个 finished 的 state 来判断是否已经下载完成。示例代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ExampleScreen extends React.Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillReceiveProps = (nextProps) =&gt; &#123;</span><br><span class=\"line\">        // 这里判断下载状态是否已完成，完成的话就去跳转</span><br><span class=\"line\">        if (nextProps.finished === true) &#123;</span><br><span class=\"line\">            // 这里需要重置一下状态，不然其他 state 发生变化会多次触发页面的跳转</span><br><span class=\"line\">            this.props.dispatch(resetFinished());</span><br><span class=\"line\">            this.props.navigator.push(&#123;</span><br><span class=\"line\">              screen: &apos;example.PDFScreen&apos;,</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 点击事件</span><br><span class=\"line\">    _someAction = () =&gt; &#123;</span><br><span class=\"line\">        // openPDF() 这个 action 会自动去下载 PDF 文件，然后修改 finished 的状态</span><br><span class=\"line\">        this.props.dispatch(openPDF());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = () =&gt; &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const mapStateToProps = state =&gt; &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    finished: state.finished</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default connect(mapStateToProps)(ExampleScreen);</span><br></pre></td></tr></table></figure>\n<p>上面的做法是可以实现我们的需求，但是这种写法很蛋疼。因为当你在调用用 openPDF() 的时候，你以为后面的事不需要你操心，然后这个时候有人告诉你还需要在其他地方增加一个中间状态去补充 openPDF() 的后续逻辑处理。</p>\n<p>经过讨论之后，我们决定改成用 callback 的方式来实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ExampleScreen extends React.Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 点击事件</span><br><span class=\"line\">    _someAction = () =&gt; &#123;</span><br><span class=\"line\">        // openPDF() 是一个异步 action</span><br><span class=\"line\">        this.props.dispatch(openPDF(callback: () =&gt; &#123;</span><br><span class=\"line\">            this.props.navigator.push(&#123;</span><br><span class=\"line\">              screen: &apos;example.PDFScreen&apos;,</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = () =&gt; &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 callback 的好处就是去掉了一个烦人的中间状态，并且从阅读体验来说很容易让读者明白这个点击事件在干什么。但是在 redux 的 action 方法中增加一个 callback 的调用，看起来也有点不伦不类的。虽然我认为 callback 和其他参数具有相同的法律地位。</p>\n<p>其实最好的实现是，这个点击事件应该连页面的跳转逻辑也不需要处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ExampleScreen extends React.Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 点击事件，这个事件只做一件事就是去 dispatch 一个 openPDF() 的 action</span><br><span class=\"line\">    _someAction = () =&gt; &#123;</span><br><span class=\"line\">        this.props.dispatch(openPDF());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    render = () =&gt; &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>像上面这种实现，我们也就只能在 openPDF() 里动手脚了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// action.js</span><br><span class=\"line\">export const openPDF = await () =&gt; &#123;</span><br><span class=\"line\">    return dispatch =&gt; &#123;</span><br><span class=\"line\">        // 异步下载 PDF</span><br><span class=\"line\">        async downloadPDF();</span><br><span class=\"line\">        // 完成之后通过 router 去实现页面跳转</span><br><span class=\"line\">        dispatch(openRouter(&apos;PDFScreen&apos;));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里就不再详细说 router 的实现细节了，因为网上有很多现成的资料。（PS: 主要是我也还没看到这一块）</p>\n</blockquote>\n<p>从页面（Screen）的角度来说，我认为这样的处理是最合适的。因为 Screen 只需要关注本页面的 state 和 action，至于跳转的逻辑交给后面的 action 来处理是最好的。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjei470ru0000u5vbks7wgwm2","category_id":"cjei470s30002u5vbxcftd4yq","_id":"cjei470sm000du5vbsbbu9xho"},{"post_id":"cjei470sh000au5vb5suebogh","category_id":"cjei470s30002u5vbxcftd4yq","_id":"cjei470ss000ju5vbiumiqi8z"},{"post_id":"cjei470s00001u5vb5jdyqmnu","category_id":"cjei470s30002u5vbxcftd4yq","_id":"cjei470sx000ou5vb7m2a0y1a"},{"post_id":"cjei470sk000bu5vbz0sa4dl7","category_id":"cjei470s30002u5vbxcftd4yq","_id":"cjei470t0000ru5vbv3qxwbqs"},{"post_id":"cjei470sn000gu5vbg148h2u0","category_id":"cjei470sl000cu5vb5g4kajds","_id":"cjei470t2000vu5vb0o9j1wdi"},{"post_id":"cjei470s60004u5vbwmhenkn7","category_id":"cjei470sl000cu5vb5g4kajds","_id":"cjei470t3000xu5vbque5azpf"},{"post_id":"cjei470sp000iu5vbs0vg6tgb","category_id":"cjei470sl000cu5vb5g4kajds","_id":"cjei470t40011u5vb5m51h29f"},{"post_id":"cjei470s90005u5vb8ivr8y63","category_id":"cjei470sl000cu5vb5g4kajds","_id":"cjei470t40013u5vb3a1oo44n"},{"post_id":"cjei470sc0006u5vbhk35gkur","category_id":"cjei470sl000cu5vb5g4kajds","_id":"cjei470t50016u5vbmc6bwi9y"},{"post_id":"cjei470su000nu5vbvr0nefky","category_id":"cjei470t3000yu5vbuncm8asd","_id":"cjei470t60018u5vb2yw1tgvp"},{"post_id":"cjei470sy000qu5vbc3471g1f","category_id":"cjei470t50014u5vb2n8z04ma","_id":"cjei470t8001au5vb5wogwd7r"}],"PostTag":[{"post_id":"cjei470ru0000u5vbks7wgwm2","tag_id":"cjei470s50003u5vb44na5as7","_id":"cjei470sh0009u5vbshw2863y"},{"post_id":"cjei470sh000au5vb5suebogh","tag_id":"cjei470s50003u5vb44na5as7","_id":"cjei470sn000fu5vbagxz0hj6"},{"post_id":"cjei470s00001u5vb5jdyqmnu","tag_id":"cjei470s50003u5vb44na5as7","_id":"cjei470sp000hu5vb2svd1hb7"},{"post_id":"cjei470sk000bu5vbz0sa4dl7","tag_id":"cjei470s50003u5vb44na5as7","_id":"cjei470st000mu5vbrz55omj1"},{"post_id":"cjei470sn000gu5vbg148h2u0","tag_id":"cjei470sm000eu5vbg6cxqtyw","_id":"cjei470sy000pu5vbttqnetue"},{"post_id":"cjei470s60004u5vbwmhenkn7","tag_id":"cjei470sm000eu5vbg6cxqtyw","_id":"cjei470t2000uu5vbk1eh1ir8"},{"post_id":"cjei470sp000iu5vbs0vg6tgb","tag_id":"cjei470sm000eu5vbg6cxqtyw","_id":"cjei470t3000wu5vbgk5hazga"},{"post_id":"cjei470s90005u5vb8ivr8y63","tag_id":"cjei470sm000eu5vbg6cxqtyw","_id":"cjei470t40010u5vb4odl4tf7"},{"post_id":"cjei470sc0006u5vbhk35gkur","tag_id":"cjei470sm000eu5vbg6cxqtyw","_id":"cjei470t40012u5vbl4stjhqx"},{"post_id":"cjei470su000nu5vbvr0nefky","tag_id":"cjei470t3000zu5vbmavq8jpo","_id":"cjei470t60017u5vbnp0twcn7"},{"post_id":"cjei470sy000qu5vbc3471g1f","tag_id":"cjei470t50015u5vbasykuhtv","_id":"cjei470t70019u5vbe3gfb3en"}],"Tag":[{"name":"tip","_id":"cjei470s50003u5vb44na5as7"},{"name":"iOS","_id":"cjei470sm000eu5vbg6cxqtyw"},{"name":"other","_id":"cjei470t3000zu5vbmavq8jpo"},{"name":"React","_id":"cjei470t50015u5vbasykuhtv"}]}}