{"meta":{"title":"帕帕's Blog","subtitle":"记录点点滴滴","description":"奋斗中的程序员。","author":"帕帕","url":"https://hparis.github.io/blog"},"pages":[],"posts":[{"title":"Raspberry PI 基本使用","slug":"Raspberry-PI-基本使用","date":"2018-03-05T22:04:56.000Z","updated":"2018-03-08T07:39:50.972Z","comments":true,"path":"2018/03/06/Raspberry-PI-基本使用/","link":"","permalink":"https://hparis.github.io/blog/2018/03/06/Raspberry-PI-基本使用/","excerpt":"","text":"1. 保证 Raspberry PI 能够在外网使用12// 在你的 Raspberry PI 上使用 autossh 来实现不掉线的反向代理：autossh -M 5678 -fNR 2018:localhost:22 root@54.219.12.213 12// 在你的外网服务器（比如上面例子中的：54.219.12.213）上可以使用 ssh 登录你的 Raspberry PIssh -p 2018 pi@127.0.0.1","categories":[{"name":"tip","slug":"tip","permalink":"https://hparis.github.io/blog/categories/tip/"}],"tags":[{"name":"tip","slug":"tip","permalink":"https://hparis.github.io/blog/tags/tip/"}]},{"title":"redux 之页面跳转","slug":"redux-之页面跳转","date":"2018-02-26T17:48:56.000Z","updated":"2018-03-08T07:39:19.848Z","comments":true,"path":"2018/02/27/redux-之页面跳转/","link":"","permalink":"https://hparis.github.io/blog/2018/02/27/redux-之页面跳转/","excerpt":"","text":"最近正在用 React Native 重构整个项目，我们用了 react-native-navigation 这个库来作为项目的导航控制器。所以，我们平常会把页面跳转逻辑的时候放在 Screen 里面的，比如: 12345678910111213class FirstScreen extends React.Component &#123; // 点击事件 _someAction = () =&gt; &#123; this.props.navigator.push(&#123; screen: 'example.SecondScreen', &#125;); &#125; render = () =&gt; &#123; ... &#125;&#125; 一般情况下，上面的写法没有问题。但是直到我们碰到这样一个需求的时候就抓瞎了：点击一个 PDF 文件，如果 PDF 文件没有下载就先去下载，下载完成之后自动跳转到 PDF 阅读器。由于用了 redux 之后，我们就增加一个 finished 的 state 来判断是否已经下载完成。示例代码如下： 12345678910111213141516171819202122232425262728293031class ExampleScreen extends React.Component &#123; componentWillReceiveProps = (nextProps) =&gt; &#123; // 这里判断下载状态是否已完成，完成的话就去跳转 if (nextProps.finished === true) &#123; // 这里需要重置一下状态，不然其他 state 发生变化会多次触发页面的跳转 this.props.dispatch(resetFinished()); this.props.navigator.push(&#123; screen: 'example.PDFScreen', &#125;); &#125; &#125; // 点击事件 _someAction = () =&gt; &#123; // openPDF() 这个 action 会自动去下载 PDF 文件，然后修改 finished 的状态 this.props.dispatch(openPDF()); &#125; render = () =&gt; &#123; ... &#125;&#125;const mapStateToProps = state =&gt; &#123; return &#123; finished: state.finished &#125;&#125;;export default connect(mapStateToProps)(ExampleScreen); 上面的做法是可以实现我们的需求，但是这种写法很蛋疼。因为当你在调用用 openPDF() 的时候，你以为后面的事不需要你操心，然后这个时候有人告诉你还需要在其他地方增加一个中间状态去补充 openPDF() 的后续逻辑处理。 经过讨论之后，我们决定改成用 callback 的方式来实现： 12345678910111213141516class ExampleScreen extends React.Component &#123; // 点击事件 _someAction = () =&gt; &#123; // openPDF() 是一个异步 action this.props.dispatch(openPDF(callback: () =&gt; &#123; this.props.navigator.push(&#123; screen: 'example.PDFScreen', &#125;); &#125;)); &#125; render = () =&gt; &#123; ... &#125;&#125; 使用 callback 的好处就是去掉了一个烦人的中间状态，并且从阅读体验来说很容易让读者明白这个点击事件在干什么。但是在 redux 的 action 方法中增加一个 callback 的调用，看起来也有点不伦不类的。虽然我认为 callback 和其他参数具有相同的法律地位。 其实最好的实现是，这个点击事件应该连页面的跳转逻辑也不需要处理： 1234567891011class ExampleScreen extends React.Component &#123; // 点击事件，这个事件只做一件事就是去 dispatch 一个 openPDF() 的 action _someAction = () =&gt; &#123; this.props.dispatch(openPDF()); &#125; render = () =&gt; &#123; ... &#125;&#125; 像上面这种实现，我们也就只能在 openPDF() 里动手脚了： 123456789// action.jsexport const openPDF = await () =&gt; &#123; return dispatch =&gt; &#123; // 异步下载 PDF async downloadPDF(); // 完成之后通过 router 去实现页面跳转 dispatch(openRouter('PDFScreen')); &#125;;&#125; 这里就不再详细说 router 的实现细节了，因为网上有很多现成的资料。（PS: 主要是我也还没看到这一块） 从页面（Screen）的角度来说，我认为这样的处理是最合适的。因为 Screen 只需要关注本页面的 state 和 action，至于跳转的逻辑交给后面的 action 来处理是最好的。","categories":[{"name":"React","slug":"React","permalink":"https://hparis.github.io/blog/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://hparis.github.io/blog/tags/React/"}]},{"title":"Swift High-Performance Tip 2：final 和 private(fileprivate)","slug":"Swift-High-Performance-Tip 2：final和private(fileprivate)","date":"2017-09-05T15:30:56.000Z","updated":"2018-03-06T07:06:37.644Z","comments":true,"path":"2017/09/05/Swift-High-Performance-Tip 2：final和private(fileprivate)/","link":"","permalink":"https://hparis.github.io/blog/2017/09/05/Swift-High-Performance-Tip 2：final和private(fileprivate)/","excerpt":"","text":"Dynamic dispatch means that program has to determine at run time which method or property is being referred to and then perform an indirect call or indirect access. 我们都知道 Swift 的 class 是可以被继承，function 和 property 是可以被重写的，而这就意味着 Swift 需要 dynamic dispatch 这种机制来完成这些功能。Swift 的 dynamic dispatch 首先会再 method table 查找方法，然后间接调用。很明显这种方式要比直接调用的效率慢，并且用间接调用的方式还会阻止编译器的一些优化无法实现。 那么应该怎么优化呢？ 当我们明确的知道 class、function、property 是不需要 overridden，我们可以通过使用 final 和 private(fileprivate) 这些关键字减少动态派发的发生，从而有效的提高效率。 在 Swift 中，如果被 final 或 private(fileprivate) 修饰的 class、function、property 是不能 overridden，并且调用这些 class、function、property 的时候不再通过 dynamic dispatch 去间接调用，而是直接调用。 所以，通过在必要的代码中使用 final 或 private(fileprivate) 这些关键字进行优化的话，将可以有效提高的效率。 Whole Module Optimization Swift 的 class、function、property 的默认权限都是 internal ，除非我们明确的加上 public 或 private(fileprivate) 关键字才能改变它们的默认权限。 编译器在编译 Module 的时候都是对里面的源文件进行单独编译，这样的话编译器就无法确切的知道被 internal 修饰的 class、function、property 究竟有没有被 overridden。一旦我们开启 Whole Module Optimization 的优化选项，编译器就会同时对整个 Module 的所有源文件进行编译，这个时候编译器就可以知道哪些被 internal 修饰的 class、function、property 没有被 overridden，从而把它们的权限从 internal 修改为 final。这样的话，就可以减少 dynamic dispatch 的发生从而提高效率。 开启编译优化选项的步骤如下：Xcode -&gt; Build Settings -&gt; Swift Compiler -&gt; Optimization Level。 参考文献 https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/ https://developer.apple.com/swift/blog/?id=27 https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations","categories":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/tags/iOS/"}]},{"title":"Shell Tip","slug":"Shell-Tip","date":"2017-09-05T15:30:56.000Z","updated":"2018-03-08T07:40:50.710Z","comments":true,"path":"2017/09/05/Shell-Tip/","link":"","permalink":"https://hparis.github.io/blog/2017/09/05/Shell-Tip/","excerpt":"","text":"Tip 1 : 修改文件里面的内容早上产品有一个小需求就是把工程中的所有网页的标题修改为黑米流量通，可以使用以下命令来实现 1find . -name '*.html' -print0 | xargs -0 sed -i '' -e 's/&lt;title&gt;.*&lt;\\/title&gt;/&lt;title&gt;黑米流量通&lt;\\/title&gt;/g' find 查找命令，可以用 man find 查看更多的信息 . 代表当前目录 -name find 命令的参数，表示要查找的文件名 -print0 是一种不换行的输出格式，以 ASCII NUL 字符（也就是\\0）作为分隔符。上面的例子可能是 a.html\\0b.html\\0c.html | 这是一个管道符，表示把前面命令的输出作为后面命令的输入 xargs 是用来构造输入参数，并且循环执行每一个参数 -0 表示让 xargs 使用 ASCII NUL 来分隔参数。上面的例子将被分隔成 a.html b.html c.html 三个参数依次执行 sed 这是一个流编辑器，如果传的是文件名会把文件内容读入内存，如果只是普通字符串就会把字符串读入内存 -i 表示要把原来的文件内容做一次备份，后面的 &#39;&#39; 是表示要备份的文件名字，如果没有文件名字就表示不需要备份 -e 表示后面的字符串是一个命令，需要被执行 s/old/new/g 这个是用来替换字符串的命令 Tip 2 : 查找文件的内容把匹配的文件内容的相关文件列出来 1find . -name '*.html' -print0 | xargs -0 grep 'PATTERN' Tip 3 : 解决 Homebrew 的权限问题查看 Homebrew 的所有权 1ls -al `which brew` 把 Homebrew 的用户和分组修改为 root 和 wheel 1sudo chown root:wheel `which brew` 最后还原 Homebrew 的权限（安全） 1sudo chown : `chown brew` Tip 4 : 利用 Shell 生成生成 ICON12345678910111213141516171819202122232425262728#!/bin/sh#此脚本是用来生成 iPhone 和 iPad 所需 icon 的不同尺寸的，最好是准备一张 1024x1024 的 Icon 图片filename=\"icon.png\"dirname=\"icon\"name_array=(\"Icon-20.png\" \"Icon-20@2x.png\" \"Icon-20@3x.png\"\"Icon-29.png\" \"Icon-29@2x.png\" \"Icon-29@3x.png\"\"Icon-40.png\" \"Icon-40@2x.png\" \"Icon-40@3x.png\"\"Icon-60@2x.png\" \"Icon-60@3x.png\"\"Icon-76.png\" \"Icon-76@2x.png\"\"Icon-83.5@2x.png\")size_array=(\"20\" \"40\" \"80\"\"29\" \"58\" \"87\"\"40\" \"80\" \"120\"\"120\" \"180\"\"76\" \"152\"\"167\")mkdir $dirnamefor ((i=0;i&lt;$&#123;#name_array[@]&#125;;++i)); do m_dir=$dirname/$&#123;name_array[i]&#125; cp $filename $m_dir sips -Z $&#123;size_array[i]&#125; $m_dirdone Tip5 : 使用 Python 共享当前目录利用下面的命令可以暂时开启一个端口号为 8000 的 HTTP 服务，其他人只需要在浏览器输入 http://ip-address:8000 即可浏览共享目录下的文件 1python -m SimpleHTTPServer Tip6 : 加密和解密文件 加密 1tar czf - &#123;SRC_DIR&#125; | openssl des3 -salt -k \"&#123;KEY&#125;\" -out &#123;DIST_PACKAGE&#125;.tar.gz 示例： 目录名 paris_code，秘钥 meta#com，输出包 paris_code_20161008.tar.gz 1tar czf - paris_code | openssl des3 -salt -k \"meta#com\" -out paris_code_20161008.tar.gz 解密 第一步：获取代码压缩文件包 下载地址 http://XXXX.com/paris_code_20161008.tar.gz 第二步：解密文件（OS X / Linux only） 在 Terminal 进入压缩文件包同级目录，输入以下命令： 1openssl des3 -d -k \"meta#com\" -salt -in paris_code_20161008.tar.gz | tar xzf - Tip7: iOS 打包命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788echo \"----------------\"echo \"Begin Build!\"PROJECT_NAME=\"orbit\"BUILD_DATE=\"$(date +'%Y%m%d')\"BUNDLE_ID=\"com.meta.paris\"cd $&#123;WORKSPACE&#125;#/usr/local/bin/npm installif [ -d \"$&#123;WORKSPACE&#125;/build\" ]; then if ls $&#123;WORKSPACE&#125;/build/**/*.ipa 1&gt; /dev/null 2&gt;&amp;1; then rm -rf $&#123;WORKSPACE&#125;/build/**/*.ipa; fi; if ls $&#123;WORKSPACE&#125;/build/**/*.xcarchive 1&gt; /dev/null 2&gt;&amp;1; then rm -rf $&#123;WORKSPACE&#125;/build/**/*.xcarchive; fi;else mkdir $&#123;WORKSPACE&#125;/build; fi;echo \"计算今天的 Build Version\"if [ -d \"$&#123;WORKSPACE&#125;/build/$&#123;BUILD_DATE&#125;\" ]; then #如果不加上面的 if, Jenkins 无法直接执行下面的命令❓ BUILD_DATE_COUNT=$(ls $&#123;WORKSPACE&#125;/build | grep \"^$&#123;BUILD_DATE&#125;\" -c) if [ $&#123;BUILD_DATE_COUNT&#125; -lt 10 ]; then BUILD_DATE_COUNT=\"0$&#123;BUILD_DATE_COUNT&#125;\" fi; BUILD_VERSION=\"$&#123;BUILD_DATE&#125;$&#123;BUILD_DATE_COUNT&#125;\"else BUILD_VERSION=$&#123;BUILD_DATE&#125;fi;echo \"今天的 Build Version 是 $&#123;BUILD_VERSION&#125;\"if [ -d \"$&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;\" ]; then rm -rf $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;; fi;mkdir $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;;if [ -d \"$&#123;WORKSPACE&#125;/Enterprise.plist\" ]; then rm $&#123;WORKSPACE&#125;/Enterprise.plist; fi;#http://www.matrixprojects.net/p/xcodebuild-export-options-plist/Enterprise='&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;teamID&lt;/key&gt; &lt;string&gt;&lt;/string&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;app-store&lt;/string&gt; &lt;key&gt;uploadSymbols&lt;/key&gt; &lt;true/&gt; &lt;key&gt;uploadBitcode&lt;/key&gt; &lt;false/&gt;&lt;/dict&gt;&lt;/plist&gt;'echo $&#123;Enterprise&#125; &gt; $&#123;WORKSPACE&#125;/Enterprise.plistsed -i '' 's/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g' \\$&#123;WORKSPACE&#125;/$&#123;PROJECT_NAME&#125;.xcodeproj/project.pbxprojsed -i '' 's/DEVELOPMENT_TEAM = .*;/DEVELOPMENT_TEAM = \"\";/g' \\$&#123;WORKSPACE&#125;/$&#123;PROJECT_NAME&#125;.xcodeproj/project.pbxproj#动态生成 Build Versionsed -i '' \"/&lt;key&gt;CFBundleVersion&lt;\\/key&gt;/&#123;N;s/&lt;string&gt;.*&lt;\\/string&gt;/&lt;string&gt;$&#123;BUILD_VERSION&#125;&lt;\\/string&gt;/g;&#125;\" \\$&#123;WORKSPACE&#125;/$&#123;PROJECT_NAME&#125;/$&#123;PROJECT_NAME&#125;-Info.plistxcodebuild -workspace $&#123;WORKSPACE&#125;/$&#123;PROJECT_NAME&#125;.xcworkspace \\-scheme $&#123;PROJECT_NAME&#125; -sdk iphoneos \\build CODE_SIGN_IDENTITY=\"iPhone Distribution: Beijing PS Technology Co., Ltd.\" \\PROVISIONING_PROFILE=\"\" \\-configuration Release clean archive \\-archivePath $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;/$&#123;PROJECT_NAME&#125;.xcarchivexcodebuild -exportArchive -exportOptionsPlist $&#123;WORKSPACE&#125;/Enterprise.plist \\-archivePath $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;/$&#123;PROJECT_NAME&#125;.xcarchive \\-exportPath $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;/echo \"----------------\"echo \"Build successfully!\"echo \"Begin Upload to itunes...\"#Use [shenzhen](https://github.com/nomad/shenzhen) to upload the ipa file to itunes connect./usr/local/bin/ipa distribute:itunesconnect -f $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;/$&#123;PROJECT_NAME&#125;.ipa -a YourAppleID -p YourPassword -i $&#123;BUNDLE_ID&#125; --uploadecho \"Upload successfully!\"","categories":[{"name":"tip","slug":"tip","permalink":"https://hparis.github.io/blog/categories/tip/"}],"tags":[{"name":"tip","slug":"tip","permalink":"https://hparis.github.io/blog/tags/tip/"}]},{"title":"Swift High-Performance Tip 1：Array 和 ContiguousArray","slug":"Swift-High-Performance-Tip 1：Array和ContiguousArray","date":"2017-09-05T15:30:56.000Z","updated":"2018-03-06T07:06:43.216Z","comments":true,"path":"2017/09/05/Swift-High-Performance-Tip 1：Array和ContiguousArray/","link":"","permalink":"https://hparis.github.io/blog/2017/09/05/Swift-High-Performance-Tip 1：Array和ContiguousArray/","excerpt":"","text":"Array 是随机存储的（random-access）集合类型。 ContiguousArray 是连续存储（contiguously stored）的数组，并且不允许和 NSArray 进行桥接的。 当我们的数组元素是 Class 或 @objc protocol 类型的话，并且我们不需要在 Objective-C 中使用该数组的话，那么我们最好使用 ContiguousArray。这是因为 Array 需要额外的资源来处理跟 NSArray 的桥接功能，但是 ContiguousArray 则不需要，所以 ContiguousArray 比 Array 的效率要高。 1234567class A &#123;&#125;// 不要用Array: let array = Array&lt;A&gt;()let contiguousArray = ContiguousArray&lt;A&gt;() 另外需要注意的是官方文档说如果数组元素不是 Class 和 @objc protocol 类型的话，Array 和 ContiguousArray 的效率是一样的。（我猜测是因为如果 Array 的元素都是 Struct 类型的话，它就不需要消耗资源来处理桥接的问题了。） Efficiency is equivalent to that of Array, unless Element is a class or @objc protocol type, in which case using ContiguousArray may be more efficient. 但是 @Paul Hudson 在他的《Pro Swift》中说他发现即使数组元素是 Struct 类型的话，ContiguousArray 也要比 Array 更快。我们来看看他给出的例子： 123456789101112let array2 = Array&lt;Int&gt;(1...1000000)let array3 = ContiguousArray&lt;Int&gt;(1...1000000)var start = CFAbsoluteTimeGetCurrent()array2.reduce(0, combine: +)var end = CFAbsoluteTimeGetCurrent() - startprint(\"Took \\(end) seconds\")start = CFAbsoluteTimeGetCurrent()array3.reduce(0, combine: +)end = CFAbsoluteTimeGetCurrent() - startprint(\"Took \\(end) seconds\") 经过我的测试，上面的代码中 ContiguousArray 只用了0.19秒而 Array 用了0.38秒，所以 ContiguousArray 确实要比 Array 快。 如果大家想在性能上有所提升的话，建议大家可以用 ContiguousArray 试一试。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/tags/iOS/"}]},{"title":"RAC和内存管理","slug":"RAC和内存管理","date":"2017-09-05T15:30:56.000Z","updated":"2018-03-08T07:46:26.835Z","comments":true,"path":"2017/09/05/RAC和内存管理/","link":"","permalink":"https://hparis.github.io/blog/2017/09/05/RAC和内存管理/","excerpt":"","text":"最近在用 RAC 的时候发现自己对内存管理还是有些困惑，于是自己写了一些代码来验证自己的一些理解。在一开始接触 RAC 的时候，我们知道 RAC 对于 block 都是 copy 赋值的。 1234567@implementation RACSignal#pragma mark Lifecycle+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123; return [RACDynamicSignal createSignal:didSubscribe];&#125; 123456789@implementation RACDynamicSignal#pragma mark Lifecycle+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123; RACDynamicSignal *signal = [[self alloc] init]; signal-&gt;_didSubscribe = [didSubscribe copy]; return [signal setNameWithFormat:@\"+createSignal:\"];&#125; 在创建 RACSingal 的时候会调用其子类 RACDynamicSignal 去创建，我们也看到 RACDynamicSignal 对 didSuscribe 这个 block 是进行了 copy。所以大家可能会被要求注意循环引用的问题，于是大家都用 @weakify(target) 和 @strongify(target) 来避免循环引用的问题。那是不是所有用到 RAC 的地方都需要使用这些宏来避免循环引用的问题，不尽然。比如下面这个： 1234// 场景1[RACObserve(self, title) subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;]; 接下来，我们来对比以下的几种用法： 12345678910111213141516171819202122232425262728@interface ViewController()@property (strong, nonatomic) ViewModel * viewModel;@end@implementation ViewController- (void)viewDidiLoad &#123; [super viewDidLoad]; self.viewModel = [ViewModel new]; // 场景2 dispatch_async(dispatch_get_main_queue(), ^&#123; self.title = @\"你好\"; &#125;); // 场景3 [self.viewModel.titleSignal subscribeNext:^(NSString * title) &#123; self.title = title; &#125;]; // 场景4 [RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) &#123; self.title = title; &#125;]; &#125;@end 场景2是我们平常都会用到的，而且我们也没有在这种场景下去考虑循环引用的问题，这是因为 dispatch 的 block 不是属于 self 的（至于这个 block 是属于谁的，回头我再查点资料或者请各位指教），所以即使你在 block 使用了 self 也不会有循环应用的问题。 场景3很明显是有循环引用的问题：self-&gt;viewModel-&gt;titleSignal-&gt;block-&gt;self，这个时候如果我们不做处理的话，那么 self 就永远不会被释放。正确的做法应该是使用 @weakify(self) 和 @strongify(self)： 123456// 场景3@weakify(self);[self.viewModel.titleSignal subscribeNext:^(NSString * title) &#123; @strongify(self); self.title = title;&#125;]; 场景4在我们看来是没有问题的，因为这里看起来只有 singal-&gt;block-&gt;self 的引用，它们之间并没有造成循环引用的问题。我们先来看看 RACObserve 的实现： 12345678910#define RACObserve(TARGET, KEYPATH) \\(&#123; \\_Pragma(\"clang diagnostic push\") \\_Pragma(\"clang diagnostic ignored \\\"-Wreceiver-is-weak\\\"\") \\__weak id target_ = (TARGET); \\[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \\_Pragma(\"clang diagnostic pop\") \\&#125;)- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak NSObject *)observer; 其实，看到这里你会认为这里只是调用了一个方法创建了一个 Signal，而且这个 Signal 也并不属于任何对象。我们再来看看具体的实现是怎么样的？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (RACSignal *)rac_valuesAndChangesForKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options observer:(__weak NSObject *)weakObserver &#123; NSObject *strongObserver = weakObserver; keyPath = [keyPath copy]; NSRecursiveLock *objectLock = [[NSRecursiveLock alloc] init]; objectLock.name = @\"org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing\"; __weak NSObject *weakSelf = self; RACSignal *deallocSignal = [[RACSignal zip:@[ self.rac_willDeallocSignal, strongObserver.rac_willDeallocSignal ?: [RACSignal never] ]] doCompleted:^&#123; // Forces deallocation to wait if the object variables are currently // being read on another thread. [objectLock lock]; @onExit &#123; [objectLock unlock]; &#125;; &#125;]; return [[[RACSignal createSignal:^ RACDisposable * (id&lt;RACSubscriber&gt; subscriber) &#123; // Hold onto the lock the whole time we're setting up the KVO // observation, because any resurrection that might be caused by our // retaining below must be balanced out by the time -dealloc returns // (if another thread is waiting on the lock above). [objectLock lock]; @onExit &#123; [objectLock unlock]; &#125;; __strong NSObject *observer __attribute__((objc_precise_lifetime)) = weakObserver; __strong NSObject *self __attribute__((objc_precise_lifetime)) = weakSelf; if (self == nil) &#123; [subscriber sendCompleted]; return nil; &#125; return [self rac_observeKeyPath:keyPath options:options observer:observer block:^(id value, NSDictionary *change, BOOL causedByDealloc, BOOL affectedOnlyLastComponent) &#123; [subscriber sendNext:RACTuplePack(value, change)]; &#125;]; &#125;] takeUntil:deallocSignal] setNameWithFormat:@\"%@ -rac_valueAndChangesForKeyPath: %@ options: %lu observer: %@\", self.rac_description, keyPath, (unsigned long)options, strongObserver.rac_description];&#125; 重点观察 deallocSignal 和 [signal takeUntile:deallocSignal]，我们把 deallocSignal 单独拿出来看看： 1234567891011RACSignal *deallocSignal = [[RACSignal zip:@[ self.rac_willDeallocSignal, strongObserver.rac_willDeallocSignal ?: [RACSignal never] ]] doCompleted:^&#123; // Forces deallocation to wait if the object variables are currently // being read on another thread. [objectLock lock]; @onExit &#123; [objectLock unlock]; &#125;;&#125;]; 这里的 deallocSignal 是只有在 self 和 strongObserve 都将要发生 dealloc 的时候才会触发的。即用 RACObserve 创建的信号只有在其 target 和 observe 都发生 dealloc 的时候才会被 disposable (这个好像是 RAC 用来销毁自己资源的东西)。不明白的童鞋，我们回头来分析一下场景4的代码： 1234// 场景4[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) &#123; self.title = title;&#125;]; 用 RACObserve 创建的信号看起来只要出了函数体其资源应该就会被回收，但是这个信号其实是只有在 self.viewModel.rac_willDeallocSignal 和 self.rac_willDeallocSignal 都发生的情况下才会被释放。所以场景4的引用关系看起来只有 signal-&gt;block-&gt;self，但是这个 signal 只有在 self.rac_willDeallocSignal 的时候才会被释放。所以这里如果不打断这种关系的话就会造成循环引用的问题，正确做法应该是： 123456// 场景4@weakify(self);[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) &#123; @strongify(self); self.title = title;&#125;]; 最后，在说一个特别需要注意的，就是 UITableViewCell 和 UICollectionViewCell 复用和 RAC 的问题。 123456789101112131415- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return 1000;&#125;- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath &#123; UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"TableViewCell\"]; @weakify(self); [RACObserve(cell.textLabel, text) subscribeNext:^(id x) &#123; @strongify(self); NSLog(@\"%@\", self); &#125;]; return cell;&#125; 我们看到这里的 RACObserve 创建的 Signal 和 self 之间已经去掉了循环引用的问题，所以应该是没有什么问题的。但是结合之前我们对 RACObserve 的理解再仔细分析一下，这里的 Signal 只要 self 没有被 dealloc 的话就不会被释放。虽然每次 UITableViewCell 都会被重用，但是每次重用过程中创建的信号确实无法被 disposable。那我们该怎么做呢？ 123456789101112131415- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return 1000;&#125;- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath &#123; UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"TableViewCell\"]; @weakify(self); [[RACObserve(cell.textLabel, text) takeUntil:cell.rac_prepareForReuseSignal] subscribeNext:^(id x) &#123; @strongify(self); NSLog(@\"%@\", self); &#125;]; return cell;&#125; 注意，我们在cell里面创建的信号加上 takeUntil:cell.rac_prepareForReuseSignal，这个是让 cell 在每次重用的时候都去 disposable 创建的信号。 以上所说的关于内存的东西我都用 Instrument 的 Allocations 验证过了，但是依旧建议大家自己也去试试。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/tags/iOS/"}]},{"title":"Vim Tip","slug":"Vim-Tip","date":"2017-09-05T15:30:56.000Z","updated":"2018-03-06T07:07:22.896Z","comments":true,"path":"2017/09/05/Vim-Tip/","link":"","permalink":"https://hparis.github.io/blog/2017/09/05/Vim-Tip/","excerpt":"","text":"1、替换第n1行到第n2行的内容1:n1,n2/origin/replace/g 2、替换整个文件的内容1:%s/origin/replace/g 3、移动n1-n2行(包括n1,n2)到n3行之下1n1,n2 m n3 4、复制n1-n2行(包括n1,n2)到n3行之下1:n1,n2 co n3 5、删除文件的空行1:g/^$/d 6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）1:r!seq 100 7、在当前的每一行文字前面增加“序号. ”（来自池老师《说，谁才是最帅的编程工具？》）1:let i=1 | g /^/ s//\\=i.\". \"/ | let i+=1 8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）123vim:n **/*.java:argdo %s/apache/eclipse/ge | update","categories":[{"name":"tip","slug":"tip","permalink":"https://hparis.github.io/blog/categories/tip/"}],"tags":[{"name":"tip","slug":"tip","permalink":"https://hparis.github.io/blog/tags/tip/"}]},{"title":"Auto Update","slug":"Auto-Update","date":"2017-09-05T15:30:56.000Z","updated":"2018-03-08T07:40:01.861Z","comments":true,"path":"2017/09/05/Auto-Update/","link":"","permalink":"https://hparis.github.io/blog/2017/09/05/Auto-Update/","excerpt":"","text":"1234567891011121314151617181920#!/bin/sh# 此脚本是用来自动更新 Mac 上的一些软件或配置echo \"Begin gem update ...\"gem updateecho \"End gem update!\"#echo \"Begin gem install cocoapods ...\"#gem install cocoapods#echo \"End gem install cocoapods!\"echo \"\\n\"echo \"Begin pod setup ...\"pod setupecho \"End pod setup!\"echo \"\\n\"echo \"Begin brew update ...\"brew updateecho \"End brew update\"","categories":[{"name":"tip","slug":"tip","permalink":"https://hparis.github.io/blog/categories/tip/"}],"tags":[{"name":"tip","slug":"tip","permalink":"https://hparis.github.io/blog/tags/tip/"}]},{"title":"include 和 import 的区别","slug":"include和import的区别","date":"2017-09-05T15:30:56.000Z","updated":"2018-03-08T07:46:11.663Z","comments":true,"path":"2017/09/05/include和import的区别/","link":"","permalink":"https://hparis.github.io/blog/2017/09/05/include和import的区别/","excerpt":"","text":"今天我们来了解下面这几种包含文件的方式有什么特点和区别： 12345#include \"fiel\"#include &lt;file&gt;#import \"file\"#import &lt;file&gt;@import Module 一、#include学过 C 语言的人都知道，#include 其实是一个预处理命令。它会在预处理的时候简单的把被 #include 包含的文件内容进行复制粘贴。我们来看看下面的代码： 1234// A.hvoid sampleA() &#123; // A code&#125; 123456// B.h#include \"A.h\"void sampleB() &#123; // B code&#125; 我们使用 gcc -E B.h 命令来看看经过预处理后的文件内容大概如下： 12345678910111213141516# 1 \"B.h\"# 1 \"&lt;built-in&gt;\" 1# 1 \"&lt;built-in&gt;\" 3# 329 \"&lt;built-in&gt;\" 3# 1 \"&lt;command line&gt;\" 1# 1 \"&lt;built-in&gt;\" 2# 1 \"B.h\" 2# 1 \"./A.h\" 1void sampleA() &#123;&#125;# 2 \"B.h\" 2void sampleB() &#123;&#125; 我们可以看到经过预处理之后，A.h 文件中的内容被直接复制并粘贴到 B.h 文件中来。如果我们在 B.h 文件中多次包含了 A.h 文件，会出现什么情况？比如： 1234// A.hvoid sampleA() &#123; // A code&#125; 1234567// B.h#include \"A.h\"#include \"A.h\"void sampleB() &#123; // B code&#125; 经过预处理之后的内容大概如下： 123456789101112131415161718192021# 1 \"B.h\"# 1 \"&lt;built-in&gt;\" 1# 1 \"&lt;built-in&gt;\" 3# 329 \"&lt;built-in&gt;\" 3# 1 \"&lt;command line&gt;\" 1# 1 \"&lt;built-in&gt;\" 2# 1 \"B.h\" 2# 1 \"./A.h\" 1void sampleA() &#123;&#125;# 2 \"B.h\" 2# 1 \"./A.h\" 1void sampleA() &#123;&#125;# 3 \"B.h\" 2void sampleB() &#123;&#125; A.h 文件中的 sampleA() 函数出现了两次，所以我们需要利用其他的一些预处理命令来规避这种情况，看看下面的代码： 12345678// A.h#ifndef FILE_A#define FILE_Avoid sampleA() &#123; // A code&#125;#endif 1234567// B.h#include \"A.h\"#include \"A.h\"void sampleB() &#123; // B code&#125; 我们再来看看增加了这些预处理命令之后的预处理文件内容： 1234567891011121314151617181920# 1 \"B.h\"# 1 \"&lt;built-in&gt;\" 1# 1 \"&lt;built-in&gt;\" 3# 329 \"&lt;built-in&gt;\" 3# 1 \"&lt;command line&gt;\" 1# 1 \"&lt;built-in&gt;\" 2# 1 \"B.h\" 2# 1 \"./A.h\" 1void sampleA() &#123;&#125;# 2 \"B.h\" 2void sampleB() &#123;&#125; OK，这就正常了。如果我们在 A.h 中包含 B.h，然后又在 B.h 中包含 A.h，具体代码如下： 1234567// A.h#include \"B.h\"void sampleA() &#123; // A code&#125;#endif 123456// B.h#include &quot;A.h&quot;void sampleB() &#123; // B code&#125; 我们再来看看经过 gcc -E B.h 处理之后的文件内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 1 \"B.h\"# 1 \"&lt;built-in&gt;\" 1# 1 \"&lt;built-in&gt;\" 3# 329 \"&lt;built-in&gt;\" 3# 1 \"&lt;command line&gt;\" 1# 1 \"&lt;built-in&gt;\" 2# 1 \"B.h\" 2# 1 \"./A.h\" 1# 1 \"./B.h\" 1# 1 \"./A.h\" 1# 1 \"./B.h\" 1......# 1 \"./A.h\" 1# 1 \"./B.h\" 1In file included from ./B.h:1:In file included from ./A.h:1:In file included from ./B.h:1:In file included from ./A.h:1:......In file included from ./B.h:1:In file included from ./A.h:1:./A.h:1:10: error: #include nested too deeply#include \"B.h\" ^void sampleA() &#123;&#125;# 2 \"./B.h\" 2void sampleB() &#123;&#125;# 2 \"./A.h\" 2void sampleA() &#123;&#125;# 2 \"./B.h\" 2void sampleB() &#123;&#125;# 2 \"./A.h\" 2void sampleA() &#123;&#125;......# 2 \"./A.h\" 2void sampleA() &#123;&#125;# 2 \"./B.h\" 2void sampleB() &#123;&#125;1 error generated. 我们发现 A.h 和 B.h 重复出现，这是因为这个时候 A.h 和 B.h 文件互相引用导致的。从理论上来讲，这个时候会无限循环下去，直至世界终结。在这里最后会出现一句 1 error generated.的提示是 gcc 强行中断了这个预处理的过程，所以我们才能看到这样的结果。那我们可以怎么做？当然是利用前面说的预处理命令来避免循环引用的问题。看下面的代码： 12345678910// A.h#ifndef FILE_A#define FILE_A#include \"B.h\"void sampleA() &#123; // A code&#125;#endif 12345678910// B.h#ifndef FILE_B#define FILE_B#include \"A.h\"void sampleB() &#123; // B code&#125;#endif 这个时候使用 gcc -E B.h 就可以正常的进行预处理，最后的结果如下： 12345678910111213141516171819202122232425# 1 \"B.h\"# 1 \"&lt;built-in&gt;\" 1# 1 \"&lt;built-in&gt;\" 3# 329 \"&lt;built-in&gt;\" 3# 1 \"&lt;command line&gt;\" 1# 1 \"&lt;built-in&gt;\" 2# 1 \"B.h\" 2# 1 \"./A.h\" 1# 1 \"./B.h\" 1# 5 \"./A.h\" 2void sampleA() &#123;&#125;# 5 \"./B.h\" 2void sampleB() &#123;&#125; 所以C程序员总是需要通过各种手段（比如：#pragma once）来防范此类事件的发生。 二、#import我们在文件中通过#import来导入 iAd Framework： 编译报错： 需要重新导入和链接 Framework： 编译成功： 从上面的过程中我们就知道在 Objective-C 项目中使用 #import 需要注意导入和链接 Framework，否则是会报错的。 预处理器在碰到 #import 命令的时候，它会采用递归的方式把被所有头文件的内容复制并粘贴到当前文件中，如果文件依赖层次比较深就会造成预处理后的文件内容体积大幅度变大。 比如导入 UIKit 的时候只需要一行代码： 1#import &lt;UIKit/UIKit.h&gt; 预处理之后会变成200多行（UIKit.h 文件有200多行代码）： 1234567#import &lt;UIKit/UIKitDefines.h&gt;#if __has_include(&lt;UIKit/UIAccelerometer.h&gt;)#import &lt;UIKit/UIAccelerometer.h&gt;.....#import &lt;UIKit/UIRegion.h&gt;#endif 接下来还需要递归的把每个头文件的内容展开，最后的结果就是一行代码变成超过11000行代码。如果有多个文件都包含来 UIKit 的头文件，这样就会让每个文件的体积都会变得很大，编译过程也会变得越来越慢。这种递归的方式会让项目的编译时间变成：M source files + N headers =&gt; M x N compile time。 所以这个时候有一个优化方法就是把项目中频繁被引用的文件放到 PCH（Pre-Compile Header）文件中。PCH 会被编译一次并且会被缓存，这就可以缩短编译时间，我们也不需要在不同的文件里面添加import语法。 当然，PCH 也有自己的缺点： 维护负担：随着项目变得越来越复杂，我们就会不停的往PCH文件加入内容，内容一旦变多就会变得不好维护。（这也是我们平常在项目中要避免在 ViewController 做太多事情的，要研究 MVVM的缘故。） 命名空间污染 最后，给大家提供一个例子看看 #import 编译出来之后的文件内容： 1234567// A.h#import \"B.h\" void sampleA() &#123; // A code&#125;#endif 1234567// B.h#import \"A.h\"#import \"A.h\"void sampleB() &#123; // B code&#125; 使用 gcc -E B.h 进行预处理之后的内容如下： 12345678910111213141516171819# 1 \"B.h\"# 1 \"&lt;built-in&gt;\" 1# 1 \"&lt;built-in&gt;\" 3# 329 \"&lt;built-in&gt;\" 3# 1 \"&lt;command line&gt;\" 1# 1 \"&lt;built-in&gt;\" 2# 1 \"B.h\" 2# 1 \"./A.h\" 1void sampleA() &#123;&#125;# 2 \"./B.h\" 2void sampleB() &#123;&#125; 我们在B.h中有两个 #import “A.h”，但是这些内容跟我们之前在 A.h 和 B.h 文件中使用 #include 和其他预处理命令之后的处理结果很相似，所以我们就明白了 #import 大概做了什么事。 三、@import在2012年的 LLVM 大会上，苹果的 Doug Gregor 首次提出了 Objective-C 中的 Module。使用 @import 方式导入有几个好处： 不需要像 #import 一样得手动去链接 Framework，@import会自动去链接 @import 工作方式和 PCH 很像，但是 @import 要比 PCH 的效率高出许多 @import 导入 Modul 优化文件体积变大、编译速度变慢的问题 可以部分导入（@import Framework.A）或全部导入（@import Framework） 所以，建议大家尽量使用 @import 来导入文件。如果你以前的项目用的是 #import，那么你也不需要担心，我们只通过 Build Settings 开启 Modules 选项（看下图），#import 和 #include 会自动被映射成 @import，所以你不需要更改原来的代码也能享受 @import带来的好处。 详细内容可以看看苹果2013年的 Advances in Objective-C，里面就详细介绍了 Module。 四、文件路径接下来我们来了解一下 #include 和 #include “file”： #include \\: 表示编译器会直接到系统设定的目录下寻找指定的文件。 #include “file”: 表示编译器会到当前的目录下寻找指定的文件，如果找不到，则会去系统设定的目录下寻找指定的文件。 参考文献： https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html http://stackoverflow.com/questions/18947516/import-vs-import-ios-7 https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7","categories":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/tags/iOS/"}]},{"title":"计算机的启动过程","slug":"启动","date":"2017-09-05T15:30:56.000Z","updated":"2018-03-06T07:07:33.154Z","comments":true,"path":"2017/09/05/启动/","link":"","permalink":"https://hparis.github.io/blog/2017/09/05/启动/","excerpt":"","text":"一、启动 启动电源 CPU(只能执行指令，不能保存指令，它的指令全存在内存中)去内存地址 0xFFFFFFF0 找到第一条需要执行的指令（跳转指令） 跳转到 BIOS 系统，运行 BIOS 的一大堆指令，只要是做系统自检（硬盘、内存、显卡等）。如果有问题会通过喇叭声音的长短组合进行提示 BIOS 在自检之后生成中断向量表 当 BIOS 的所有工作都完成之后，会给 CPU 发送一条中断指令，比如 int 0x19 CPU 接到中断指令之后就去中断向量表找到第 19 号对应的一大堆指令 这堆指令主要是把磁盘的第一扇区（磁盘最开始的 512 Byte）的数据运到内存中，之后 CPU 就开始执行这些指令 这些精巧的指令会把 OS(操作系统) 从磁盘运到内存中 二、运行 OS 进入内存之后，立刻就是老大 OS 告诉 CPU 开始运行 A 程序 CPU 会去硬盘把 A 程序装载到内存中，CPU 才能执行 A 程序的指令 如果此时 OS 告诉 CPU 去执行 B 程序，那么 CPU 会保存好现场，然后去执行 B 程序的指令 三、缓存 因为硬盘的读写速度太慢了，所以都需要先把硬盘的数据装载到内存中之后，CPU 再去内存取指令来执行 但是内存的读写速度依旧还是要比 CPU 慢，一旦指令多起来之后内存的读写速度也会让 CPU 觉得受不了 经过一段时间的运行之后，我们会发现 CPU 去内存取指令是有规律的，这个规律叫程序的局部性原理。CPU 在访问一个内存位置以后过不多久还会多次访问；一个内存位置被访问了， 附近的位置很快也会访问到。 CPU 需要读写指令和数据的时候直接从缓存要，如果缓存没有才会去找内存 局部性原理在程序切换之后，缓存就会失效。因为两个程序之间没什么联系，局部性原理就不起作用了，所以需要重建缓存。 四、流水线 CPU 在计算的过程分成四个步骤：从内存读取指令 - 翻译指令 - 执行 - 把结果写回内存（该步骤有时候没有） CPU 可以同时执行上面四个步骤，比如： 1234读取指令 A读取指令 B - 翻译指令 A读取指令 C - 翻译指令 B - 执行指令 C读取指令 D - 翻译指令 C - 执行指令 B - 把指令 A 的结果写回内存 参考文献： https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513017&amp;idx=1&amp;sn=5550ee714abd36d0b580713f673e670b&amp;scene=21#wechat_redirect","categories":[{"name":"other","slug":"other","permalink":"https://hparis.github.io/blog/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://hparis.github.io/blog/tags/other/"}]},{"title":"初步了解 GCD","slug":"初步了解GCD","date":"2017-09-05T15:30:56.000Z","updated":"2018-03-08T07:44:53.058Z","comments":true,"path":"2017/09/05/初步了解GCD/","link":"","permalink":"https://hparis.github.io/blog/2017/09/05/初步了解GCD/","excerpt":"","text":"GCD简介GCD(Grand Central Dispatch) 是苹果提供的一套多线程编程技术。想象一下，如果让你编写一个可以高效的跑在不同计算机、不同内核的应用程序，你会怎么做呢？你要看看硬件是什么，看看有有多少个内核，想想用什么算法，想想在什么时候去切换线程…总之，你要做的东西多了去了。而 GCD 帮我们屏蔽了这些技术细节，但是如果要用好 GCD 的话，还是要多了解一些知识点。 Dispatch对象和内存管理在 Objective-C 里面，所有的 dispatch 对象都是 Objective-C 对象，所以他们同样适用引用技术的内存管理。如果你是使用 ARC 的话，dispatch 对象会向普通的 Objective-C 对象一样自动进行 retain 和 release 操作；如果你是使用 MRC，要记住使用 dispatch_retain 和 dispatch_release 来进行管理。 常用APIdispatch_queue_t（调度队列）1public func dispatch_queue_create(label: UnsafePointer&lt;Int8&gt;, _ attr: dispatch_queue_attr_t!) -&gt; dispatch_queue_t! 在 GCD 中只能通过上面的 API 来创建调度队列，我们可以通过创建各种各样的 Block 形式的任务并由该调度队列来决定如何去执行这些 Block 任务。上面创建调度队列的函数需要两个参数： label: 这个参数是用来给你创建的调度队列进行命名的，特别是在调试的时候你可以通过该参数来判断是哪个调度队列的任务在执行。 attr: 这个参数只有 DISPATCH_QUEUE_SERIAL 和 DISPATCH_QUEUE_CONCURRENT 两种值（在 Objective-C 中这个参数可以为 NULL，这个时候默认是 DISPATCH_QUEUE_SERIAL）。DISPATCH_QUEUE_SERIAL 是告诉调度队列以串行的方式去执行任务，DISPATCH_QUEUE_CONCURRENT 是告诉调度队列以并发的方式去执行任务。 当然我们还可以通过下面的方法来获取系统已经创建好的调度队列： 12// 获取全局队列public func dispatch_get_global_queue(identifier: Int, _ flags: UInt) -&gt; dispatch_queue_t! 12// 获取主线程的com.apple.main-thread (serial)队列public func dispatch_get_main_queue() -&gt; dispatch_queue_t! 注意，所有 pending 状态的 Block 任务都会持有该调度队列的引用，所以我们不需要显示的去持有调度队列，而调度队列会在所有的 Block 任务都从 pending 变为 finished 之后才会被释放。 总之，现在大家要知道的是我们可以把不同的 Block任务提交到调度队列，具体的细节和实现看看后面内容。 dispatch_sync和dispatch_async（同步和异步）123456789101112let queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL) // 创建调度队列print(\"Begin Sync\")// 同步调用dispatch_sync(queue) &#123; // Block任务 print(\"Execute Block Task1\") &#125;dispatch_sync(queue) &#123; // Block任务 print(\"Execute Block Task2\") &#125;print(\"After Sync\") 这段代码的输出结果如下： 1234Begin SyncExecute Block Task1Execute Block Task2After Sync 上面的例子就是我们平常对 dispatch_sync 的用法，并且我们可以看到第一个 Block 任务执行之后才会执行第二个 Block 任务。dispatch_sync 需要等待 Block的任务执行完成之后，才能继续往后执行。但是使用 dispatch_sync 的时候，有几点是需要注意的： 当调用 dispatch_sync 方法的时候，系统默认情况下会在当前线程去执行调度队列里的任务，只有在一些特殊情况下才会把调度队列的任务分配到其他线程去执行。所以我们就知道，线程和调度队列并不是一对一的关系。至于为什么默认情况下会在当前线程去执行调度队列里的任务，我的猜测是为了性能。大家想一想，dispatch_sync 会同步执行 Block任务， Block任务没有结束的情况下，后面的代码是无法执行的。基于这样一个同步的机制，GCD 还有必要先把当前线程挂起，然后去创建新线程，然后切换到新的线程去执行调度队列里的任务，然后再把线程切换到当前线程，然后再让当前线程恢复么？结论是没有必要。 你不能够在当前的串行调度队列的任务里面去添加新的任务到当前的调度队列里面，否则会造成死锁。这句话怎么理解呢，我们来来看看下面的例子： 123456789101112131415// 例1let queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL) // 创建串行的调度队列// 同步调用dispatch_sync(queue) &#123; // Block1 print(\"Begin Execute Block Task1\") dispatch_sync(queue) &#123; // Block2 print(\"Execute Block Task2\") &#125; print(\"End Execute Block Task1\")&#125;// 例1的结果Begin Execute Block Task1 为什么 Block1 后面的 print 和 Block2 的 print 都不执行了呢？首先我们要知道被 DISPATCH_QUEUE_SERIAL 声明的调度队列是串行调度队列，串行调度队列里的任务是同时只能有一个任务在执行，并且当前任务没有执行完成，下一个任务也无法执行。上面的例子中会先输出 Block1 中的 Begin Execute Block Task1，然后这个时候再把 Block2 添加到同一个串行调度队列中去。这个时候的 Block1 还没有执行完成，它需要等 dispatch_sync 的 Block2 执行完成之后才能继续执行，而 Block2 又必须等待 Block1 执行完成之后才能执行，所以这个时候就造成 Block1 等着 Block2，Block2 等着 Block1 的死锁。 我们再把调度队列属性改为 DISPAT_QUEUE_CONCURRENT，然后再看看执行结果是什么： 123456789101112// 例2let queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL) // 创建串行的调度队列// 同步调用dispatch_sync(queue) &#123; // Block1 print(\"Begin Execute Block Task1\") dispatch_sync(queue) &#123; // Block2 print(\"Execute Block Task2\") &#125; print(\"End Execute Block Task1\")&#125; 1234// 例2的结果Begin Execute Block Task1Execute Block Task2End Execute Block Task1 被 DISPATCH_QUEUE_CONCURRENT 声明的并发调度队列就没有这种死锁的问题。并发调度队列里的任务是不会霸占资源不放的，每一个任务执行一个时间片段之后会把资源交出来给别的任务去执行。所以例2中的 Block1 虽然需要等待 Block2 执行完成之后才能继续执行，但是当 Block1 在等待的过程中，是可以把资源释放出来交给 Block2 去执行，Block2 执行完成之后 Block1 就可以继续执行了。所以，这个时候就不会造成死锁来。 再来看看下面的例子会不会造成死锁： 12345override func viewDidLoad() &#123; dispatch_sync(dispatch_get_main_queue()) &#123; print(\"Excute Block Task\") &#125;&#125; 答案是会的。给大家一点提示，主线程的默认调度队列是串行（DISPATCH_QUEUE_SERIAL）的，viewDidLoad() 是在主线程的调度队列 com.apple.main-thread (serial) 执行的。 上面的例子主要是希望大家理解串行和并发的概念，同时要明白造成死锁的原因。而要解决死锁一般可以用 DISPATCH_QUEUE_CONCURRENT 或接下来我们要讲的 dispatch_async 来解决。 通过对 dispatch_sync 的了解，我们可以利用 dispatch_async 很快的写出异步代码： 123456789101112let queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL) // 创建调度队列print(\"Begin Async\")// 异步调用dispatch_async(queue) &#123; // Block1 print(\"Execute Block Task1\") &#125;dispatch_async(queue) &#123; // Block2 print(\"Execute Block Task2\") &#125;print(\"After Async\") 这个例子的结果有好几种： 12345// 结果1Begin AsyncAfter AsyncExecute Block Task1ExEcute Block Task2 12345// 结果2Begin AsyncExecute Block Task1ExEcute Block Task2After Async 上面只是列出来两种可能，但实际上还有其他的可能。当我们调用 dispatch_async 的时候，它总是会在 Block 任务被提交之后马上返回，而不会傻傻的等待 Block 任务执行完成。由于上面创建的是串行调度队列，所以我们可以保证 Block1 要比 Block2 优先执行，但是 After Async 就无法确定是在 Block1 的前后还是 Block2 的前后。 如果我们把上面的 DISPATCH_QUEUE_SERIAL 改成 DISPATCH_QUEUE_CONCURRENT，那我们就无法确定 After Async、Block1 和 Block2 这三者的执行顺序了。 我们刚才说到用 dispatch_async 可以解决死锁的问题，那它是怎么解决的呢？ 1234567891011let queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL) // 创建串行的调度队列// 异步调用dispatch_async(queue) &#123; // Block1 print(\"Begin Execute Block Task1\") dispatch_async(queue) &#123; // Block2 print(\"Execute Block Task2\") &#125; print(\"End Execute Block Task1\")&#125; 上面的例子会优先输出 Block1 的 Begin Execute Block Task1 之后，通过 dispatch_async 把 Block2 提交到串行队列里面，然后又马上返回到 Block1 去输出 End Execute Block Task1，这个时候的 Block1 就结束了，接下来就开始执行 Block2。所以上面的代码是不会造成死锁的，虽然上面的例子也是创建了一个串行调度队列，但是该调度队列只是保证了 Block1 要比 Block2 优先执行。 dispatch_once写过 Objective-C 的人都知道，dispatch_once 一般会被用来创建单例对象： 12345678910@implementation Single+ (Single *)sharedInstance &#123; static Single * _single = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _single = [[Single alloc] init]; &#125;); return _single; &#125;@end 这是由于 dispatch_once 是线程安全且只会执行一次，所以才会被用来作为单例的实现。这里需要注意的是 dispatch_once_t 必须是静态的或全局的才能保证 dispatch_once 的 Block 只会被执行一次，所以上面的代码用了 static 来修饰 dispatch_once_t。 dispatch_apply1public func dispatch_apply(iterations: Int, _ queue: dispatch_queue_t!, _ block: (Int) -&gt; Void) 其中的 interations 是表明要执行多少次 block，block 中的 Int 是该 Block 被执行的序号。调用这个方法的时候要注意该方法跟 dispatch_sync 一样会阻塞当前线程，所以我们需要注意在主线程中调用该方法。 dispatch_after1public func dispatch_after(when: dispatch_time_t, _ queue: dispatch_queue_t, _ block: dispatch_block_t) 调用这个方法的时候需要注意的是 when 这个参数，你需要通过 dispatch_time 或 dispatch_walltime 来创建。并且该方法是异步执行的，并不会阻塞当前线程。 一般的写法如下： 123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(5 * NSEC_PER_SEC)), queue) &#123; print(\"5s \\(NSThread.currentThread())\")&#125; dispatch_group_tdispatch_group_t 是用来做聚合同步的，它可以用来跟踪你提交的所有任务（即使是在不同的调度队列也可以）的完成状态。 接下来我们来看看 dispatch group 的一些常见用法： 1234567891011121314151617181920212223// 创建dispatch_group_t对象let group = dispatch_group_create()// 创建串行队列let serialQueue = dispatch_queue_create(\"Serial Queue\", DISPATCH_QUEUE_SERIAL)// 提交两个Block任务到serialQueue，同时关联serialQueue和group的关系dispatch_group_async(group, serialQueue) &#123; print(\"Execute Block1 within Serial Queue\")&#125;dispatch_group_async(group, serialQueue) &#123; print(\"Execute Block2 within Serial Queue\")&#125;// 创建并发队列，并提交Block任务，同时关联该并发队列和group的关系dispatch_group_async(group, dispatch_queue_create(\"Concurrent Queue\", DISPATCH_QUEUE_CONCURRENT)) &#123; print(\"Execute Block within Concurrent Queue\")&#125;// 下面的代码只有当前面被关联到group的所有任务完成之后才会被触发dispatch_group_notify(group, dispatch_queue_create(\"Finished\")) &#123; print(\"Finished\")&#125; 注意，关联到 group 的方法只有 dispatch_group_async 而没有 dispatch_group_sync。 但是还有另外一种方法可以让我们关联一个普通的任务： 12345678910111213141516// 创建dispatch_group_t对象let group = dispatch_group_create()// 使用dispatch_group_enter和dispatch_group_leave的话，我们不需要调用// dispatch_group_async也能关联一个任务到group上dispatch_group_enter(group)self.executeTask &#123; // 执行代码 dispatch_group_leave(group)&#125;// 下面的代码只有当前面被关联到group的所有任务完成之后才会被触发dispatch_group_notify(group, dispatch_queue_create(\"Finished\")) &#123; print(\"Finished\")&#125; 使用 dispatch_group_enter 和 dispatch_group_leave 的时候，它们必须成双成对出现，否则 dispatch_group_notify 是不会被调用的。 接下来我们还要了解一下 dispatch_group_wait： 1public func dispatch_group_wait(group: dispatch_group_t, _ timeout: dispatch_time_t) -&gt; Int dispatch_group_wait 可以指定一个 timeout 的参数，当 group 的任务没有在规定的时间内完成，它会返回一个非零的值，当 group 的任务能够在规定的时间内完成就返回0。同时，大家要注意这个方法会挂起当前线程，所以在主线程的时候要慎重使用该方法。 dispatch_barrier_t我们先来试想一个场景，假如现在有多个线程要去读取一份文件的内容，同时又有其他线程想要去更新该文件的内容，那么就有可能会发生你读错文件内容的现象。这个时候我们可以把所有读写操作都放到我们之前学习的串行队列去执行，但是我们都知道同时有多个线程去读取一份文件内容是没有问题的。 使用 dispatch barrier 可以解决上面的问题： 1234567891011121314// 创建操作文件的并发队列let queue = dispatch_queue_create(\"File\", DISPATCH_QUEUE_CONCURRENT)dispatch_async(queue) &#123; // Read1&#125;dispatch_async(queue) &#123; // Read2&#125;dispatch_barrier_async(queue) &#123; // Write&#125;dispatch_async(queue) &#123; // Read3&#125; 通过 dispatch_barrier_async 或 dispatch_barrier_sync 提交的任务会等待当前队列里正在执行的任务执行完毕才会执行，并且其他还没有执行的任务都必须等待提交到 dispatch barrier 的任务执行完毕之后才会开始执行。所以上面的代码中，当 Write 任务被提交的时候，如果当前队列中只有 Read1 在执行，那么 Write 会等待 Read1 执行完成之后才会执行，Read2 和 Read3 都必须等待 Write 执行完之后才会执行。另外，上面的代码中创建的是并发队列，因为如果是串行队列的话就没有必要用 dispatch barrier 了。 dispatch_semaphore_tdispatch semaphore 是一个效率非常高的传统计数信号量，所以我们一般可以用这个来控制最大的并发数量。 1234567891011121314151617// 创建初始值为2的信号量，最大并发数量为2let semaphore = dispatch_semaphore_create(2)// 创建并发队列let queue = dispatch_queue_create(\"Semaphore\", DISPATCH_QUEUE_CONCURRENT)// 创建100个并发任务for index in 1...100 &#123; // 这个方法会进行信号量减1的操作，并且如果信号量减1之后的结果小于0的话，该方法会造成线程的挂起直 // 到该信号量进行加1操作才会恢复，所以在主线程要注意该方法的使用。 // 注意：这个方法要放在dispatch_async外面，否则系统依旧会创建超过2个线程同时来处理该调度队列 // 的任务 dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER) dispatch_async(queue) &#123; // 释放资源，信号量增加1 dispatch_semaphore_signal(semaphore) &#125;&#125; 其他GCD 在 Swift3 的语法跟现在的语法不太一样了，有兴趣的可以自行去了解。在未来可能会考虑把本文章的代码都用 Swift3 的语法来重新写一下。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/tags/iOS/"}]}]}