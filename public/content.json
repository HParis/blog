{"meta":{"title":"帕帕's Blog","subtitle":"记录点点滴滴","description":"奋斗中的程序员。","author":"帕帕","url":"https://hparis.github.io/blog"},"pages":[{"title":"Categories","date":"2018-03-19T14:23:35.140Z","updated":"2018-03-08T07:22:12.283Z","comments":true,"path":"categories/index.html","permalink":"https://hparis.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-03-27T03:24:57.172Z","updated":"2018-03-27T03:24:57.153Z","comments":true,"path":"about/index.html","permalink":"https://hparis.github.io/blog/about/index.html","excerpt":"","text":"工作经历北京品冠天成科技有限公司iOS 高级工程师（2016.08 - 至今） 负责日常的产品研发和维护工作 负责对新技术的研究与应用 负责代码的重构和封装 定制项目的开发 微信小程序的开发 React Native 的开发 自动化打包流程 北京黑米世纪网络科技有限公司iOS 高级工程师（2013.03 - 2016.08） Review 团队成员代码，提出指导意见 负责对进行架构设计、开发、性能分析和优化，分析和发现系统的优化点 新技术的学习并推动团队成员的技术进步 为产品部门提供技术支持，提出产品的不足之处，帮助改进产品 重构代码，封装常用的工具和公司的基础业务 日常的研发编码工作 负责客户端团队的招聘工作"},{"title":"Tags","date":"2018-03-08T08:19:23.811Z","updated":"2018-03-08T07:22:12.283Z","comments":true,"path":"tags/index.html","permalink":"https://hparis.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"self 在 block 中的引用计数变化","slug":"self-在-block-中的引用计数变化","date":"2018-04-19T11:34:51.000Z","updated":"2018-04-23T08:21:10.189Z","comments":true,"path":"2018/04/19/self-在-block-中的引用计数变化/","link":"","permalink":"https://hparis.github.io/blog/2018/04/19/self-在-block-中的引用计数变化/","excerpt":"","text":"相信大家在 Objective-C 中都会通过 __waek 的修饰符来保证 block 和 self 不会互相引用，代码如下: 12345__weak typeof(self) weakSelf = self;self.block = ^&#123; __strong typeof(self) strongSelf = self; ...&#125; 但是你思考过 self 在这一段旅程中的引用计数变化么，接下来我会通过三个例子来展示这一段旅程是怎样的？ 123456789101112131415161718192021222324252627282930// 🌰1NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));self.block = ^&#123; self; NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));&#125;;self.block();NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));// 🌰2__weak typeof(self) weakSelf = self;NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));self.block = ^&#123; weakSelf; NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));&#125;;self.block();NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));// 🌰3__weak typeof(self) weakSelf = self;NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));self.block = ^&#123; __strong typeof(self) strongSelf = weakSelf; NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));&#125;;self.block();NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self))); 我们可以通过 Clang 对上面的三个例子做一下编译，通过编译后的 C 代码（接下来所展示代码都是经过简化），我们可以推导出 self 的引用计数变化。 🌰1 的 C 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Block 结构体。这个大家可以通过其他的资料去看看，我们今天主要是来探寻一下 self 的旅程，这里就不对 Block 本身做更详细的介绍struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;// ^&#123;&#125; 的实现struct __BlockTest__test_block_impl_0 &#123; struct __block_impl impl; struct __BlockTest__test_block_desc_0* Desc; BlockTest *const __strong self; __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __strong _self, int flags=0) : self(_self) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;// Block 方法static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123; BlockTest *const __strong self = __cself-&gt;self; // bound by copy self;&#125;// Block 的 copy 操作static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;// Block 的 dispose 操作static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;// 描述 Block 的 copy 和 disposestatic struct __BlockTest__test_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*); void (*dispose)(struct __BlockTest__test_block_impl_0*);&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;// 方法主体static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123; ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, self, 570425344))); ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))();&#125; 在方法主体里面首先会构造一个 __BlockTest__test_block_impl_0 的结构体，该结构体捕获了 self； __BlockTest__test_block_impl_0 的构造函数中使用了 __strong 来捕获 self，所以我们知道在构造的时候默认是使用 __strong 来捕获外部的对象变量，此时 self 的引用计数应该要 +1； Block 被构造出来之后需要被赋值给 self，我们知道在 ARC 模式下此时的 Block 会执行 Copy 操作，从 _NSConcreteStackBlock 变成 _NSMallocBlock； Block 通过 __BlockTest__test_block_desc_0_DATA 找到 Copy 方法的具体实现 __BlockTest__test_block_copy_0，从上面的代码中我们知道该方法的实现是通过 _Block_object_assign 来实现的（对于这个方法的实现细节暂时还没有找到更相信的资料，有知道的可以麻烦告诉一下），通过名字我们可以猜测出该方法只是把捕获的变量地址直接拷贝一份到堆内存中，但是不会引起引用计数的变化； 当 Block 被真正执行的时候会通过 __block_impl 的 FuncPtr 找到真正的实现代码 __BlockTest__test_block_func_0，我们观察到在这个方法里面有这样一句代码 BlockTest *const __strong self = __cself-&gt;self，很明显此时 self 的引用计数会 +1，当该 __BlockTest__test_block_func_0 执行完毕之后还是会释放 self 的，此时引用计数会 -1； 从上面的分析过程中，我们知道由于 Block 在构造的时候默认就对捕获的 self 进行了强引用，导致 self 的引用计数 +1；而又由于 self 持有了 Block，所以这里就造成了循环引用的问题。 我们来看 🌰2 能不能解决这个问题？ 🌰2 的 C 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839// ^&#123;&#125; 结构体struct __BlockTest__test_block_impl_0 &#123; struct __block_impl impl; struct __BlockTest__test_block_desc_0* Desc; BlockTest *const __weak weakSelf; __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;// Block 方法static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123; BlockTest *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy weakSelf;&#125;// Block 的 copy 操作static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;// Block 的 dispose 操作static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;// 描述 Block 的 copy 和 disposestatic struct __BlockTest__test_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*); void (*dispose)(struct __BlockTest__test_block_impl_0*);&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;// 方法主体static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123; __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self; ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344))); ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))();&#125; 方法主体会先用 __weak 初始化一个 weakSelf，此时 self 的引用计数是不会发生变化的；之后会构造一个__BlockTest__test_block_impl_0 的结构体，该结构体捕获了 weakSelf； __BlockTest__test_block_impl_0 的构造函数中使用了 __weak 来捕获 weakSelf，所以我们知道此时 self 的引用计数应该要也是不会发生变化的； 然后把该结构体赋值给 self.block，block 结构体被从栈复制到堆的时候使用了 _Block_object_assign，所以此时 self 的引用计数不会发生变化 然后 block 在被执行的时候做了一下 __weak 的操作 BlockTest *const __weak weakSelf = __cself-&gt;weakSelf，这时候 self 的引用计数也不会发生变化 由于 block 对 weakSelf 没有强引用，所以在 block 执行完成之后也不需要做释放 weakSelf 的工作 所以，在该例子中 block 无法强引用 weakSelf，weakSelf 的引用计数没有发生任何变化。由于 self 没有被 block 强应用，所以当 self 要被释放的时候，block 也会被释放，这就解决了我们 🌰1 中的循环引用的问题。但是在 block 方法执行的过程中，self 对象有可能已经被释放了，此时如果你还去使用 weakSelf 就有可能造成奔溃的情况。 🌰3 的 C 代码如下： 123456789101112131415161718192021222324252627282930313233struct __BlockTest__test_block_impl_0 &#123; struct __block_impl impl; struct __BlockTest__test_block_desc_0* Desc; BlockTest *const __weak weakSelf; __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123; BlockTest *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy __attribute__((objc_ownership(strong))) typeof(self) strongSelf = weakSelf; &#125;static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;static struct __BlockTest__test_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*); void (*dispose)(struct __BlockTest__test_block_impl_0*);&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123; __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self; ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344))); ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))(); &#125; 前面的步骤都跟 🌰2 中的一样，关键是在 Block 的方法实现里面有点不一样。我们来看看 __BlockTest__test_block_func_0，它首先调用了 BlockTest *const __weak weakSelf = __cself-&gt;weakSelf， 所以它此时的引用计数不会发生变化；但是接下来又用 objc_ownership(strong) 来强引用 weakSelf，所以此时 self 的引用计数 +1。这就保证了在函数执行的过程中，Block 会一直持有 self，知道 Block 执行完毕之后会释放 weakSelf。 所以 🌰3 完美的解决了循环应用和直接使用 __weak 可能导致奔溃的问题。 最后，说一下关于 _Block_object_assign 的猜想： 1_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/); 通过上面的例子，我们知道 Block 在构造的时候就会对捕获的变量进行内存管理（强引用和弱引用），所以当 Block 在做 Copy 操作的时候其实没有必要对它捕获的变量再做一遍内存管理了。这也应该是 Block 的 Copy 操作使用了 _Block_object_assign 这种不会导致引用计数发生变化的方式来实现的原因。","categories":[{"name":"技术","slug":"技术","permalink":"https://hparis.github.io/blog/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://hparis.github.io/blog/tags/Objective-C/"},{"name":"Block","slug":"Block","permalink":"https://hparis.github.io/blog/tags/Block/"}]},{"title":"常用工具","slug":"常用工具","date":"2018-04-09T02:53:18.333Z","updated":"2018-04-23T08:18:41.327Z","comments":true,"path":"2018/04/09/常用工具/","link":"","permalink":"https://hparis.github.io/blog/2018/04/09/常用工具/","excerpt":"","text":"Ruby版本管理工具 - rvm $ rvm list 列出已安装的 ruby 版本 $ rvm list kn=own 显示 local + remote 的 ruby 版本 $ rvm use [ruby-version] 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本 $ rvm remove [ruby-version] 删除 ruby 版本 包管理工具 - gem $ gem install [gem-package] 安装 gem 包 $ gem update 更新 gem 包 $ gem update --system 更新 gem 本身 $ gem install [gem-package] 安装 gem 包 $ gem list 列出所有安装的 gem 包 $ gem remove [gem-package] 删除安装过的 gem 包 常用工具cocoapods gem instal cocoapods 安装 cocoapods pod setup 初始化和更新 Pod 库 pod install 根据当前目录的 Podfile 文件安装 Pod 库 pod update 更新 Podfile 文件中的 Pod 库 Python版本管理工具 - pyenvJavaScript包管理工具 - npm包管理工具 - brew","categories":[{"name":"技术","slug":"技术","permalink":"https://hparis.github.io/blog/categories/技术/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://hparis.github.io/blog/tags/其他/"}]},{"title":"如何用 Objective-C 实现一个死锁","slug":"如何用-Objective-C-实现一个死锁","date":"2018-04-01T20:29:42.000Z","updated":"2018-04-01T14:16:27.166Z","comments":true,"path":"2018/04/02/如何用-Objective-C-实现一个死锁/","link":"","permalink":"https://hparis.github.io/blog/2018/04/02/如何用-Objective-C-实现一个死锁/","excerpt":"","text":"当系统存在两个线程及以上的时候，双方都在等待对方停止执行，以获得系统资源，但是没有一方提前退出的时候就叫做死锁。 那在 Objective-C 里面如何实现死锁呢： 12345678910111213141516171819202122self.lock1 = [NSLock new];self.lock2 = [NSLock new]; dispatch_async(dispatch_queue_create(&quot;com.papa.task1&quot;, DISPATCH_QUEUE_SERIAL), ^&#123; [self.lock1 lock]; NSLog(@&quot;task1 获得 lock1&quot;); sleep(2); [self.lock2 lock]; NSLog(@&quot;task1 获得 lock2&quot;); [self.lock2 unlock]; [self.lock1 unlock];&#125;);dispatch_async(dispatch_queue_create(&quot;com.papa.task2&quot;, DISPATCH_QUEUE_SERIAL), ^&#123; [self.lock2 lock]; NSLog(@&quot;task2 获得 lock2&quot;); sleep(2); [self.lock1 lock]; NSLog(@&quot;task2 获得 lock1&quot;); [self.lock1 unlock]; [self.lock2 unlock];&#125;); 我们可以看到最后控制台输出的结果是： 12task2 获得 lock2task1 获得 lock1 或 12task2 获得 lock2task1 获得 lock1 为什么是两种结果呢，可以参考我的「初步了解 GCD」。 但是不管如何，这两种结果都没有输出 task1 获得 lock2 或 task2 获得 lock1。我们来分析一下： task1 获得 lock1，然后沉睡 2s task2 获得 lock2，然后沉睡 2s task1 经过 2s 的沉睡之后想要去获取 lock2，此时发现 lock2 已经被使用，那就继续等待 task2 经过 2s 的沉睡之后想要去获取 lock1，此时发现 lock1 已经被使用，那就继续等待 task1 又被唤醒想要去获取 lock2，此时 lock2 依旧没有被 task2 释放，只能继续等待 task2 又被唤醒想要去获取 lock1，此时 lock1 依旧没有被 task1 释放，只能继续等待 … … 于是 task1 和 task2 都在等待对方释放资源，但是自己也不退出也不释放资源，最终导致死锁的产生。 接下来，我们来讨论另外一个例子是不是死锁： 123456// 某个按钮的点击事件- (void)onClick:(UIEvent *)event &#123; dispatch_sync(dispatch_get_main_queue(), ^&#123; ... &#125;);&#125; 相信大家都知道上面这个例子会导致主线程发生阻塞的现象，但是这是因为死锁造成的么？ Submits a block to a dispatch queue for synchronous execution. Unlike dispatch_async, this function does not return until the block has finished. Calling this function and targeting the current queue results in deadlock. 在官方文档里面明确的说了，这就是死锁。我们可以把上面的例子“翻译”一下： 123456789101112131415161718// 首先进入 onClick 的时候，我们可以认为此时是需要加锁的// 某个按钮的点击事件- (void)onClick:(UIEvent *)event &#123; [self.lock1 lock]; // 此时我们可以认为 dispatch_sync 是在获取 block 里面的 lock2 &#123; [self.lock2 lock]; // 放在主线程执行，那么它也需要获得 lock1 [self.lock1 lock]; [self.lock1 unlock]; [self.lock2 unlock]; &#125; [self.lock1 unlock];&#125; 我们可以看到其实上面的情况就是两个任务都在同时竞争主线程的资源，并且谁都没有退出最终导致死锁的产生。但是这两个任务并不是普通的两个线程在竞争资源，而是都在主线程上，一个嵌套另外一个。而且这种特殊的情况，在运行的时候会直接导致奔溃，而不像我们一开始的例子一样只是在互相等待。但是既然苹果把这种情况也称为死锁，那我们就当做死锁来看待，毕竟他们都是在竞争系统资源。","categories":[{"name":"技术","slug":"技术","permalink":"https://hparis.github.io/blog/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://hparis.github.io/blog/tags/Objective-C/"},{"name":"GCD","slug":"GCD","permalink":"https://hparis.github.io/blog/tags/GCD/"}]},{"title":"说说 Objective-C 中的 Copy 操作","slug":"说说-Objective-C-中的-Copy-操作","date":"2018-03-23T16:35:55.000Z","updated":"2018-04-18T09:42:48.943Z","comments":true,"path":"2018/03/24/说说-Objective-C-中的-Copy-操作/","link":"","permalink":"https://hparis.github.io/blog/2018/03/24/说说-Objective-C-中的-Copy-操作/","excerpt":"","text":"浅拷贝（Shallow copies）和深拷贝（Deep copies）我们都知道 Objective-C 中把 Copy 操作分成两种：浅拷贝（Shallow copies）和深拷贝（Deep copies）。学过 C 语言的同学应该知道区分这两种操作的区别其实很简单： 浅拷贝（Shallow copies）: 指针拷贝，指向的还是同一块内容的地址深拷贝（Deep copies）: 内容拷贝 但是在 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别。我们先来看看 Apple 的官方文档给出的一张图： 通过上图可以看出浅拷贝过后，Array 1 和 Array 2 的元素都是相同的指针地址，指向相同的内容；深拷贝过后，内容被拷贝一份新的出来，Array 2 的元素的指针地址都和 Array 1 不一样，因为 Array2 的元素的指针地址都指向新的内容。 immutable 和 mutable 对象的拷贝在 Objective-C 中一般会用 copy 或 mutableCopy 进行拷贝操作，我们可以通过观察指针变化来确定这两种拷贝操作是浅复制还是深复制。 immutable 对象的复制操作 1234567NSString * aName = @&quot;帕帕&quot;;NSString * bName = [aName copy];NSMutableString * cName = [aName mutableCopy];NSLog(@&quot;aName 的指针：%p&quot;, aName);NSLog(@&quot;bName 的指针：%p&quot;, bName);NSLog(@&quot;cName 的指针：%p&quot;, cName); 输出的结果： 123aName 的指针：0x103d34070bName 的指针：0x103d34070cName 的指针：0x600000250dd0 mutable 对象的复制操作 1234567NSMutableString * aName = [NSMutableString stringWithString:@&quot;帕帕&quot;];NSString * bName = [aName copy];NSMutableString * cName = [aName mutableCopy];NSLog(@&quot;aName 的指针：%p&quot;, aName);NSLog(@&quot;bName 的指针：%p&quot;, bName);NSLog(@&quot;cName 的指针：%p&quot;, cName); 输出的结果： 123aName 的指针：0x60000025e150bName 的指针：0x600000222900cName 的指针：0x60000025e450 通过上面两个例子以及它们的输出结果，我们可以得出下面这个表格： imutable 对象 mutable 对象 copy 浅复制 深复制 mutableCopy 深复制 深复制 上面的规则对集合对象也是一样的：NSArray 和 NSMutableArray，NSDictionary 和 NSMutableDictionary，NSSet 和 NSMutableSet 单层深复制（one-level-deep）123456789101112NSMutableString * aString = [NSMutableString stringWithString:@&quot;\bHello&quot;]NSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];NSArray * bArray = [aArray copy];NSMutableString * bString = bArray[0];[bString appendString:@&quot; \b帕帕&quot;]; NSLog(@&quot;aArray 的指针：%p&quot;, aName);NSLog(@&quot;bArray 的指针：%p&quot;, bName);NSLog(@&quot;aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@&quot;, aArray[0], aArray[0]);NSLog(@&quot;bArray 第一个元素的指针: %p，\b\b内容：%@&quot;, bArray[0], bArray[0]); 输出结果： 1234aArray 的指针：0x60000025d9a0bArray 的指针：0x60000002cf60aArray \b\u001d\b第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕bArray 第一个元素的指针: 0x60000025d880，\b\b内容：\bHello \b帕帕 从 aArray 到 bArray 的 copy 操作之后，它们的指针地址发生了变化，按照我们之前的理解这是深拷贝。深拷贝会把 aArray 的元素都拷贝一份，那为什么改变 bArray 的元素的值会导致 aArray 的元素的值也发生了变化呢？ 完全深复制那我们要如何做到真正的深复制呢？我们可以简单的把上面的代码改一下： 1234567891011121314NSMutableString * aString = [NSMutableString stringWithString:@&quot;\bHello&quot;]NSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];// 只需要改动这一行代码NSArray *bArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:aArray]];NSMutableString * bString = bArray[0];[bString appendString:@&quot; \b帕帕&quot;]; NSLog(@&quot;aArray 的指针：%p&quot;, aName);NSLog(@&quot;bArray 的指针：%p&quot;, bName);NSLog(@&quot;aArray \b\u001d\b第一个元素的指针: %p，\b\b内容：%@&quot;, aArray[0], aArray[0]);NSLog(@&quot;bArray 第一个元素的指针: %p，\b\b内容：%@&quot;, bArray[0], bArray[0]); 输出结果： 1234aArray 的指针：0x600000259cb0bArray 的指针：0x600000030ac0aArray \b\u001d\b第一个元素的指针: 0x604000452120，\b\b内容：\bHellobArray 第一个元素的指针: 0x604000452780，\b\b内容：\bHello \b帕帕 只要先对集合对象分别用 NSKeyedArchiver 和 NSKeyedUnarchiver 就可以真正完成对一个集合对象的深复制。 Copy 和 内存管理之前我们说过 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别，那差别在什么地方呢？内存中做复制操作是很耗费资源的，而我们都知道 Objective-C 高效的一个原因在于它的内存管理机制是引用计数。我们前面分析的深拷贝是对内容的拷贝，这一点跟 C 语言的一样。C 语言的浅拷贝是指针的拷贝，它依旧做了一次复制操作。而在 Objective-C 中，浅拷贝其实只是引用计数的增加，不信的话，我们可以看看下面的例子： 123456NSArray * aArray = [NSArray arrayWithObjects:@&quot;帕帕&quot;, nil];NSLog(@&quot;aArray 的指针：%p，\b\b引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));NSArray * bArray = [aArray copy];NSLog(@&quot;aArray 的指针：%p，\b\b引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));NSMutableArray * cArray = [aArray mutableCopy];NSLog(@&quot;aArray 的指针：%p，\b\b引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray))); 输出结果： 123aArray 的指针：0x604000443ba0，\b\b引用计数：2aArray 的指针：0x604000443ba0，\b\b引用计数：3aArray 的指针：0x604000443ba0，\b\b引用计数：3 为什么 aArray 刚出来的时候的引用计数是 2？因为 [NSArray arrayWithObjects:@&quot;帕帕&quot;, nil] 本身就是一个对象，它的引用计数就是 1；然后我们又定义了 aArray 来引用这个对象，此时它的引用计数就增加了 1，变成了 2；之后我们对 aArray 进行了 copy 操作，发现它的引用计数变成了 3，所以这里的 copy 操作其实相当于 retaion；最有我们对 aArray 进行了 mutableCopy 操作，此时它的引用计数还是 3，没有发生变化，因为这个时候进行了内容复制。 所以在 Objective-C 中对一个 imutable 对象进行的 copy（浅复制）操作，其实都只会引起引用计数的变化，而不会在内存中做出任何拷贝操作，包括指针拷贝。 NSCopying 和 NSMutableCopying如果我们有一个自定义的对象，并且对其进行 copy 操作的话，会发生什么： 123456789// Person@interface Person: NSObject@property (nonatomic, copy) NSString * name;@end@implementation Person@endPerson * aPerson = [Person new];Person * bPerson = [aPerson copy]; Xcode 直接奔溃了： 12// 崩溃*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[Person copyWithZone:]: unrecognized selector sent to instance 0x60000000d5f0&apos; 为什么我们对一个 Person 对象使用了 copy，Xcode 确报的是找不到 copyWithZone: 这个 selector 的错误。 这是因为 Objective-C 中规定，一个对象如果想要使用 copy 或 mutableCopy 的操作，必须要实现 NSCopying 或 NSMutableCopying 这两个协议。这两个协议规定了对象需要实现 copyWithZone: 或 mutableCopyWithZone: 这两个方法，因为对一个对象做 copy 或 mutableCopy 最后都会去调用这两个方法来做最终的实现。上面例子中的集合对象能够使用 copy 和 mutableCopy 操作是也因为它们都实现了 NSCopying 和 NSMutableCopying 协议。 我们来看看如何对一个普通的对象实现 NSCopying 协议： 12345678910111213@interface Person: NSObject &lt;NSCopying&gt;@property (nonatomic, copy) NSString * name;@property (nonatomic, strong) NSMutableArray * mArray;@end@implementation Person- (instancetype)copyWithZone:(NSZone *)zone &#123; Person * person = [[self class] new]; person.name = [self.name copy]; person.mArray = [self.mArray mutableCopy]; return person;&#125;@end 这样，我们就可以愉快的使用 [Person copy] 了。当然，这里 Person 的 mArray 也只是单层深复制，如果想要实现完全深复制的话，我们可以用 NSKeyedArchiver 和 NSKeyedUnarchiver 来完成对 mArray 的完全深复制。 Block 和 Copy简单说一下，在 Objective-C 中，Block 的 copy 是一种特殊的操作。因为 Block 是一种结构体，它无法实现 NSCopying 或 NSMutableCopying 协议，但是它却可以调用 copy 方法。这是由 Block 的结构体决定的： Block 里面的 descriptor 有 copy 的函数指针，当对 Block 执行 copy 操作最后都会通过该函数指针进行真正的操作。这也是 Bloc看不需要实现 NSCopying 和 NSMutableCopying 就能调用 copy 方法的原因。 参考资料： https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html https://www.zybuluo.com/MicroCai/note/50592","categories":[{"name":"技术","slug":"技术","permalink":"https://hparis.github.io/blog/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://hparis.github.io/blog/tags/Objective-C/"}]},{"title":"如何在 iOS 上自定义 React Native Component","slug":"如何在-iOS-上自定义-React-Native-Component","date":"2018-03-19T17:22:09.000Z","updated":"2018-03-23T08:36:38.931Z","comments":true,"path":"2018/03/20/如何在-iOS-上自定义-React-Native-Component/","link":"","permalink":"https://hparis.github.io/blog/2018/03/20/如何在-iOS-上自定义-React-Native-Component/","excerpt":"","text":"当我们要在 iOS 端实现一个 React Native 可用的 Component，比如： 1&lt;MapView onRegionChange=&#123;(event) =&gt; &#123;&#125;&#125; zoomLevel=&#123;2&#125; /&gt; 那么我们基本上就是要解决下面这三个问题： 如何把 iOS 上的 UI 暴露给 React Native 端？ 如何在 React Native 给 iOS 的 UI 传值？ 如何在 React Native 中响应 iOS 的事件？ 这三个问题可以在官方文档找到答案。 如何把 iOS 上的 UI 暴露给 React Native 端首先你需要创建一个继承自 RCTViewManager 的子类： 1234567891011121314151617181920212223// RNTMapManager.m#import &lt;MapKit/MapKit.h&gt;#import &lt;React/RCTViewManager.h&gt;// 继承 RCTViewManager@interface RNTMapManager : RCTViewManager@end@implementation RNTMapManager// 调用 RCT_EXPORT_MODULE 暴露该类的名字给 React Native 使用。如果你想自定义// 暴露给 React Native 的名字时，你需要 RCT_EXPORT_MODULE(YOUR_CUSTOM_NAME)。RCT_EXPORT_MODULE()// 由于 RCTViewManager 是 NSObject，所以这里必须需要实现该方法来告诉// React Native 去使用哪个 UIView- (UIView *)view&#123; return [MKMapView new];&#125;@end 这样我们就可以在 React Native 使用 MapView 了： 1234567891011121314151617// MapView.jsimport &#123; requireNativeComponent &#125; from &apos;react-native&apos;;// requireNativeComponent 会自动把 iOS 上的 RNTMapManager 解析成 RNTMap。// 如果去掉 iOS 上的 Manager 后缀会有什么影响？嗯，没有任何影响。module.exports = requireNativeComponent(&apos;RNTMap&apos;, null);// MyApp.jsimport MapView from &apos;./MapView.js&apos;;...render() &#123; return &lt;MapView /&gt;;&#125; 如何在 React Native 给 iOS 的 UI 传值如果需要传值给 iOS 上的 UI，那么需要使用另外一个宏： 1RCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL) 这时候就可以在 React Native 上使用了： 1&lt;MapView zoomEnable=&#123;true&#125; /&gt; 这里需要注意的是，RCT_EXPORT_VIEW_PROPERTY 所暴露的属性必须是之前我们说的 UIView（即继承于 RCTViewManager 并通过 - (UIView *)view; 返回的 View）已经存在的属性。 除了上面的宏 RCT_EXPORT_VIEW_PROPERTY 可以暴露属性给 React Native 使用之外还有下面 5 种（这里先挖个坑，回头研究一下再说说下面五种的作用和区别）： RCT_REMAP_VIEW_PROPERTY RCT_CUSTOM_VIEW_PROPERTY RCT_EXPORT_SHADOW_PROPERTY RCT_REMAP_SHADOW_PROPERTY RCT_CUSTOM_SHADOW_PROPERTY 如何在 React Native 中响应 iOS 的事件要想在 React Native 中响应 iOS 的事件，只需要暴露用 RCTBubblingEventBlock 或 RCTDirectEventBlock 定义的属性即可，代码如下： 1234567891011121314151617181920// RNTMapView.h#import &lt;MapKit/MapKit.h&gt;#import &lt;React/RCTComponent.h&gt;// 由于 MKMapView 没有任何 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的// 属性，所以这里需要定义 MKMapView 的子类 RNTMapView@interface RNTMapView: MKMapView// 需要暴露给 React Native 的事件属性@property (nonatomic, copy) RCTBubblingEventBlock onRegionChange;@end// RNTMapView.m#import &quot;RNTMapView.h&quot;@implementation RNTMapView@end 然后我们需要在 RCTViewManager 中暴露 onRegionChange 给 React Native 使用： 123456789101112131415161718192021// RNTMapManager.m#import &lt;MapKit/MapKit.h&gt;#import &lt;React/RCTViewManager.h&gt;#import &quot;RNTMapView.h&quot;@interface RNTMapManager : RCTViewManager &lt;MKMapViewDelegate&gt;@end@implementation RNTMapManagerRCT_EXPORT_MODULE()// 暴露 RNTMapView 中的 `onRegionChange` 属性RCT_EXPORT_VIEW_PROPERTY(onRegionChange, RCTBubblingEventBlock)- (UIView *)view &#123; // 这里需要返回 RNTMapView 而不是 MKMapView return [RNTMapView new];&#125;@end 重要的事说三遍：使用 RCTBubblingEventBlock 或 RCTDirectEventBlock 所定义的事件都必须加上前缀 on，否则 React Native 无法接收到事件使用 RCTBubblingEventBlock 或 RCTDirectEventBlock 所定义的事件都必须加上前缀 on，否则 React Native 无法接收到事件使用 RCTBubblingEventBlock 或 RCTDirectEventBlock 所定义的事件都必须加上前缀 on，否则 React Native 无法接收到事件","categories":[{"name":"技术","slug":"技术","permalink":"https://hparis.github.io/blog/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/tags/iOS/"},{"name":"RN","slug":"RN","permalink":"https://hparis.github.io/blog/tags/RN/"}]},{"title":"Raspberry PI 基本使用","slug":"Raspberry-PI-基本使用","date":"2018-03-05T22:04:56.000Z","updated":"2018-03-23T08:45:00.633Z","comments":true,"path":"2018/03/06/Raspberry-PI-基本使用/","link":"","permalink":"https://hparis.github.io/blog/2018/03/06/Raspberry-PI-基本使用/","excerpt":"","text":"1. 保证 Raspberry PI 能够在外网使用12// 在你的 Raspberry PI 上使用 autossh 来实现不掉线的反向代理：autossh -M 5678 -fNR 2018:localhost:22 root@54.219.12.213 12// 在你的外网服务器（比如上面例子中的：54.219.12.213）上可以使用 ssh 登录你的 Raspberry PIssh -p 2018 pi@127.0.0.1","categories":[{"name":"Raspberry PI","slug":"Raspberry-PI","permalink":"https://hparis.github.io/blog/categories/Raspberry-PI/"}],"tags":[{"name":"Raspberry PI","slug":"Raspberry-PI","permalink":"https://hparis.github.io/blog/tags/Raspberry-PI/"}]},{"title":"redux 之页面跳转","slug":"redux-之页面跳转","date":"2018-02-26T17:48:56.000Z","updated":"2018-03-23T08:45:29.506Z","comments":true,"path":"2018/02/27/redux-之页面跳转/","link":"","permalink":"https://hparis.github.io/blog/2018/02/27/redux-之页面跳转/","excerpt":"","text":"最近正在用 React Native 重构整个项目，我们用了 react-native-navigation 这个库来作为项目的导航控制器。所以，我们平常会把页面跳转逻辑的时候放在 Screen 里面的，比如: 12345678910111213class FirstScreen extends React.Component &#123; // 点击事件 _someAction = () =&gt; &#123; this.props.navigator.push(&#123; screen: 'example.SecondScreen', &#125;); &#125; render = () =&gt; &#123; ... &#125;&#125; 一般情况下，上面的写法没有问题。但是直到我们碰到这样一个需求的时候就抓瞎了：点击一个 PDF 文件，如果 PDF 文件没有下载就先去下载，下载完成之后自动跳转到 PDF 阅读器。由于用了 redux 之后，我们就增加一个 finished 的 state 来判断是否已经下载完成。示例代码如下： 12345678910111213141516171819202122232425262728293031class ExampleScreen extends React.Component &#123; componentWillReceiveProps = (nextProps) =&gt; &#123; // 这里判断下载状态是否已完成，完成的话就去跳转 if (nextProps.finished === true) &#123; // 这里需要重置一下状态，不然其他 state 发生变化会多次触发页面的跳转 this.props.dispatch(resetFinished()); this.props.navigator.push(&#123; screen: 'example.PDFScreen', &#125;); &#125; &#125; // 点击事件 _someAction = () =&gt; &#123; // openPDF() 这个 action 会自动去下载 PDF 文件，然后修改 finished 的状态 this.props.dispatch(openPDF()); &#125; render = () =&gt; &#123; ... &#125;&#125;const mapStateToProps = state =&gt; &#123; return &#123; finished: state.finished &#125;&#125;;export default connect(mapStateToProps)(ExampleScreen); 上面的做法是可以实现我们的需求，但是这种写法很蛋疼。因为当你在调用用 openPDF() 的时候，你以为后面的事不需要你操心，然后这个时候有人告诉你还需要在其他地方增加一个中间状态去补充 openPDF() 的后续逻辑处理。 经过讨论之后，我们决定改成用 callback 的方式来实现： 12345678910111213141516class ExampleScreen extends React.Component &#123; // 点击事件 _someAction = () =&gt; &#123; // openPDF() 是一个异步 action this.props.dispatch(openPDF(callback: () =&gt; &#123; this.props.navigator.push(&#123; screen: 'example.PDFScreen', &#125;); &#125;)); &#125; render = () =&gt; &#123; ... &#125;&#125; 使用 callback 的好处就是去掉了一个烦人的中间状态，并且从阅读体验来说很容易让读者明白这个点击事件在干什么。但是在 redux 的 action 方法中增加一个 callback 的调用，看起来也有点不伦不类的。虽然我认为 callback 和其他参数具有相同的法律地位。 其实最好的实现是，这个点击事件应该连页面的跳转逻辑也不需要处理： 1234567891011class ExampleScreen extends React.Component &#123; // 点击事件，这个事件只做一件事就是去 dispatch 一个 openPDF() 的 action _someAction = () =&gt; &#123; this.props.dispatch(openPDF()); &#125; render = () =&gt; &#123; ... &#125;&#125; 像上面这种实现，我们也就只能在 openPDF() 里动手脚了： 123456789// action.jsexport const openPDF = await () =&gt; &#123; return dispatch =&gt; &#123; // 异步下载 PDF async downloadPDF(); // 完成之后通过 router 去实现页面跳转 dispatch(openRouter('PDFScreen')); &#125;;&#125; 这里就不再详细说 router 的实现细节了，因为网上有很多现成的资料。（PS: 主要是我也还没看到这一块） 从页面（Screen）的角度来说，我认为这样的处理是最合适的。因为 Screen 只需要关注本页面的 state 和 action，至于跳转的逻辑交给后面的 action 来处理是最好的。","categories":[{"name":"技术","slug":"技术","permalink":"https://hparis.github.io/blog/categories/技术/"}],"tags":[{"name":"RN","slug":"RN","permalink":"https://hparis.github.io/blog/tags/RN/"},{"name":"redux","slug":"redux","permalink":"https://hparis.github.io/blog/tags/redux/"}]},{"title":"Swift High-Performance Tip 1：Array 和 ContiguousArray","slug":"Swift-High-Performance-Tip 1：Array和ContiguousArray","date":"2017-09-05T15:30:56.000Z","updated":"2018-03-23T08:42:53.310Z","comments":true,"path":"2017/09/05/Swift-High-Performance-Tip 1：Array和ContiguousArray/","link":"","permalink":"https://hparis.github.io/blog/2017/09/05/Swift-High-Performance-Tip 1：Array和ContiguousArray/","excerpt":"","text":"Array 是随机存储的（random-access）集合类型。 ContiguousArray 是连续存储（contiguously stored）的数组，并且不允许和 NSArray 进行桥接的。 当我们的数组元素是 Class 或 @objc protocol 类型的话，并且我们不需要在 Objective-C 中使用该数组的话，那么我们最好使用 ContiguousArray。这是因为 Array 需要额外的资源来处理跟 NSArray 的桥接功能，但是 ContiguousArray 则不需要，所以 ContiguousArray 比 Array 的效率要高。 1234567class A &#123;&#125;// 不要用Array: let array = Array&lt;A&gt;()let contiguousArray = ContiguousArray&lt;A&gt;() 另外需要注意的是官方文档说如果数组元素不是 Class 和 @objc protocol 类型的话，Array 和 ContiguousArray 的效率是一样的。（我猜测是因为如果 Array 的元素都是 Struct 类型的话，它就不需要消耗资源来处理桥接的问题了。） Efficiency is equivalent to that of Array, unless Element is a class or @objc protocol type, in which case using ContiguousArray may be more efficient. 但是 @Paul Hudson 在他的《Pro Swift》中说他发现即使数组元素是 Struct 类型的话，ContiguousArray 也要比 Array 更快。我们来看看他给出的例子： 123456789101112let array2 = Array&lt;Int&gt;(1...1000000)let array3 = ContiguousArray&lt;Int&gt;(1...1000000)var start = CFAbsoluteTimeGetCurrent()array2.reduce(0, combine: +)var end = CFAbsoluteTimeGetCurrent() - startprint(\"Took \\(end) seconds\")start = CFAbsoluteTimeGetCurrent()array3.reduce(0, combine: +)end = CFAbsoluteTimeGetCurrent() - startprint(\"Took \\(end) seconds\") 经过我的测试，上面的代码中 ContiguousArray 只用了0.19秒而 Array 用了0.38秒，所以 ContiguousArray 确实要比 Array 快。 如果大家想在性能上有所提升的话，建议大家可以用 ContiguousArray 试一试。","categories":[{"name":"技术","slug":"技术","permalink":"https://hparis.github.io/blog/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://hparis.github.io/blog/tags/Swift/"}]},{"title":"Shell Tip","slug":"Shell-Tip","date":"2017-09-05T15:30:56.000Z","updated":"2018-04-09T03:12:39.696Z","comments":true,"path":"2017/09/05/Shell-Tip/","link":"","permalink":"https://hparis.github.io/blog/2017/09/05/Shell-Tip/","excerpt":"","text":"记录日常中用到的一些 Bash 脚本，经常更新 Tip 1 : 修改文件里面的内容早上产品有一个小需求就是把工程中的所有网页的标题修改为黑米流量通，可以使用以下命令来实现 1$ find . -name '*.html' -print0 | xargs -0 sed -i '' -e 's/&lt;title&gt;.*&lt;\\/title&gt;/&lt;title&gt;黑米流量通&lt;\\/title&gt;/g' find 查找命令，可以用 man find 查看更多的信息 . 代表当前目录 -name find 命令的参数，表示要查找的文件名 -print0 是一种不换行的输出格式，以 ASCII NUL 字符（也就是\\0）作为分隔符。上面的例子可能是 a.html\\0b.html\\0c.html | 这是一个管道符，表示把前面命令的输出作为后面命令的输入 xargs 是用来构造输入参数，并且循环执行每一个参数 -0 表示让 xargs 使用 ASCII NUL 来分隔参数。上面的例子将被分隔成 a.html b.html c.html 三个参数依次执行 sed 这是一个流编辑器，如果传的是文件名会把文件内容读入内存，如果只是普通字符串就会把字符串读入内存 -i 表示要把原来的文件内容做一次备份，后面的 &#39;&#39; 是表示要备份的文件名字，如果没有文件名字就表示不需要备份 -e 表示后面的字符串是一个命令，需要被执行 s/old/new/g 这个是用来替换字符串的命令 Tip 2 : 查找文件的内容把匹配的文件内容的相关文件列出来 1$ find . -name '*.html' -print0 | xargs -0 grep 'PATTERN' Tip 3 : 解决 Homebrew 的权限问题查看 Homebrew 的所有权 1$ ls -al `which brew` 把 Homebrew 的用户和分组修改为 root 和 wheel 1$ sudo chown root:wheel `which brew` 最后还原 Homebrew 的权限（安全） 1$ sudo chown : `chown brew` Tip 4 : 利用 Shell 生成生成 ICON12345678910111213141516171819202122232425262728#!/bin/sh#此脚本是用来生成 iPhone 和 iPad 所需 icon 的不同尺寸的，最好是准备一张 1024x1024 的 Icon 图片filename=\"icon.png\"dirname=\"icon\"name_array=(\"Icon-20.png\" \"Icon-20@2x.png\" \"Icon-20@3x.png\"\"Icon-29.png\" \"Icon-29@2x.png\" \"Icon-29@3x.png\"\"Icon-40.png\" \"Icon-40@2x.png\" \"Icon-40@3x.png\"\"Icon-60@2x.png\" \"Icon-60@3x.png\"\"Icon-76.png\" \"Icon-76@2x.png\"\"Icon-83.5@2x.png\")size_array=(\"20\" \"40\" \"80\"\"29\" \"58\" \"87\"\"40\" \"80\" \"120\"\"120\" \"180\"\"76\" \"152\"\"167\")mkdir $dirnamefor ((i=0;i&lt;$&#123;#name_array[@]&#125;;++i)); do m_dir=$dirname/$&#123;name_array[i]&#125; cp $filename $m_dir sips -Z $&#123;size_array[i]&#125; $m_dirdone Tip5 : 使用 Python 共享当前目录利用下面的命令可以暂时开启一个端口号为 8000 的 HTTP 服务，其他人只需要在浏览器输入 http://ip-address:8000 即可浏览共享目录下的文件 1$ python -m SimpleHTTPServer Tip6 : 加密和解密文件 加密 1$ tar czf - &#123;SRC_DIR&#125; | openssl des3 -salt -k \"&#123;KEY&#125;\" -out &#123;DIST_PACKAGE&#125;.tar.gz 示例： 目录名 paris_code，秘钥 meta#com，输出包 paris_code_20161008.tar.gz 1$ tar czf - paris_code | openssl des3 -salt -k \"meta#com\" -out paris_code_20161008.tar.gz 解密 第一步：获取代码压缩文件包 下载地址 http://XXXX.com/paris_code_20161008.tar.gz 第二步：解密文件（OS X / Linux only） 在 Terminal 进入压缩文件包同级目录，输入以下命令： 1$ openssl des3 -d -k \"meta#com\" -salt -in paris_code_20161008.tar.gz | tar xzf - Tip7: iOS 打包命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788echo \"----------------\"echo \"Begin Build!\"PROJECT_NAME=\"orbit\"BUILD_DATE=\"$(date +'%Y%m%d')\"BUNDLE_ID=\"com.meta.paris\"cd $&#123;WORKSPACE&#125;#/usr/local/bin/npm installif [ -d \"$&#123;WORKSPACE&#125;/build\" ]; then if ls $&#123;WORKSPACE&#125;/build/**/*.ipa 1&gt; /dev/null 2&gt;&amp;1; then rm -rf $&#123;WORKSPACE&#125;/build/**/*.ipa; fi; if ls $&#123;WORKSPACE&#125;/build/**/*.xcarchive 1&gt; /dev/null 2&gt;&amp;1; then rm -rf $&#123;WORKSPACE&#125;/build/**/*.xcarchive; fi;else mkdir $&#123;WORKSPACE&#125;/build; fi;echo \"计算今天的 Build Version\"if [ -d \"$&#123;WORKSPACE&#125;/build/$&#123;BUILD_DATE&#125;\" ]; then #如果不加上面的 if, Jenkins 无法直接执行下面的命令❓ BUILD_DATE_COUNT=$(ls $&#123;WORKSPACE&#125;/build | grep \"^$&#123;BUILD_DATE&#125;\" -c) if [ $&#123;BUILD_DATE_COUNT&#125; -lt 10 ]; then BUILD_DATE_COUNT=\"0$&#123;BUILD_DATE_COUNT&#125;\" fi; BUILD_VERSION=\"$&#123;BUILD_DATE&#125;$&#123;BUILD_DATE_COUNT&#125;\"else BUILD_VERSION=$&#123;BUILD_DATE&#125;fi;echo \"今天的 Build Version 是 $&#123;BUILD_VERSION&#125;\"if [ -d \"$&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;\" ]; then rm -rf $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;; fi;mkdir $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;;if [ -d \"$&#123;WORKSPACE&#125;/Enterprise.plist\" ]; then rm $&#123;WORKSPACE&#125;/Enterprise.plist; fi;#http://www.matrixprojects.net/p/xcodebuild-export-options-plist/Enterprise='&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;teamID&lt;/key&gt; &lt;string&gt;&lt;/string&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;app-store&lt;/string&gt; &lt;key&gt;uploadSymbols&lt;/key&gt; &lt;true/&gt; &lt;key&gt;uploadBitcode&lt;/key&gt; &lt;false/&gt;&lt;/dict&gt;&lt;/plist&gt;'echo $&#123;Enterprise&#125; &gt; $&#123;WORKSPACE&#125;/Enterprise.plistsed -i '' 's/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g' \\$&#123;WORKSPACE&#125;/$&#123;PROJECT_NAME&#125;.xcodeproj/project.pbxprojsed -i '' 's/DEVELOPMENT_TEAM = .*;/DEVELOPMENT_TEAM = \"\";/g' \\$&#123;WORKSPACE&#125;/$&#123;PROJECT_NAME&#125;.xcodeproj/project.pbxproj#动态生成 Build Versionsed -i '' \"/&lt;key&gt;CFBundleVersion&lt;\\/key&gt;/&#123;N;s/&lt;string&gt;.*&lt;\\/string&gt;/&lt;string&gt;$&#123;BUILD_VERSION&#125;&lt;\\/string&gt;/g;&#125;\" \\$&#123;WORKSPACE&#125;/$&#123;PROJECT_NAME&#125;/$&#123;PROJECT_NAME&#125;-Info.plistxcodebuild -workspace $&#123;WORKSPACE&#125;/$&#123;PROJECT_NAME&#125;.xcworkspace \\-scheme $&#123;PROJECT_NAME&#125; -sdk iphoneos \\build CODE_SIGN_IDENTITY=\"iPhone Distribution: Beijing PS Technology Co., Ltd.\" \\PROVISIONING_PROFILE=\"\" \\-configuration Release clean archive \\-archivePath $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;/$&#123;PROJECT_NAME&#125;.xcarchivexcodebuild -exportArchive -exportOptionsPlist $&#123;WORKSPACE&#125;/Enterprise.plist \\-archivePath $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;/$&#123;PROJECT_NAME&#125;.xcarchive \\-exportPath $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;/echo \"----------------\"echo \"Build successfully!\"echo \"Begin Upload to itunes...\"#Use [shenzhen](https://github.com/nomad/shenzhen) to upload the ipa file to itunes connect./usr/local/bin/ipa distribute:itunesconnect -f $&#123;WORKSPACE&#125;/build/$&#123;BUILD_VERSION&#125;/$&#123;PROJECT_NAME&#125;.ipa -a YourAppleID -p YourPassword -i $&#123;BUNDLE_ID&#125; --uploadecho \"Upload successfully!\" Tip8: 重置 iOS 模拟器相信各位在做 iOS 开发的同学都会碰到模拟器上各种神奇的现象，通过重置 iOS 模拟器基本上可以解决大部分问题： 123456// 退出当前的所有模拟器$ osascript -e 'tell application \"iOS Simulator\" to quit'$ osascript -e 'tell application \"Simulator\" to quit'// 清掉之前使用模拟器产生的所有内容$ xcrun simctl erase all","categories":[{"name":"技术","slug":"技术","permalink":"https://hparis.github.io/blog/categories/技术/"}],"tags":[{"name":"tip","slug":"tip","permalink":"https://hparis.github.io/blog/tags/tip/"}]},{"title":"Swift High-Performance Tip 2：final 和 private(fileprivate)","slug":"Swift-High-Performance-Tip 2：final和private(fileprivate)","date":"2017-09-05T15:30:56.000Z","updated":"2018-03-23T08:43:01.021Z","comments":true,"path":"2017/09/05/Swift-High-Performance-Tip 2：final和private(fileprivate)/","link":"","permalink":"https://hparis.github.io/blog/2017/09/05/Swift-High-Performance-Tip 2：final和private(fileprivate)/","excerpt":"","text":"Dynamic dispatch means that program has to determine at run time which method or property is being referred to and then perform an indirect call or indirect access. 我们都知道 Swift 的 class 是可以被继承，function 和 property 是可以被重写的，而这就意味着 Swift 需要 dynamic dispatch 这种机制来完成这些功能。Swift 的 dynamic dispatch 首先会再 method table 查找方法，然后间接调用。很明显这种方式要比直接调用的效率慢，并且用间接调用的方式还会阻止编译器的一些优化无法实现。 那么应该怎么优化呢？ 当我们明确的知道 class、function、property 是不需要 overridden，我们可以通过使用 final 和 private(fileprivate) 这些关键字减少动态派发的发生，从而有效的提高效率。 在 Swift 中，如果被 final 或 private(fileprivate) 修饰的 class、function、property 是不能 overridden，并且调用这些 class、function、property 的时候不再通过 dynamic dispatch 去间接调用，而是直接调用。 所以，通过在必要的代码中使用 final 或 private(fileprivate) 这些关键字进行优化的话，将可以有效提高的效率。 Whole Module Optimization Swift 的 class、function、property 的默认权限都是 internal ，除非我们明确的加上 public 或 private(fileprivate) 关键字才能改变它们的默认权限。 编译器在编译 Module 的时候都是对里面的源文件进行单独编译，这样的话编译器就无法确切的知道被 internal 修饰的 class、function、property 究竟有没有被 overridden。一旦我们开启 Whole Module Optimization 的优化选项，编译器就会同时对整个 Module 的所有源文件进行编译，这个时候编译器就可以知道哪些被 internal 修饰的 class、function、property 没有被 overridden，从而把它们的权限从 internal 修改为 final。这样的话，就可以减少 dynamic dispatch 的发生从而提高效率。 开启编译优化选项的步骤如下：Xcode -&gt; Build Settings -&gt; Swift Compiler -&gt; Optimization Level。 参考文献 https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/ https://developer.apple.com/swift/blog/?id=27 https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations","categories":[{"name":"技术","slug":"技术","permalink":"https://hparis.github.io/blog/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://hparis.github.io/blog/tags/Swift/"}]},{"title":"初步了解 GCD","slug":"初步了解GCD","date":"2017-09-05T15:30:56.000Z","updated":"2018-04-16T08:00:54.841Z","comments":true,"path":"2017/09/05/初步了解GCD/","link":"","permalink":"https://hparis.github.io/blog/2017/09/05/初步了解GCD/","excerpt":"","text":"GCD 简介GCD(Grand Central Dispatch) 是苹果提供的一套多线程编程技术。想象一下，如果让你编写一个可以高效的跑在不同计算机、不同内核的应用程序，你会怎么做呢？你要看看硬件是什么，看看有有多少个内核，想想用什么算法，想想在什么时候去切换线程…总之，你要做的东西多了去了。而 GCD 帮我们屏蔽了这些技术细节，但是如果要用好 GCD 的话，还是要多了解一些知识点。 Dispatch 对象和内存管理在 Objective-C 里面，所有的 dispatch 对象都是 Objective-C 对象，所以他们同样适用引用技术的内存管理。如果你是使用 ARC 的话，dispatch 对象会向普通的 Objective-C 对象一样自动进行 retain 和 release 操作；如果你是使用 MRC，要记住使用 dispatch_retain 和 dispatch_release 来进行管理。 常用 APIdispatch_queue_t（调度队列）1public func dispatch_queue_create(label: UnsafePointer&lt;Int8&gt;, _ attr: dispatch_queue_attr_t!) -&gt; dispatch_queue_t! 在 GCD 中只能通过上面的 API 来创建调度队列，我们可以通过创建各种各样的 Block 形式的任务并由该调度队列来决定如何去执行这些 Block 任务。上面创建调度队列的函数需要两个参数： label: 这个参数是用来给你创建的调度队列进行命名的，特别是在调试的时候你可以通过该参数来判断是哪个调度队列的任务在执行。 attr: 这个参数只有 DISPATCH_QUEUE_SERIAL 和 DISPATCH_QUEUE_CONCURRENT 两种值（在 Objective-C 中这个参数可以为 NULL，这个时候默认是 DISPATCH_QUEUE_SERIAL）。DISPATCH_QUEUE_SERIAL 是告诉调度队列以串行的方式去执行任务，DISPATCH_QUEUE_CONCURRENT 是告诉调度队列以并发的方式去执行任务。 当然我们还可以通过下面的方法来获取系统已经创建好的调度队列： 12// 获取全局队列public func dispatch_get_global_queue(identifier: Int, _ flags: UInt) -&gt; dispatch_queue_t! 12// 获取主线程的com.apple.main-thread (serial)队列public func dispatch_get_main_queue() -&gt; dispatch_queue_t! 注意，所有 pending 状态的 Block 任务都会持有该调度队列的引用，所以我们不需要显示的去持有调度队列，而调度队列会在所有的 Block 任务都从 pending 变为 finished 之后才会被释放。 总之，现在大家要知道的是我们可以把不同的 Block任务提交到调度队列，具体的细节和实现看看后面内容。 dispatch_sync 和 dispatch_async（同步和异步）123456789101112let queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL) // 创建调度队列print(\"Begin Sync\")// 同步调用dispatch_sync(queue) &#123; // Block任务 print(\"Execute Block Task1\") &#125;dispatch_sync(queue) &#123; // Block任务 print(\"Execute Block Task2\") &#125;print(\"After Sync\") 这段代码的输出结果如下： 1234Begin SyncExecute Block Task1Execute Block Task2After Sync 上面的例子就是我们平常对 dispatch_sync 的用法，并且我们可以看到第一个 Block 任务执行之后才会执行第二个 Block 任务。dispatch_sync 需要等待 Block的任务执行完成之后，才能继续往后执行。但是使用 dispatch_sync 的时候，有几点是需要注意的： 当调用 dispatch_sync 方法的时候，系统默认情况下会在当前线程去执行调度队列里的任务，只有在一些特殊情况下才会把调度队列的任务分配到其他线程去执行。所以我们就知道，线程和调度队列并不是一对一的关系。至于为什么默认情况下会在当前线程去执行调度队列里的任务，我的猜测是为了性能。大家想一想，dispatch_sync 会同步执行 Block任务， Block任务没有结束的情况下，后面的代码是无法执行的。基于这样一个同步的机制，GCD 还有必要先把当前线程挂起，然后去创建新线程，然后切换到新的线程去执行调度队列里的任务，然后再把线程切换到当前线程，然后再让当前线程恢复么？结论是没有必要。 你不能够在当前的串行调度队列的任务里面去添加新的任务到当前的调度队列里面，否则会造成死锁。这句话怎么理解呢，我们来来看看下面的例子： 123456789101112131415// 例1let queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL) // 创建串行的调度队列// 同步调用dispatch_sync(queue) &#123; // Block1 print(\"Begin Execute Block Task1\") dispatch_sync(queue) &#123; // Block2 print(\"Execute Block Task2\") &#125; print(\"End Execute Block Task1\")&#125;// 例1的结果Begin Execute Block Task1 为什么 Block1 后面的 print 和 Block2 的 print 都不执行了呢？首先我们要知道被 DISPATCH_QUEUE_SERIAL 声明的调度队列是串行调度队列，串行调度队列里的任务是同时只能有一个任务在执行，并且当前任务没有执行完成，下一个任务也无法执行。上面的例子中会先输出 Block1 中的 Begin Execute Block Task1，然后这个时候再把 Block2 添加到同一个串行调度队列中去。这个时候的 Block1 还没有执行完成，它需要等 dispatch_sync 的 Block2 执行完成之后才能继续执行，而 Block2 又必须等待 Block1 执行完成之后才能执行，所以这个时候就造成 Block1 等着 Block2，Block2 等着 Block1 的死锁。 我们再把调度队列属性改为 DISPAT_QUEUE_CONCURRENT，然后再看看执行结果是什么： 123456789101112// 例2let queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL) // 创建串行的调度队列// 同步调用dispatch_sync(queue) &#123; // Block1 print(\"Begin Execute Block Task1\") dispatch_sync(queue) &#123; // Block2 print(\"Execute Block Task2\") &#125; print(\"End Execute Block Task1\")&#125; 1234// 例2的结果Begin Execute Block Task1Execute Block Task2End Execute Block Task1 被 DISPATCH_QUEUE_CONCURRENT 声明的并发调度队列就没有这种死锁的问题。并发调度队列里的任务是不会霸占资源不放的，每一个任务执行一个时间片段之后会把资源交出来给别的任务去执行。所以例2中的 Block1 虽然需要等待 Block2 执行完成之后才能继续执行，但是当 Block1 在等待的过程中，是可以把资源释放出来交给 Block2 去执行，Block2 执行完成之后 Block1 就可以继续执行了。所以，这个时候就不会造成死锁来。 再来看看下面的例子会不会造成死锁： 12345override func viewDidLoad() &#123; dispatch_sync(dispatch_get_main_queue()) &#123; print(\"Excute Block Task\") &#125;&#125; 答案是会的。给大家一点提示，主线程的默认调度队列是串行（DISPATCH_QUEUE_SERIAL）的，viewDidLoad() 是在主线程的调度队列 com.apple.main-thread (serial) 执行的。 上面的例子主要是希望大家理解串行和并发的概念，同时要明白造成死锁的原因。而要解决死锁一般可以用 DISPATCH_QUEUE_CONCURRENT 或接下来我们要讲的 dispatch_async 来解决。 通过对 dispatch_sync 的了解，我们可以利用 dispatch_async 很快的写出异步代码： 123456789101112let queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL) // 创建调度队列print(\"Begin Async\")// 异步调用dispatch_async(queue) &#123; // Block1 print(\"Execute Block Task1\") &#125;dispatch_async(queue) &#123; // Block2 print(\"Execute Block Task2\") &#125;print(\"After Async\") 这个例子的结果有好几种： 12345// 结果1Begin AsyncAfter AsyncExecute Block Task1ExEcute Block Task2 12345// 结果2Begin AsyncExecute Block Task1ExEcute Block Task2After Async 上面只是列出来两种可能，但实际上还有其他的可能。当我们调用 dispatch_async 的时候，它总是会在 Block 任务被提交之后马上返回，而不会傻傻的等待 Block 任务执行完成。由于上面创建的是串行调度队列，所以我们可以保证 Block1 要比 Block2 优先执行，但是 After Async 就无法确定是在 Block1 的前后还是 Block2 的前后。 如果我们把上面的 DISPATCH_QUEUE_SERIAL 改成 DISPATCH_QUEUE_CONCURRENT，那我们就无法确定 After Async、Block1 和 Block2 这三者的执行顺序了。 我们刚才说到用 dispatch_async 可以解决死锁的问题，那它是怎么解决的呢？ 1234567891011let queue = dispatch_queue_create(\"com.PS.Queue\", DISPATCH_QUEUE_SERIAL) // 创建串行的调度队列// 异步调用dispatch_async(queue) &#123; // Block1 print(\"Begin Execute Block Task1\") dispatch_async(queue) &#123; // Block2 print(\"Execute Block Task2\") &#125; print(\"End Execute Block Task1\")&#125; 上面的例子会优先输出 Block1 的 Begin Execute Block Task1 之后，通过 dispatch_async 把 Block2 提交到串行队列里面，然后又马上返回到 Block1 去输出 End Execute Block Task1，这个时候的 Block1 就结束了，接下来就开始执行 Block2。所以上面的代码是不会造成死锁的，虽然上面的例子也是创建了一个串行调度队列，但是该调度队列只是保证了 Block1 要比 Block2 优先执行。 dispatch_once写过 Objective-C 的人都知道，dispatch_once 一般会被用来创建单例对象： 12345678910@implementation Single+ (Single *)sharedInstance &#123; static Single * _single = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _single = [[Single alloc] init]; &#125;); return _single; &#125;@end 这是由于 dispatch_once 是线程安全且只会执行一次，所以才会被用来作为单例的实现。这里需要注意的是 dispatch_once_t 必须是静态的或全局的才能保证 dispatch_once 的 Block 只会被执行一次，所以上面的代码用了 static 来修饰 dispatch_once_t。 dispatch_apply1public func dispatch_apply(iterations: Int, _ queue: dispatch_queue_t!, _ block: (Int) -&gt; Void) 其中的 interations 是表明要执行多少次 block，block 中的 Int 是该 Block 被执行的序号。调用这个方法的时候要注意该方法跟 dispatch_sync 一样会阻塞当前线程，所以我们需要注意在主线程中调用该方法。 dispatch_after1public func dispatch_after(when: dispatch_time_t, _ queue: dispatch_queue_t, _ block: dispatch_block_t) 调用这个方法的时候需要注意的是 when 这个参数，你需要通过 dispatch_time 或 dispatch_walltime 来创建。并且该方法是异步执行的，并不会阻塞当前线程。 一般的写法如下： 123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(5 * NSEC_PER_SEC)), queue) &#123; print(\"5s \\(NSThread.currentThread())\")&#125; dispatch_group_tdispatch_group_t 是用来做聚合同步的，它可以用来跟踪你提交的所有任务（即使是在不同的调度队列也可以）的完成状态。 接下来我们来看看 dispatch group 的一些常见用法： 1234567891011121314151617181920212223// 创建 dispatch_group_t 对象let group = dispatch_group_create()// 创建串行队列let serialQueue = dispatch_queue_create(\"Serial Queue\", DISPATCH_QUEUE_SERIAL)// 提交两个 Block 任务到 serialQueue，同时关联 serialQueue 和 group 的关系dispatch_group_async(group, serialQueue) &#123; print(\"Execute Block1 within Serial Queue\")&#125;dispatch_group_async(group, serialQueue) &#123; print(\"Execute Block2 within Serial Queue\")&#125;// 创建并发队列，并提交 Block 任务，同时关联该并发队列和 group 的关系dispatch_group_async(group, dispatch_queue_create(\"Concurrent Queue\", DISPATCH_QUEUE_CONCURRENT)) &#123; print(\"Execute Block within Concurrent Queue\")&#125;// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发dispatch_group_notify(group, dispatch_queue_create(\"Finished\")) &#123; print(\"Finished\")&#125; 注意，关联到 group 的方法只有 dispatch_group_async 而没有 dispatch_group_sync。 但是还有另外一种方法可以让我们关联一个普通的任务： 12345678910111213141516// 创建 dispatch_group_t 对象let group = dispatch_group_create()// 使用 dispatch_group_enter 和 dispatch_group_leave 的话，我们不需要调用// dispatch_group_async 也能关联一个任务到 group 上dispatch_group_enter(group)self.executeTask &#123; // 执行代码 dispatch_group_leave(group)&#125;// 下面的代码只有当前面被关联到 group 的所有任务完成之后才会被触发dispatch_group_notify(group, dispatch_queue_create(\"Finished\")) &#123; print(\"Finished\")&#125; 使用 dispatch_group_enter 和 dispatch_group_leave 的时候，它们必须成双成对出现，否则 dispatch_group_notify 是不会被调用的。 接下来我们还要了解一下 dispatch_group_wait： 1public func dispatch_group_wait(group: dispatch_group_t, _ timeout: dispatch_time_t) -&gt; Int dispatch_group_wait 可以指定一个 timeout 的参数，当 group 的任务没有在规定的时间内完成，它会返回一个非零的值，当 group 的任务能够在规定的时间内完成就返回0。同时，大家要注意这个方法会挂起当前线程，所以在主线程的时候要慎重使用该方法。 dispatch_barrier_t我们先来试想一个场景，假如现在有多个线程要去读取一份文件的内容，同时又有其他线程想要去更新该文件的内容，那么就有可能会发生你读错文件内容的现象。这个时候我们可以把所有读写操作都放到我们之前学习的串行队列去执行，但是我们都知道同时有多个线程去读取一份文件内容是没有问题的。 使用 dispatch barrier 可以解决上面的问题： 1234567891011121314// 创建操作文件的并发队列let queue = dispatch_queue_create(\"File\", DISPATCH_QUEUE_CONCURRENT)dispatch_async(queue) &#123; // Read1&#125;dispatch_async(queue) &#123; // Read2&#125;dispatch_barrier_async(queue) &#123; // Write&#125;dispatch_async(queue) &#123; // Read3&#125; 通过 dispatch_barrier_async 或 dispatch_barrier_sync 提交的任务会等待当前队列里正在执行的任务执行完毕才会执行，并且其他还没有执行的任务都必须等待提交到 dispatch barrier 的任务执行完毕之后才会开始执行。所以上面的代码中，当 Write 任务被提交的时候，如果当前队列中只有 Read1 在执行，那么 Write 会等待 Read1 执行完成之后才会执行，Read2 和 Read3 都必须等待 Write 执行完之后才会执行。另外，上面的代码中创建的是并发队列，因为如果是串行队列的话就没有必要用 dispatch barrier 了。 dispatch_semaphore_tdispatch semaphore 是一个效率非常高的传统计数信号量，所以我们一般可以用这个来控制最大的并发数量。 1234567891011121314151617// 创建初始值为2的信号量，最大并发数量为2let semaphore = dispatch_semaphore_create(2)// 创建并发队列let queue = dispatch_queue_create(\"Semaphore\", DISPATCH_QUEUE_CONCURRENT)// 创建100个并发任务for index in 1...100 &#123; // 这个方法会进行信号量减1的操作，并且如果信号量减1之后的结果小于0的话，该方法会造成线程的挂起直 // 到该信号量进行加1操作才会恢复，所以在主线程要注意该方法的使用。 // 注意：这个方法要放在 dispatch_async 外面，否则系统依旧会创建超过2个线程同时来处理该调度队列 // 的任务 dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER) dispatch_async(queue) &#123; // 释放资源，信号量增加1 dispatch_semaphore_signal(semaphore) &#125;&#125; 其他GCD 在 Swift3 的语法跟现在的语法不太一样了，有兴趣的可以自行去了解。在未来可能会考虑把本文章的代码都用 Swift3 的语法来重新写一下。","categories":[{"name":"技术","slug":"技术","permalink":"https://hparis.github.io/blog/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/tags/iOS/"},{"name":"GCD","slug":"GCD","permalink":"https://hparis.github.io/blog/tags/GCD/"}]},{"title":"Vim Tip","slug":"Vim-Tip","date":"2017-09-05T15:30:56.000Z","updated":"2018-03-23T08:43:06.334Z","comments":true,"path":"2017/09/05/Vim-Tip/","link":"","permalink":"https://hparis.github.io/blog/2017/09/05/Vim-Tip/","excerpt":"","text":"1、替换第n1行到第n2行的内容1:n1,n2/origin/replace/g 2、替换整个文件的内容1:%s/origin/replace/g 3、移动n1-n2行(包括n1,n2)到n3行之下1n1,n2 m n3 4、复制n1-n2行(包括n1,n2)到n3行之下1:n1,n2 co n3 5、删除文件的空行1:g/^$/d 6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）1:r!seq 100 7、在当前的每一行文字前面增加“序号. ”（来自池老师《说，谁才是最帅的编程工具？》）1:let i=1 | g /^/ s//\\=i.\". \"/ | let i+=1 8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）123vim:n **/*.java:argdo %s/apache/eclipse/ge | update","categories":[{"name":"技术","slug":"技术","permalink":"https://hparis.github.io/blog/categories/技术/"}],"tags":[{"name":"tip","slug":"tip","permalink":"https://hparis.github.io/blog/tags/tip/"}]},{"title":"include 和 import 的区别","slug":"include和import的区别","date":"2017-09-05T15:30:56.000Z","updated":"2018-03-23T08:42:11.229Z","comments":true,"path":"2017/09/05/include和import的区别/","link":"","permalink":"https://hparis.github.io/blog/2017/09/05/include和import的区别/","excerpt":"","text":"今天我们来了解下面这几种包含文件的方式有什么特点和区别： 12345#include \"fiel\"#include &lt;file&gt;#import \"file\"#import &lt;file&gt;@import Module 一、#include学过 C 语言的人都知道，#include 其实是一个预处理命令。它会在预处理的时候简单的把被 #include 包含的文件内容进行复制粘贴。我们来看看下面的代码： 1234// A.hvoid sampleA() &#123; // A code&#125; 123456// B.h#include \"A.h\"void sampleB() &#123; // B code&#125; 我们使用 gcc -E B.h 命令来看看经过预处理后的文件内容大概如下： 12345678910111213141516# 1 \"B.h\"# 1 \"&lt;built-in&gt;\" 1# 1 \"&lt;built-in&gt;\" 3# 329 \"&lt;built-in&gt;\" 3# 1 \"&lt;command line&gt;\" 1# 1 \"&lt;built-in&gt;\" 2# 1 \"B.h\" 2# 1 \"./A.h\" 1void sampleA() &#123;&#125;# 2 \"B.h\" 2void sampleB() &#123;&#125; 我们可以看到经过预处理之后，A.h 文件中的内容被直接复制并粘贴到 B.h 文件中来。如果我们在 B.h 文件中多次包含了 A.h 文件，会出现什么情况？比如： 1234// A.hvoid sampleA() &#123; // A code&#125; 1234567// B.h#include \"A.h\"#include \"A.h\"void sampleB() &#123; // B code&#125; 经过预处理之后的内容大概如下： 123456789101112131415161718192021# 1 \"B.h\"# 1 \"&lt;built-in&gt;\" 1# 1 \"&lt;built-in&gt;\" 3# 329 \"&lt;built-in&gt;\" 3# 1 \"&lt;command line&gt;\" 1# 1 \"&lt;built-in&gt;\" 2# 1 \"B.h\" 2# 1 \"./A.h\" 1void sampleA() &#123;&#125;# 2 \"B.h\" 2# 1 \"./A.h\" 1void sampleA() &#123;&#125;# 3 \"B.h\" 2void sampleB() &#123;&#125; A.h 文件中的 sampleA() 函数出现了两次，所以我们需要利用其他的一些预处理命令来规避这种情况，看看下面的代码： 12345678// A.h#ifndef FILE_A#define FILE_Avoid sampleA() &#123; // A code&#125;#endif 1234567// B.h#include \"A.h\"#include \"A.h\"void sampleB() &#123; // B code&#125; 我们再来看看增加了这些预处理命令之后的预处理文件内容： 1234567891011121314151617181920# 1 \"B.h\"# 1 \"&lt;built-in&gt;\" 1# 1 \"&lt;built-in&gt;\" 3# 329 \"&lt;built-in&gt;\" 3# 1 \"&lt;command line&gt;\" 1# 1 \"&lt;built-in&gt;\" 2# 1 \"B.h\" 2# 1 \"./A.h\" 1void sampleA() &#123;&#125;# 2 \"B.h\" 2void sampleB() &#123;&#125; OK，这就正常了。如果我们在 A.h 中包含 B.h，然后又在 B.h 中包含 A.h，具体代码如下： 1234567// A.h#include \"B.h\"void sampleA() &#123; // A code&#125;#endif 123456// B.h#include &quot;A.h&quot;void sampleB() &#123; // B code&#125; 我们再来看看经过 gcc -E B.h 处理之后的文件内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 1 \"B.h\"# 1 \"&lt;built-in&gt;\" 1# 1 \"&lt;built-in&gt;\" 3# 329 \"&lt;built-in&gt;\" 3# 1 \"&lt;command line&gt;\" 1# 1 \"&lt;built-in&gt;\" 2# 1 \"B.h\" 2# 1 \"./A.h\" 1# 1 \"./B.h\" 1# 1 \"./A.h\" 1# 1 \"./B.h\" 1......# 1 \"./A.h\" 1# 1 \"./B.h\" 1In file included from ./B.h:1:In file included from ./A.h:1:In file included from ./B.h:1:In file included from ./A.h:1:......In file included from ./B.h:1:In file included from ./A.h:1:./A.h:1:10: error: #include nested too deeply#include \"B.h\" ^void sampleA() &#123;&#125;# 2 \"./B.h\" 2void sampleB() &#123;&#125;# 2 \"./A.h\" 2void sampleA() &#123;&#125;# 2 \"./B.h\" 2void sampleB() &#123;&#125;# 2 \"./A.h\" 2void sampleA() &#123;&#125;......# 2 \"./A.h\" 2void sampleA() &#123;&#125;# 2 \"./B.h\" 2void sampleB() &#123;&#125;1 error generated. 我们发现 A.h 和 B.h 重复出现，这是因为这个时候 A.h 和 B.h 文件互相引用导致的。从理论上来讲，这个时候会无限循环下去，直至世界终结。在这里最后会出现一句 1 error generated.的提示是 gcc 强行中断了这个预处理的过程，所以我们才能看到这样的结果。那我们可以怎么做？当然是利用前面说的预处理命令来避免循环引用的问题。看下面的代码： 12345678910// A.h#ifndef FILE_A#define FILE_A#include \"B.h\"void sampleA() &#123; // A code&#125;#endif 12345678910// B.h#ifndef FILE_B#define FILE_B#include \"A.h\"void sampleB() &#123; // B code&#125;#endif 这个时候使用 gcc -E B.h 就可以正常的进行预处理，最后的结果如下： 12345678910111213141516171819202122232425# 1 \"B.h\"# 1 \"&lt;built-in&gt;\" 1# 1 \"&lt;built-in&gt;\" 3# 329 \"&lt;built-in&gt;\" 3# 1 \"&lt;command line&gt;\" 1# 1 \"&lt;built-in&gt;\" 2# 1 \"B.h\" 2# 1 \"./A.h\" 1# 1 \"./B.h\" 1# 5 \"./A.h\" 2void sampleA() &#123;&#125;# 5 \"./B.h\" 2void sampleB() &#123;&#125; 所以C程序员总是需要通过各种手段（比如：#pragma once）来防范此类事件的发生。 二、#import我们在文件中通过#import来导入 iAd Framework： 编译报错： 需要重新导入和链接 Framework： 编译成功： 从上面的过程中我们就知道在 Objective-C 项目中使用 #import 需要注意导入和链接 Framework，否则是会报错的。 预处理器在碰到 #import 命令的时候，它会采用递归的方式把被所有头文件的内容复制并粘贴到当前文件中，如果文件依赖层次比较深就会造成预处理后的文件内容体积大幅度变大。 比如导入 UIKit 的时候只需要一行代码： 1#import &lt;UIKit/UIKit.h&gt; 预处理之后会变成200多行（UIKit.h 文件有200多行代码）： 1234567#import &lt;UIKit/UIKitDefines.h&gt;#if __has_include(&lt;UIKit/UIAccelerometer.h&gt;)#import &lt;UIKit/UIAccelerometer.h&gt;.....#import &lt;UIKit/UIRegion.h&gt;#endif 接下来还需要递归的把每个头文件的内容展开，最后的结果就是一行代码变成超过11000行代码。如果有多个文件都包含来 UIKit 的头文件，这样就会让每个文件的体积都会变得很大，编译过程也会变得越来越慢。这种递归的方式会让项目的编译时间变成：M source files + N headers =&gt; M x N compile time。 所以这个时候有一个优化方法就是把项目中频繁被引用的文件放到 PCH（Pre-Compile Header）文件中。PCH 会被编译一次并且会被缓存，这就可以缩短编译时间，我们也不需要在不同的文件里面添加import语法。 当然，PCH 也有自己的缺点： 维护负担：随着项目变得越来越复杂，我们就会不停的往PCH文件加入内容，内容一旦变多就会变得不好维护。（这也是我们平常在项目中要避免在 ViewController 做太多事情的，要研究 MVVM的缘故。） 命名空间污染 最后，给大家提供一个例子看看 #import 编译出来之后的文件内容： 1234567// A.h#import \"B.h\" void sampleA() &#123; // A code&#125;#endif 1234567// B.h#import \"A.h\"#import \"A.h\"void sampleB() &#123; // B code&#125; 使用 gcc -E B.h 进行预处理之后的内容如下： 12345678910111213141516171819# 1 \"B.h\"# 1 \"&lt;built-in&gt;\" 1# 1 \"&lt;built-in&gt;\" 3# 329 \"&lt;built-in&gt;\" 3# 1 \"&lt;command line&gt;\" 1# 1 \"&lt;built-in&gt;\" 2# 1 \"B.h\" 2# 1 \"./A.h\" 1void sampleA() &#123;&#125;# 2 \"./B.h\" 2void sampleB() &#123;&#125; 我们在B.h中有两个 #import “A.h”，但是这些内容跟我们之前在 A.h 和 B.h 文件中使用 #include 和其他预处理命令之后的处理结果很相似，所以我们就明白了 #import 大概做了什么事。 三、@import在2012年的 LLVM 大会上，苹果的 Doug Gregor 首次提出了 Objective-C 中的 Module。使用 @import 方式导入有几个好处： 不需要像 #import 一样得手动去链接 Framework，@import会自动去链接 @import 工作方式和 PCH 很像，但是 @import 要比 PCH 的效率高出许多 @import 导入 Modul 优化文件体积变大、编译速度变慢的问题 可以部分导入（@import Framework.A）或全部导入（@import Framework） 所以，建议大家尽量使用 @import 来导入文件。如果你以前的项目用的是 #import，那么你也不需要担心，我们只通过 Build Settings 开启 Modules 选项（看下图），#import 和 #include 会自动被映射成 @import，所以你不需要更改原来的代码也能享受 @import带来的好处。 详细内容可以看看苹果2013年的 Advances in Objective-C，里面就详细介绍了 Module。 四、文件路径接下来我们来了解一下 #include 和 #include “file”： #include \\: 表示编译器会直接到系统设定的目录下寻找指定的文件。 #include “file”: 表示编译器会到当前的目录下寻找指定的文件，如果找不到，则会去系统设定的目录下寻找指定的文件。 参考文献： https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html http://stackoverflow.com/questions/18947516/import-vs-import-ios-7 https://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7","categories":[{"name":"技术","slug":"技术","permalink":"https://hparis.github.io/blog/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/tags/iOS/"}]},{"title":"RAC 和内存管理","slug":"RAC和内存管理","date":"2017-09-05T15:30:56.000Z","updated":"2018-03-23T08:43:22.223Z","comments":true,"path":"2017/09/05/RAC和内存管理/","link":"","permalink":"https://hparis.github.io/blog/2017/09/05/RAC和内存管理/","excerpt":"","text":"最近在用 RAC 的时候发现自己对内存管理还是有些困惑，于是自己写了一些代码来验证自己的一些理解。在一开始接触 RAC 的时候，我们知道 RAC 对于 block 都是 copy 赋值的。 1234567@implementation RACSignal#pragma mark Lifecycle+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123; return [RACDynamicSignal createSignal:didSubscribe];&#125; 123456789@implementation RACDynamicSignal#pragma mark Lifecycle+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123; RACDynamicSignal *signal = [[self alloc] init]; signal-&gt;_didSubscribe = [didSubscribe copy]; return [signal setNameWithFormat:@\"+createSignal:\"];&#125; 在创建 RACSingal 的时候会调用其子类 RACDynamicSignal 去创建，我们也看到 RACDynamicSignal 对 didSuscribe 这个 block 是进行了 copy。所以大家可能会被要求注意循环引用的问题，于是大家都用 @weakify(target) 和 @strongify(target) 来避免循环引用的问题。那是不是所有用到 RAC 的地方都需要使用这些宏来避免循环引用的问题，不尽然。比如下面这个： 1234// 场景1[RACObserve(self, title) subscribeNext:^(id x) &#123; NSLog(@\"%@\", x);&#125;]; 接下来，我们来对比以下的几种用法： 12345678910111213141516171819202122232425262728@interface ViewController()@property (strong, nonatomic) ViewModel * viewModel;@end@implementation ViewController- (void)viewDidiLoad &#123; [super viewDidLoad]; self.viewModel = [ViewModel new]; // 场景2 dispatch_async(dispatch_get_main_queue(), ^&#123; self.title = @\"你好\"; &#125;); // 场景3 [self.viewModel.titleSignal subscribeNext:^(NSString * title) &#123; self.title = title; &#125;]; // 场景4 [RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) &#123; self.title = title; &#125;]; &#125;@end 场景2是我们平常都会用到的，而且我们也没有在这种场景下去考虑循环引用的问题，这是因为 dispatch 的 block 不是属于 self 的（至于这个 block 是属于谁的，回头我再查点资料或者请各位指教），所以即使你在 block 使用了 self 也不会有循环应用的问题。 场景3很明显是有循环引用的问题：self-&gt;viewModel-&gt;titleSignal-&gt;block-&gt;self，这个时候如果我们不做处理的话，那么 self 就永远不会被释放。正确的做法应该是使用 @weakify(self) 和 @strongify(self)： 123456// 场景3@weakify(self);[self.viewModel.titleSignal subscribeNext:^(NSString * title) &#123; @strongify(self); self.title = title;&#125;]; 场景4在我们看来是没有问题的，因为这里看起来只有 singal-&gt;block-&gt;self 的引用，它们之间并没有造成循环引用的问题。我们先来看看 RACObserve 的实现： 12345678910#define RACObserve(TARGET, KEYPATH) \\(&#123; \\_Pragma(\"clang diagnostic push\") \\_Pragma(\"clang diagnostic ignored \\\"-Wreceiver-is-weak\\\"\") \\__weak id target_ = (TARGET); \\[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \\_Pragma(\"clang diagnostic pop\") \\&#125;)- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak NSObject *)observer; 其实，看到这里你会认为这里只是调用了一个方法创建了一个 Signal，而且这个 Signal 也并不属于任何对象。我们再来看看具体的实现是怎么样的？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (RACSignal *)rac_valuesAndChangesForKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options observer:(__weak NSObject *)weakObserver &#123; NSObject *strongObserver = weakObserver; keyPath = [keyPath copy]; NSRecursiveLock *objectLock = [[NSRecursiveLock alloc] init]; objectLock.name = @\"org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing\"; __weak NSObject *weakSelf = self; RACSignal *deallocSignal = [[RACSignal zip:@[ self.rac_willDeallocSignal, strongObserver.rac_willDeallocSignal ?: [RACSignal never] ]] doCompleted:^&#123; // Forces deallocation to wait if the object variables are currently // being read on another thread. [objectLock lock]; @onExit &#123; [objectLock unlock]; &#125;; &#125;]; return [[[RACSignal createSignal:^ RACDisposable * (id&lt;RACSubscriber&gt; subscriber) &#123; // Hold onto the lock the whole time we're setting up the KVO // observation, because any resurrection that might be caused by our // retaining below must be balanced out by the time -dealloc returns // (if another thread is waiting on the lock above). [objectLock lock]; @onExit &#123; [objectLock unlock]; &#125;; __strong NSObject *observer __attribute__((objc_precise_lifetime)) = weakObserver; __strong NSObject *self __attribute__((objc_precise_lifetime)) = weakSelf; if (self == nil) &#123; [subscriber sendCompleted]; return nil; &#125; return [self rac_observeKeyPath:keyPath options:options observer:observer block:^(id value, NSDictionary *change, BOOL causedByDealloc, BOOL affectedOnlyLastComponent) &#123; [subscriber sendNext:RACTuplePack(value, change)]; &#125;]; &#125;] takeUntil:deallocSignal] setNameWithFormat:@\"%@ -rac_valueAndChangesForKeyPath: %@ options: %lu observer: %@\", self.rac_description, keyPath, (unsigned long)options, strongObserver.rac_description];&#125; 重点观察 deallocSignal 和 [signal takeUntile:deallocSignal]，我们把 deallocSignal 单独拿出来看看： 1234567891011RACSignal *deallocSignal = [[RACSignal zip:@[ self.rac_willDeallocSignal, strongObserver.rac_willDeallocSignal ?: [RACSignal never] ]] doCompleted:^&#123; // Forces deallocation to wait if the object variables are currently // being read on another thread. [objectLock lock]; @onExit &#123; [objectLock unlock]; &#125;;&#125;]; 这里的 deallocSignal 是只有在 self 和 strongObserve 都将要发生 dealloc 的时候才会触发的。即用 RACObserve 创建的信号只有在其 target 和 observe 都发生 dealloc 的时候才会被 disposable (这个好像是 RAC 用来销毁自己资源的东西)。不明白的童鞋，我们回头来分析一下场景4的代码： 1234// 场景4[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) &#123; self.title = title;&#125;]; 用 RACObserve 创建的信号看起来只要出了函数体其资源应该就会被回收，但是这个信号其实是只有在 self.viewModel.rac_willDeallocSignal 和 self.rac_willDeallocSignal 都发生的情况下才会被释放。所以场景4的引用关系看起来只有 signal-&gt;block-&gt;self，但是这个 signal 只有在 self.rac_willDeallocSignal 的时候才会被释放。所以这里如果不打断这种关系的话就会造成循环引用的问题，正确做法应该是： 123456// 场景4@weakify(self);[RACObserve(self.viewModel, title) subscribeNext:^(NSString * title) &#123; @strongify(self); self.title = title;&#125;]; 最后，在说一个特别需要注意的，就是 UITableViewCell 和 UICollectionViewCell 复用和 RAC 的问题。 123456789101112131415- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return 1000;&#125;- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath &#123; UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"TableViewCell\"]; @weakify(self); [RACObserve(cell.textLabel, text) subscribeNext:^(id x) &#123; @strongify(self); NSLog(@\"%@\", self); &#125;]; return cell;&#125; 我们看到这里的 RACObserve 创建的 Signal 和 self 之间已经去掉了循环引用的问题，所以应该是没有什么问题的。但是结合之前我们对 RACObserve 的理解再仔细分析一下，这里的 Signal 只要 self 没有被 dealloc 的话就不会被释放。虽然每次 UITableViewCell 都会被重用，但是每次重用过程中创建的信号确实无法被 disposable。那我们该怎么做呢？ 123456789101112131415- (NSInteger)tableView:(nonnull UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return 1000;&#125;- (UITableViewCell *)tableView:(nonnull UITableView *)tableView cellForRowAtIndexPath:(nonnull NSIndexPath *)indexPath &#123; UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"TableViewCell\"]; @weakify(self); [[RACObserve(cell.textLabel, text) takeUntil:cell.rac_prepareForReuseSignal] subscribeNext:^(id x) &#123; @strongify(self); NSLog(@\"%@\", self); &#125;]; return cell;&#125; 注意，我们在cell里面创建的信号加上 takeUntil:cell.rac_prepareForReuseSignal，这个是让 cell 在每次重用的时候都去 disposable 创建的信号。 以上所说的关于内存的东西我都用 Instrument 的 Allocations 验证过了，但是依旧建议大家自己也去试试。","categories":[{"name":"技术","slug":"技术","permalink":"https://hparis.github.io/blog/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://hparis.github.io/blog/tags/iOS/"},{"name":"RAC","slug":"RAC","permalink":"https://hparis.github.io/blog/tags/RAC/"}]}]}