<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
    
    <title>帕帕&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="奋斗中的程序员。">
<meta property="og:type" content="website">
<meta property="og:title" content="帕帕&#39;s Blog">
<meta property="og:url" content="https://hparis.github.io/blog/index.html">
<meta property="og:site_name" content="帕帕&#39;s Blog">
<meta property="og:description" content="奋斗中的程序员。">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="帕帕&#39;s Blog">
<meta name="twitter:description" content="奋斗中的程序员。">
    

    
        <link rel="alternate" href="/" title="帕帕&#39;s Blog" type="application/atom+xml" />
    

    

    <link rel="stylesheet" href="/blog/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/blog/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/blog/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/blog/css/style.css">

    <script src="/blog/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/blog/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/blog/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/blog/" id="logo">
                <i class="logo"></i>
                <span class="site-title">帕帕&#39;s Blog</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/blog/.">Home</a>
                
                    <a class="main-nav-link" href="/blog/archives">Archives</a>
                
                    <a class="main-nav-link" href="/blog/categories">Categories</a>
                
                    <a class="main-nav-link" href="/blog/tags">Tags</a>
                
                    <a class="main-nav-link" href="/blog/about">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/blog/css/images/avatar.png" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/blog/',
        CONTENT_URL: '/blog/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/blog/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/blog/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/blog/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/blog/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/blog/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/blog/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/blog/css/images/avatar.png" />
            <h2 id="name">帕帕</h2>
            <h3 id="title">iOS Developer &amp; RN</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Beijing, China</span>
            <a id="follow" target="_blank" href="https://github.com/HParis">FOLLOW</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                15
                <span>posts</span>
            </div>
            <div class="article-info-block">
                11
                <span>tags</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/HParis" target="_blank" title="github" class=tooltip>
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://twitter.com/Paris_Htj" target="_blank" title="twitter" class=tooltip>
                            <i class="fa fa-twitter"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://www.facebook.com/profile.php?id=100006030375941" target="_blank" title="facebook" class=tooltip>
                            <i class="fa fa-facebook"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/blog/" target="_blank" title="dribbble" class=tooltip>
                            <i class="fa fa-dribbble"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/blog/" target="_blank" title="rss" class=tooltip>
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-Swift-High-Performance-Tip 3： @objc-和-dynamic" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/blog/2018/05/25/Swift-High-Performance-Tip 3： @objc-和-dynamic/">Swift High-Performance Tip 3：@objc 和 dynamic</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/blog/2018/05/25/Swift-High-Performance-Tip 3： @objc-和-dynamic/">
            <time datetime="2018-05-24T18:48:01.000Z" itemprop="datePublished">2018-05-24</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/blog/categories/技术/">技术</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/blog/tags/Swift/">Swift</a>, <a class="tag-link" href="/blog/tags/iOS/">iOS</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h3 id="objc"><a href="#objc" class="headerlink" title="@objc"></a>@objc</h3><p>@objc 的作用是为了让 Objective-C 能够调用 Swift 的代码。其中的关键是 @objc 会生成一段 thunk 代码，Objective-C 通过这段 thunk 代码来间接调用 Swift 代码。如果是 Swift 来调用被 @objc 修饰的方法的时候，此时是不需要经过 thunk 代码就能直接调用的。</p>
<p>所以我们可以想象，如果方法变得复杂或者被 @objc 修饰的方法数量变得越来越多会发生什么事？答案就是 thunk 代码变得越来越多，最后会导致我们的包大小也变得越来越大。并且动态链接器（dynamic linker）还需要整理这些 thunk 代码，最后导致加载时间也会变得越来越长。</p>
<p>在 Swift3 的时候，编译器会推断出你的方法不是 Swift 专用的（比如有元组、结构体），就会默认给你的方法增加 @objc 的修饰。这种方式就导致了在 Swift3 的时候，会生成大量的 thunk 代码，并且这其中的大部分代码都不会被使用。所以 Swift4 默认是不做 @objc 的推断，只有我们手动添加了 @objc 之后，Objective-C 才能调用我们的 Swift 代码。 </p>
<h3 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h3><p>Swift 的方法是通过 vtable 来调用的，使用 vtable 的要比 Objective-C 的 runtime 更高效。</p>
<p>而使用 dynamic 来修饰的方法，代表这个方法是可以被动态调用的。而由于目前 Swfit 还没有时间自己的 runtime 机制，所以动态调用只能够在 Objective-C 去调用。在  Swift4 使用 dynamic 修饰一个方法的时候，编译器会要求你还需要使用 @objc 去修饰。这是为了明确的告诉编译器这个方法是由 Objective-C 的 runtime 来调用的，同时也是为了兼容以后可能会出现的 Swift runtime 机制。</p>
<p>由于目前使用 @objc dynamic 修饰的方法并不在 Swift 实例对象的 vtable 里面，所以 Swift 来调用该方法的时候依旧需要通过 thunk 代码来调用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://swiftunboxed.com/images/native-objc-dynamic.png" alt="此图出自 https://swiftunboxed.com/interop/objc-dynamic/"></p>
<p>通过上图我们知道：</p>
<blockquote>
<p>除非明确的知道会在 Objective-C 中调用这段代码，否则别使用 @objc<br>除非明确的知道该方法需要被 Objective-C 的 runtime 动态调用，否则别使用 @objc dynamic</p>
</blockquote>
<hr>
<p><strong>参考文献</strong></p>
<ol>
<li><p><a href="https://swiftunboxed.com/interop/objc-dynamic/" target="_blank" rel="noopener">https://swiftunboxed.com/interop/objc-dynamic/</a></p>
</li>
<li><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0160-objc-inference.md" target="_blank" rel="noopener">https://github.com/apple/swift-evolution/blob/master/proposals/0160-objc-inference.md</a></p>
</li>
</ol>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="https://hparis.github.io/blog/2018/05/25/Swift-High-Performance-Tip 3： @objc-和-dynamic/#comments" class="article-comment-link disqus-comment-count" data-disqus-url="https://hparis.github.io/blog/2018/05/25/Swift-High-Performance-Tip 3： @objc-和-dynamic/">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-self-在-block-中的引用计数变化" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/blog/2018/04/19/self-在-block-中的引用计数变化/">self 在 block 中的引用计数变化</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/blog/2018/04/19/self-在-block-中的引用计数变化/">
            <time datetime="2018-04-19T11:34:51.000Z" itemprop="datePublished">2018-04-19</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/blog/categories/技术/">技术</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/blog/tags/Block/">Block</a>, <a class="tag-link" href="/blog/tags/Objective-C/">Objective-C</a>, <a class="tag-link" href="/blog/tags/iOS/">iOS</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>相信大家在 Objective-C 中都会通过 <code>__waek</code> 的修饰符来保证 block 和 self 不会互相引用，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    __strong typeof(self) strongSelf = self;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是你思考过 self 在这一段旅程中的引用计数变化么，接下来我会通过三个例子来展示这一段旅程是怎样的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 🌰1</span><br><span class="line">NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    self;</span><br><span class="line">    NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class="line">&#125;;</span><br><span class="line">self.block();</span><br><span class="line">NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 🌰2</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    weakSelf;</span><br><span class="line">    NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));</span><br><span class="line">&#125;;</span><br><span class="line">self.block();</span><br><span class="line">NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 🌰3</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">NSLog(@&quot;Before block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    __strong typeof(self) strongSelf = weakSelf;</span><br><span class="line">    NSLog(@&quot;Within block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(weakSelf)));</span><br><span class="line">&#125;;</span><br><span class="line">self.block();</span><br><span class="line">NSLog(@&quot;After block：%ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br></pre></td></tr></table></figure>
<p>我们可以通过 Clang 对上面的三个例子做一下编译，通过编译后的 C 代码（接下来所展示代码都是经过简化），我们可以推导出 self 的引用计数变化。</p>
<hr>
<p>🌰1 的 C 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// Block 结构体。这个大家可以通过其他的资料去看看，我们今天主要是来探寻一下 self 的旅程，这里就不对 Block 本身做更详细的介绍</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ^&#123;&#125; 的实现</span><br><span class="line">struct __BlockTest__test_block_impl_0 &#123;</span><br><span class="line">    struct __block_impl impl;</span><br><span class="line">    struct __BlockTest__test_block_desc_0* Desc;</span><br><span class="line">    BlockTest *const __strong self;</span><br><span class="line">    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __strong _self, int flags=0) : self(_self) &#123;</span><br><span class="line">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Block 方法</span><br><span class="line">static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123;</span><br><span class="line">    BlockTest *const __strong self = __cself-&gt;self; // bound by copy</span><br><span class="line">    self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Block 的 copy 操作</span><br><span class="line">static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">// Block 的 dispose 操作</span><br><span class="line">static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">// 描述 Block 的 copy 和 dispose</span><br><span class="line">static struct __BlockTest__test_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);</span><br><span class="line">    void (*dispose)(struct __BlockTest__test_block_impl_0*);</span><br><span class="line">&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">// 方法主体</span><br><span class="line">static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123;</span><br><span class="line">    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, self, 570425344)));</span><br><span class="line">    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在方法主体里面首先会构造一个 <code>__BlockTest__test_block_impl_0</code> 的结构体，该结构体捕获了 self；</li>
<li><code>__BlockTest__test_block_impl_0</code> 的构造函数中使用了 <code>__strong</code> 来捕获 self，所以我们知道在构造的时候默认是使用 <code>__strong</code> 来捕获外部的对象变量，此时 self 的引用计数应该要 +1；</li>
<li>Block 被构造出来之后需要被赋值给 self，我们知道在 ARC 模式下此时的 Block 会执行 Copy 操作，从 <code>_NSConcreteStackBlock</code> 变成 <code>_NSMallocBlock</code>；</li>
<li>Block 通过 <code>__BlockTest__test_block_desc_0_DATA</code> 找到 Copy 方法的具体实现 <code>__BlockTest__test_block_copy_0</code>，从上面的代码中我们知道该方法的实现是通过 <code>_Block_object_assign</code> 来实现的（对于这个方法的实现细节暂时还没有找到更相信的资料，有知道的可以麻烦告诉一下），通过名字我们可以猜测出该方法只是把捕获的变量地址直接拷贝一份到堆内存中，但是不会引起引用计数的变化；</li>
<li>当 Block 被真正执行的时候会通过 <code>__block_impl</code> 的 <code>FuncPtr</code> 找到真正的实现代码 <code>__BlockTest__test_block_func_0</code>，我们观察到在这个方法里面有这样一句代码 <code>BlockTest *const __strong self = __cself-&gt;self</code>，很明显此时 self 的引用计数会 +1，当该 <code>__BlockTest__test_block_func_0</code> 执行完毕之后还是会释放 self 的，此时引用计数会 -1；</li>
</ol>
<p>从上面的分析过程中，我们知道由于 Block 在构造的时候默认就对捕获的 self 进行了强引用，导致 self 的引用计数 +1；而又由于 self 持有了 Block，所以这里就造成了循环引用的问题。</p>
<p>我们来看 🌰2 能不能解决这个问题？</p>
<hr>
<p>🌰2 的 C 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// ^&#123;&#125; 结构体</span><br><span class="line">struct __BlockTest__test_block_impl_0 &#123;</span><br><span class="line">    struct __block_impl impl;</span><br><span class="line">    struct __BlockTest__test_block_desc_0* Desc;</span><br><span class="line">    BlockTest *const __weak weakSelf;</span><br><span class="line">    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123;</span><br><span class="line">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Block 方法</span><br><span class="line">static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123;</span><br><span class="line">    BlockTest *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy</span><br><span class="line">    weakSelf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Block 的 copy 操作</span><br><span class="line">static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">// Block 的 dispose 操作</span><br><span class="line">static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">// 描述 Block 的 copy 和 dispose</span><br><span class="line">static struct __BlockTest__test_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);</span><br><span class="line">    void (*dispose)(struct __BlockTest__test_block_impl_0*);</span><br><span class="line">&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">// 方法主体</span><br><span class="line">static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123;</span><br><span class="line">    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;</span><br><span class="line">    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));</span><br><span class="line">    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>方法主体会先用 <code>__weak</code> 初始化一个 weakSelf，此时 self 的引用计数是不会发生变化的；之后会构造一个<code>__BlockTest__test_block_impl_0</code> 的结构体，该结构体捕获了 weakSelf；</li>
<li><code>__BlockTest__test_block_impl_0</code> 的构造函数中使用了 <code>__weak</code> 来捕获 weakSelf，所以我们知道此时 self 的引用计数应该要也是不会发生变化的；</li>
<li>然后把该结构体赋值给 self.block，block 结构体被从栈复制到堆的时候使用了 <code>_Block_object_assign</code>，所以此时 self 的引用计数不会发生变化</li>
<li>然后 block 在被执行的时候做了一下 <code>__weak</code> 的操作 <code>BlockTest *const __weak weakSelf = __cself-&gt;weakSelf</code>，这时候 self 的引用计数也不会发生变化</li>
<li>由于 block 对 weakSelf 没有强引用，所以在 block 执行完成之后也不需要做释放 weakSelf 的工作</li>
</ol>
<p>所以，在该例子中 block 无法强引用 weakSelf，weakSelf 的引用计数没有发生任何变化。由于 self 没有被 block 强应用，所以当 self 要被释放的时候，block 也会被释放，这就解决了我们 🌰1 中的循环引用的问题。但是在 block 方法执行的过程中，self 对象有可能已经被释放了，此时如果你还去使用 weakSelf 就有可能造成奔溃的情况。</p>
<hr>
<p>🌰3 的 C 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">struct __BlockTest__test_block_impl_0 &#123;</span><br><span class="line">    struct __block_impl impl;</span><br><span class="line">    struct __BlockTest__test_block_desc_0* Desc;</span><br><span class="line">    BlockTest *const __weak weakSelf;</span><br><span class="line">    __BlockTest__test_block_impl_0(void *fp, struct __BlockTest__test_block_desc_0 *desc, BlockTest *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123;</span><br><span class="line">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __BlockTest__test_block_func_0(struct __BlockTest__test_block_impl_0 *__cself) &#123;</span><br><span class="line">    BlockTest *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy</span><br><span class="line">    __attribute__((objc_ownership(strong))) typeof(self) strongSelf = weakSelf;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __BlockTest__test_block_copy_0(struct __BlockTest__test_block_impl_0*dst, struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __BlockTest__test_block_dispose_0(struct __BlockTest__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __BlockTest__test_block_desc_0 &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">    void (*copy)(struct __BlockTest__test_block_impl_0*, struct __BlockTest__test_block_impl_0*);</span><br><span class="line">    void (*dispose)(struct __BlockTest__test_block_impl_0*);</span><br><span class="line">&#125; __BlockTest__test_block_desc_0_DATA = &#123; 0, sizeof(struct __BlockTest__test_block_impl_0), __BlockTest__test_block_copy_0, __BlockTest__test_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_BlockTest_test(BlockTest * self, SEL _cmd) &#123;</span><br><span class="line">    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;</span><br><span class="line">    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setBlock:&quot;), ((void (*)())&amp;__BlockTest__test_block_impl_0((void *)__BlockTest__test_block_func_0, &amp;__BlockTest__test_block_desc_0_DATA, weakSelf, 570425344)));</span><br><span class="line">    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;block&quot;))();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的步骤都跟 🌰2 中的一样，关键是在 Block 的方法实现里面有点不一样。我们来看看 <code>__BlockTest__test_block_func_0</code>，它首先调用了 <code>BlockTest *const __weak weakSelf = __cself-&gt;weakSelf</code>， 所以它此时的引用计数不会发生变化；但是接下来又用 <code>objc_ownership(strong)</code> 来强引用 weakSelf，所以此时 self 的引用计数 +1。这就保证了在函数执行的过程中，Block 会一直持有 self，知道 Block 执行完毕之后会释放 weakSelf。</p>
<p>所以 🌰3 完美的解决了循环应用和直接使用 <code>__weak</code> 可能导致奔溃的问题。</p>
<hr>
<p>最后，说一下关于 _Block_object_assign 的猜想：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br></pre></td></tr></table></figure>
<p>通过上面的例子，我们知道 Block 在构造的时候就会对捕获的变量进行内存管理（强引用和弱引用），所以当 Block 在做 Copy 操作的时候其实没有必要对它捕获的变量再做一遍内存管理了。这也应该是 Block 的 Copy 操作使用了 <code>_Block_object_assign</code> 这种不会导致引用计数发生变化的方式来实现的原因。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="https://hparis.github.io/blog/2018/04/19/self-在-block-中的引用计数变化/#comments" class="article-comment-link disqus-comment-count" data-disqus-url="https://hparis.github.io/blog/2018/04/19/self-在-block-中的引用计数变化/">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-常用工具" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/blog/2018/04/09/常用工具/">常用工具</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/blog/2018/04/09/常用工具/">
            <time datetime="2018-04-09T02:53:18.333Z" itemprop="datePublished">2018-04-09</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/blog/categories/技术/">技术</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/blog/tags/其他/">其他</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>此文章暂未完成….</p>
</blockquote>
<h1 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h1><h2 id="版本管理工具-rvm"><a href="#版本管理工具-rvm" class="headerlink" title="版本管理工具 - rvm"></a>版本管理工具 - rvm</h2><ul>
<li><code>$ rvm list</code> 列出已安装的 ruby 版本</li>
<li><code>$ rvm list kn=own</code> 显示 local + remote 的 ruby 版本</li>
<li><code>$ rvm use [ruby-version]</code> 可以使用 default 来改变系统环境下的 ruby 版本，或使用 system 来改变当前环境下的 ruby 版本</li>
<li><code>$ rvm remove [ruby-version]</code> 删除 ruby 版本</li>
</ul>
<h2 id="包管理工具-gem"><a href="#包管理工具-gem" class="headerlink" title="包管理工具 - gem"></a>包管理工具 - gem</h2><ul>
<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>
<li><code>$ gem update</code> 更新 gem 包</li>
<li><code>$ gem update --system</code> 更新 gem 本身</li>
<li><code>$ gem install [gem-package]</code> 安装 gem 包</li>
<li><code>$ gem list</code> 列出所有安装的 gem 包</li>
<li><code>$ gem remove [gem-package]</code> 删除安装过的 gem 包</li>
</ul>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="cocoapods"><a href="#cocoapods" class="headerlink" title="cocoapods"></a>cocoapods</h3><ul>
<li><code>gem instal cocoapods</code> 安装 cocoapods</li>
<li><code>pod setup</code> 初始化 Pod 库</li>
<li><code>pod repo update</code> 更新 Pod 库</li>
<li><code>pod install</code> 根据当前目录的 Podfile 文件安装 Pod 库</li>
<li><code>pod update</code> 更新 Podfile 文件中的 Pod 库</li>
</ul>
<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="版本管理工具-pyenv"><a href="#版本管理工具-pyenv" class="headerlink" title="版本管理工具 - pyenv"></a>版本管理工具 - pyenv</h2><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="包管理工具-npm"><a href="#包管理工具-npm" class="headerlink" title="包管理工具 - npm"></a>包管理工具 - npm</h2><h1 id="包管理工具-brew"><a href="#包管理工具-brew" class="headerlink" title="包管理工具 - brew"></a>包管理工具 - brew</h1><ul>
<li><code>brew update</code> 更新 brew package</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="https://hparis.github.io/blog/2018/04/09/常用工具/#comments" class="article-comment-link disqus-comment-count" data-disqus-url="https://hparis.github.io/blog/2018/04/09/常用工具/">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-如何用-Objective-C-实现一个死锁" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/blog/2018/04/02/如何用-Objective-C-实现一个死锁/">如何用 Objective-C 实现一个死锁</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/blog/2018/04/02/如何用-Objective-C-实现一个死锁/">
            <time datetime="2018-04-01T20:29:42.000Z" itemprop="datePublished">2018-04-01</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/blog/categories/技术/">技术</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/blog/tags/GCD/">GCD</a>, <a class="tag-link" href="/blog/tags/Objective-C/">Objective-C</a>, <a class="tag-link" href="/blog/tags/iOS/">iOS</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>当系统存在两个线程及以上的时候，双方都在等待对方停止执行，以获得系统资源，但是没有一方提前退出的时候就叫做死锁。</p>
</blockquote>
<p>那在 Objective-C 里面如何实现死锁呢：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">self.lock1 = [NSLock new];</span><br><span class="line">self.lock2 = [NSLock new];</span><br><span class="line">    </span><br><span class="line">dispatch_async(dispatch_queue_create(&quot;com.papa.task1&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class="line">    [self.lock1 lock];</span><br><span class="line">    NSLog(@&quot;task1 获得 lock1&quot;);</span><br><span class="line">    sleep(2);</span><br><span class="line">    [self.lock2 lock];</span><br><span class="line">    NSLog(@&quot;task1 获得 lock2&quot;);</span><br><span class="line">    [self.lock2 unlock];</span><br><span class="line">    [self.lock1 unlock];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_queue_create(&quot;com.papa.task2&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class="line">    [self.lock2 lock];</span><br><span class="line">    NSLog(@&quot;task2 获得 lock2&quot;);</span><br><span class="line">    sleep(2);</span><br><span class="line">    [self.lock1 lock];</span><br><span class="line">    NSLog(@&quot;task2 获得 lock1&quot;);</span><br><span class="line">    [self.lock1 unlock];</span><br><span class="line">    [self.lock2 unlock];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以看到最后控制台输出的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task2 获得 lock2</span><br><span class="line">task1 获得 lock1</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task2 获得 lock2</span><br><span class="line">task1 获得 lock1</span><br></pre></td></tr></table></figure>
<p>为什么是两种结果呢，可以参考我的<a href="https://hparis.github.io/blog/2017/09/05/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3GCD/">「初步了解 GCD」</a>。</p>
<p>但是不管如何，这两种结果都没有输出 <code>task1 获得 lock2</code> 或 <code>task2 获得 lock1</code>。我们来分析一下：</p>
<ul>
<li>task1 获得 lock1，然后沉睡 2s</li>
<li>task2 获得 lock2，然后沉睡 2s</li>
<li>task1 经过 2s 的沉睡之后想要去获取 lock2，此时发现 lock2 已经被使用，那就继续等待</li>
<li>task2 经过 2s 的沉睡之后想要去获取 lock1，此时发现 lock1 已经被使用，那就继续等待</li>
<li>task1 又被唤醒想要去获取 lock2，此时 lock2 依旧没有被 task2 释放，只能继续等待</li>
<li>task2 又被唤醒想要去获取 lock1，此时 lock1 依旧没有被 task1 释放，只能继续等待</li>
<li>…</li>
<li>…</li>
</ul>
<p>于是 task1 和 task2 都在等待对方释放资源，但是自己也不退出也不释放资源，最终导致死锁的产生。</p>
<p>接下来，我们来讨论另外一个例子是不是死锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 某个按钮的点击事件</span><br><span class="line">- (void)onClick:(UIEvent *)event &#123;</span><br><span class="line">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        ...    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信大家都知道上面这个例子会导致主线程发生阻塞的现象，但是这是因为死锁造成的么？</p>
<blockquote>
<p>Submits a block to a dispatch queue for synchronous execution. Unlike dispatch_async, this function does not return until the block has finished. Calling this function and targeting the current queue results in deadlock.</p>
</blockquote>
<p>在官方文档里面明确的说了，这就是死锁。我们可以把上面的例子“翻译”一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 首先进入 onClick 的时候，我们可以认为此时是需要加锁的</span><br><span class="line">// 某个按钮的点击事件</span><br><span class="line">- (void)onClick:(UIEvent *)event &#123;</span><br><span class="line">    [self.lock1 lock];</span><br><span class="line">    </span><br><span class="line">    // 此时我们可以认为 dispatch_sync 是在获取 block 里面的 lock2 </span><br><span class="line">    &#123;</span><br><span class="line">        [self.lock2 lock];</span><br><span class="line">        </span><br><span class="line">        // 放在主线程执行，那么它也需要获得 lock1 </span><br><span class="line">        [self.lock1 lock];</span><br><span class="line">        [self.lock1 unlock];</span><br><span class="line">        </span><br><span class="line">        [self.lock2 unlock];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self.lock1 unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到其实上面的情况就是两个任务都在同时竞争主线程的资源，并且谁都没有退出最终导致死锁的产生。但是这两个任务并不是普通的两个线程在竞争资源，而是都在主线程上，一个嵌套另外一个。而且这种特殊的情况，在运行的时候会直接导致奔溃，而不像我们一开始的例子一样只是在互相等待。但是既然苹果把这种情况也称为死锁，那我们就当做死锁来看待，毕竟他们都是在竞争系统资源。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="https://hparis.github.io/blog/2018/04/02/如何用-Objective-C-实现一个死锁/#comments" class="article-comment-link disqus-comment-count" data-disqus-url="https://hparis.github.io/blog/2018/04/02/如何用-Objective-C-实现一个死锁/">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-说说-Objective-C-中的-Copy-操作" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/blog/2018/03/24/说说-Objective-C-中的-Copy-操作/">说说 Objective-C 中的 Copy 操作</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/blog/2018/03/24/说说-Objective-C-中的-Copy-操作/">
            <time datetime="2018-03-23T16:35:55.000Z" itemprop="datePublished">2018-03-23</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/blog/categories/技术/">技术</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/blog/tags/Objective-C/">Objective-C</a>, <a class="tag-link" href="/blog/tags/iOS/">iOS</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h2 id="浅拷贝（Shallow-copies）和深拷贝（Deep-copies）"><a href="#浅拷贝（Shallow-copies）和深拷贝（Deep-copies）" class="headerlink" title="浅拷贝（Shallow copies）和深拷贝（Deep copies）"></a>浅拷贝（Shallow copies）和深拷贝（Deep copies）</h2><p>我们都知道 Objective-C 中把 Copy 操作分成两种：<code>浅拷贝（Shallow copies）</code>和<code>深拷贝（Deep copies）</code>。学过 C 语言的同学应该知道区分这两种操作的区别其实很简单：</p>
<blockquote>
<p>浅拷贝（Shallow copies）: 指针拷贝，指向的还是同一块内容的地址<br>深拷贝（Deep copies）: 内容拷贝</p>
</blockquote>
<p>但是在 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别。我们先来看看 Apple 的官方文档给出的一张图：</p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png" alt="Collections Programming Topics"></p>
<p>通过上图可以看出<code>浅拷贝</code>过后，Array 1 和 Array 2 的元素都是相同的指针地址，指向相同的内容；<code>深拷贝</code>过后，内容被拷贝一份新的出来，Array 2 的元素的指针地址都和 Array 1 不一样，因为 Array2 的元素的指针地址都指向新的内容。</p>
<h2 id="immutable-和-mutable-对象的拷贝"><a href="#immutable-和-mutable-对象的拷贝" class="headerlink" title="immutable 和 mutable 对象的拷贝"></a>immutable 和 mutable 对象的拷贝</h2><p>在 Objective-C 中一般会用 copy 或 mutableCopy 进行拷贝操作，我们可以通过观察指针变化来确定这两种拷贝操作是<code>浅复制</code>还是<code>深复制</code>。</p>
<ul>
<li><p>immutable 对象的复制操作</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString * aName = @&quot;帕帕&quot;;</span><br><span class="line">NSString * bName = [aName copy];</span><br><span class="line">NSMutableString * cName = [aName mutableCopy];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;aName 的指针：%p&quot;, aName);</span><br><span class="line">NSLog(@&quot;bName 的指针：%p&quot;, bName);</span><br><span class="line">NSLog(@&quot;cName 的指针：%p&quot;, cName);</span><br></pre></td></tr></table></figure>
<p>  输出的结果：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aName 的指针：0x103d34070</span><br><span class="line">bName 的指针：0x103d34070</span><br><span class="line">cName 的指针：0x600000250dd0</span><br></pre></td></tr></table></figure>
</li>
<li><p>mutable 对象的复制操作</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSMutableString * aName = [NSMutableString stringWithString:@&quot;帕帕&quot;];</span><br><span class="line">NSString * bName = [aName copy];</span><br><span class="line">NSMutableString * cName = [aName mutableCopy];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;aName 的指针：%p&quot;, aName);</span><br><span class="line">NSLog(@&quot;bName 的指针：%p&quot;, bName);</span><br><span class="line">NSLog(@&quot;cName 的指针：%p&quot;, cName);</span><br></pre></td></tr></table></figure>
<p>  输出的结果：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aName 的指针：0x60000025e150</span><br><span class="line">bName 的指针：0x600000222900</span><br><span class="line">cName 的指针：0x60000025e450</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过上面两个例子以及它们的输出结果，我们可以得出下面这个表格：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">imutable 对象</th>
<th style="text-align:center">mutable 对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">copy</td>
<td style="text-align:center">浅复制</td>
<td style="text-align:center">深复制</td>
</tr>
<tr>
<td style="text-align:center">mutableCopy</td>
<td style="text-align:center">深复制</td>
<td style="text-align:center">深复制</td>
</tr>
</tbody>
</table>
<p>上面的规则对集合对象也是一样的：NSArray 和 NSMutableArray，NSDictionary 和 NSMutableDictionary，NSSet 和 NSMutableSet</p>
<h2 id="单层深复制（one-level-deep）"><a href="#单层深复制（one-level-deep）" class="headerlink" title="单层深复制（one-level-deep）"></a>单层深复制（one-level-deep）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableString * aString = [NSMutableString stringWithString:@&quot;Hello&quot;]</span><br><span class="line"></span><br><span class="line">NSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];</span><br><span class="line">NSArray * bArray = [aArray copy];</span><br><span class="line"></span><br><span class="line">NSMutableString * bString = bArray[0];</span><br><span class="line">[bString appendString:@&quot; 帕帕&quot;];</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;aArray 的指针：%p&quot;, aName);</span><br><span class="line">NSLog(@&quot;bArray 的指针：%p&quot;, bName);</span><br><span class="line">NSLog(@&quot;aArray 第一个元素的指针: %p，内容：%@&quot;, aArray[0], aArray[0]);</span><br><span class="line">NSLog(@&quot;bArray 第一个元素的指针: %p，内容：%@&quot;, bArray[0], bArray[0]);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aArray 的指针：0x60000025d9a0</span><br><span class="line">bArray 的指针：0x60000002cf60</span><br><span class="line">aArray 第一个元素的指针: 0x60000025d880，内容：Hello 帕帕</span><br><span class="line">bArray 第一个元素的指针: 0x60000025d880，内容：Hello 帕帕</span><br></pre></td></tr></table></figure>
<p>从 aArray 到 bArray 的 copy 操作之后，它们的指针地址发生了变化，按照我们之前的理解这是<code>深拷贝</code>。<code>深拷贝</code>会把 aArray 的元素都拷贝一份，那为什么改变 bArray 的元素的值会导致 aArray 的元素的值也发生了变化呢？</p>
<p><img src="https://i.imgur.com/svn3AbQ.png" alt="集合对象的深拷贝"></p>
<h2 id="完全深复制"><a href="#完全深复制" class="headerlink" title="完全深复制"></a>完全深复制</h2><p>那我们要如何做到真正的深复制呢？我们可以简单的把上面的代码改一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSMutableString * aString = [NSMutableString stringWithString:@&quot;Hello&quot;]</span><br><span class="line"></span><br><span class="line">NSMutableArray * aArray = [NSMutableArray arrayWithObjects:aString, nil];</span><br><span class="line"></span><br><span class="line">// 只需要改动这一行代码</span><br><span class="line">NSArray *bArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:aArray]];</span><br><span class="line"></span><br><span class="line">NSMutableString * bString = bArray[0];</span><br><span class="line">[bString appendString:@&quot; 帕帕&quot;];</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;aArray 的指针：%p&quot;, aName);</span><br><span class="line">NSLog(@&quot;bArray 的指针：%p&quot;, bName);</span><br><span class="line">NSLog(@&quot;aArray 第一个元素的指针: %p，内容：%@&quot;, aArray[0], aArray[0]);</span><br><span class="line">NSLog(@&quot;bArray 第一个元素的指针: %p，内容：%@&quot;, bArray[0], bArray[0]);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aArray 的指针：0x600000259cb0</span><br><span class="line">bArray 的指针：0x600000030ac0</span><br><span class="line">aArray 第一个元素的指针: 0x604000452120，内容：Hello</span><br><span class="line">bArray 第一个元素的指针: 0x604000452780，内容：Hello 帕帕</span><br></pre></td></tr></table></figure>
<p>只要先对集合对象分别用 NSKeyedArchiver 和 NSKeyedUnarchiver 就可以真正完成对一个集合对象的深复制。</p>
<h2 id="Copy-和-内存管理"><a href="#Copy-和-内存管理" class="headerlink" title="Copy 和 内存管理"></a>Copy 和 内存管理</h2><p>之前我们说过 Objective-C 里面对于 Copy 的实现还是跟 C 语言的有点差别，那差别在什么地方呢？<br>内存中做复制操作是很耗费资源的，而我们都知道 Objective-C 高效的一个原因在于它的内存管理机制是<code>引用计数</code>。我们前面分析的<code>深拷贝</code>是对内容的拷贝，这一点跟 C 语言的一样。C 语言的<code>浅拷贝</code>是指针的拷贝，它依旧做了一次复制操作。而在 Objective-C 中，<code>浅拷贝</code>其实只是引用计数的增加，不信的话，我们可以看看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSArray * aArray = [NSArray arrayWithObjects:@&quot;帕帕&quot;, nil];</span><br><span class="line">NSLog(@&quot;aArray 的指针：%p，引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));</span><br><span class="line">NSArray * bArray = [aArray copy];</span><br><span class="line">NSLog(@&quot;aArray 的指针：%p，引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));</span><br><span class="line">NSMutableArray * cArray = [aArray mutableCopy];</span><br><span class="line">NSLog(@&quot;aArray 的指针：%p，引用计数：%ld&quot;, aArray, CFGetRetainCount((__bridge CFTypeRef)(aArray)));</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aArray 的指针：0x604000443ba0，引用计数：2</span><br><span class="line">aArray 的指针：0x604000443ba0，引用计数：3</span><br><span class="line">aArray 的指针：0x604000443ba0，引用计数：3</span><br></pre></td></tr></table></figure>
<p>为什么 aArray 刚出来的时候的引用计数是 2？因为 <code>[NSArray arrayWithObjects:@&quot;帕帕&quot;, nil]</code> 本身就是一个对象，它的引用计数就是 1；然后我们又定义了 aArray 来引用这个对象，此时它的引用计数就增加了 1，变成了 2；之后我们对 aArray 进行了 copy 操作，发现它的引用计数变成了 3，所以这里的 copy 操作其实相当于 retaion；最有我们对 aArray 进行了 mutableCopy 操作，此时它的引用计数还是 3，没有发生变化，因为这个时候进行了内容复制。</p>
<p>所以在 Objective-C 中对一个 imutable 对象进行的 copy（浅复制）操作，其实都只会引起引用计数的变化，而不会在内存中做出任何拷贝操作，包括指针拷贝。</p>
<h2 id="NSCopying-和-NSMutableCopying"><a href="#NSCopying-和-NSMutableCopying" class="headerlink" title="NSCopying 和 NSMutableCopying"></a>NSCopying 和 NSMutableCopying</h2><p>如果我们有一个自定义的对象，并且对其进行 copy 操作的话，会发生什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Person</span><br><span class="line">@interface Person: NSObject</span><br><span class="line">@property (nonatomic, copy) NSString * name;</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Person * aPerson = [Person new];</span><br><span class="line">Person * bPerson = [aPerson copy];</span><br></pre></td></tr></table></figure>
<p>Xcode 直接奔溃了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 崩溃</span><br><span class="line">*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[Person copyWithZone:]: unrecognized selector sent to instance 0x60000000d5f0&apos;</span><br></pre></td></tr></table></figure>
<p>为什么我们对一个 Person 对象使用了 copy，Xcode 确报的是找不到 <code>copyWithZone:</code> 这个 selector 的错误。</p>
<p>这是因为 Objective-C 中规定，一个对象如果想要使用 copy 或 mutableCopy 的操作，必须要实现 <code>NSCopying</code> 或 <code>NSMutableCopying</code> 这两个协议。这两个协议规定了对象需要实现 <code>copyWithZone:</code> 或 <code>mutableCopyWithZone:</code> 这两个方法，因为对一个对象做 copy 或 mutableCopy 最后都会去调用这两个方法来做最终的实现。<br>上面例子中的集合对象能够使用 copy 和 mutableCopy 操作是也因为它们都实现了 NSCopying 和 NSMutableCopying 协议。</p>
<p>我们来看看如何对一个普通的对象实现 NSCopying 协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface Person: NSObject &lt;NSCopying&gt;</span><br><span class="line">@property (nonatomic, copy) NSString * name;</span><br><span class="line">@property (nonatomic, strong) NSMutableArray * mArray;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (instancetype)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    Person * person = [[self class] new];</span><br><span class="line">    person.name = [self.name copy];</span><br><span class="line">    person.mArray = [self.mArray mutableCopy];</span><br><span class="line">    return person;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这样，我们就可以愉快的使用 <code>[Person copy]</code> 了。当然，这里 Person 的 mArray 也只是<code>单层深复制</code>，如果想要实现<code>完全深复制</code>的话，我们可以用 NSKeyedArchiver 和 NSKeyedUnarchiver 来完成对 mArray 的<code>完全深复制</code>。</p>
<h2 id="Block-和-Copy"><a href="#Block-和-Copy" class="headerlink" title="Block 和 Copy"></a>Block 和 Copy</h2><p>简单说一下，在 Objective-C 中，Block 的 copy 是一种特殊的操作。因为 Block 是一种结构体，它无法实现 NSCopying 或 NSMutableCopying 协议，但是它却可以调用 copy 方法。这是由 Block 的结构体决定的：</p>
<p><img src="http://www.devtalking.com/postImages/block-struct.jpg" alt=""></p>
<p>Block 里面的 descriptor 有 copy 的函数指针，当对 Block 执行 copy 操作最后都会通过该函数指针进行真正的操作。这也是 Bloc看不需要实现 NSCopying 和 NSMutableCopying 就能调用 copy 方法的原因。</p>
<p>参考资料：</p>
<ol>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html" target="_blank" rel="noopener">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html</a></li>
<li><a href="https://www.zybuluo.com/MicroCai/note/50592" target="_blank" rel="noopener">https://www.zybuluo.com/MicroCai/note/50592</a></li>
</ol>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="https://hparis.github.io/blog/2018/03/24/说说-Objective-C-中的-Copy-操作/#comments" class="article-comment-link disqus-comment-count" data-disqus-url="https://hparis.github.io/blog/2018/03/24/说说-Objective-C-中的-Copy-操作/">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-如何在-iOS-上自定义-React-Native-Component" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/blog/2018/03/20/如何在-iOS-上自定义-React-Native-Component/">如何在 iOS 上自定义 React Native Component</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/blog/2018/03/20/如何在-iOS-上自定义-React-Native-Component/">
            <time datetime="2018-03-19T17:22:09.000Z" itemprop="datePublished">2018-03-19</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/blog/categories/技术/">技术</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/blog/tags/RN/">RN</a>, <a class="tag-link" href="/blog/tags/iOS/">iOS</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>当我们要在 iOS 端实现一个 React Native 可用的 Component，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MapView onRegionChange=&#123;(event) =&gt; &#123;&#125;&#125; zoomLevel=&#123;2&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>那么我们基本上就是要解决下面这三个问题：</p>
<ul>
<li>如何把 iOS 上的 UI 暴露给 React Native 端？</li>
<li>如何在 React Native 给 iOS 的 UI 传值？</li>
<li>如何在 React Native 中响应 iOS 的事件？</li>
</ul>
<blockquote>
<p>这三个问题可以在<a href="https://facebook.github.io/react-native/docs/native-components-ios.html" target="_blank" rel="noopener">官方文档</a>找到答案。</p>
</blockquote>
<h2 id="如何把-iOS-上的-UI-暴露给-React-Native-端"><a href="#如何把-iOS-上的-UI-暴露给-React-Native-端" class="headerlink" title="如何把 iOS 上的 UI 暴露给 React Native 端"></a>如何把 iOS 上的 UI 暴露给 React Native 端</h2><p>首先你需要创建一个继承自 <code>RCTViewManager</code> 的子类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// RNTMapManager.m</span><br><span class="line">#import &lt;MapKit/MapKit.h&gt;</span><br><span class="line">#import &lt;React/RCTViewManager.h&gt;</span><br><span class="line"></span><br><span class="line">// 继承 RCTViewManager</span><br><span class="line">@interface RNTMapManager : RCTViewManager</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation RNTMapManager</span><br><span class="line"></span><br><span class="line">// 调用 RCT_EXPORT_MODULE 暴露该类的名字给 React Native 使用。如果你想自定义</span><br><span class="line">// 暴露给 React Native 的名字时，你需要 RCT_EXPORT_MODULE(YOUR_CUSTOM_NAME)。</span><br><span class="line">RCT_EXPORT_MODULE()</span><br><span class="line"></span><br><span class="line">// 由于 RCTViewManager 是 NSObject，所以这里必须需要实现该方法来告诉</span><br><span class="line">// React Native 去使用哪个 UIView</span><br><span class="line">- (UIView *)view</span><br><span class="line">&#123;</span><br><span class="line">  return [MKMapView new];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这样我们就可以在 React Native 使用 MapView 了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// MapView.js</span><br><span class="line"></span><br><span class="line">import &#123; requireNativeComponent &#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">// requireNativeComponent 会自动把 iOS 上的 RNTMapManager 解析成 RNTMap。</span><br><span class="line">// 如果去掉 iOS 上的 Manager 后缀会有什么影响？嗯，没有任何影响。</span><br><span class="line">module.exports = requireNativeComponent(&apos;RNTMap&apos;, null);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// MyApp.js</span><br><span class="line">import MapView from &apos;./MapView.js&apos;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  return &lt;MapView /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何在-React-Native-给-iOS-的-UI-传值"><a href="#如何在-React-Native-给-iOS-的-UI-传值" class="headerlink" title="如何在 React Native 给 iOS 的 UI 传值"></a>如何在 React Native 给 iOS 的 UI 传值</h2><p>如果需要传值给 iOS 上的 UI，那么需要使用另外一个宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)</span><br></pre></td></tr></table></figure>
<p>这时候就可以在 React Native 上使用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MapView zoomEnable=&#123;true&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，<code>RCT_EXPORT_VIEW_PROPERTY</code> 所暴露的属性必须是之前我们说的 UIView（即继承于 <code>RCTViewManager</code> 并通过 <code>- (UIView *)view;</code> 返回的 View）已经存在的属性。</p>
<p>除了上面的宏 <code>RCT_EXPORT_VIEW_PROPERTY</code> 可以暴露属性给 React Native 使用之外还有下面 5 种（这里先挖个坑，回头研究一下再说说下面五种的作用和区别）：</p>
<ul>
<li>RCT_REMAP_VIEW_PROPERTY</li>
<li>RCT_CUSTOM_VIEW_PROPERTY</li>
<li>RCT_EXPORT_SHADOW_PROPERTY</li>
<li>RCT_REMAP_SHADOW_PROPERTY</li>
<li>RCT_CUSTOM_SHADOW_PROPERTY</li>
</ul>
<h2 id="如何在-React-Native-中响应-iOS-的事件"><a href="#如何在-React-Native-中响应-iOS-的事件" class="headerlink" title="如何在 React Native 中响应 iOS 的事件"></a>如何在 React Native 中响应 iOS 的事件</h2><p>要想在 React Native 中响应 iOS 的事件，只需要暴露用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 定义的属性即可，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// RNTMapView.h</span><br><span class="line">#import &lt;MapKit/MapKit.h&gt;</span><br><span class="line">#import &lt;React/RCTComponent.h&gt;</span><br><span class="line"></span><br><span class="line">// 由于 MKMapView 没有任何 `RCTBubblingEventBlock` 或 `RCTDirectEventBlock` 所定义的</span><br><span class="line">// 属性，所以这里需要定义 MKMapView 的子类 RNTMapView</span><br><span class="line">@interface RNTMapView: MKMapView</span><br><span class="line"></span><br><span class="line">// 需要暴露给 React Native 的事件属性</span><br><span class="line">@property (nonatomic, copy) RCTBubblingEventBlock onRegionChange;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// RNTMapView.m</span><br><span class="line">#import &quot;RNTMapView.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation RNTMapView</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>然后我们需要在 <code>RCTViewManager</code> 中暴露 <code>onRegionChange</code> 给 React Native 使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// RNTMapManager.m</span><br><span class="line">#import &lt;MapKit/MapKit.h&gt;</span><br><span class="line">#import &lt;React/RCTViewManager.h&gt;</span><br><span class="line"></span><br><span class="line">#import &quot;RNTMapView.h&quot;</span><br><span class="line"></span><br><span class="line">@interface RNTMapManager : RCTViewManager &lt;MKMapViewDelegate&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation RNTMapManager</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_MODULE()</span><br><span class="line">// 暴露 RNTMapView 中的 `onRegionChange` 属性</span><br><span class="line">RCT_EXPORT_VIEW_PROPERTY(onRegionChange, RCTBubblingEventBlock)</span><br><span class="line"></span><br><span class="line">- (UIView *)view &#123;</span><br><span class="line">    // 这里需要返回 RNTMapView 而不是 MKMapView</span><br><span class="line">    return [RNTMapView new];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重要的事说三遍：<br>使用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 所定义的事件都必须加上前缀 <code>on</code>，否则 React Native 无法接收到事件<br>使用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 所定义的事件都必须加上前缀 <code>on</code>，否则 React Native 无法接收到事件<br>使用 <code>RCTBubblingEventBlock</code> 或 <code>RCTDirectEventBlock</code> 所定义的事件都必须加上前缀 <code>on</code>，否则 React Native 无法接收到事件</p>
</blockquote>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="https://hparis.github.io/blog/2018/03/20/如何在-iOS-上自定义-React-Native-Component/#comments" class="article-comment-link disqus-comment-count" data-disqus-url="https://hparis.github.io/blog/2018/03/20/如何在-iOS-上自定义-React-Native-Component/">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-Raspberry-PI-基本使用" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/blog/2018/03/06/Raspberry-PI-基本使用/">Raspberry PI 基本使用</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/blog/2018/03/06/Raspberry-PI-基本使用/">
            <time datetime="2018-03-05T22:04:56.000Z" itemprop="datePublished">2018-03-05</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/blog/categories/Raspberry-PI/">Raspberry PI</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/blog/tags/Raspberry-PI/">Raspberry PI</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h2 id="1-保证-Raspberry-PI-能够在外网使用"><a href="#1-保证-Raspberry-PI-能够在外网使用" class="headerlink" title="1. 保证 Raspberry PI 能够在外网使用"></a>1. 保证 Raspberry PI 能够在外网使用</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在你的 Raspberry PI 上使用 autossh 来实现不掉线的反向代理：</span><br><span class="line">autossh -M 5678 -fNR 2018:localhost:22 root@54.219.12.213</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在你的外网服务器（比如上面例子中的：54.219.12.213）上可以使用 ssh 登录你的 Raspberry PI</span><br><span class="line">ssh -p 2018 pi@127.0.0.1</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="https://hparis.github.io/blog/2018/03/06/Raspberry-PI-基本使用/#comments" class="article-comment-link disqus-comment-count" data-disqus-url="https://hparis.github.io/blog/2018/03/06/Raspberry-PI-基本使用/">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-redux-之页面跳转" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/blog/2018/02/27/redux-之页面跳转/">redux 之页面跳转</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/blog/2018/02/27/redux-之页面跳转/">
            <time datetime="2018-02-26T17:48:56.000Z" itemprop="datePublished">2018-02-26</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/blog/categories/技术/">技术</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/blog/tags/RN/">RN</a>, <a class="tag-link" href="/blog/tags/redux/">redux</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>最近正在用 React Native 重构整个项目，我们用了 <strong><a href="https://github.com/krystofcelba/react-native-navigation#rn52" target="_blank" rel="noopener">react-native-navigation</a></strong> 这个库来作为项目的导航控制器。<br>所以，我们平常会把页面跳转逻辑的时候放在 Screen 里面的，比如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstScreen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 点击事件</span></span><br><span class="line">    _someAction = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.props.navigator.push(&#123;</span><br><span class="line">          screen: <span class="string">'example.SecondScreen'</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，上面的写法没有问题。但是直到我们碰到这样一个需求的时候就抓瞎了：点击一个 PDF 文件，如果 PDF 文件没有下载就先去下载，下载完成之后自动跳转到 PDF 阅读器。由于用了 redux 之后，我们就增加一个 finished 的 state 来判断是否已经下载完成。示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleScreen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    componentWillReceiveProps = <span class="function">(<span class="params">nextProps</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里判断下载状态是否已完成，完成的话就去跳转</span></span><br><span class="line">        <span class="keyword">if</span> (nextProps.finished === <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里需要重置一下状态，不然其他 state 发生变化会多次触发页面的跳转</span></span><br><span class="line">            <span class="keyword">this</span>.props.dispatch(resetFinished());</span><br><span class="line">            <span class="keyword">this</span>.props.navigator.push(&#123;</span><br><span class="line">              screen: <span class="string">'example.PDFScreen'</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 点击事件</span></span><br><span class="line">    _someAction = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// openPDF() 这个 action 会自动去下载 PDF 文件，然后修改 finished 的状态</span></span><br><span class="line">        <span class="keyword">this</span>.props.dispatch(openPDF());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    finished: state.finished</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(ExampleScreen);</span><br></pre></td></tr></table></figure>
<p>上面的做法是可以实现我们的需求，但是这种写法很蛋疼。因为当你在调用用 openPDF() 的时候，你以为后面的事不需要你操心，然后这个时候有人告诉你还需要在其他地方增加一个中间状态去补充 openPDF() 的后续逻辑处理。</p>
<p>经过讨论之后，我们决定改成用 callback 的方式来实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleScreen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击事件</span></span><br><span class="line">    _someAction = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// openPDF() 是一个异步 action</span></span><br><span class="line">        <span class="keyword">this</span>.props.dispatch(openPDF(callback: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.props.navigator.push(&#123;</span><br><span class="line">              screen: <span class="string">'example.PDFScreen'</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 callback 的好处就是去掉了一个烦人的中间状态，并且从阅读体验来说很容易让读者明白这个点击事件在干什么。但是在 redux 的 action 方法中增加一个 callback 的调用，看起来也有点不伦不类的。虽然我认为 callback 和其他参数具有相同的法律地位。</p>
<p>其实最好的实现是，这个点击事件应该连页面的跳转逻辑也不需要处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleScreen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击事件，这个事件只做一件事就是去 dispatch 一个 openPDF() 的 action</span></span><br><span class="line">    _someAction = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.props.dispatch(openPDF());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这种实现，我们也就只能在 openPDF() 里动手脚了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// action.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> openPDF = <span class="keyword">await</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 异步下载 PDF</span></span><br><span class="line">        <span class="keyword">async</span> downloadPDF();</span><br><span class="line">        <span class="comment">// 完成之后通过 router 去实现页面跳转</span></span><br><span class="line">        dispatch(openRouter(<span class="string">'PDFScreen'</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里就不再详细说 router 的实现细节了，因为网上有很多现成的资料。（PS: 主要是我也还没看到这一块）</p>
</blockquote>
<p>从页面（Screen）的角度来说，我认为这样的处理是最合适的。因为 Screen 只需要关注本页面的 state 和 action，至于跳转的逻辑交给后面的 action 来处理是最好的。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="https://hparis.github.io/blog/2018/02/27/redux-之页面跳转/#comments" class="article-comment-link disqus-comment-count" data-disqus-url="https://hparis.github.io/blog/2018/02/27/redux-之页面跳转/">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-Swift-High-Performance-Tip 2：final和private(fileprivate)" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/blog/2017/09/05/Swift-High-Performance-Tip 2：final和private(fileprivate)/">Swift High-Performance Tip 2：final 和 private(fileprivate)</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/blog/2017/09/05/Swift-High-Performance-Tip 2：final和private(fileprivate)/">
            <time datetime="2017-09-05T15:30:56.000Z" itemprop="datePublished">2017-09-05</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/blog/categories/技术/">技术</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/blog/tags/Swift/">Swift</a>, <a class="tag-link" href="/blog/tags/iOS/">iOS</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <blockquote>
<p>Dynamic dispatch means that program has to determine at run time which method or property is being referred to and then perform an indirect call or indirect access.</p>
</blockquote>
<p>我们都知道 Swift 的 class 是可以被继承，function 和 property 是可以被重写的，而这就意味着 Swift 需要 dynamic dispatch 这种机制来完成这些功能。Swift 的 dynamic dispatch 首先会再 method table 查找方法，然后间接调用。很明显这种方式要比直接调用的效率慢，并且用间接调用的方式还会阻止编译器的一些优化无法实现。</p>
<p><strong>那么应该怎么优化呢？</strong></p>
<p>当我们明确的知道 class、function、property 是不需要 overridden，我们可以通过使用 final 和 private(fileprivate) 这些关键字减少动态派发的发生，从而有效的提高效率。</p>
<p>在 Swift 中，如果被 final 或 private(fileprivate) 修饰的 class、function、property 是不能 overridden，并且调用这些 class、function、property 的时候不再通过 dynamic dispatch 去间接调用，而是直接调用。</p>
<p>所以，通过在必要的代码中使用 final 或 private(fileprivate) 这些关键字进行优化的话，将可以有效提高的效率。</p>
<p><strong>Whole Module Optimization</strong></p>
<p>Swift 的 class、function、property 的默认权限都是 internal ，除非我们明确的加上 public 或 private(fileprivate) 关键字才能改变它们的默认权限。</p>
<p>编译器在编译 Module 的时候都是对里面的源文件进行单独编译，这样的话编译器就无法确切的知道被 internal 修饰的 class、function、property 究竟有没有被 overridden。一旦我们开启 Whole Module Optimization 的优化选项，编译器就会同时对整个 Module 的所有源文件进行编译，这个时候编译器就可以知道哪些被 internal 修饰的 class、function、property 没有被 overridden，从而把它们的权限从 internal 修改为 final。这样的话，就可以减少 dynamic dispatch 的发生从而提高效率。</p>
<p>开启编译优化选项的步骤如下：Xcode -&gt; Build Settings -&gt; Swift Compiler -&gt; Optimization Level。</p>
<p><img src="http://i.imgur.com/0AxWEVA.jpg" alt=""></p>
<hr>
<p><strong>参考文献</strong></p>
<ol>
<li><p><a href="https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/" target="_blank" rel="noopener">https://www.reddit.com/r/iOSProgramming/comments/3atu5w/does_swift_use_dynamic_method_dispatch_or_a/</a></p>
</li>
<li><p><a href="https://developer.apple.com/swift/blog/?id=27" target="_blank" rel="noopener">https://developer.apple.com/swift/blog/?id=27</a></p>
</li>
<li><p><a href="https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations" target="_blank" rel="noopener">https://github.com/apple/swift/blob/3ef6c79e3c591cf31b8a853b1357e1b8c5771252/docs/OptimizationTips.rst#whole-module-optimizations</a></p>
</li>
</ol>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="https://hparis.github.io/blog/2017/09/05/Swift-High-Performance-Tip 2：final和private(fileprivate)/#comments" class="article-comment-link disqus-comment-count" data-disqus-url="https://hparis.github.io/blog/2017/09/05/Swift-High-Performance-Tip 2：final和private(fileprivate)/">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-Vim-Tip" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/blog/2017/09/05/Vim-Tip/">Vim Tip</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/blog/2017/09/05/Vim-Tip/">
            <time datetime="2017-09-05T15:30:56.000Z" itemprop="datePublished">2017-09-05</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/blog/categories/技术/">技术</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/blog/tags/tip/">tip</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h2 id="1、替换第n1行到第n2行的内容"><a href="#1、替换第n1行到第n2行的内容" class="headerlink" title="1、替换第n1行到第n2行的内容"></a>1、替换第n1行到第n2行的内容</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:n1,n2/origin/replace/g</span><br></pre></td></tr></table></figure>
<h2 id="2、替换整个文件的内容"><a href="#2、替换整个文件的内容" class="headerlink" title="2、替换整个文件的内容"></a>2、替换整个文件的内容</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/origin/replace/g</span><br></pre></td></tr></table></figure>
<h2 id="3、移动n1-n2行-包括n1-n2-到n3行之下"><a href="#3、移动n1-n2行-包括n1-n2-到n3行之下" class="headerlink" title="3、移动n1-n2行(包括n1,n2)到n3行之下"></a>3、移动n1-n2行(包括n1,n2)到n3行之下</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n1,n2 <span class="keyword">m</span> n3</span><br></pre></td></tr></table></figure>
<h2 id="4、复制n1-n2行-包括n1-n2-到n3行之下"><a href="#4、复制n1-n2行-包括n1-n2-到n3行之下" class="headerlink" title="4、复制n1-n2行(包括n1,n2)到n3行之下"></a>4、复制n1-n2行(包括n1,n2)到n3行之下</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:n1,n2 <span class="keyword">co</span> n3</span><br></pre></td></tr></table></figure>
<h2 id="5、删除文件的空行"><a href="#5、删除文件的空行" class="headerlink" title="5、删除文件的空行"></a>5、删除文件的空行</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/^$/d</span><br></pre></td></tr></table></figure>
<h2 id="6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）"><a href="#6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）" class="headerlink" title="6、在文本中插入一个1到100的序列（来自池老师《说，谁才是最帅的编程工具？》）"></a>6、在文本中插入一个1到100的序列（来自池老师<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650712546&amp;idx=1&amp;sn=c4db99547b75d6001b3cfaa6cbc0e715&amp;scene=1&amp;srcid=0805j7ny3Ua1WufWDEpnhwOG#rd" target="_blank" rel="noopener">《说，谁才是最帅的编程工具？》</a>）</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r!seq <span class="number">100</span></span><br></pre></td></tr></table></figure>
<h2 id="7、在当前的每一行文字前面增加“序号-”（来自池老师《说，谁才是最帅的编程工具？》）"><a href="#7、在当前的每一行文字前面增加“序号-”（来自池老师《说，谁才是最帅的编程工具？》）" class="headerlink" title="7、在当前的每一行文字前面增加“序号. ”（来自池老师《说，谁才是最帅的编程工具？》）"></a>7、在当前的每一行文字前面增加“序号. ”（来自池老师<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650712546&amp;idx=1&amp;sn=c4db99547b75d6001b3cfaa6cbc0e715&amp;scene=1&amp;srcid=0805j7ny3Ua1WufWDEpnhwOG#rd" target="_blank" rel="noopener">《说，谁才是最帅的编程工具？》</a>）</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">let</span> i=<span class="number">1</span> | g /^/ s//\=i.<span class="string">". "</span>/ | <span class="keyword">let</span> i+=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="8、当前目录下（包括子文件夹）所有后缀为-java-的文件中的-apache-替换成-eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）"><a href="#8、当前目录下（包括子文件夹）所有后缀为-java-的文件中的-apache-替换成-eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）" class="headerlink" title="8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师《说，谁才是最帅的编程工具？》）"></a>8、当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么在当前目录下依次执行如下命令：（来自池老师<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650712546&amp;idx=1&amp;sn=c4db99547b75d6001b3cfaa6cbc0e715&amp;scene=1&amp;srcid=0805j7ny3Ua1WufWDEpnhwOG#rd" target="_blank" rel="noopener">《说，谁才是最帅的编程工具？》</a>）</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span></span><br><span class="line">:n **/*.java</span><br><span class="line">:<span class="keyword">argdo</span> %s/apache/eclipse/ge | <span class="keyword">update</span></span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    
        <a href="https://hparis.github.io/blog/2017/09/05/Vim-Tip/#comments" class="article-comment-link disqus-comment-count" data-disqus-url="https://hparis.github.io/blog/2017/09/05/Vim-Tip/">Comments</a>
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/">Next &raquo;</a>
    </nav>
</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">recent</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2018/05/25/Swift-High-Performance-Tip 3： @objc-和-dynamic/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/技术/">技术</a></p>
                            <p class="item-title"><a href="/blog/2018/05/25/Swift-High-Performance-Tip 3： @objc-和-dynamic/" class="title">Swift High-Performance Tip 3：@objc 和 dynamic</a></p>
                            <p class="item-date"><time datetime="2018-05-24T18:48:01.000Z" itemprop="datePublished">2018-05-24</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2018/04/19/self-在-block-中的引用计数变化/" class="thumbnail">
    
    
        <span style="background-image:url(https://images.unsplash.com/photo-1462303966430-8a4708fd729e?ixlib=rb-0.3.5&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;s=c9dd0952e673c518403fb8d4c28f93b5&amp;auto=format&amp;fit=crop&amp;w=160&amp;q=60)" alt="self 在 block 中的引用计数变化" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/技术/">技术</a></p>
                            <p class="item-title"><a href="/blog/2018/04/19/self-在-block-中的引用计数变化/" class="title">self 在 block 中的引用计数变化</a></p>
                            <p class="item-date"><time datetime="2018-04-19T11:34:51.000Z" itemprop="datePublished">2018-04-19</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2018/04/09/常用工具/" class="thumbnail">
    
    
        <span style="background-image:url(https://images.unsplash.com/photo-1514443031610-8c063c7a9822?ixlib=rb-0.3.5&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;s=73d9a7ce5ba0ed22cb91bdc0506ac9d0&amp;auto=format&amp;fit=crop&amp;w=160&amp;q=10)" alt="常用工具" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/技术/">技术</a></p>
                            <p class="item-title"><a href="/blog/2018/04/09/常用工具/" class="title">常用工具</a></p>
                            <p class="item-date"><time datetime="2018-04-09T02:53:18.333Z" itemprop="datePublished">2018-04-09</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2018/04/02/如何用-Objective-C-实现一个死锁/" class="thumbnail">
    
    
        <span style="background-image:url(https://images.unsplash.com/photo-1509655172625-03265ba919a1?ixlib=rb-0.3.5&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;s=24b01fba0d86b9fa95814c692429379f&amp;auto=format&amp;fit=crop&amp;w=160&amp;q=100)" alt="如何用 Objective-C 实现一个死锁" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/技术/">技术</a></p>
                            <p class="item-title"><a href="/blog/2018/04/02/如何用-Objective-C-实现一个死锁/" class="title">如何用 Objective-C 实现一个死锁</a></p>
                            <p class="item-date"><time datetime="2018-04-01T20:29:42.000Z" itemprop="datePublished">2018-04-01</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/blog/2018/03/24/说说-Objective-C-中的-Copy-操作/" class="thumbnail">
    
    
        <span style="background-image:url(https://i.imgur.com/svn3AbQs.png)" alt="说说 Objective-C 中的 Copy 操作" class="thumbnail-image"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/blog/categories/技术/">技术</a></p>
                            <p class="item-title"><a href="/blog/2018/03/24/说说-Objective-C-中的-Copy-操作/" class="title">说说 Objective-C 中的 Copy 操作</a></p>
                            <p class="item-date"><time datetime="2018-03-23T16:35:55.000Z" itemprop="datePublished">2018-03-23</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Raspberry-PI/">Raspberry PI</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/技术/">技术</a><span class="category-list-count">14</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/05/">May 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/04/">April 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/03/">March 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/02/">February 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/09/">September 2017</a><span class="archive-list-count">7</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tags</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Block/">Block</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/GCD/">GCD</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Objective-C/">Objective-C</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/RAC/">RAC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/RN/">RN</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Raspberry-PI/">Raspberry PI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Swift/">Swift</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/iOS/">iOS</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/redux/">redux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/tip/">tip</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/其他/">其他</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/blog/tags/Block/" style="font-size: 10px;">Block</a> <a href="/blog/tags/GCD/" style="font-size: 13.33px;">GCD</a> <a href="/blog/tags/Objective-C/" style="font-size: 16.67px;">Objective-C</a> <a href="/blog/tags/RAC/" style="font-size: 10px;">RAC</a> <a href="/blog/tags/RN/" style="font-size: 13.33px;">RN</a> <a href="/blog/tags/Raspberry-PI/" style="font-size: 10px;">Raspberry PI</a> <a href="/blog/tags/Swift/" style="font-size: 16.67px;">Swift</a> <a href="/blog/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/blog/tags/redux/" style="font-size: 10px;">redux</a> <a href="/blog/tags/tip/" style="font-size: 13.33px;">tip</a> <a href="/blog/tags/其他/" style="font-size: 10px;">其他</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2018 帕帕<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        
    
    <script>
    var disqus_config = function () {
        
        this.page.identifier = '';
    };
    (function() { 
        var d = document, s = d.createElement('script');  
        s.src = '//' + 'pariscode' + '.disqus.com/count.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>




    
        <script src="/blog/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/blog/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/blog/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/blog/js/main.js"></script>

    </div>
</body>
</html>